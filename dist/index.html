<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <link rel="stylesheet" href="https://doof72pbjabye.cloudfront.net/fonts/inter/font.css"></link>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      html, body {
        position:relative;
        margin: 0;
        padding: 0;
        height:100%;
        display:flex;
        flex-direction: column;
      }
      #container {
        display:flex;
        flex-direction: column;
        flex: 1 0 100%;
      }
    </style>
  </head>
  <title>simulator</title>
  <body>
    <div id="container"></div>
    <script>
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn2, res) => function __init() {
    return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
  };
  var __commonJS = (cb, mod2) => function __require() {
    return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
  };
  var __export = (target, all) => {
    for (var name2 in all)
      __defProp(target, name2, { get: all[name2], enumerable: true });
  };
  var __copyProps = (to, from2, except, desc) => {
    if (from2 && typeof from2 === "object" || typeof from2 === "function") {
      for (let key of __getOwnPropNames(from2))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
    isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
    mod2
  ));
  var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);

  // node_modules/@esbuild-plugins/node-globals-polyfill/_virtual-process-polyfill_.js
  function defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
  }
  function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
  }
  function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
      return setTimeout(fun, 0);
    }
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
      cachedSetTimeout = setTimeout;
      return setTimeout(fun, 0);
    }
    try {
      return cachedSetTimeout(fun, 0);
    } catch (e) {
      try {
        return cachedSetTimeout.call(null, fun, 0);
      } catch (e2) {
        return cachedSetTimeout.call(this, fun, 0);
      }
    }
  }
  function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
      return clearTimeout(marker);
    }
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
      cachedClearTimeout = clearTimeout;
      return clearTimeout(marker);
    }
    try {
      return cachedClearTimeout(marker);
    } catch (e) {
      try {
        return cachedClearTimeout.call(null, marker);
      } catch (e2) {
        return cachedClearTimeout.call(this, marker);
      }
    }
  }
  function cleanUpNextTick() {
    if (!draining || !currentQueue) {
      return;
    }
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length) {
      drainQueue();
    }
  }
  function drainQueue() {
    if (draining) {
      return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
  }
  function nextTick(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
      runTimeout(drainQueue);
    }
  }
  function Item(fun, array6) {
    this.fun = fun;
    this.array = array6;
  }
  function noop() {
  }
  function binding(name2) {
    throw new Error("process.binding is not supported");
  }
  function cwd() {
    return "/";
  }
  function chdir(dir) {
    throw new Error("process.chdir is not supported");
  }
  function umask() {
    return 0;
  }
  function hrtime(previousTimestamp) {
    var clocktime = performanceNow.call(performance2) * 1e-3;
    var seconds = Math.floor(clocktime);
    var nanoseconds = Math.floor(clocktime % 1 * 1e9);
    if (previousTimestamp) {
      seconds = seconds - previousTimestamp[0];
      nanoseconds = nanoseconds - previousTimestamp[1];
      if (nanoseconds < 0) {
        seconds--;
        nanoseconds += 1e9;
      }
    }
    return [seconds, nanoseconds];
  }
  function uptime() {
    var currentTime = new Date();
    var dif = currentTime - startTime;
    return dif / 1e3;
  }
  var cachedSetTimeout, cachedClearTimeout, queue, draining, currentQueue, queueIndex, title, platform, browser, env, argv, version, versions, release, config, on, addListener, once, off, removeListener, removeAllListeners, emit, performance2, performanceNow, startTime, process, defines;
  var init_virtual_process_polyfill = __esm({
    "node_modules/@esbuild-plugins/node-globals-polyfill/_virtual-process-polyfill_.js"() {
      cachedSetTimeout = defaultSetTimout;
      cachedClearTimeout = defaultClearTimeout;
      if (typeof window.setTimeout === "function") {
        cachedSetTimeout = setTimeout;
      }
      if (typeof window.clearTimeout === "function") {
        cachedClearTimeout = clearTimeout;
      }
      queue = [];
      draining = false;
      queueIndex = -1;
      Item.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      title = "browser";
      platform = "browser";
      browser = true;
      env = {};
      argv = [];
      version = "";
      versions = {};
      release = {};
      config = {};
      on = noop;
      addListener = noop;
      once = noop;
      off = noop;
      removeListener = noop;
      removeAllListeners = noop;
      emit = noop;
      performance2 = window.performance || {};
      performanceNow = performance2.now || performance2.mozNow || performance2.msNow || performance2.oNow || performance2.webkitNow || function() {
        return new Date().getTime();
      };
      startTime = new Date();
      process = {
        nextTick,
        title,
        browser,
        env,
        argv,
        version,
        versions,
        on,
        addListener,
        once,
        off,
        removeListener,
        removeAllListeners,
        emit,
        binding,
        cwd,
        chdir,
        umask,
        hrtime,
        platform,
        release,
        config,
        uptime
      };
      defines = {};
      Object.keys(defines).forEach((key) => {
        const segs = key.split(".");
        let target = process;
        for (let i = 0; i < segs.length; i++) {
          const seg = segs[i];
          if (i === segs.length - 1) {
            target[seg] = defines[key];
          } else {
            target = target[seg] || (target[seg] = {});
          }
        }
      });
    }
  });

  // node_modules/@esbuild-plugins/node-globals-polyfill/Buffer.js
  function init() {
    inited = true;
    var code2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (var i = 0, len = code2.length; i < len; ++i) {
      lookup[i] = code2[i];
      revLookup[code2.charCodeAt(i)] = i;
    }
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
  }
  function base64toByteArray(b64) {
    if (!inited) {
      init();
    }
    var i, j2, l2, tmp, placeHolders, arr;
    var len = b64.length;
    if (len % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
    arr = new Arr(len * 3 / 4 - placeHolders);
    l2 = placeHolders > 0 ? len - 4 : len;
    var L2 = 0;
    for (i = 0, j2 = 0; i < l2; i += 4, j2 += 3) {
      tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
      arr[L2++] = tmp >> 16 & 255;
      arr[L2++] = tmp >> 8 & 255;
      arr[L2++] = tmp & 255;
    }
    if (placeHolders === 2) {
      tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
      arr[L2++] = tmp & 255;
    } else if (placeHolders === 1) {
      tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
      arr[L2++] = tmp >> 8 & 255;
      arr[L2++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  function encodeChunk(uint8, start, end) {
    var tmp;
    var output2 = [];
    for (var i = start; i < end; i += 3) {
      tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
      output2.push(tripletToBase64(tmp));
    }
    return output2.join("");
  }
  function base64fromByteArray(uint8) {
    if (!inited) {
      init();
    }
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3;
    var output2 = "";
    var parts = [];
    var maxChunkLength = 16383;
    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(
        encodeChunk(
          uint8,
          i,
          i + maxChunkLength > len2 ? len2 : i + maxChunkLength
        )
      );
    }
    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      output2 += lookup[tmp >> 2];
      output2 += lookup[tmp << 4 & 63];
      output2 += "==";
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + uint8[len - 1];
      output2 += lookup[tmp >> 10];
      output2 += lookup[tmp >> 4 & 63];
      output2 += lookup[tmp << 2 & 63];
      output2 += "=";
    }
    parts.push(output2);
    return parts.join("");
  }
  function kMaxLength() {
    return Buffer.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
  }
  function createBuffer(that, length) {
    if (kMaxLength() < length) {
      throw new RangeError("Invalid typed array length");
    }
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      that = new Uint8Array(length);
      that.__proto__ = Buffer.prototype;
    } else {
      if (that === null) {
        that = new Buffer(length);
      }
      that.length = length;
    }
    return that;
  }
  function Buffer(arg, encodingOrOffset, length) {
    if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
      return new Buffer(arg, encodingOrOffset, length);
    }
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new Error(
          "If encoding is specified then the first argument must be a string"
        );
      }
      return allocUnsafe(this, arg);
    }
    return from(this, arg, encodingOrOffset, length);
  }
  function from(that, value, encodingOrOffset, length) {
    if (typeof value === "number") {
      throw new TypeError('"value" argument must not be a number');
    }
    if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
      return fromArrayBuffer(that, value, encodingOrOffset, length);
    }
    if (typeof value === "string") {
      return fromString(that, value, encodingOrOffset);
    }
    return fromObject(that, value);
  }
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be a number');
    } else if (size < 0) {
      throw new RangeError('"size" argument must not be negative');
    }
  }
  function alloc(that, size, fill2, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(that, size);
    }
    if (fill2 !== void 0) {
      return typeof encoding === "string" ? createBuffer(that, size).fill(fill2, encoding) : createBuffer(that, size).fill(fill2);
    }
    return createBuffer(that, size);
  }
  function allocUnsafe(that, size) {
    assertSize(size);
    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) {
      for (var i = 0; i < size; ++i) {
        that[i] = 0;
      }
    }
    return that;
  }
  function fromString(that, string4, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer.isEncoding(encoding)) {
      throw new TypeError('"encoding" must be a valid string encoding');
    }
    var length = byteLength(string4, encoding) | 0;
    that = createBuffer(that, length);
    var actual = that.write(string4, encoding);
    if (actual !== length) {
      that = that.slice(0, actual);
    }
    return that;
  }
  function fromArrayLike(that, array6) {
    var length = array6.length < 0 ? 0 : checked(array6.length) | 0;
    that = createBuffer(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array6[i] & 255;
    }
    return that;
  }
  function fromArrayBuffer(that, array6, byteOffset, length) {
    array6.byteLength;
    if (byteOffset < 0 || array6.byteLength < byteOffset) {
      throw new RangeError("'offset' is out of bounds");
    }
    if (array6.byteLength < byteOffset + (length || 0)) {
      throw new RangeError("'length' is out of bounds");
    }
    if (byteOffset === void 0 && length === void 0) {
      array6 = new Uint8Array(array6);
    } else if (length === void 0) {
      array6 = new Uint8Array(array6, byteOffset);
    } else {
      array6 = new Uint8Array(array6, byteOffset, length);
    }
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      that = array6;
      that.__proto__ = Buffer.prototype;
    } else {
      that = fromArrayLike(that, array6);
    }
    return that;
  }
  function fromObject(that, obj) {
    if (internalIsBuffer(obj)) {
      var len = checked(obj.length) | 0;
      that = createBuffer(that, len);
      if (that.length === 0) {
        return that;
      }
      obj.copy(that, 0, 0, len);
      return that;
    }
    if (obj) {
      if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
        if (typeof obj.length !== "number" || isnan(obj.length)) {
          return createBuffer(that, 0);
        }
        return fromArrayLike(that, obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(that, obj.data);
      }
    }
    throw new TypeError(
      "First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object."
    );
  }
  function checked(length) {
    if (length >= kMaxLength()) {
      throw new RangeError(
        "Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes"
      );
    }
    return length | 0;
  }
  function internalIsBuffer(b2) {
    return !!(b2 != null && b2._isBuffer);
  }
  function byteLength(string4, encoding) {
    if (internalIsBuffer(string4)) {
      return string4.length;
    }
    if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string4) || string4 instanceof ArrayBuffer)) {
      return string4.byteLength;
    }
    if (typeof string4 !== "string") {
      string4 = "" + string4;
    }
    var len = string4.length;
    if (len === 0)
      return 0;
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
        case void 0:
          return utf8ToBytes(string4).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string4).length;
        default:
          if (loweredCase)
            return utf8ToBytes(string4).length;
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  function slowToString(encoding, start, end) {
    var loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  function swap(b2, n, m) {
    var i = b2[n];
    b2[n] = b2[m];
    b2[m] = i;
  }
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (isNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer.from(val, encoding);
    }
    if (internalIsBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(
            buffer2,
            val,
            byteOffset
          );
        } else {
          return Uint8Array.prototype.lastIndexOf.call(
            buffer2,
            val,
            byteOffset
          );
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read(buf, i2) {
      if (indexSize === 1) {
        return buf[i2];
      } else {
        return buf.readUInt16BE(i2 * indexSize);
      }
    }
    var i;
    if (dir) {
      var foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i;
          if (i - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        var found = true;
        for (var j2 = 0; j2 < valLength; j2++) {
          if (read(arr, i + j2) !== read(val, j2)) {
            found = false;
            break;
          }
        }
        if (found)
          return i;
      }
    }
    return -1;
  }
  function hexWrite(buf, string4, offset3, length) {
    offset3 = Number(offset3) || 0;
    var remaining = buf.length - offset3;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    var strLen = string4.length;
    if (strLen % 2 !== 0)
      throw new TypeError("Invalid hex string");
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i = 0; i < length; ++i) {
      var parsed = parseInt(string4.substr(i * 2, 2), 16);
      if (isNaN(parsed))
        return i;
      buf[offset3 + i] = parsed;
    }
    return i;
  }
  function utf8Write(buf, string4, offset3, length) {
    return blitBuffer(
      utf8ToBytes(string4, buf.length - offset3),
      buf,
      offset3,
      length
    );
  }
  function asciiWrite(buf, string4, offset3, length) {
    return blitBuffer(asciiToBytes(string4), buf, offset3, length);
  }
  function latin1Write(buf, string4, offset3, length) {
    return asciiWrite(buf, string4, offset3, length);
  }
  function base64Write(buf, string4, offset3, length) {
    return blitBuffer(base64ToBytes(string4), buf, offset3, length);
  }
  function ucs2Write(buf, string4, offset3, length) {
    return blitBuffer(
      utf16leToBytes(string4, buf.length - offset3),
      buf,
      offset3,
      length
    );
  }
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64fromByteArray(buf);
    } else {
      return base64fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;
    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    var res = "";
    var i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len)
      end = len;
    var out = "";
    for (var i = start; i < end; ++i) {
      out += toHex(buf[i]);
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    var bytes2 = buf.slice(start, end);
    var res = "";
    for (var i = 0; i < bytes2.length; i += 2) {
      res += String.fromCharCode(bytes2[i] + bytes2[i + 1] * 256);
    }
    return res;
  }
  function checkOffset(offset3, ext, length) {
    if (offset3 % 1 !== 0 || offset3 < 0)
      throw new RangeError("offset is not uint");
    if (offset3 + ext > length)
      throw new RangeError("Trying to access beyond buffer length");
  }
  function checkInt(buf, value, offset3, ext, max, min) {
    if (!internalIsBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('"value" argument is out of bounds');
    if (offset3 + ext > buf.length)
      throw new RangeError("Index out of range");
  }
  function objectWriteUInt16(buf, value, offset3, littleEndian) {
    if (value < 0)
      value = 65535 + value + 1;
    for (var i = 0, j2 = Math.min(buf.length - offset3, 2); i < j2; ++i) {
      buf[offset3 + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
    }
  }
  function objectWriteUInt32(buf, value, offset3, littleEndian) {
    if (value < 0)
      value = 4294967295 + value + 1;
    for (var i = 0, j2 = Math.min(buf.length - offset3, 4); i < j2; ++i) {
      buf[offset3 + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;
    }
  }
  function checkIEEE754(buf, value, offset3, ext, max, min) {
    if (offset3 + ext > buf.length)
      throw new RangeError("Index out of range");
    if (offset3 < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset3, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(
        buf,
        value,
        offset3,
        4,
        34028234663852886e22,
        -34028234663852886e22
      );
    }
    ieee754write(buf, value, offset3, littleEndian, 23, 4);
    return offset3 + 4;
  }
  function writeDouble(buf, value, offset3, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(
        buf,
        value,
        offset3,
        8,
        17976931348623157e292,
        -17976931348623157e292
      );
    }
    ieee754write(buf, value, offset3, littleEndian, 52, 8);
    return offset3 + 8;
  }
  function base64clean(str3) {
    str3 = stringtrim(str3).replace(INVALID_BASE64_RE, "");
    if (str3.length < 2)
      return "";
    while (str3.length % 4 !== 0) {
      str3 = str3 + "=";
    }
    return str3;
  }
  function stringtrim(str3) {
    if (str3.trim)
      return str3.trim();
    return str3.replace(/^\s+|\s+$/g, "");
  }
  function toHex(n) {
    if (n < 16)
      return "0" + n.toString(16);
    return n.toString(16);
  }
  function utf8ToBytes(string4, units) {
    units = units || Infinity;
    var codePoint;
    var length = string4.length;
    var leadSurrogate = null;
    var bytes2 = [];
    for (var i = 0; i < length; ++i) {
      codePoint = string4.charCodeAt(i);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes2.push(239, 191, 189);
            continue;
          } else if (i + 1 === length) {
            if ((units -= 3) > -1)
              bytes2.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes2.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes2.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes2.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes2.push(codePoint >> 6 | 192, codePoint & 63 | 128);
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes2.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes2.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes2;
  }
  function asciiToBytes(str3) {
    var byteArray = [];
    for (var i = 0; i < str3.length; ++i) {
      byteArray.push(str3.charCodeAt(i) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str3, units) {
    var c2, hi, lo;
    var byteArray = [];
    for (var i = 0; i < str3.length; ++i) {
      if ((units -= 2) < 0)
        break;
      c2 = str3.charCodeAt(i);
      hi = c2 >> 8;
      lo = c2 % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str3) {
    return base64toByteArray(base64clean(str3));
  }
  function blitBuffer(src, dst, offset3, length) {
    for (var i = 0; i < length; ++i) {
      if (i + offset3 >= dst.length || i >= src.length)
        break;
      dst[i + offset3] = src[i];
    }
    return i;
  }
  function isnan(val) {
    return val !== val;
  }
  function isBuffer(obj) {
    return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
  }
  function isFastBuffer(obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
  }
  function isSlowBuffer(obj) {
    return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0));
  }
  function ieee754read(buffer2, offset3, isLE2, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE2 ? nBytes - 1 : 0;
    var d2 = isLE2 ? -1 : 1;
    var s = buffer2[offset3 + i];
    i += d2;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer2[offset3 + i], i += d2, nBits -= 8) {
    }
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer2[offset3 + i], i += d2, nBits -= 8) {
    }
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  }
  function ieee754write(buffer2, value, offset3, isLE2, mLen, nBytes) {
    var e, m, c2;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt2 = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE2 ? 0 : nBytes - 1;
    var d2 = isLE2 ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c2 = Math.pow(2, -e)) < 1) {
        e--;
        c2 *= 2;
      }
      if (e + eBias >= 1) {
        value += rt2 / c2;
      } else {
        value += rt2 * Math.pow(2, 1 - eBias);
      }
      if (value * c2 >= 2) {
        e++;
        c2 /= 2;
      }
      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c2 - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    for (; mLen >= 8; buffer2[offset3 + i] = m & 255, i += d2, m /= 256, mLen -= 8) {
    }
    e = e << mLen | m;
    eLen += mLen;
    for (; eLen > 0; buffer2[offset3 + i] = e & 255, i += d2, e /= 256, eLen -= 8) {
    }
    buffer2[offset3 + i - d2] |= s * 128;
  }
  var lookup, revLookup, Arr, inited, MAX_ARGUMENTS_LENGTH, INVALID_BASE64_RE;
  var init_Buffer = __esm({
    "node_modules/@esbuild-plugins/node-globals-polyfill/Buffer.js"() {
      init_virtual_process_polyfill();
      init_buffer();
      lookup = [];
      revLookup = [];
      Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      inited = false;
      Buffer.TYPED_ARRAY_SUPPORT = window.TYPED_ARRAY_SUPPORT !== void 0 ? window.TYPED_ARRAY_SUPPORT : true;
      Buffer.poolSize = 8192;
      Buffer._augment = function(arr) {
        arr.__proto__ = Buffer.prototype;
        return arr;
      };
      Buffer.from = function(value, encodingOrOffset, length) {
        return from(null, value, encodingOrOffset, length);
      };
      Buffer.kMaxLength = kMaxLength();
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        Buffer.prototype.__proto__ = Uint8Array.prototype;
        Buffer.__proto__ = Uint8Array;
        if (typeof Symbol !== "undefined" && Symbol.species && Buffer[Symbol.species] === Buffer) {
        }
      }
      Buffer.alloc = function(size, fill2, encoding) {
        return alloc(null, size, fill2, encoding);
      };
      Buffer.allocUnsafe = function(size) {
        return allocUnsafe(null, size);
      };
      Buffer.allocUnsafeSlow = function(size) {
        return allocUnsafe(null, size);
      };
      Buffer.isBuffer = isBuffer;
      Buffer.compare = function compare(a, b2) {
        if (!internalIsBuffer(a) || !internalIsBuffer(b2)) {
          throw new TypeError("Arguments must be Buffers");
        }
        if (a === b2)
          return 0;
        var x2 = a.length;
        var y2 = b2.length;
        for (var i = 0, len = Math.min(x2, y2); i < len; ++i) {
          if (a[i] !== b2[i]) {
            x2 = a[i];
            y2 = b2[i];
            break;
          }
        }
        if (x2 < y2)
          return -1;
        if (y2 < x2)
          return 1;
        return 0;
      };
      Buffer.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer.concat = function concat(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer.alloc(0);
        }
        var i;
        if (length === void 0) {
          length = 0;
          for (i = 0; i < list.length; ++i) {
            length += list[i].length;
          }
        }
        var buffer2 = Buffer.allocUnsafe(length);
        var pos = 0;
        for (i = 0; i < list.length; ++i) {
          var buf = list[i];
          if (!internalIsBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          }
          buf.copy(buffer2, pos);
          pos += buf.length;
        }
        return buffer2;
      };
      Buffer.byteLength = byteLength;
      Buffer.prototype._isBuffer = true;
      Buffer.prototype.swap16 = function swap16() {
        var len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (var i = 0; i < len; i += 2) {
          swap(this, i, i + 1);
        }
        return this;
      };
      Buffer.prototype.swap32 = function swap32() {
        var len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (var i = 0; i < len; i += 4) {
          swap(this, i, i + 3);
          swap(this, i + 1, i + 2);
        }
        return this;
      };
      Buffer.prototype.swap64 = function swap64() {
        var len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (var i = 0; i < len; i += 8) {
          swap(this, i, i + 7);
          swap(this, i + 1, i + 6);
          swap(this, i + 2, i + 5);
          swap(this, i + 3, i + 4);
        }
        return this;
      };
      Buffer.prototype.toString = function toString() {
        var length = this.length | 0;
        if (length === 0)
          return "";
        if (arguments.length === 0)
          return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer.prototype.equals = function equals(b2) {
        if (!internalIsBuffer(b2))
          throw new TypeError("Argument must be a Buffer");
        if (this === b2)
          return true;
        return Buffer.compare(this, b2) === 0;
      };
      Buffer.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
        if (!internalIsBuffer(target)) {
          throw new TypeError("Argument must be a Buffer");
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target)
          return 0;
        var x2 = thisEnd - thisStart;
        var y2 = end - start;
        var len = Math.min(x2, y2);
        var thisCopy = this.slice(thisStart, thisEnd);
        var targetCopy = target.slice(start, end);
        for (var i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x2 = thisCopy[i];
            y2 = targetCopy[i];
            break;
          }
        }
        if (x2 < y2)
          return -1;
        if (y2 < x2)
          return 1;
        return 0;
      };
      Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      Buffer.prototype.write = function write(string4, offset3, length, encoding) {
        if (offset3 === void 0) {
          encoding = "utf8";
          length = this.length;
          offset3 = 0;
        } else if (length === void 0 && typeof offset3 === "string") {
          encoding = offset3;
          length = this.length;
          offset3 = 0;
        } else if (isFinite(offset3)) {
          offset3 = offset3 | 0;
          if (isFinite(length)) {
            length = length | 0;
            if (encoding === void 0)
              encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        var remaining = this.length - offset3;
        if (length === void 0 || length > remaining)
          length = remaining;
        if (string4.length > 0 && (length < 0 || offset3 < 0) || offset3 > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding)
          encoding = "utf8";
        var loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string4, offset3, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string4, offset3, length);
            case "ascii":
              return asciiWrite(this, string4, offset3, length);
            case "latin1":
            case "binary":
              return latin1Write(this, string4, offset3, length);
            case "base64":
              return base64Write(this, string4, offset3, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string4, offset3, length);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      MAX_ARGUMENTS_LENGTH = 4096;
      Buffer.prototype.slice = function slice(start, end) {
        var len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0)
            start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0)
            end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start)
          end = start;
        var newBuf;
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          newBuf = this.subarray(start, end);
          newBuf.__proto__ = Buffer.prototype;
        } else {
          var sliceLen = end - start;
          newBuf = new Buffer(sliceLen, void 0);
          for (var i = 0; i < sliceLen; ++i) {
            newBuf[i] = this[i + start];
          }
        }
        return newBuf;
      };
      Buffer.prototype.readUIntLE = function readUIntLE(offset3, byteLength3, noAssert) {
        offset3 = offset3 | 0;
        byteLength3 = byteLength3 | 0;
        if (!noAssert)
          checkOffset(offset3, byteLength3, this.length);
        var val = this[offset3];
        var mul = 1;
        var i = 0;
        while (++i < byteLength3 && (mul *= 256)) {
          val += this[offset3 + i] * mul;
        }
        return val;
      };
      Buffer.prototype.readUIntBE = function readUIntBE(offset3, byteLength3, noAssert) {
        offset3 = offset3 | 0;
        byteLength3 = byteLength3 | 0;
        if (!noAssert) {
          checkOffset(offset3, byteLength3, this.length);
        }
        var val = this[offset3 + --byteLength3];
        var mul = 1;
        while (byteLength3 > 0 && (mul *= 256)) {
          val += this[offset3 + --byteLength3] * mul;
        }
        return val;
      };
      Buffer.prototype.readUInt8 = function readUInt8(offset3, noAssert) {
        if (!noAssert)
          checkOffset(offset3, 1, this.length);
        return this[offset3];
      };
      Buffer.prototype.readUInt16LE = function readUInt16LE(offset3, noAssert) {
        if (!noAssert)
          checkOffset(offset3, 2, this.length);
        return this[offset3] | this[offset3 + 1] << 8;
      };
      Buffer.prototype.readUInt16BE = function readUInt16BE(offset3, noAssert) {
        if (!noAssert)
          checkOffset(offset3, 2, this.length);
        return this[offset3] << 8 | this[offset3 + 1];
      };
      Buffer.prototype.readUInt32LE = function readUInt32LE(offset3, noAssert) {
        if (!noAssert)
          checkOffset(offset3, 4, this.length);
        return (this[offset3] | this[offset3 + 1] << 8 | this[offset3 + 2] << 16) + this[offset3 + 3] * 16777216;
      };
      Buffer.prototype.readUInt32BE = function readUInt32BE(offset3, noAssert) {
        if (!noAssert)
          checkOffset(offset3, 4, this.length);
        return this[offset3] * 16777216 + (this[offset3 + 1] << 16 | this[offset3 + 2] << 8 | this[offset3 + 3]);
      };
      Buffer.prototype.readIntLE = function readIntLE(offset3, byteLength3, noAssert) {
        offset3 = offset3 | 0;
        byteLength3 = byteLength3 | 0;
        if (!noAssert)
          checkOffset(offset3, byteLength3, this.length);
        var val = this[offset3];
        var mul = 1;
        var i = 0;
        while (++i < byteLength3 && (mul *= 256)) {
          val += this[offset3 + i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength3);
        return val;
      };
      Buffer.prototype.readIntBE = function readIntBE(offset3, byteLength3, noAssert) {
        offset3 = offset3 | 0;
        byteLength3 = byteLength3 | 0;
        if (!noAssert)
          checkOffset(offset3, byteLength3, this.length);
        var i = byteLength3;
        var mul = 1;
        var val = this[offset3 + --i];
        while (i > 0 && (mul *= 256)) {
          val += this[offset3 + --i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength3);
        return val;
      };
      Buffer.prototype.readInt8 = function readInt8(offset3, noAssert) {
        if (!noAssert)
          checkOffset(offset3, 1, this.length);
        if (!(this[offset3] & 128))
          return this[offset3];
        return (255 - this[offset3] + 1) * -1;
      };
      Buffer.prototype.readInt16LE = function readInt16LE(offset3, noAssert) {
        if (!noAssert)
          checkOffset(offset3, 2, this.length);
        var val = this[offset3] | this[offset3 + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer.prototype.readInt16BE = function readInt16BE(offset3, noAssert) {
        if (!noAssert)
          checkOffset(offset3, 2, this.length);
        var val = this[offset3 + 1] | this[offset3] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer.prototype.readInt32LE = function readInt32LE(offset3, noAssert) {
        if (!noAssert)
          checkOffset(offset3, 4, this.length);
        return this[offset3] | this[offset3 + 1] << 8 | this[offset3 + 2] << 16 | this[offset3 + 3] << 24;
      };
      Buffer.prototype.readInt32BE = function readInt32BE(offset3, noAssert) {
        if (!noAssert)
          checkOffset(offset3, 4, this.length);
        return this[offset3] << 24 | this[offset3 + 1] << 16 | this[offset3 + 2] << 8 | this[offset3 + 3];
      };
      Buffer.prototype.readFloatLE = function readFloatLE(offset3, noAssert) {
        if (!noAssert)
          checkOffset(offset3, 4, this.length);
        return ieee754read(this, offset3, true, 23, 4);
      };
      Buffer.prototype.readFloatBE = function readFloatBE(offset3, noAssert) {
        if (!noAssert)
          checkOffset(offset3, 4, this.length);
        return ieee754read(this, offset3, false, 23, 4);
      };
      Buffer.prototype.readDoubleLE = function readDoubleLE(offset3, noAssert) {
        if (!noAssert)
          checkOffset(offset3, 8, this.length);
        return ieee754read(this, offset3, true, 52, 8);
      };
      Buffer.prototype.readDoubleBE = function readDoubleBE(offset3, noAssert) {
        if (!noAssert)
          checkOffset(offset3, 8, this.length);
        return ieee754read(this, offset3, false, 52, 8);
      };
      Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset3, byteLength3, noAssert) {
        value = +value;
        offset3 = offset3 | 0;
        byteLength3 = byteLength3 | 0;
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
          checkInt(this, value, offset3, byteLength3, maxBytes, 0);
        }
        var mul = 1;
        var i = 0;
        this[offset3] = value & 255;
        while (++i < byteLength3 && (mul *= 256)) {
          this[offset3 + i] = value / mul & 255;
        }
        return offset3 + byteLength3;
      };
      Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset3, byteLength3, noAssert) {
        value = +value;
        offset3 = offset3 | 0;
        byteLength3 = byteLength3 | 0;
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
          checkInt(this, value, offset3, byteLength3, maxBytes, 0);
        }
        var i = byteLength3 - 1;
        var mul = 1;
        this[offset3 + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          this[offset3 + i] = value / mul & 255;
        }
        return offset3 + byteLength3;
      };
      Buffer.prototype.writeUInt8 = function writeUInt8(value, offset3, noAssert) {
        value = +value;
        offset3 = offset3 | 0;
        if (!noAssert)
          checkInt(this, value, offset3, 1, 255, 0);
        if (!Buffer.TYPED_ARRAY_SUPPORT)
          value = Math.floor(value);
        this[offset3] = value & 255;
        return offset3 + 1;
      };
      Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset3, noAssert) {
        value = +value;
        offset3 = offset3 | 0;
        if (!noAssert)
          checkInt(this, value, offset3, 2, 65535, 0);
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          this[offset3] = value & 255;
          this[offset3 + 1] = value >>> 8;
        } else {
          objectWriteUInt16(this, value, offset3, true);
        }
        return offset3 + 2;
      };
      Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset3, noAssert) {
        value = +value;
        offset3 = offset3 | 0;
        if (!noAssert)
          checkInt(this, value, offset3, 2, 65535, 0);
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          this[offset3] = value >>> 8;
          this[offset3 + 1] = value & 255;
        } else {
          objectWriteUInt16(this, value, offset3, false);
        }
        return offset3 + 2;
      };
      Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset3, noAssert) {
        value = +value;
        offset3 = offset3 | 0;
        if (!noAssert)
          checkInt(this, value, offset3, 4, 4294967295, 0);
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          this[offset3 + 3] = value >>> 24;
          this[offset3 + 2] = value >>> 16;
          this[offset3 + 1] = value >>> 8;
          this[offset3] = value & 255;
        } else {
          objectWriteUInt32(this, value, offset3, true);
        }
        return offset3 + 4;
      };
      Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset3, noAssert) {
        value = +value;
        offset3 = offset3 | 0;
        if (!noAssert)
          checkInt(this, value, offset3, 4, 4294967295, 0);
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          this[offset3] = value >>> 24;
          this[offset3 + 1] = value >>> 16;
          this[offset3 + 2] = value >>> 8;
          this[offset3 + 3] = value & 255;
        } else {
          objectWriteUInt32(this, value, offset3, false);
        }
        return offset3 + 4;
      };
      Buffer.prototype.writeIntLE = function writeIntLE(value, offset3, byteLength3, noAssert) {
        value = +value;
        offset3 = offset3 | 0;
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength3 - 1);
          checkInt(this, value, offset3, byteLength3, limit - 1, -limit);
        }
        var i = 0;
        var mul = 1;
        var sub = 0;
        this[offset3] = value & 255;
        while (++i < byteLength3 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset3 + i - 1] !== 0) {
            sub = 1;
          }
          this[offset3 + i] = (value / mul >> 0) - sub & 255;
        }
        return offset3 + byteLength3;
      };
      Buffer.prototype.writeIntBE = function writeIntBE(value, offset3, byteLength3, noAssert) {
        value = +value;
        offset3 = offset3 | 0;
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength3 - 1);
          checkInt(this, value, offset3, byteLength3, limit - 1, -limit);
        }
        var i = byteLength3 - 1;
        var mul = 1;
        var sub = 0;
        this[offset3 + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset3 + i + 1] !== 0) {
            sub = 1;
          }
          this[offset3 + i] = (value / mul >> 0) - sub & 255;
        }
        return offset3 + byteLength3;
      };
      Buffer.prototype.writeInt8 = function writeInt8(value, offset3, noAssert) {
        value = +value;
        offset3 = offset3 | 0;
        if (!noAssert)
          checkInt(this, value, offset3, 1, 127, -128);
        if (!Buffer.TYPED_ARRAY_SUPPORT)
          value = Math.floor(value);
        if (value < 0)
          value = 255 + value + 1;
        this[offset3] = value & 255;
        return offset3 + 1;
      };
      Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset3, noAssert) {
        value = +value;
        offset3 = offset3 | 0;
        if (!noAssert)
          checkInt(this, value, offset3, 2, 32767, -32768);
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          this[offset3] = value & 255;
          this[offset3 + 1] = value >>> 8;
        } else {
          objectWriteUInt16(this, value, offset3, true);
        }
        return offset3 + 2;
      };
      Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset3, noAssert) {
        value = +value;
        offset3 = offset3 | 0;
        if (!noAssert)
          checkInt(this, value, offset3, 2, 32767, -32768);
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          this[offset3] = value >>> 8;
          this[offset3 + 1] = value & 255;
        } else {
          objectWriteUInt16(this, value, offset3, false);
        }
        return offset3 + 2;
      };
      Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset3, noAssert) {
        value = +value;
        offset3 = offset3 | 0;
        if (!noAssert)
          checkInt(this, value, offset3, 4, 2147483647, -2147483648);
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          this[offset3] = value & 255;
          this[offset3 + 1] = value >>> 8;
          this[offset3 + 2] = value >>> 16;
          this[offset3 + 3] = value >>> 24;
        } else {
          objectWriteUInt32(this, value, offset3, true);
        }
        return offset3 + 4;
      };
      Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset3, noAssert) {
        value = +value;
        offset3 = offset3 | 0;
        if (!noAssert)
          checkInt(this, value, offset3, 4, 2147483647, -2147483648);
        if (value < 0)
          value = 4294967295 + value + 1;
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          this[offset3] = value >>> 24;
          this[offset3 + 1] = value >>> 16;
          this[offset3 + 2] = value >>> 8;
          this[offset3 + 3] = value & 255;
        } else {
          objectWriteUInt32(this, value, offset3, false);
        }
        return offset3 + 4;
      };
      Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset3, noAssert) {
        return writeFloat(this, value, offset3, true, noAssert);
      };
      Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset3, noAssert) {
        return writeFloat(this, value, offset3, false, noAssert);
      };
      Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset3, noAssert) {
        return writeDouble(this, value, offset3, true, noAssert);
      };
      Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset3, noAssert) {
        return writeDouble(this, value, offset3, false, noAssert);
      };
      Buffer.prototype.copy = function copy(target, targetStart, start, end) {
        if (!start)
          start = 0;
        if (!end && end !== 0)
          end = this.length;
        if (targetStart >= target.length)
          targetStart = target.length;
        if (!targetStart)
          targetStart = 0;
        if (end > 0 && end < start)
          end = start;
        if (end === start)
          return 0;
        if (target.length === 0 || this.length === 0)
          return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length)
          throw new RangeError("sourceStart out of bounds");
        if (end < 0)
          throw new RangeError("sourceEnd out of bounds");
        if (end > this.length)
          end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        var len = end - start;
        var i;
        if (this === target && start < targetStart && targetStart < end) {
          for (i = len - 1; i >= 0; --i) {
            target[i + targetStart] = this[i + start];
          }
        } else if (len < 1e3 || !Buffer.TYPED_ARRAY_SUPPORT) {
          for (i = 0; i < len; ++i) {
            target[i + targetStart] = this[i + start];
          }
        } else {
          Uint8Array.prototype.set.call(
            target,
            this.subarray(start, start + len),
            targetStart
          );
        }
        return len;
      };
      Buffer.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (val.length === 1) {
            var code2 = val.charCodeAt(0);
            if (code2 < 256) {
              val = code2;
            }
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
        } else if (typeof val === "number") {
          val = val & 255;
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val)
          val = 0;
        var i;
        if (typeof val === "number") {
          for (i = start; i < end; ++i) {
            this[i] = val;
          }
        } else {
          var bytes2 = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
          var len = bytes2.length;
          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes2[i % len];
          }
        }
        return this;
      };
      INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
    }
  });

  // node_modules/@esbuild-plugins/node-globals-polyfill/_buffer.js
  var init_buffer = __esm({
    "node_modules/@esbuild-plugins/node-globals-polyfill/_buffer.js"() {
      init_Buffer();
    }
  });

  // node_modules/react/cjs/react.development.js
  var require_react_development = __commonJS({
    "node_modules/react/cjs/react.development.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      if (true) {
        (function() {
          "use strict";
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
          }
          var ReactVersion = "18.2.0";
          var REACT_ELEMENT_TYPE = Symbol.for("react.element");
          var REACT_PORTAL_TYPE = Symbol.for("react.portal");
          var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
          var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
          var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
          var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
          var REACT_CONTEXT_TYPE = Symbol.for("react.context");
          var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
          var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
          var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
          var REACT_MEMO_TYPE = Symbol.for("react.memo");
          var REACT_LAZY_TYPE = Symbol.for("react.lazy");
          var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
          var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
          var FAUX_ITERATOR_SYMBOL = "@@iterator";
          function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== "object") {
              return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === "function") {
              return maybeIterator;
            }
            return null;
          }
          var ReactCurrentDispatcher = {
            current: null
          };
          var ReactCurrentBatchConfig = {
            transition: null
          };
          var ReactCurrentActQueue = {
            current: null,
            isBatchingLegacy: false,
            didScheduleLegacyUpdate: false
          };
          var ReactCurrentOwner = {
            current: null
          };
          var ReactDebugCurrentFrame = {};
          var currentExtraStackFrame = null;
          function setExtraStackFrame(stack) {
            {
              currentExtraStackFrame = stack;
            }
          }
          {
            ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
              {
                currentExtraStackFrame = stack;
              }
            };
            ReactDebugCurrentFrame.getCurrentStack = null;
            ReactDebugCurrentFrame.getStackAddendum = function() {
              var stack = "";
              if (currentExtraStackFrame) {
                stack += currentExtraStackFrame;
              }
              var impl = ReactDebugCurrentFrame.getCurrentStack;
              if (impl) {
                stack += impl() || "";
              }
              return stack;
            };
          }
          var enableScopeAPI = false;
          var enableCacheElement = false;
          var enableTransitionTracing = false;
          var enableLegacyHidden = false;
          var enableDebugTracing = false;
          var ReactSharedInternals = {
            ReactCurrentDispatcher,
            ReactCurrentBatchConfig,
            ReactCurrentOwner
          };
          {
            ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
            ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
          }
          function warn(format) {
            {
              {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                printWarning("warn", format, args);
              }
            }
          }
          function error2(format) {
            {
              {
                for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  args[_key2 - 1] = arguments[_key2];
                }
                printWarning("error", format, args);
              }
            }
          }
          function printWarning(level, format, args) {
            {
              var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack = ReactDebugCurrentFrame2.getStackAddendum();
              if (stack !== "") {
                format += "%s";
                args = args.concat([stack]);
              }
              var argsWithFormat = args.map(function(item) {
                return String(item);
              });
              argsWithFormat.unshift("Warning: " + format);
              Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
          }
          var didWarnStateUpdateForUnmountedComponent = {};
          function warnNoop(publicInstance, callerName) {
            {
              var _constructor = publicInstance.constructor;
              var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
              var warningKey = componentName + "." + callerName;
              if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
                return;
              }
              error2("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
              didWarnStateUpdateForUnmountedComponent[warningKey] = true;
            }
          }
          var ReactNoopUpdateQueue = {
            isMounted: function(publicInstance) {
              return false;
            },
            enqueueForceUpdate: function(publicInstance, callback, callerName) {
              warnNoop(publicInstance, "forceUpdate");
            },
            enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
              warnNoop(publicInstance, "replaceState");
            },
            enqueueSetState: function(publicInstance, partialState, callback, callerName) {
              warnNoop(publicInstance, "setState");
            }
          };
          var assign2 = Object.assign;
          var emptyObject = {};
          {
            Object.freeze(emptyObject);
          }
          function Component(props, context, updater) {
            this.props = props;
            this.context = context;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
          }
          Component.prototype.isReactComponent = {};
          Component.prototype.setState = function(partialState, callback) {
            if (typeof partialState !== "object" && typeof partialState !== "function" && partialState != null) {
              throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
            }
            this.updater.enqueueSetState(this, partialState, callback, "setState");
          };
          Component.prototype.forceUpdate = function(callback) {
            this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
          };
          {
            var deprecatedAPIs = {
              isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
              replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
            };
            var defineDeprecationWarning = function(methodName, info) {
              Object.defineProperty(Component.prototype, methodName, {
                get: function() {
                  warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
                  return void 0;
                }
              });
            };
            for (var fnName in deprecatedAPIs) {
              if (deprecatedAPIs.hasOwnProperty(fnName)) {
                defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
              }
            }
          }
          function ComponentDummy() {
          }
          ComponentDummy.prototype = Component.prototype;
          function PureComponent(props, context, updater) {
            this.props = props;
            this.context = context;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
          }
          var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
          pureComponentPrototype.constructor = PureComponent;
          assign2(pureComponentPrototype, Component.prototype);
          pureComponentPrototype.isPureReactComponent = true;
          function createRef() {
            var refObject = {
              current: null
            };
            {
              Object.seal(refObject);
            }
            return refObject;
          }
          var isArrayImpl = Array.isArray;
          function isArray2(a) {
            return isArrayImpl(a);
          }
          function typeName(value) {
            {
              var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
              var type5 = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
              return type5;
            }
          }
          function willCoercionThrow(value) {
            {
              try {
                testStringCoercion(value);
                return false;
              } catch (e) {
                return true;
              }
            }
          }
          function testStringCoercion(value) {
            return "" + value;
          }
          function checkKeyStringCoercion(value) {
            {
              if (willCoercionThrow(value)) {
                error2("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function getWrappedName(outerType, innerType, wrapperName) {
            var displayName = outerType.displayName;
            if (displayName) {
              return displayName;
            }
            var functionName = innerType.displayName || innerType.name || "";
            return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
          }
          function getContextName(type5) {
            return type5.displayName || "Context";
          }
          function getComponentNameFromType(type5) {
            if (type5 == null) {
              return null;
            }
            {
              if (typeof type5.tag === "number") {
                error2("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
              }
            }
            if (typeof type5 === "function") {
              return type5.displayName || type5.name || null;
            }
            if (typeof type5 === "string") {
              return type5;
            }
            switch (type5) {
              case REACT_FRAGMENT_TYPE:
                return "Fragment";
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_PROFILER_TYPE:
                return "Profiler";
              case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
              case REACT_SUSPENSE_TYPE:
                return "Suspense";
              case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            }
            if (typeof type5 === "object") {
              switch (type5.$$typeof) {
                case REACT_CONTEXT_TYPE:
                  var context = type5;
                  return getContextName(context) + ".Consumer";
                case REACT_PROVIDER_TYPE:
                  var provider = type5;
                  return getContextName(provider._context) + ".Provider";
                case REACT_FORWARD_REF_TYPE:
                  return getWrappedName(type5, type5.render, "ForwardRef");
                case REACT_MEMO_TYPE:
                  var outerName = type5.displayName || null;
                  if (outerName !== null) {
                    return outerName;
                  }
                  return getComponentNameFromType(type5.type) || "Memo";
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type5;
                  var payload = lazyComponent._payload;
                  var init2 = lazyComponent._init;
                  try {
                    return getComponentNameFromType(init2(payload));
                  } catch (x2) {
                    return null;
                  }
                }
              }
            }
            return null;
          }
          var hasOwnProperty2 = Object.prototype.hasOwnProperty;
          var RESERVED_PROPS = {
            key: true,
            ref: true,
            __self: true,
            __source: true
          };
          var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
          {
            didWarnAboutStringRefs = {};
          }
          function hasValidRef(config2) {
            {
              if (hasOwnProperty2.call(config2, "ref")) {
                var getter = Object.getOwnPropertyDescriptor(config2, "ref").get;
                if (getter && getter.isReactWarning) {
                  return false;
                }
              }
            }
            return config2.ref !== void 0;
          }
          function hasValidKey(config2) {
            {
              if (hasOwnProperty2.call(config2, "key")) {
                var getter = Object.getOwnPropertyDescriptor(config2, "key").get;
                if (getter && getter.isReactWarning) {
                  return false;
                }
              }
            }
            return config2.key !== void 0;
          }
          function defineKeyPropWarningGetter(props, displayName) {
            var warnAboutAccessingKey = function() {
              {
                if (!specialPropKeyWarningShown) {
                  specialPropKeyWarningShown = true;
                  error2("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
                }
              }
            };
            warnAboutAccessingKey.isReactWarning = true;
            Object.defineProperty(props, "key", {
              get: warnAboutAccessingKey,
              configurable: true
            });
          }
          function defineRefPropWarningGetter(props, displayName) {
            var warnAboutAccessingRef = function() {
              {
                if (!specialPropRefWarningShown) {
                  specialPropRefWarningShown = true;
                  error2("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
                }
              }
            };
            warnAboutAccessingRef.isReactWarning = true;
            Object.defineProperty(props, "ref", {
              get: warnAboutAccessingRef,
              configurable: true
            });
          }
          function warnIfStringRefCannotBeAutoConverted(config2) {
            {
              if (typeof config2.ref === "string" && ReactCurrentOwner.current && config2.__self && ReactCurrentOwner.current.stateNode !== config2.__self) {
                var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
                if (!didWarnAboutStringRefs[componentName]) {
                  error2('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config2.ref);
                  didWarnAboutStringRefs[componentName] = true;
                }
              }
            }
          }
          var ReactElement = function(type5, key, ref, self2, source, owner, props) {
            var element = {
              $$typeof: REACT_ELEMENT_TYPE,
              type: type5,
              key,
              ref,
              props,
              _owner: owner
            };
            {
              element._store = {};
              Object.defineProperty(element._store, "validated", {
                configurable: false,
                enumerable: false,
                writable: true,
                value: false
              });
              Object.defineProperty(element, "_self", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: self2
              });
              Object.defineProperty(element, "_source", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: source
              });
              if (Object.freeze) {
                Object.freeze(element.props);
                Object.freeze(element);
              }
            }
            return element;
          };
          function createElement(type5, config2, children) {
            var propName;
            var props = {};
            var key = null;
            var ref = null;
            var self2 = null;
            var source = null;
            if (config2 != null) {
              if (hasValidRef(config2)) {
                ref = config2.ref;
                {
                  warnIfStringRefCannotBeAutoConverted(config2);
                }
              }
              if (hasValidKey(config2)) {
                {
                  checkKeyStringCoercion(config2.key);
                }
                key = "" + config2.key;
              }
              self2 = config2.__self === void 0 ? null : config2.__self;
              source = config2.__source === void 0 ? null : config2.__source;
              for (propName in config2) {
                if (hasOwnProperty2.call(config2, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                  props[propName] = config2[propName];
                }
              }
            }
            var childrenLength = arguments.length - 2;
            if (childrenLength === 1) {
              props.children = children;
            } else if (childrenLength > 1) {
              var childArray = Array(childrenLength);
              for (var i = 0; i < childrenLength; i++) {
                childArray[i] = arguments[i + 2];
              }
              {
                if (Object.freeze) {
                  Object.freeze(childArray);
                }
              }
              props.children = childArray;
            }
            if (type5 && type5.defaultProps) {
              var defaultProps = type5.defaultProps;
              for (propName in defaultProps) {
                if (props[propName] === void 0) {
                  props[propName] = defaultProps[propName];
                }
              }
            }
            {
              if (key || ref) {
                var displayName = typeof type5 === "function" ? type5.displayName || type5.name || "Unknown" : type5;
                if (key) {
                  defineKeyPropWarningGetter(props, displayName);
                }
                if (ref) {
                  defineRefPropWarningGetter(props, displayName);
                }
              }
            }
            return ReactElement(type5, key, ref, self2, source, ReactCurrentOwner.current, props);
          }
          function cloneAndReplaceKey(oldElement, newKey) {
            var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
            return newElement;
          }
          function cloneElement(element, config2, children) {
            if (element === null || element === void 0) {
              throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
            }
            var propName;
            var props = assign2({}, element.props);
            var key = element.key;
            var ref = element.ref;
            var self2 = element._self;
            var source = element._source;
            var owner = element._owner;
            if (config2 != null) {
              if (hasValidRef(config2)) {
                ref = config2.ref;
                owner = ReactCurrentOwner.current;
              }
              if (hasValidKey(config2)) {
                {
                  checkKeyStringCoercion(config2.key);
                }
                key = "" + config2.key;
              }
              var defaultProps;
              if (element.type && element.type.defaultProps) {
                defaultProps = element.type.defaultProps;
              }
              for (propName in config2) {
                if (hasOwnProperty2.call(config2, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                  if (config2[propName] === void 0 && defaultProps !== void 0) {
                    props[propName] = defaultProps[propName];
                  } else {
                    props[propName] = config2[propName];
                  }
                }
              }
            }
            var childrenLength = arguments.length - 2;
            if (childrenLength === 1) {
              props.children = children;
            } else if (childrenLength > 1) {
              var childArray = Array(childrenLength);
              for (var i = 0; i < childrenLength; i++) {
                childArray[i] = arguments[i + 2];
              }
              props.children = childArray;
            }
            return ReactElement(element.type, key, ref, self2, source, owner, props);
          }
          function isValidElement(object3) {
            return typeof object3 === "object" && object3 !== null && object3.$$typeof === REACT_ELEMENT_TYPE;
          }
          var SEPARATOR = ".";
          var SUBSEPARATOR = ":";
          function escape(key) {
            var escapeRegex = /[=:]/g;
            var escaperLookup = {
              "=": "=0",
              ":": "=2"
            };
            var escapedString = key.replace(escapeRegex, function(match) {
              return escaperLookup[match];
            });
            return "$" + escapedString;
          }
          var didWarnAboutMaps = false;
          var userProvidedKeyEscapeRegex = /\/+/g;
          function escapeUserProvidedKey(text) {
            return text.replace(userProvidedKeyEscapeRegex, "$&/");
          }
          function getElementKey(element, index) {
            if (typeof element === "object" && element !== null && element.key != null) {
              {
                checkKeyStringCoercion(element.key);
              }
              return escape("" + element.key);
            }
            return index.toString(36);
          }
          function mapIntoArray(children, array6, escapedPrefix, nameSoFar, callback) {
            var type5 = typeof children;
            if (type5 === "undefined" || type5 === "boolean") {
              children = null;
            }
            var invokeCallback = false;
            if (children === null) {
              invokeCallback = true;
            } else {
              switch (type5) {
                case "string":
                case "number":
                  invokeCallback = true;
                  break;
                case "object":
                  switch (children.$$typeof) {
                    case REACT_ELEMENT_TYPE:
                    case REACT_PORTAL_TYPE:
                      invokeCallback = true;
                  }
              }
            }
            if (invokeCallback) {
              var _child = children;
              var mappedChild = callback(_child);
              var childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
              if (isArray2(mappedChild)) {
                var escapedChildKey = "";
                if (childKey != null) {
                  escapedChildKey = escapeUserProvidedKey(childKey) + "/";
                }
                mapIntoArray(mappedChild, array6, escapedChildKey, "", function(c2) {
                  return c2;
                });
              } else if (mappedChild != null) {
                if (isValidElement(mappedChild)) {
                  {
                    if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {
                      checkKeyStringCoercion(mappedChild.key);
                    }
                  }
                  mappedChild = cloneAndReplaceKey(
                    mappedChild,
                    escapedPrefix + (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? escapeUserProvidedKey("" + mappedChild.key) + "/" : "") + childKey
                  );
                }
                array6.push(mappedChild);
              }
              return 1;
            }
            var child;
            var nextName;
            var subtreeCount = 0;
            var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
            if (isArray2(children)) {
              for (var i = 0; i < children.length; i++) {
                child = children[i];
                nextName = nextNamePrefix + getElementKey(child, i);
                subtreeCount += mapIntoArray(child, array6, escapedPrefix, nextName, callback);
              }
            } else {
              var iteratorFn = getIteratorFn(children);
              if (typeof iteratorFn === "function") {
                var iterableChildren = children;
                {
                  if (iteratorFn === iterableChildren.entries) {
                    if (!didWarnAboutMaps) {
                      warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                    }
                    didWarnAboutMaps = true;
                  }
                }
                var iterator = iteratorFn.call(iterableChildren);
                var step;
                var ii = 0;
                while (!(step = iterator.next()).done) {
                  child = step.value;
                  nextName = nextNamePrefix + getElementKey(child, ii++);
                  subtreeCount += mapIntoArray(child, array6, escapedPrefix, nextName, callback);
                }
              } else if (type5 === "object") {
                var childrenString = String(children);
                throw new Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). If you meant to render a collection of children, use an array instead.");
              }
            }
            return subtreeCount;
          }
          function mapChildren(children, func, context) {
            if (children == null) {
              return children;
            }
            var result = [];
            var count = 0;
            mapIntoArray(children, result, "", "", function(child) {
              return func.call(context, child, count++);
            });
            return result;
          }
          function countChildren(children) {
            var n = 0;
            mapChildren(children, function() {
              n++;
            });
            return n;
          }
          function forEachChildren(children, forEachFunc, forEachContext) {
            mapChildren(children, function() {
              forEachFunc.apply(this, arguments);
            }, forEachContext);
          }
          function toArray(children) {
            return mapChildren(children, function(child) {
              return child;
            }) || [];
          }
          function onlyChild(children) {
            if (!isValidElement(children)) {
              throw new Error("React.Children.only expected to receive a single React element child.");
            }
            return children;
          }
          function createContext3(defaultValue) {
            var context = {
              $$typeof: REACT_CONTEXT_TYPE,
              _currentValue: defaultValue,
              _currentValue2: defaultValue,
              _threadCount: 0,
              Provider: null,
              Consumer: null,
              _defaultValue: null,
              _globalName: null
            };
            context.Provider = {
              $$typeof: REACT_PROVIDER_TYPE,
              _context: context
            };
            var hasWarnedAboutUsingNestedContextConsumers = false;
            var hasWarnedAboutUsingConsumerProvider = false;
            var hasWarnedAboutDisplayNameOnConsumer = false;
            {
              var Consumer = {
                $$typeof: REACT_CONTEXT_TYPE,
                _context: context
              };
              Object.defineProperties(Consumer, {
                Provider: {
                  get: function() {
                    if (!hasWarnedAboutUsingConsumerProvider) {
                      hasWarnedAboutUsingConsumerProvider = true;
                      error2("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                    }
                    return context.Provider;
                  },
                  set: function(_Provider) {
                    context.Provider = _Provider;
                  }
                },
                _currentValue: {
                  get: function() {
                    return context._currentValue;
                  },
                  set: function(_currentValue) {
                    context._currentValue = _currentValue;
                  }
                },
                _currentValue2: {
                  get: function() {
                    return context._currentValue2;
                  },
                  set: function(_currentValue2) {
                    context._currentValue2 = _currentValue2;
                  }
                },
                _threadCount: {
                  get: function() {
                    return context._threadCount;
                  },
                  set: function(_threadCount) {
                    context._threadCount = _threadCount;
                  }
                },
                Consumer: {
                  get: function() {
                    if (!hasWarnedAboutUsingNestedContextConsumers) {
                      hasWarnedAboutUsingNestedContextConsumers = true;
                      error2("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                    }
                    return context.Consumer;
                  }
                },
                displayName: {
                  get: function() {
                    return context.displayName;
                  },
                  set: function(displayName) {
                    if (!hasWarnedAboutDisplayNameOnConsumer) {
                      warn("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName);
                      hasWarnedAboutDisplayNameOnConsumer = true;
                    }
                  }
                }
              });
              context.Consumer = Consumer;
            }
            {
              context._currentRenderer = null;
              context._currentRenderer2 = null;
            }
            return context;
          }
          var Uninitialized = -1;
          var Pending = 0;
          var Resolved = 1;
          var Rejected = 2;
          function lazyInitializer(payload) {
            if (payload._status === Uninitialized) {
              var ctor = payload._result;
              var thenable = ctor();
              thenable.then(function(moduleObject2) {
                if (payload._status === Pending || payload._status === Uninitialized) {
                  var resolved = payload;
                  resolved._status = Resolved;
                  resolved._result = moduleObject2;
                }
              }, function(error3) {
                if (payload._status === Pending || payload._status === Uninitialized) {
                  var rejected = payload;
                  rejected._status = Rejected;
                  rejected._result = error3;
                }
              });
              if (payload._status === Uninitialized) {
                var pending = payload;
                pending._status = Pending;
                pending._result = thenable;
              }
            }
            if (payload._status === Resolved) {
              var moduleObject = payload._result;
              {
                if (moduleObject === void 0) {
                  error2("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?", moduleObject);
                }
              }
              {
                if (!("default" in moduleObject)) {
                  error2("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
                }
              }
              return moduleObject.default;
            } else {
              throw payload._result;
            }
          }
          function lazy(ctor) {
            var payload = {
              _status: Uninitialized,
              _result: ctor
            };
            var lazyType = {
              $$typeof: REACT_LAZY_TYPE,
              _payload: payload,
              _init: lazyInitializer
            };
            {
              var defaultProps;
              var propTypes;
              Object.defineProperties(lazyType, {
                defaultProps: {
                  configurable: true,
                  get: function() {
                    return defaultProps;
                  },
                  set: function(newDefaultProps) {
                    error2("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                    defaultProps = newDefaultProps;
                    Object.defineProperty(lazyType, "defaultProps", {
                      enumerable: true
                    });
                  }
                },
                propTypes: {
                  configurable: true,
                  get: function() {
                    return propTypes;
                  },
                  set: function(newPropTypes) {
                    error2("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                    propTypes = newPropTypes;
                    Object.defineProperty(lazyType, "propTypes", {
                      enumerable: true
                    });
                  }
                }
              });
            }
            return lazyType;
          }
          function forwardRef(render) {
            {
              if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
                error2("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
              } else if (typeof render !== "function") {
                error2("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render);
              } else {
                if (render.length !== 0 && render.length !== 2) {
                  error2("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
                }
              }
              if (render != null) {
                if (render.defaultProps != null || render.propTypes != null) {
                  error2("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
                }
              }
            }
            var elementType = {
              $$typeof: REACT_FORWARD_REF_TYPE,
              render
            };
            {
              var ownName;
              Object.defineProperty(elementType, "displayName", {
                enumerable: false,
                configurable: true,
                get: function() {
                  return ownName;
                },
                set: function(name2) {
                  ownName = name2;
                  if (!render.name && !render.displayName) {
                    render.displayName = name2;
                  }
                }
              });
            }
            return elementType;
          }
          var REACT_MODULE_REFERENCE;
          {
            REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
          }
          function isValidElementType(type5) {
            if (typeof type5 === "string" || typeof type5 === "function") {
              return true;
            }
            if (type5 === REACT_FRAGMENT_TYPE || type5 === REACT_PROFILER_TYPE || enableDebugTracing || type5 === REACT_STRICT_MODE_TYPE || type5 === REACT_SUSPENSE_TYPE || type5 === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type5 === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
              return true;
            }
            if (typeof type5 === "object" && type5 !== null) {
              if (type5.$$typeof === REACT_LAZY_TYPE || type5.$$typeof === REACT_MEMO_TYPE || type5.$$typeof === REACT_PROVIDER_TYPE || type5.$$typeof === REACT_CONTEXT_TYPE || type5.$$typeof === REACT_FORWARD_REF_TYPE || type5.$$typeof === REACT_MODULE_REFERENCE || type5.getModuleId !== void 0) {
                return true;
              }
            }
            return false;
          }
          function memo(type5, compare4) {
            {
              if (!isValidElementType(type5)) {
                error2("memo: The first argument must be a component. Instead received: %s", type5 === null ? "null" : typeof type5);
              }
            }
            var elementType = {
              $$typeof: REACT_MEMO_TYPE,
              type: type5,
              compare: compare4 === void 0 ? null : compare4
            };
            {
              var ownName;
              Object.defineProperty(elementType, "displayName", {
                enumerable: false,
                configurable: true,
                get: function() {
                  return ownName;
                },
                set: function(name2) {
                  ownName = name2;
                  if (!type5.name && !type5.displayName) {
                    type5.displayName = name2;
                  }
                }
              });
            }
            return elementType;
          }
          function resolveDispatcher() {
            var dispatcher = ReactCurrentDispatcher.current;
            {
              if (dispatcher === null) {
                error2("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
              }
            }
            return dispatcher;
          }
          function useContext5(Context) {
            var dispatcher = resolveDispatcher();
            {
              if (Context._context !== void 0) {
                var realContext = Context._context;
                if (realContext.Consumer === Context) {
                  error2("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
                } else if (realContext.Provider === Context) {
                  error2("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
                }
              }
            }
            return dispatcher.useContext(Context);
          }
          function useState6(initialState2) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useState(initialState2);
          }
          function useReducer2(reducer2, initialArg, init2) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useReducer(reducer2, initialArg, init2);
          }
          function useRef2(initialValue) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useRef(initialValue);
          }
          function useEffect6(create5, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useEffect(create5, deps);
          }
          function useInsertionEffect(create5, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useInsertionEffect(create5, deps);
          }
          function useLayoutEffect(create5, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useLayoutEffect(create5, deps);
          }
          function useCallback2(callback, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useCallback(callback, deps);
          }
          function useMemo2(create5, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useMemo(create5, deps);
          }
          function useImperativeHandle(ref, create5, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useImperativeHandle(ref, create5, deps);
          }
          function useDebugValue2(value, formatterFn) {
            {
              var dispatcher = resolveDispatcher();
              return dispatcher.useDebugValue(value, formatterFn);
            }
          }
          function useTransition() {
            var dispatcher = resolveDispatcher();
            return dispatcher.useTransition();
          }
          function useDeferredValue(value) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useDeferredValue(value);
          }
          function useId() {
            var dispatcher = resolveDispatcher();
            return dispatcher.useId();
          }
          function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
          }
          var disabledDepth = 0;
          var prevLog;
          var prevInfo;
          var prevWarn;
          var prevError;
          var prevGroup;
          var prevGroupCollapsed;
          var prevGroupEnd;
          function disabledLog() {
          }
          disabledLog.__reactDisabledLog = true;
          function disableLogs() {
            {
              if (disabledDepth === 0) {
                prevLog = console.log;
                prevInfo = console.info;
                prevWarn = console.warn;
                prevError = console.error;
                prevGroup = console.group;
                prevGroupCollapsed = console.groupCollapsed;
                prevGroupEnd = console.groupEnd;
                var props = {
                  configurable: true,
                  enumerable: true,
                  value: disabledLog,
                  writable: true
                };
                Object.defineProperties(console, {
                  info: props,
                  log: props,
                  warn: props,
                  error: props,
                  group: props,
                  groupCollapsed: props,
                  groupEnd: props
                });
              }
              disabledDepth++;
            }
          }
          function reenableLogs() {
            {
              disabledDepth--;
              if (disabledDepth === 0) {
                var props = {
                  configurable: true,
                  enumerable: true,
                  writable: true
                };
                Object.defineProperties(console, {
                  log: assign2({}, props, {
                    value: prevLog
                  }),
                  info: assign2({}, props, {
                    value: prevInfo
                  }),
                  warn: assign2({}, props, {
                    value: prevWarn
                  }),
                  error: assign2({}, props, {
                    value: prevError
                  }),
                  group: assign2({}, props, {
                    value: prevGroup
                  }),
                  groupCollapsed: assign2({}, props, {
                    value: prevGroupCollapsed
                  }),
                  groupEnd: assign2({}, props, {
                    value: prevGroupEnd
                  })
                });
              }
              if (disabledDepth < 0) {
                error2("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
              }
            }
          }
          var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
          var prefix;
          function describeBuiltInComponentFrame(name2, source, ownerFn) {
            {
              if (prefix === void 0) {
                try {
                  throw Error();
                } catch (x2) {
                  var match = x2.stack.trim().match(/\n( *(at )?)/);
                  prefix = match && match[1] || "";
                }
              }
              return "\n" + prefix + name2;
            }
          }
          var reentry = false;
          var componentFrameCache;
          {
            var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
            componentFrameCache = new PossiblyWeakMap();
          }
          function describeNativeComponentFrame(fn2, construct) {
            if (!fn2 || reentry) {
              return "";
            }
            {
              var frame = componentFrameCache.get(fn2);
              if (frame !== void 0) {
                return frame;
              }
            }
            var control;
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            var previousDispatcher;
            {
              previousDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = null;
              disableLogs();
            }
            try {
              if (construct) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if (typeof Reflect === "object" && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x2) {
                    control = x2;
                  }
                  Reflect.construct(fn2, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x2) {
                    control = x2;
                  }
                  fn2.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x2) {
                  control = x2;
                }
                fn2();
              }
            } catch (sample) {
              if (sample && control && typeof sample.stack === "string") {
                var sampleLines = sample.stack.split("\n");
                var controlLines = control.stack.split("\n");
                var s = sampleLines.length - 1;
                var c2 = controlLines.length - 1;
                while (s >= 1 && c2 >= 0 && sampleLines[s] !== controlLines[c2]) {
                  c2--;
                }
                for (; s >= 1 && c2 >= 0; s--, c2--) {
                  if (sampleLines[s] !== controlLines[c2]) {
                    if (s !== 1 || c2 !== 1) {
                      do {
                        s--;
                        c2--;
                        if (c2 < 0 || sampleLines[s] !== controlLines[c2]) {
                          var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                          if (fn2.displayName && _frame.includes("<anonymous>")) {
                            _frame = _frame.replace("<anonymous>", fn2.displayName);
                          }
                          {
                            if (typeof fn2 === "function") {
                              componentFrameCache.set(fn2, _frame);
                            }
                          }
                          return _frame;
                        }
                      } while (s >= 1 && c2 >= 0);
                    }
                    break;
                  }
                }
              }
            } finally {
              reentry = false;
              {
                ReactCurrentDispatcher$1.current = previousDispatcher;
                reenableLogs();
              }
              Error.prepareStackTrace = previousPrepareStackTrace;
            }
            var name2 = fn2 ? fn2.displayName || fn2.name : "";
            var syntheticFrame = name2 ? describeBuiltInComponentFrame(name2) : "";
            {
              if (typeof fn2 === "function") {
                componentFrameCache.set(fn2, syntheticFrame);
              }
            }
            return syntheticFrame;
          }
          function describeFunctionComponentFrame(fn2, source, ownerFn) {
            {
              return describeNativeComponentFrame(fn2, false);
            }
          }
          function shouldConstruct(Component2) {
            var prototype = Component2.prototype;
            return !!(prototype && prototype.isReactComponent);
          }
          function describeUnknownElementTypeFrameInDEV(type5, source, ownerFn) {
            if (type5 == null) {
              return "";
            }
            if (typeof type5 === "function") {
              {
                return describeNativeComponentFrame(type5, shouldConstruct(type5));
              }
            }
            if (typeof type5 === "string") {
              return describeBuiltInComponentFrame(type5);
            }
            switch (type5) {
              case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame("Suspense");
              case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame("SuspenseList");
            }
            if (typeof type5 === "object") {
              switch (type5.$$typeof) {
                case REACT_FORWARD_REF_TYPE:
                  return describeFunctionComponentFrame(type5.render);
                case REACT_MEMO_TYPE:
                  return describeUnknownElementTypeFrameInDEV(type5.type, source, ownerFn);
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type5;
                  var payload = lazyComponent._payload;
                  var init2 = lazyComponent._init;
                  try {
                    return describeUnknownElementTypeFrameInDEV(init2(payload), source, ownerFn);
                  } catch (x2) {
                  }
                }
              }
            }
            return "";
          }
          var loggedTypeFailures = {};
          var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
          function setCurrentlyValidatingElement(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
              } else {
                ReactDebugCurrentFrame$1.setExtraStackFrame(null);
              }
            }
          }
          function checkPropTypes(typeSpecs, values, location, componentName, element) {
            {
              var has = Function.call.bind(hasOwnProperty2);
              for (var typeSpecName in typeSpecs) {
                if (has(typeSpecs, typeSpecName)) {
                  var error$1 = void 0;
                  try {
                    if (typeof typeSpecs[typeSpecName] !== "function") {
                      var err2 = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                      err2.name = "Invariant Violation";
                      throw err2;
                    }
                    error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                  } catch (ex) {
                    error$1 = ex;
                  }
                  if (error$1 && !(error$1 instanceof Error)) {
                    setCurrentlyValidatingElement(element);
                    error2("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                    setCurrentlyValidatingElement(null);
                  }
                  if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                    loggedTypeFailures[error$1.message] = true;
                    setCurrentlyValidatingElement(element);
                    error2("Failed %s type: %s", location, error$1.message);
                    setCurrentlyValidatingElement(null);
                  }
                }
              }
            }
          }
          function setCurrentlyValidatingElement$1(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                setExtraStackFrame(stack);
              } else {
                setExtraStackFrame(null);
              }
            }
          }
          var propTypesMisspellWarningShown;
          {
            propTypesMisspellWarningShown = false;
          }
          function getDeclarationErrorAddendum() {
            if (ReactCurrentOwner.current) {
              var name2 = getComponentNameFromType(ReactCurrentOwner.current.type);
              if (name2) {
                return "\n\nCheck the render method of `" + name2 + "`.";
              }
            }
            return "";
          }
          function getSourceInfoErrorAddendum(source) {
            if (source !== void 0) {
              var fileName = source.fileName.replace(/^.*[\\\/]/, "");
              var lineNumber = source.lineNumber;
              return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
            }
            return "";
          }
          function getSourceInfoErrorAddendumForProps(elementProps) {
            if (elementProps !== null && elementProps !== void 0) {
              return getSourceInfoErrorAddendum(elementProps.__source);
            }
            return "";
          }
          var ownerHasKeyUseWarning = {};
          function getCurrentComponentErrorInfo(parentType) {
            var info = getDeclarationErrorAddendum();
            if (!info) {
              var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
              if (parentName) {
                info = "\n\nCheck the top-level render call using <" + parentName + ">.";
              }
            }
            return info;
          }
          function validateExplicitKey(element, parentType) {
            if (!element._store || element._store.validated || element.key != null) {
              return;
            }
            element._store.validated = true;
            var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
            if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
              return;
            }
            ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
            var childOwner = "";
            if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
              childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
            }
            {
              setCurrentlyValidatingElement$1(element);
              error2('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
              setCurrentlyValidatingElement$1(null);
            }
          }
          function validateChildKeys(node, parentType) {
            if (typeof node !== "object") {
              return;
            }
            if (isArray2(node)) {
              for (var i = 0; i < node.length; i++) {
                var child = node[i];
                if (isValidElement(child)) {
                  validateExplicitKey(child, parentType);
                }
              }
            } else if (isValidElement(node)) {
              if (node._store) {
                node._store.validated = true;
              }
            } else if (node) {
              var iteratorFn = getIteratorFn(node);
              if (typeof iteratorFn === "function") {
                if (iteratorFn !== node.entries) {
                  var iterator = iteratorFn.call(node);
                  var step;
                  while (!(step = iterator.next()).done) {
                    if (isValidElement(step.value)) {
                      validateExplicitKey(step.value, parentType);
                    }
                  }
                }
              }
            }
          }
          function validatePropTypes(element) {
            {
              var type5 = element.type;
              if (type5 === null || type5 === void 0 || typeof type5 === "string") {
                return;
              }
              var propTypes;
              if (typeof type5 === "function") {
                propTypes = type5.propTypes;
              } else if (typeof type5 === "object" && (type5.$$typeof === REACT_FORWARD_REF_TYPE || type5.$$typeof === REACT_MEMO_TYPE)) {
                propTypes = type5.propTypes;
              } else {
                return;
              }
              if (propTypes) {
                var name2 = getComponentNameFromType(type5);
                checkPropTypes(propTypes, element.props, "prop", name2, element);
              } else if (type5.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
                propTypesMisspellWarningShown = true;
                var _name = getComponentNameFromType(type5);
                error2("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
              }
              if (typeof type5.getDefaultProps === "function" && !type5.getDefaultProps.isReactClassApproved) {
                error2("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
              }
            }
          }
          function validateFragmentProps(fragment) {
            {
              var keys = Object.keys(fragment.props);
              for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                if (key !== "children" && key !== "key") {
                  setCurrentlyValidatingElement$1(fragment);
                  error2("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                  setCurrentlyValidatingElement$1(null);
                  break;
                }
              }
              if (fragment.ref !== null) {
                setCurrentlyValidatingElement$1(fragment);
                error2("Invalid attribute `ref` supplied to `React.Fragment`.");
                setCurrentlyValidatingElement$1(null);
              }
            }
          }
          function createElementWithValidation(type5, props, children) {
            var validType = isValidElementType(type5);
            if (!validType) {
              var info = "";
              if (type5 === void 0 || typeof type5 === "object" && type5 !== null && Object.keys(type5).length === 0) {
                info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
              }
              var sourceInfo = getSourceInfoErrorAddendumForProps(props);
              if (sourceInfo) {
                info += sourceInfo;
              } else {
                info += getDeclarationErrorAddendum();
              }
              var typeString;
              if (type5 === null) {
                typeString = "null";
              } else if (isArray2(type5)) {
                typeString = "array";
              } else if (type5 !== void 0 && type5.$$typeof === REACT_ELEMENT_TYPE) {
                typeString = "<" + (getComponentNameFromType(type5.type) || "Unknown") + " />";
                info = " Did you accidentally export a JSX literal instead of a component?";
              } else {
                typeString = typeof type5;
              }
              {
                error2("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
              }
            }
            var element = createElement.apply(this, arguments);
            if (element == null) {
              return element;
            }
            if (validType) {
              for (var i = 2; i < arguments.length; i++) {
                validateChildKeys(arguments[i], type5);
              }
            }
            if (type5 === REACT_FRAGMENT_TYPE) {
              validateFragmentProps(element);
            } else {
              validatePropTypes(element);
            }
            return element;
          }
          var didWarnAboutDeprecatedCreateFactory = false;
          function createFactoryWithValidation(type5) {
            var validatedFactory = createElementWithValidation.bind(null, type5);
            validatedFactory.type = type5;
            {
              if (!didWarnAboutDeprecatedCreateFactory) {
                didWarnAboutDeprecatedCreateFactory = true;
                warn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
              }
              Object.defineProperty(validatedFactory, "type", {
                enumerable: false,
                get: function() {
                  warn("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
                  Object.defineProperty(this, "type", {
                    value: type5
                  });
                  return type5;
                }
              });
            }
            return validatedFactory;
          }
          function cloneElementWithValidation(element, props, children) {
            var newElement = cloneElement.apply(this, arguments);
            for (var i = 2; i < arguments.length; i++) {
              validateChildKeys(arguments[i], newElement.type);
            }
            validatePropTypes(newElement);
            return newElement;
          }
          function startTransition(scope, options) {
            var prevTransition = ReactCurrentBatchConfig.transition;
            ReactCurrentBatchConfig.transition = {};
            var currentTransition = ReactCurrentBatchConfig.transition;
            {
              ReactCurrentBatchConfig.transition._updatedFibers = /* @__PURE__ */ new Set();
            }
            try {
              scope();
            } finally {
              ReactCurrentBatchConfig.transition = prevTransition;
              {
                if (prevTransition === null && currentTransition._updatedFibers) {
                  var updatedFibersCount = currentTransition._updatedFibers.size;
                  if (updatedFibersCount > 10) {
                    warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
                  }
                  currentTransition._updatedFibers.clear();
                }
              }
            }
          }
          var didWarnAboutMessageChannel = false;
          var enqueueTaskImpl = null;
          function enqueueTask(task) {
            if (enqueueTaskImpl === null) {
              try {
                var requireString = ("require" + Math.random()).slice(0, 7);
                var nodeRequire = module2 && module2[requireString];
                enqueueTaskImpl = nodeRequire.call(module2, "timers").setImmediate;
              } catch (_err) {
                enqueueTaskImpl = function(callback) {
                  {
                    if (didWarnAboutMessageChannel === false) {
                      didWarnAboutMessageChannel = true;
                      if (typeof MessageChannel === "undefined") {
                        error2("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning.");
                      }
                    }
                  }
                  var channel = new MessageChannel();
                  channel.port1.onmessage = callback;
                  channel.port2.postMessage(void 0);
                };
              }
            }
            return enqueueTaskImpl(task);
          }
          var actScopeDepth = 0;
          var didWarnNoAwaitAct = false;
          function act(callback) {
            {
              var prevActScopeDepth = actScopeDepth;
              actScopeDepth++;
              if (ReactCurrentActQueue.current === null) {
                ReactCurrentActQueue.current = [];
              }
              var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;
              var result;
              try {
                ReactCurrentActQueue.isBatchingLegacy = true;
                result = callback();
                if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {
                  var queue2 = ReactCurrentActQueue.current;
                  if (queue2 !== null) {
                    ReactCurrentActQueue.didScheduleLegacyUpdate = false;
                    flushActQueue(queue2);
                  }
                }
              } catch (error3) {
                popActScope(prevActScopeDepth);
                throw error3;
              } finally {
                ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
              }
              if (result !== null && typeof result === "object" && typeof result.then === "function") {
                var thenableResult = result;
                var wasAwaited = false;
                var thenable = {
                  then: function(resolve, reject) {
                    wasAwaited = true;
                    thenableResult.then(function(returnValue2) {
                      popActScope(prevActScopeDepth);
                      if (actScopeDepth === 0) {
                        recursivelyFlushAsyncActWork(returnValue2, resolve, reject);
                      } else {
                        resolve(returnValue2);
                      }
                    }, function(error3) {
                      popActScope(prevActScopeDepth);
                      reject(error3);
                    });
                  }
                };
                {
                  if (!didWarnNoAwaitAct && typeof Promise !== "undefined") {
                    Promise.resolve().then(function() {
                    }).then(function() {
                      if (!wasAwaited) {
                        didWarnNoAwaitAct = true;
                        error2("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);");
                      }
                    });
                  }
                }
                return thenable;
              } else {
                var returnValue = result;
                popActScope(prevActScopeDepth);
                if (actScopeDepth === 0) {
                  var _queue = ReactCurrentActQueue.current;
                  if (_queue !== null) {
                    flushActQueue(_queue);
                    ReactCurrentActQueue.current = null;
                  }
                  var _thenable = {
                    then: function(resolve, reject) {
                      if (ReactCurrentActQueue.current === null) {
                        ReactCurrentActQueue.current = [];
                        recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                      } else {
                        resolve(returnValue);
                      }
                    }
                  };
                  return _thenable;
                } else {
                  var _thenable2 = {
                    then: function(resolve, reject) {
                      resolve(returnValue);
                    }
                  };
                  return _thenable2;
                }
              }
            }
          }
          function popActScope(prevActScopeDepth) {
            {
              if (prevActScopeDepth !== actScopeDepth - 1) {
                error2("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. ");
              }
              actScopeDepth = prevActScopeDepth;
            }
          }
          function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
            {
              var queue2 = ReactCurrentActQueue.current;
              if (queue2 !== null) {
                try {
                  flushActQueue(queue2);
                  enqueueTask(function() {
                    if (queue2.length === 0) {
                      ReactCurrentActQueue.current = null;
                      resolve(returnValue);
                    } else {
                      recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                    }
                  });
                } catch (error3) {
                  reject(error3);
                }
              } else {
                resolve(returnValue);
              }
            }
          }
          var isFlushing = false;
          function flushActQueue(queue2) {
            {
              if (!isFlushing) {
                isFlushing = true;
                var i = 0;
                try {
                  for (; i < queue2.length; i++) {
                    var callback = queue2[i];
                    do {
                      callback = callback(true);
                    } while (callback !== null);
                  }
                  queue2.length = 0;
                } catch (error3) {
                  queue2 = queue2.slice(i + 1);
                  throw error3;
                } finally {
                  isFlushing = false;
                }
              }
            }
          }
          var createElement$1 = createElementWithValidation;
          var cloneElement$1 = cloneElementWithValidation;
          var createFactory = createFactoryWithValidation;
          var Children = {
            map: mapChildren,
            forEach: forEachChildren,
            count: countChildren,
            toArray,
            only: onlyChild
          };
          exports2.Children = Children;
          exports2.Component = Component;
          exports2.Fragment = REACT_FRAGMENT_TYPE;
          exports2.Profiler = REACT_PROFILER_TYPE;
          exports2.PureComponent = PureComponent;
          exports2.StrictMode = REACT_STRICT_MODE_TYPE;
          exports2.Suspense = REACT_SUSPENSE_TYPE;
          exports2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
          exports2.cloneElement = cloneElement$1;
          exports2.createContext = createContext3;
          exports2.createElement = createElement$1;
          exports2.createFactory = createFactory;
          exports2.createRef = createRef;
          exports2.forwardRef = forwardRef;
          exports2.isValidElement = isValidElement;
          exports2.lazy = lazy;
          exports2.memo = memo;
          exports2.startTransition = startTransition;
          exports2.unstable_act = act;
          exports2.useCallback = useCallback2;
          exports2.useContext = useContext5;
          exports2.useDebugValue = useDebugValue2;
          exports2.useDeferredValue = useDeferredValue;
          exports2.useEffect = useEffect6;
          exports2.useId = useId;
          exports2.useImperativeHandle = useImperativeHandle;
          exports2.useInsertionEffect = useInsertionEffect;
          exports2.useLayoutEffect = useLayoutEffect;
          exports2.useMemo = useMemo2;
          exports2.useReducer = useReducer2;
          exports2.useRef = useRef2;
          exports2.useState = useState6;
          exports2.useSyncExternalStore = useSyncExternalStore;
          exports2.useTransition = useTransition;
          exports2.version = ReactVersion;
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
          }
        })();
      }
    }
  });

  // node_modules/react/index.js
  var require_react = __commonJS({
    "node_modules/react/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      if (false) {
        module2.exports = null;
      } else {
        module2.exports = require_react_development();
      }
    }
  });

  // node_modules/object-assign/index.js
  var require_object_assign = __commonJS({
    "node_modules/object-assign/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var getOwnPropertySymbols = Object.getOwnPropertySymbols;
      var hasOwnProperty2 = Object.prototype.hasOwnProperty;
      var propIsEnumerable = Object.prototype.propertyIsEnumerable;
      function toObject(val) {
        if (val === null || val === void 0) {
          throw new TypeError("Object.assign cannot be called with null or undefined");
        }
        return Object(val);
      }
      function shouldUseNative() {
        try {
          if (!Object.assign) {
            return false;
          }
          var test1 = new String("abc");
          test1[5] = "de";
          if (Object.getOwnPropertyNames(test1)[0] === "5") {
            return false;
          }
          var test2 = {};
          for (var i = 0; i < 10; i++) {
            test2["_" + String.fromCharCode(i)] = i;
          }
          var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
            return test2[n];
          });
          if (order2.join("") !== "0123456789") {
            return false;
          }
          var test3 = {};
          "abcdefghijklmnopqrst".split("").forEach(function(letter) {
            test3[letter] = letter;
          });
          if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
            return false;
          }
          return true;
        } catch (err2) {
          return false;
        }
      }
      module2.exports = shouldUseNative() ? Object.assign : function(target, source) {
        var from2;
        var to = toObject(target);
        var symbols;
        for (var s = 1; s < arguments.length; s++) {
          from2 = Object(arguments[s]);
          for (var key in from2) {
            if (hasOwnProperty2.call(from2, key)) {
              to[key] = from2[key];
            }
          }
          if (getOwnPropertySymbols) {
            symbols = getOwnPropertySymbols(from2);
            for (var i = 0; i < symbols.length; i++) {
              if (propIsEnumerable.call(from2, symbols[i])) {
                to[symbols[i]] = from2[symbols[i]];
              }
            }
          }
        }
        return to;
      };
    }
  });

  // node_modules/react-reconciler/node_modules/scheduler/cjs/scheduler.development.js
  var require_scheduler_development = __commonJS({
    "node_modules/react-reconciler/node_modules/scheduler/cjs/scheduler.development.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      if (true) {
        (function() {
          "use strict";
          var enableSchedulerDebugging = false;
          var enableProfiling = false;
          var requestHostCallback;
          var requestHostTimeout;
          var cancelHostTimeout;
          var requestPaint;
          var hasPerformanceNow = typeof performance === "object" && typeof performance.now === "function";
          if (hasPerformanceNow) {
            var localPerformance = performance;
            exports2.unstable_now = function() {
              return localPerformance.now();
            };
          } else {
            var localDate = Date;
            var initialTime = localDate.now();
            exports2.unstable_now = function() {
              return localDate.now() - initialTime;
            };
          }
          if (typeof window === "undefined" || typeof MessageChannel !== "function") {
            var _callback = null;
            var _timeoutID = null;
            var _flushCallback = function() {
              if (_callback !== null) {
                try {
                  var currentTime = exports2.unstable_now();
                  var hasRemainingTime = true;
                  _callback(hasRemainingTime, currentTime);
                  _callback = null;
                } catch (e) {
                  setTimeout(_flushCallback, 0);
                  throw e;
                }
              }
            };
            requestHostCallback = function(cb) {
              if (_callback !== null) {
                setTimeout(requestHostCallback, 0, cb);
              } else {
                _callback = cb;
                setTimeout(_flushCallback, 0);
              }
            };
            requestHostTimeout = function(cb, ms) {
              _timeoutID = setTimeout(cb, ms);
            };
            cancelHostTimeout = function() {
              clearTimeout(_timeoutID);
            };
            exports2.unstable_shouldYield = function() {
              return false;
            };
            requestPaint = exports2.unstable_forceFrameRate = function() {
            };
          } else {
            var _setTimeout = window.setTimeout;
            var _clearTimeout = window.clearTimeout;
            if (typeof console !== "undefined") {
              var requestAnimationFrame = window.requestAnimationFrame;
              var cancelAnimationFrame = window.cancelAnimationFrame;
              if (typeof requestAnimationFrame !== "function") {
                console["error"]("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
              }
              if (typeof cancelAnimationFrame !== "function") {
                console["error"]("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
              }
            }
            var isMessageLoopRunning = false;
            var scheduledHostCallback = null;
            var taskTimeoutID = -1;
            var yieldInterval = 5;
            var deadline = 0;
            {
              exports2.unstable_shouldYield = function() {
                return exports2.unstable_now() >= deadline;
              };
              requestPaint = function() {
              };
            }
            exports2.unstable_forceFrameRate = function(fps) {
              if (fps < 0 || fps > 125) {
                console["error"]("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
                return;
              }
              if (fps > 0) {
                yieldInterval = Math.floor(1e3 / fps);
              } else {
                yieldInterval = 5;
              }
            };
            var performWorkUntilDeadline = function() {
              if (scheduledHostCallback !== null) {
                var currentTime = exports2.unstable_now();
                deadline = currentTime + yieldInterval;
                var hasTimeRemaining = true;
                try {
                  var hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
                  if (!hasMoreWork) {
                    isMessageLoopRunning = false;
                    scheduledHostCallback = null;
                  } else {
                    port.postMessage(null);
                  }
                } catch (error2) {
                  port.postMessage(null);
                  throw error2;
                }
              } else {
                isMessageLoopRunning = false;
              }
            };
            var channel = new MessageChannel();
            var port = channel.port2;
            channel.port1.onmessage = performWorkUntilDeadline;
            requestHostCallback = function(callback) {
              scheduledHostCallback = callback;
              if (!isMessageLoopRunning) {
                isMessageLoopRunning = true;
                port.postMessage(null);
              }
            };
            requestHostTimeout = function(callback, ms) {
              taskTimeoutID = _setTimeout(function() {
                callback(exports2.unstable_now());
              }, ms);
            };
            cancelHostTimeout = function() {
              _clearTimeout(taskTimeoutID);
              taskTimeoutID = -1;
            };
          }
          function push(heap, node) {
            var index = heap.length;
            heap.push(node);
            siftUp(heap, node, index);
          }
          function peek(heap) {
            var first = heap[0];
            return first === void 0 ? null : first;
          }
          function pop(heap) {
            var first = heap[0];
            if (first !== void 0) {
              var last = heap.pop();
              if (last !== first) {
                heap[0] = last;
                siftDown(heap, last, 0);
              }
              return first;
            } else {
              return null;
            }
          }
          function siftUp(heap, node, i) {
            var index = i;
            while (true) {
              var parentIndex = index - 1 >>> 1;
              var parent = heap[parentIndex];
              if (parent !== void 0 && compare4(parent, node) > 0) {
                heap[parentIndex] = node;
                heap[index] = parent;
                index = parentIndex;
              } else {
                return;
              }
            }
          }
          function siftDown(heap, node, i) {
            var index = i;
            var length = heap.length;
            while (index < length) {
              var leftIndex = (index + 1) * 2 - 1;
              var left = heap[leftIndex];
              var rightIndex = leftIndex + 1;
              var right = heap[rightIndex];
              if (left !== void 0 && compare4(left, node) < 0) {
                if (right !== void 0 && compare4(right, left) < 0) {
                  heap[index] = right;
                  heap[rightIndex] = node;
                  index = rightIndex;
                } else {
                  heap[index] = left;
                  heap[leftIndex] = node;
                  index = leftIndex;
                }
              } else if (right !== void 0 && compare4(right, node) < 0) {
                heap[index] = right;
                heap[rightIndex] = node;
                index = rightIndex;
              } else {
                return;
              }
            }
          }
          function compare4(a, b2) {
            var diff = a.sortIndex - b2.sortIndex;
            return diff !== 0 ? diff : a.id - b2.id;
          }
          var ImmediatePriority = 1;
          var UserBlockingPriority = 2;
          var NormalPriority = 3;
          var LowPriority = 4;
          var IdlePriority = 5;
          function markTaskErrored(task, ms) {
          }
          var maxSigned31BitInt = 1073741823;
          var IMMEDIATE_PRIORITY_TIMEOUT = -1;
          var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
          var NORMAL_PRIORITY_TIMEOUT = 5e3;
          var LOW_PRIORITY_TIMEOUT = 1e4;
          var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;
          var taskQueue = [];
          var timerQueue = [];
          var taskIdCounter = 1;
          var currentTask = null;
          var currentPriorityLevel = NormalPriority;
          var isPerformingWork = false;
          var isHostCallbackScheduled = false;
          var isHostTimeoutScheduled = false;
          function advanceTimers(currentTime) {
            var timer = peek(timerQueue);
            while (timer !== null) {
              if (timer.callback === null) {
                pop(timerQueue);
              } else if (timer.startTime <= currentTime) {
                pop(timerQueue);
                timer.sortIndex = timer.expirationTime;
                push(taskQueue, timer);
              } else {
                return;
              }
              timer = peek(timerQueue);
            }
          }
          function handleTimeout(currentTime) {
            isHostTimeoutScheduled = false;
            advanceTimers(currentTime);
            if (!isHostCallbackScheduled) {
              if (peek(taskQueue) !== null) {
                isHostCallbackScheduled = true;
                requestHostCallback(flushWork);
              } else {
                var firstTimer = peek(timerQueue);
                if (firstTimer !== null) {
                  requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
                }
              }
            }
          }
          function flushWork(hasTimeRemaining, initialTime2) {
            isHostCallbackScheduled = false;
            if (isHostTimeoutScheduled) {
              isHostTimeoutScheduled = false;
              cancelHostTimeout();
            }
            isPerformingWork = true;
            var previousPriorityLevel = currentPriorityLevel;
            try {
              if (enableProfiling) {
                try {
                  return workLoop(hasTimeRemaining, initialTime2);
                } catch (error2) {
                  if (currentTask !== null) {
                    var currentTime = exports2.unstable_now();
                    markTaskErrored(currentTask, currentTime);
                    currentTask.isQueued = false;
                  }
                  throw error2;
                }
              } else {
                return workLoop(hasTimeRemaining, initialTime2);
              }
            } finally {
              currentTask = null;
              currentPriorityLevel = previousPriorityLevel;
              isPerformingWork = false;
            }
          }
          function workLoop(hasTimeRemaining, initialTime2) {
            var currentTime = initialTime2;
            advanceTimers(currentTime);
            currentTask = peek(taskQueue);
            while (currentTask !== null && !enableSchedulerDebugging) {
              if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || exports2.unstable_shouldYield())) {
                break;
              }
              var callback = currentTask.callback;
              if (typeof callback === "function") {
                currentTask.callback = null;
                currentPriorityLevel = currentTask.priorityLevel;
                var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
                var continuationCallback = callback(didUserCallbackTimeout);
                currentTime = exports2.unstable_now();
                if (typeof continuationCallback === "function") {
                  currentTask.callback = continuationCallback;
                } else {
                  if (currentTask === peek(taskQueue)) {
                    pop(taskQueue);
                  }
                }
                advanceTimers(currentTime);
              } else {
                pop(taskQueue);
              }
              currentTask = peek(taskQueue);
            }
            if (currentTask !== null) {
              return true;
            } else {
              var firstTimer = peek(timerQueue);
              if (firstTimer !== null) {
                requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
              }
              return false;
            }
          }
          function unstable_runWithPriority(priorityLevel, eventHandler) {
            switch (priorityLevel) {
              case ImmediatePriority:
              case UserBlockingPriority:
              case NormalPriority:
              case LowPriority:
              case IdlePriority:
                break;
              default:
                priorityLevel = NormalPriority;
            }
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = priorityLevel;
            try {
              return eventHandler();
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          }
          function unstable_next(eventHandler) {
            var priorityLevel;
            switch (currentPriorityLevel) {
              case ImmediatePriority:
              case UserBlockingPriority:
              case NormalPriority:
                priorityLevel = NormalPriority;
                break;
              default:
                priorityLevel = currentPriorityLevel;
                break;
            }
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = priorityLevel;
            try {
              return eventHandler();
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          }
          function unstable_wrapCallback(callback) {
            var parentPriorityLevel = currentPriorityLevel;
            return function() {
              var previousPriorityLevel = currentPriorityLevel;
              currentPriorityLevel = parentPriorityLevel;
              try {
                return callback.apply(this, arguments);
              } finally {
                currentPriorityLevel = previousPriorityLevel;
              }
            };
          }
          function unstable_scheduleCallback(priorityLevel, callback, options) {
            var currentTime = exports2.unstable_now();
            var startTime2;
            if (typeof options === "object" && options !== null) {
              var delay = options.delay;
              if (typeof delay === "number" && delay > 0) {
                startTime2 = currentTime + delay;
              } else {
                startTime2 = currentTime;
              }
            } else {
              startTime2 = currentTime;
            }
            var timeout;
            switch (priorityLevel) {
              case ImmediatePriority:
                timeout = IMMEDIATE_PRIORITY_TIMEOUT;
                break;
              case UserBlockingPriority:
                timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
                break;
              case IdlePriority:
                timeout = IDLE_PRIORITY_TIMEOUT;
                break;
              case LowPriority:
                timeout = LOW_PRIORITY_TIMEOUT;
                break;
              case NormalPriority:
              default:
                timeout = NORMAL_PRIORITY_TIMEOUT;
                break;
            }
            var expirationTime = startTime2 + timeout;
            var newTask = {
              id: taskIdCounter++,
              callback,
              priorityLevel,
              startTime: startTime2,
              expirationTime,
              sortIndex: -1
            };
            if (startTime2 > currentTime) {
              newTask.sortIndex = startTime2;
              push(timerQueue, newTask);
              if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
                if (isHostTimeoutScheduled) {
                  cancelHostTimeout();
                } else {
                  isHostTimeoutScheduled = true;
                }
                requestHostTimeout(handleTimeout, startTime2 - currentTime);
              }
            } else {
              newTask.sortIndex = expirationTime;
              push(taskQueue, newTask);
              if (!isHostCallbackScheduled && !isPerformingWork) {
                isHostCallbackScheduled = true;
                requestHostCallback(flushWork);
              }
            }
            return newTask;
          }
          function unstable_pauseExecution() {
          }
          function unstable_continueExecution() {
            if (!isHostCallbackScheduled && !isPerformingWork) {
              isHostCallbackScheduled = true;
              requestHostCallback(flushWork);
            }
          }
          function unstable_getFirstCallbackNode() {
            return peek(taskQueue);
          }
          function unstable_cancelCallback(task) {
            task.callback = null;
          }
          function unstable_getCurrentPriorityLevel() {
            return currentPriorityLevel;
          }
          var unstable_requestPaint = requestPaint;
          var unstable_Profiling = null;
          exports2.unstable_IdlePriority = IdlePriority;
          exports2.unstable_ImmediatePriority = ImmediatePriority;
          exports2.unstable_LowPriority = LowPriority;
          exports2.unstable_NormalPriority = NormalPriority;
          exports2.unstable_Profiling = unstable_Profiling;
          exports2.unstable_UserBlockingPriority = UserBlockingPriority;
          exports2.unstable_cancelCallback = unstable_cancelCallback;
          exports2.unstable_continueExecution = unstable_continueExecution;
          exports2.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
          exports2.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
          exports2.unstable_next = unstable_next;
          exports2.unstable_pauseExecution = unstable_pauseExecution;
          exports2.unstable_requestPaint = unstable_requestPaint;
          exports2.unstable_runWithPriority = unstable_runWithPriority;
          exports2.unstable_scheduleCallback = unstable_scheduleCallback;
          exports2.unstable_wrapCallback = unstable_wrapCallback;
        })();
      }
    }
  });

  // node_modules/react-reconciler/node_modules/scheduler/index.js
  var require_scheduler = __commonJS({
    "node_modules/react-reconciler/node_modules/scheduler/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      if (false) {
        module2.exports = null;
      } else {
        module2.exports = require_scheduler_development();
      }
    }
  });

  // node_modules/react-reconciler/node_modules/scheduler/cjs/scheduler-tracing.development.js
  var require_scheduler_tracing_development = __commonJS({
    "node_modules/react-reconciler/node_modules/scheduler/cjs/scheduler-tracing.development.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      if (true) {
        (function() {
          "use strict";
          var DEFAULT_THREAD_ID = 0;
          var interactionIDCounter = 0;
          var threadIDCounter = 0;
          exports2.__interactionsRef = null;
          exports2.__subscriberRef = null;
          {
            exports2.__interactionsRef = {
              current: /* @__PURE__ */ new Set()
            };
            exports2.__subscriberRef = {
              current: null
            };
          }
          function unstable_clear(callback) {
            var prevInteractions = exports2.__interactionsRef.current;
            exports2.__interactionsRef.current = /* @__PURE__ */ new Set();
            try {
              return callback();
            } finally {
              exports2.__interactionsRef.current = prevInteractions;
            }
          }
          function unstable_getCurrent() {
            {
              return exports2.__interactionsRef.current;
            }
          }
          function unstable_getThreadID() {
            return ++threadIDCounter;
          }
          function unstable_trace(name2, timestamp, callback) {
            var threadID = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : DEFAULT_THREAD_ID;
            var interaction = {
              __count: 1,
              id: interactionIDCounter++,
              name: name2,
              timestamp
            };
            var prevInteractions = exports2.__interactionsRef.current;
            var interactions = new Set(prevInteractions);
            interactions.add(interaction);
            exports2.__interactionsRef.current = interactions;
            var subscriber = exports2.__subscriberRef.current;
            var returnValue;
            try {
              if (subscriber !== null) {
                subscriber.onInteractionTraced(interaction);
              }
            } finally {
              try {
                if (subscriber !== null) {
                  subscriber.onWorkStarted(interactions, threadID);
                }
              } finally {
                try {
                  returnValue = callback();
                } finally {
                  exports2.__interactionsRef.current = prevInteractions;
                  try {
                    if (subscriber !== null) {
                      subscriber.onWorkStopped(interactions, threadID);
                    }
                  } finally {
                    interaction.__count--;
                    if (subscriber !== null && interaction.__count === 0) {
                      subscriber.onInteractionScheduledWorkCompleted(interaction);
                    }
                  }
                }
              }
            }
            return returnValue;
          }
          function unstable_wrap(callback) {
            var threadID = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_THREAD_ID;
            var wrappedInteractions = exports2.__interactionsRef.current;
            var subscriber = exports2.__subscriberRef.current;
            if (subscriber !== null) {
              subscriber.onWorkScheduled(wrappedInteractions, threadID);
            }
            wrappedInteractions.forEach(function(interaction) {
              interaction.__count++;
            });
            var hasRun = false;
            function wrapped() {
              var prevInteractions = exports2.__interactionsRef.current;
              exports2.__interactionsRef.current = wrappedInteractions;
              subscriber = exports2.__subscriberRef.current;
              try {
                var returnValue;
                try {
                  if (subscriber !== null) {
                    subscriber.onWorkStarted(wrappedInteractions, threadID);
                  }
                } finally {
                  try {
                    returnValue = callback.apply(void 0, arguments);
                  } finally {
                    exports2.__interactionsRef.current = prevInteractions;
                    if (subscriber !== null) {
                      subscriber.onWorkStopped(wrappedInteractions, threadID);
                    }
                  }
                }
                return returnValue;
              } finally {
                if (!hasRun) {
                  hasRun = true;
                  wrappedInteractions.forEach(function(interaction) {
                    interaction.__count--;
                    if (subscriber !== null && interaction.__count === 0) {
                      subscriber.onInteractionScheduledWorkCompleted(interaction);
                    }
                  });
                }
              }
            }
            wrapped.cancel = function cancel() {
              subscriber = exports2.__subscriberRef.current;
              try {
                if (subscriber !== null) {
                  subscriber.onWorkCanceled(wrappedInteractions, threadID);
                }
              } finally {
                wrappedInteractions.forEach(function(interaction) {
                  interaction.__count--;
                  if (subscriber && interaction.__count === 0) {
                    subscriber.onInteractionScheduledWorkCompleted(interaction);
                  }
                });
              }
            };
            return wrapped;
          }
          var subscribers = null;
          {
            subscribers = /* @__PURE__ */ new Set();
          }
          function unstable_subscribe(subscriber) {
            {
              subscribers.add(subscriber);
              if (subscribers.size === 1) {
                exports2.__subscriberRef.current = {
                  onInteractionScheduledWorkCompleted,
                  onInteractionTraced,
                  onWorkCanceled,
                  onWorkScheduled,
                  onWorkStarted,
                  onWorkStopped
                };
              }
            }
          }
          function unstable_unsubscribe(subscriber) {
            {
              subscribers.delete(subscriber);
              if (subscribers.size === 0) {
                exports2.__subscriberRef.current = null;
              }
            }
          }
          function onInteractionTraced(interaction) {
            var didCatchError = false;
            var caughtError = null;
            subscribers.forEach(function(subscriber) {
              try {
                subscriber.onInteractionTraced(interaction);
              } catch (error2) {
                if (!didCatchError) {
                  didCatchError = true;
                  caughtError = error2;
                }
              }
            });
            if (didCatchError) {
              throw caughtError;
            }
          }
          function onInteractionScheduledWorkCompleted(interaction) {
            var didCatchError = false;
            var caughtError = null;
            subscribers.forEach(function(subscriber) {
              try {
                subscriber.onInteractionScheduledWorkCompleted(interaction);
              } catch (error2) {
                if (!didCatchError) {
                  didCatchError = true;
                  caughtError = error2;
                }
              }
            });
            if (didCatchError) {
              throw caughtError;
            }
          }
          function onWorkScheduled(interactions, threadID) {
            var didCatchError = false;
            var caughtError = null;
            subscribers.forEach(function(subscriber) {
              try {
                subscriber.onWorkScheduled(interactions, threadID);
              } catch (error2) {
                if (!didCatchError) {
                  didCatchError = true;
                  caughtError = error2;
                }
              }
            });
            if (didCatchError) {
              throw caughtError;
            }
          }
          function onWorkStarted(interactions, threadID) {
            var didCatchError = false;
            var caughtError = null;
            subscribers.forEach(function(subscriber) {
              try {
                subscriber.onWorkStarted(interactions, threadID);
              } catch (error2) {
                if (!didCatchError) {
                  didCatchError = true;
                  caughtError = error2;
                }
              }
            });
            if (didCatchError) {
              throw caughtError;
            }
          }
          function onWorkStopped(interactions, threadID) {
            var didCatchError = false;
            var caughtError = null;
            subscribers.forEach(function(subscriber) {
              try {
                subscriber.onWorkStopped(interactions, threadID);
              } catch (error2) {
                if (!didCatchError) {
                  didCatchError = true;
                  caughtError = error2;
                }
              }
            });
            if (didCatchError) {
              throw caughtError;
            }
          }
          function onWorkCanceled(interactions, threadID) {
            var didCatchError = false;
            var caughtError = null;
            subscribers.forEach(function(subscriber) {
              try {
                subscriber.onWorkCanceled(interactions, threadID);
              } catch (error2) {
                if (!didCatchError) {
                  didCatchError = true;
                  caughtError = error2;
                }
              }
            });
            if (didCatchError) {
              throw caughtError;
            }
          }
          exports2.unstable_clear = unstable_clear;
          exports2.unstable_getCurrent = unstable_getCurrent;
          exports2.unstable_getThreadID = unstable_getThreadID;
          exports2.unstable_subscribe = unstable_subscribe;
          exports2.unstable_trace = unstable_trace;
          exports2.unstable_unsubscribe = unstable_unsubscribe;
          exports2.unstable_wrap = unstable_wrap;
        })();
      }
    }
  });

  // node_modules/react-reconciler/node_modules/scheduler/tracing.js
  var require_tracing = __commonJS({
    "node_modules/react-reconciler/node_modules/scheduler/tracing.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      if (false) {
        module2.exports = null;
      } else {
        module2.exports = require_scheduler_tracing_development();
      }
    }
  });

  // node_modules/react-reconciler/cjs/react-reconciler.development.js
  var require_react_reconciler_development = __commonJS({
    "node_modules/react-reconciler/cjs/react-reconciler.development.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      if (true) {
        module2.exports = function $$$reconciler($$$hostConfig) {
          var exports3 = {};
          "use strict";
          var React15 = require_react();
          var _assign = require_object_assign();
          var Scheduler = require_scheduler();
          var tracing = require_tracing();
          var ReactSharedInternals = React15.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
          function warn(format) {
            {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              printWarning("warn", format, args);
            }
          }
          function error2(format) {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
          function printWarning(level, format, args) {
            {
              var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack = ReactDebugCurrentFrame2.getStackAddendum();
              if (stack !== "") {
                format += "%s";
                args = args.concat([stack]);
              }
              var argsWithFormat = args.map(function(item) {
                return "" + item;
              });
              argsWithFormat.unshift("Warning: " + format);
              Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
          }
          var FunctionComponent = 0;
          var ClassComponent = 1;
          var IndeterminateComponent = 2;
          var HostRoot = 3;
          var HostPortal = 4;
          var HostComponent = 5;
          var HostText = 6;
          var Fragment = 7;
          var Mode = 8;
          var ContextConsumer = 9;
          var ContextProvider = 10;
          var ForwardRef = 11;
          var Profiler = 12;
          var SuspenseComponent = 13;
          var MemoComponent = 14;
          var SimpleMemoComponent = 15;
          var LazyComponent = 16;
          var IncompleteClassComponent = 17;
          var DehydratedFragment = 18;
          var SuspenseListComponent = 19;
          var FundamentalComponent = 20;
          var ScopeComponent = 21;
          var Block = 22;
          var OffscreenComponent = 23;
          var LegacyHiddenComponent = 24;
          function get(key) {
            return key._reactInternals;
          }
          function set(key, value) {
            key._reactInternals = value;
          }
          var REACT_ELEMENT_TYPE = 60103;
          var REACT_PORTAL_TYPE = 60106;
          var REACT_FRAGMENT_TYPE = 60107;
          var REACT_STRICT_MODE_TYPE = 60108;
          var REACT_PROFILER_TYPE = 60114;
          var REACT_PROVIDER_TYPE = 60109;
          var REACT_CONTEXT_TYPE = 60110;
          var REACT_FORWARD_REF_TYPE = 60112;
          var REACT_SUSPENSE_TYPE = 60113;
          var REACT_SUSPENSE_LIST_TYPE = 60120;
          var REACT_MEMO_TYPE = 60115;
          var REACT_LAZY_TYPE = 60116;
          var REACT_BLOCK_TYPE = 60121;
          var REACT_SERVER_BLOCK_TYPE = 60122;
          var REACT_FUNDAMENTAL_TYPE = 60117;
          var REACT_SCOPE_TYPE = 60119;
          var REACT_OPAQUE_ID_TYPE = 60128;
          var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
          var REACT_OFFSCREEN_TYPE = 60130;
          var REACT_LEGACY_HIDDEN_TYPE = 60131;
          if (typeof Symbol === "function" && Symbol.for) {
            var symbolFor = Symbol.for;
            REACT_ELEMENT_TYPE = symbolFor("react.element");
            REACT_PORTAL_TYPE = symbolFor("react.portal");
            REACT_FRAGMENT_TYPE = symbolFor("react.fragment");
            REACT_STRICT_MODE_TYPE = symbolFor("react.strict_mode");
            REACT_PROFILER_TYPE = symbolFor("react.profiler");
            REACT_PROVIDER_TYPE = symbolFor("react.provider");
            REACT_CONTEXT_TYPE = symbolFor("react.context");
            REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref");
            REACT_SUSPENSE_TYPE = symbolFor("react.suspense");
            REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list");
            REACT_MEMO_TYPE = symbolFor("react.memo");
            REACT_LAZY_TYPE = symbolFor("react.lazy");
            REACT_BLOCK_TYPE = symbolFor("react.block");
            REACT_SERVER_BLOCK_TYPE = symbolFor("react.server.block");
            REACT_FUNDAMENTAL_TYPE = symbolFor("react.fundamental");
            REACT_SCOPE_TYPE = symbolFor("react.scope");
            REACT_OPAQUE_ID_TYPE = symbolFor("react.opaque.id");
            REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode");
            REACT_OFFSCREEN_TYPE = symbolFor("react.offscreen");
            REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
          }
          var MAYBE_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
          var FAUX_ITERATOR_SYMBOL = "@@iterator";
          function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== "object") {
              return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === "function") {
              return maybeIterator;
            }
            return null;
          }
          function getWrappedName(outerType, innerType, wrapperName) {
            var functionName = innerType.displayName || innerType.name || "";
            return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
          }
          function getContextName(type5) {
            return type5.displayName || "Context";
          }
          function getComponentName(type5) {
            if (type5 == null) {
              return null;
            }
            {
              if (typeof type5.tag === "number") {
                error2("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue.");
              }
            }
            if (typeof type5 === "function") {
              return type5.displayName || type5.name || null;
            }
            if (typeof type5 === "string") {
              return type5;
            }
            switch (type5) {
              case REACT_FRAGMENT_TYPE:
                return "Fragment";
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_PROFILER_TYPE:
                return "Profiler";
              case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
              case REACT_SUSPENSE_TYPE:
                return "Suspense";
              case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            }
            if (typeof type5 === "object") {
              switch (type5.$$typeof) {
                case REACT_CONTEXT_TYPE:
                  var context = type5;
                  return getContextName(context) + ".Consumer";
                case REACT_PROVIDER_TYPE:
                  var provider = type5;
                  return getContextName(provider._context) + ".Provider";
                case REACT_FORWARD_REF_TYPE:
                  return getWrappedName(type5, type5.render, "ForwardRef");
                case REACT_MEMO_TYPE:
                  return getComponentName(type5.type);
                case REACT_BLOCK_TYPE:
                  return getComponentName(type5._render);
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type5;
                  var payload = lazyComponent._payload;
                  var init2 = lazyComponent._init;
                  try {
                    return getComponentName(init2(payload));
                  } catch (x2) {
                    return null;
                  }
                }
              }
            }
            return null;
          }
          var NoFlags = 0;
          var PerformedWork = 1;
          var Placement = 2;
          var Update = 4;
          var PlacementAndUpdate = 6;
          var Deletion = 8;
          var ContentReset = 16;
          var Callback = 32;
          var DidCapture = 64;
          var Ref = 128;
          var Snapshot = 256;
          var Passive = 512;
          var PassiveUnmountPendingDev = 8192;
          var Hydrating = 1024;
          var HydratingAndUpdate = 1028;
          var LifecycleEffectMask = 932;
          var HostEffectMask = 2047;
          var Incomplete = 2048;
          var ShouldCapture = 4096;
          var ForceUpdateForLegacySuspense = 16384;
          var enableProfilerTimer = true;
          var enableFundamentalAPI = false;
          var enableNewReconciler = false;
          var warnAboutStringRefs = false;
          var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
          function getNearestMountedFiber(fiber) {
            var node = fiber;
            var nearestMounted = fiber;
            if (!fiber.alternate) {
              var nextNode = node;
              do {
                node = nextNode;
                if ((node.flags & (Placement | Hydrating)) !== NoFlags) {
                  nearestMounted = node.return;
                }
                nextNode = node.return;
              } while (nextNode);
            } else {
              while (node.return) {
                node = node.return;
              }
            }
            if (node.tag === HostRoot) {
              return nearestMounted;
            }
            return null;
          }
          function isFiberMounted(fiber) {
            return getNearestMountedFiber(fiber) === fiber;
          }
          function isMounted(component) {
            {
              var owner = ReactCurrentOwner.current;
              if (owner !== null && owner.tag === ClassComponent) {
                var ownerFiber = owner;
                var instance2 = ownerFiber.stateNode;
                if (!instance2._warnedAboutRefsInRender) {
                  error2("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentName(ownerFiber.type) || "A component");
                }
                instance2._warnedAboutRefsInRender = true;
              }
            }
            var fiber = get(component);
            if (!fiber) {
              return false;
            }
            return getNearestMountedFiber(fiber) === fiber;
          }
          function assertIsMounted(fiber) {
            if (!(getNearestMountedFiber(fiber) === fiber)) {
              {
                throw Error("Unable to find node on an unmounted component.");
              }
            }
          }
          function findCurrentFiberUsingSlowPath(fiber) {
            var alternate = fiber.alternate;
            if (!alternate) {
              var nearestMounted = getNearestMountedFiber(fiber);
              if (!(nearestMounted !== null)) {
                {
                  throw Error("Unable to find node on an unmounted component.");
                }
              }
              if (nearestMounted !== fiber) {
                return null;
              }
              return fiber;
            }
            var a = fiber;
            var b2 = alternate;
            while (true) {
              var parentA = a.return;
              if (parentA === null) {
                break;
              }
              var parentB = parentA.alternate;
              if (parentB === null) {
                var nextParent = parentA.return;
                if (nextParent !== null) {
                  a = b2 = nextParent;
                  continue;
                }
                break;
              }
              if (parentA.child === parentB.child) {
                var child = parentA.child;
                while (child) {
                  if (child === a) {
                    assertIsMounted(parentA);
                    return fiber;
                  }
                  if (child === b2) {
                    assertIsMounted(parentA);
                    return alternate;
                  }
                  child = child.sibling;
                }
                {
                  {
                    throw Error("Unable to find node on an unmounted component.");
                  }
                }
              }
              if (a.return !== b2.return) {
                a = parentA;
                b2 = parentB;
              } else {
                var didFindChild = false;
                var _child = parentA.child;
                while (_child) {
                  if (_child === a) {
                    didFindChild = true;
                    a = parentA;
                    b2 = parentB;
                    break;
                  }
                  if (_child === b2) {
                    didFindChild = true;
                    b2 = parentA;
                    a = parentB;
                    break;
                  }
                  _child = _child.sibling;
                }
                if (!didFindChild) {
                  _child = parentB.child;
                  while (_child) {
                    if (_child === a) {
                      didFindChild = true;
                      a = parentB;
                      b2 = parentA;
                      break;
                    }
                    if (_child === b2) {
                      didFindChild = true;
                      b2 = parentB;
                      a = parentA;
                      break;
                    }
                    _child = _child.sibling;
                  }
                  if (!didFindChild) {
                    {
                      throw Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
                    }
                  }
                }
              }
              if (!(a.alternate === b2)) {
                {
                  throw Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
            }
            if (!(a.tag === HostRoot)) {
              {
                throw Error("Unable to find node on an unmounted component.");
              }
            }
            if (a.stateNode.current === a) {
              return fiber;
            }
            return alternate;
          }
          function findCurrentHostFiber(parent) {
            var currentParent = findCurrentFiberUsingSlowPath(parent);
            if (!currentParent) {
              return null;
            }
            var node = currentParent;
            while (true) {
              if (node.tag === HostComponent || node.tag === HostText) {
                return node;
              } else if (node.child) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === currentParent) {
                return null;
              }
              while (!node.sibling) {
                if (!node.return || node.return === currentParent) {
                  return null;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
            return null;
          }
          function findCurrentHostFiberWithNoPortals(parent) {
            var currentParent = findCurrentFiberUsingSlowPath(parent);
            if (!currentParent) {
              return null;
            }
            var node = currentParent;
            while (true) {
              if (node.tag === HostComponent || node.tag === HostText || enableFundamentalAPI) {
                return node;
              } else if (node.child && node.tag !== HostPortal) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === currentParent) {
                return null;
              }
              while (!node.sibling) {
                if (!node.return || node.return === currentParent) {
                  return null;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
            return null;
          }
          function doesFiberContain(parentFiber, childFiber) {
            var node = childFiber;
            var parentFiberAlternate = parentFiber.alternate;
            while (node !== null) {
              if (node === parentFiber || node === parentFiberAlternate) {
                return true;
              }
              node = node.return;
            }
            return false;
          }
          var getPublicInstance = $$$hostConfig.getPublicInstance;
          var getRootHostContext = $$$hostConfig.getRootHostContext;
          var getChildHostContext = $$$hostConfig.getChildHostContext;
          var prepareForCommit = $$$hostConfig.prepareForCommit;
          var resetAfterCommit = $$$hostConfig.resetAfterCommit;
          var createInstance = $$$hostConfig.createInstance;
          var appendInitialChild = $$$hostConfig.appendInitialChild;
          var finalizeInitialChildren = $$$hostConfig.finalizeInitialChildren;
          var prepareUpdate = $$$hostConfig.prepareUpdate;
          var shouldSetTextContent = $$$hostConfig.shouldSetTextContent;
          var createTextInstance = $$$hostConfig.createTextInstance;
          var scheduleTimeout = $$$hostConfig.scheduleTimeout;
          var cancelTimeout = $$$hostConfig.cancelTimeout;
          var noTimeout = $$$hostConfig.noTimeout;
          var now = $$$hostConfig.now;
          var isPrimaryRenderer = $$$hostConfig.isPrimaryRenderer;
          var warnsIfNotActing = $$$hostConfig.warnsIfNotActing;
          var supportsMutation = $$$hostConfig.supportsMutation;
          var supportsPersistence = $$$hostConfig.supportsPersistence;
          var supportsHydration = $$$hostConfig.supportsHydration;
          var getFundamentalComponentInstance = $$$hostConfig.getFundamentalComponentInstance;
          var mountFundamentalComponent = $$$hostConfig.mountFundamentalComponent;
          var shouldUpdateFundamentalComponent = $$$hostConfig.shouldUpdateFundamentalComponent;
          var getInstanceFromNode = $$$hostConfig.getInstanceFromNode;
          var isOpaqueHydratingObject = $$$hostConfig.isOpaqueHydratingObject;
          var makeOpaqueHydratingObject = $$$hostConfig.makeOpaqueHydratingObject;
          var makeClientId = $$$hostConfig.makeClientId;
          var makeClientIdInDEV = $$$hostConfig.makeClientIdInDEV;
          var beforeActiveInstanceBlur = $$$hostConfig.beforeActiveInstanceBlur;
          var afterActiveInstanceBlur = $$$hostConfig.afterActiveInstanceBlur;
          var preparePortalMount = $$$hostConfig.preparePortalMount;
          var prepareScopeUpdate = $$$hostConfig.preparePortalMount;
          var getInstanceFromScope = $$$hostConfig.getInstanceFromScope;
          var supportsTestSelectors = $$$hostConfig.supportsTestSelectors;
          var findFiberRoot = $$$hostConfig.findFiberRoot;
          var getBoundingRect = $$$hostConfig.getBoundingRect;
          var getTextContent = $$$hostConfig.getTextContent;
          var isHiddenSubtree = $$$hostConfig.isHiddenSubtree;
          var matchAccessibilityRole = $$$hostConfig.matchAccessibilityRole;
          var setFocusIfFocusable = $$$hostConfig.setFocusIfFocusable;
          var setupIntersectionObserver = $$$hostConfig.setupIntersectionObserver;
          var appendChild = $$$hostConfig.appendChild;
          var appendChildToContainer = $$$hostConfig.appendChildToContainer;
          var commitTextUpdate = $$$hostConfig.commitTextUpdate;
          var commitMount = $$$hostConfig.commitMount;
          var commitUpdate = $$$hostConfig.commitUpdate;
          var insertBefore = $$$hostConfig.insertBefore;
          var insertInContainerBefore = $$$hostConfig.insertInContainerBefore;
          var removeChild = $$$hostConfig.removeChild;
          var removeChildFromContainer = $$$hostConfig.removeChildFromContainer;
          var resetTextContent = $$$hostConfig.resetTextContent;
          var hideInstance = $$$hostConfig.hideInstance;
          var hideTextInstance = $$$hostConfig.hideTextInstance;
          var unhideInstance = $$$hostConfig.unhideInstance;
          var unhideTextInstance = $$$hostConfig.unhideTextInstance;
          var updateFundamentalComponent = $$$hostConfig.updateFundamentalComponent;
          var unmountFundamentalComponent = $$$hostConfig.unmountFundamentalComponent;
          var clearContainer = $$$hostConfig.clearContainer;
          var cloneInstance = $$$hostConfig.cloneInstance;
          var createContainerChildSet = $$$hostConfig.createContainerChildSet;
          var appendChildToContainerChildSet = $$$hostConfig.appendChildToContainerChildSet;
          var finalizeContainerChildren = $$$hostConfig.finalizeContainerChildren;
          var replaceContainerChildren = $$$hostConfig.replaceContainerChildren;
          var cloneHiddenInstance = $$$hostConfig.cloneHiddenInstance;
          var cloneHiddenTextInstance = $$$hostConfig.cloneHiddenTextInstance;
          var cloneFundamentalInstance = $$$hostConfig.cloneInstance;
          var canHydrateInstance = $$$hostConfig.canHydrateInstance;
          var canHydrateTextInstance = $$$hostConfig.canHydrateTextInstance;
          var canHydrateSuspenseInstance = $$$hostConfig.canHydrateSuspenseInstance;
          var isSuspenseInstancePending = $$$hostConfig.isSuspenseInstancePending;
          var isSuspenseInstanceFallback = $$$hostConfig.isSuspenseInstanceFallback;
          var registerSuspenseInstanceRetry = $$$hostConfig.registerSuspenseInstanceRetry;
          var getNextHydratableSibling = $$$hostConfig.getNextHydratableSibling;
          var getFirstHydratableChild = $$$hostConfig.getFirstHydratableChild;
          var hydrateInstance = $$$hostConfig.hydrateInstance;
          var hydrateTextInstance = $$$hostConfig.hydrateTextInstance;
          var hydrateSuspenseInstance = $$$hostConfig.hydrateSuspenseInstance;
          var getNextHydratableInstanceAfterSuspenseInstance = $$$hostConfig.getNextHydratableInstanceAfterSuspenseInstance;
          var commitHydratedContainer = $$$hostConfig.commitHydratedContainer;
          var commitHydratedSuspenseInstance = $$$hostConfig.commitHydratedSuspenseInstance;
          var clearSuspenseBoundary = $$$hostConfig.clearSuspenseBoundary;
          var clearSuspenseBoundaryFromContainer = $$$hostConfig.clearSuspenseBoundaryFromContainer;
          var didNotMatchHydratedContainerTextInstance = $$$hostConfig.didNotMatchHydratedContainerTextInstance;
          var didNotMatchHydratedTextInstance = $$$hostConfig.didNotMatchHydratedTextInstance;
          var didNotHydrateContainerInstance = $$$hostConfig.didNotHydrateContainerInstance;
          var didNotHydrateInstance = $$$hostConfig.didNotHydrateInstance;
          var didNotFindHydratableContainerInstance = $$$hostConfig.didNotFindHydratableContainerInstance;
          var didNotFindHydratableContainerTextInstance = $$$hostConfig.didNotFindHydratableContainerTextInstance;
          var didNotFindHydratableContainerSuspenseInstance = $$$hostConfig.didNotFindHydratableContainerSuspenseInstance;
          var didNotFindHydratableInstance = $$$hostConfig.didNotFindHydratableInstance;
          var didNotFindHydratableTextInstance = $$$hostConfig.didNotFindHydratableTextInstance;
          var didNotFindHydratableSuspenseInstance = $$$hostConfig.didNotFindHydratableSuspenseInstance;
          var disabledDepth = 0;
          var prevLog;
          var prevInfo;
          var prevWarn;
          var prevError;
          var prevGroup;
          var prevGroupCollapsed;
          var prevGroupEnd;
          function disabledLog() {
          }
          disabledLog.__reactDisabledLog = true;
          function disableLogs() {
            {
              if (disabledDepth === 0) {
                prevLog = console.log;
                prevInfo = console.info;
                prevWarn = console.warn;
                prevError = console.error;
                prevGroup = console.group;
                prevGroupCollapsed = console.groupCollapsed;
                prevGroupEnd = console.groupEnd;
                var props = {
                  configurable: true,
                  enumerable: true,
                  value: disabledLog,
                  writable: true
                };
                Object.defineProperties(console, {
                  info: props,
                  log: props,
                  warn: props,
                  error: props,
                  group: props,
                  groupCollapsed: props,
                  groupEnd: props
                });
              }
              disabledDepth++;
            }
          }
          function reenableLogs() {
            {
              disabledDepth--;
              if (disabledDepth === 0) {
                var props = {
                  configurable: true,
                  enumerable: true,
                  writable: true
                };
                Object.defineProperties(console, {
                  log: _assign({}, props, {
                    value: prevLog
                  }),
                  info: _assign({}, props, {
                    value: prevInfo
                  }),
                  warn: _assign({}, props, {
                    value: prevWarn
                  }),
                  error: _assign({}, props, {
                    value: prevError
                  }),
                  group: _assign({}, props, {
                    value: prevGroup
                  }),
                  groupCollapsed: _assign({}, props, {
                    value: prevGroupCollapsed
                  }),
                  groupEnd: _assign({}, props, {
                    value: prevGroupEnd
                  })
                });
              }
              if (disabledDepth < 0) {
                error2("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
              }
            }
          }
          var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
          var prefix;
          function describeBuiltInComponentFrame(name2, source, ownerFn) {
            {
              if (prefix === void 0) {
                try {
                  throw Error();
                } catch (x2) {
                  var match = x2.stack.trim().match(/\n( *(at )?)/);
                  prefix = match && match[1] || "";
                }
              }
              return "\n" + prefix + name2;
            }
          }
          var reentry = false;
          var componentFrameCache;
          {
            var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
            componentFrameCache = new PossiblyWeakMap();
          }
          function describeNativeComponentFrame(fn2, construct) {
            if (!fn2 || reentry) {
              return "";
            }
            {
              var frame = componentFrameCache.get(fn2);
              if (frame !== void 0) {
                return frame;
              }
            }
            var control;
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            var previousDispatcher;
            {
              previousDispatcher = ReactCurrentDispatcher.current;
              ReactCurrentDispatcher.current = null;
              disableLogs();
            }
            try {
              if (construct) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if (typeof Reflect === "object" && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x2) {
                    control = x2;
                  }
                  Reflect.construct(fn2, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x2) {
                    control = x2;
                  }
                  fn2.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x2) {
                  control = x2;
                }
                fn2();
              }
            } catch (sample) {
              if (sample && control && typeof sample.stack === "string") {
                var sampleLines = sample.stack.split("\n");
                var controlLines = control.stack.split("\n");
                var s = sampleLines.length - 1;
                var c2 = controlLines.length - 1;
                while (s >= 1 && c2 >= 0 && sampleLines[s] !== controlLines[c2]) {
                  c2--;
                }
                for (; s >= 1 && c2 >= 0; s--, c2--) {
                  if (sampleLines[s] !== controlLines[c2]) {
                    if (s !== 1 || c2 !== 1) {
                      do {
                        s--;
                        c2--;
                        if (c2 < 0 || sampleLines[s] !== controlLines[c2]) {
                          var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                          {
                            if (typeof fn2 === "function") {
                              componentFrameCache.set(fn2, _frame);
                            }
                          }
                          return _frame;
                        }
                      } while (s >= 1 && c2 >= 0);
                    }
                    break;
                  }
                }
              }
            } finally {
              reentry = false;
              {
                ReactCurrentDispatcher.current = previousDispatcher;
                reenableLogs();
              }
              Error.prepareStackTrace = previousPrepareStackTrace;
            }
            var name2 = fn2 ? fn2.displayName || fn2.name : "";
            var syntheticFrame = name2 ? describeBuiltInComponentFrame(name2) : "";
            {
              if (typeof fn2 === "function") {
                componentFrameCache.set(fn2, syntheticFrame);
              }
            }
            return syntheticFrame;
          }
          function describeClassComponentFrame(ctor, source, ownerFn) {
            {
              return describeNativeComponentFrame(ctor, true);
            }
          }
          function describeFunctionComponentFrame(fn2, source, ownerFn) {
            {
              return describeNativeComponentFrame(fn2, false);
            }
          }
          function shouldConstruct(Component) {
            var prototype = Component.prototype;
            return !!(prototype && prototype.isReactComponent);
          }
          function describeUnknownElementTypeFrameInDEV(type5, source, ownerFn) {
            if (type5 == null) {
              return "";
            }
            if (typeof type5 === "function") {
              {
                return describeNativeComponentFrame(type5, shouldConstruct(type5));
              }
            }
            if (typeof type5 === "string") {
              return describeBuiltInComponentFrame(type5);
            }
            switch (type5) {
              case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame("Suspense");
              case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame("SuspenseList");
            }
            if (typeof type5 === "object") {
              switch (type5.$$typeof) {
                case REACT_FORWARD_REF_TYPE:
                  return describeFunctionComponentFrame(type5.render);
                case REACT_MEMO_TYPE:
                  return describeUnknownElementTypeFrameInDEV(type5.type, source, ownerFn);
                case REACT_BLOCK_TYPE:
                  return describeFunctionComponentFrame(type5._render);
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type5;
                  var payload = lazyComponent._payload;
                  var init2 = lazyComponent._init;
                  try {
                    return describeUnknownElementTypeFrameInDEV(init2(payload), source, ownerFn);
                  } catch (x2) {
                  }
                }
              }
            }
            return "";
          }
          var loggedTypeFailures = {};
          var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
          function setCurrentlyValidatingElement(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                ReactDebugCurrentFrame.setExtraStackFrame(stack);
              } else {
                ReactDebugCurrentFrame.setExtraStackFrame(null);
              }
            }
          }
          function checkPropTypes(typeSpecs, values, location, componentName, element) {
            {
              var has = Function.call.bind(Object.prototype.hasOwnProperty);
              for (var typeSpecName in typeSpecs) {
                if (has(typeSpecs, typeSpecName)) {
                  var error$1 = void 0;
                  try {
                    if (typeof typeSpecs[typeSpecName] !== "function") {
                      var err2 = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                      err2.name = "Invariant Violation";
                      throw err2;
                    }
                    error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                  } catch (ex) {
                    error$1 = ex;
                  }
                  if (error$1 && !(error$1 instanceof Error)) {
                    setCurrentlyValidatingElement(element);
                    error2("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                    setCurrentlyValidatingElement(null);
                  }
                  if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                    loggedTypeFailures[error$1.message] = true;
                    setCurrentlyValidatingElement(element);
                    error2("Failed %s type: %s", location, error$1.message);
                    setCurrentlyValidatingElement(null);
                  }
                }
              }
            }
          }
          var valueStack = [];
          var fiberStack;
          {
            fiberStack = [];
          }
          var index = -1;
          function createCursor(defaultValue) {
            return {
              current: defaultValue
            };
          }
          function pop(cursor, fiber) {
            if (index < 0) {
              {
                error2("Unexpected pop.");
              }
              return;
            }
            {
              if (fiber !== fiberStack[index]) {
                error2("Unexpected Fiber popped.");
              }
            }
            cursor.current = valueStack[index];
            valueStack[index] = null;
            {
              fiberStack[index] = null;
            }
            index--;
          }
          function push(cursor, value, fiber) {
            index++;
            valueStack[index] = cursor.current;
            {
              fiberStack[index] = fiber;
            }
            cursor.current = value;
          }
          var warnedAboutMissingGetChildContext;
          {
            warnedAboutMissingGetChildContext = {};
          }
          var emptyContextObject = {};
          {
            Object.freeze(emptyContextObject);
          }
          var contextStackCursor = createCursor(emptyContextObject);
          var didPerformWorkStackCursor = createCursor(false);
          var previousContext = emptyContextObject;
          function getUnmaskedContext(workInProgress2, Component, didPushOwnContextIfProvider) {
            {
              if (didPushOwnContextIfProvider && isContextProvider(Component)) {
                return previousContext;
              }
              return contextStackCursor.current;
            }
          }
          function cacheContext(workInProgress2, unmaskedContext, maskedContext) {
            {
              var instance2 = workInProgress2.stateNode;
              instance2.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
              instance2.__reactInternalMemoizedMaskedChildContext = maskedContext;
            }
          }
          function getMaskedContext(workInProgress2, unmaskedContext) {
            {
              var type5 = workInProgress2.type;
              var contextTypes = type5.contextTypes;
              if (!contextTypes) {
                return emptyContextObject;
              }
              var instance2 = workInProgress2.stateNode;
              if (instance2 && instance2.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
                return instance2.__reactInternalMemoizedMaskedChildContext;
              }
              var context = {};
              for (var key in contextTypes) {
                context[key] = unmaskedContext[key];
              }
              {
                var name2 = getComponentName(type5) || "Unknown";
                checkPropTypes(contextTypes, context, "context", name2);
              }
              if (instance2) {
                cacheContext(workInProgress2, unmaskedContext, context);
              }
              return context;
            }
          }
          function hasContextChanged() {
            {
              return didPerformWorkStackCursor.current;
            }
          }
          function isContextProvider(type5) {
            {
              var childContextTypes = type5.childContextTypes;
              return childContextTypes !== null && childContextTypes !== void 0;
            }
          }
          function popContext(fiber) {
            {
              pop(didPerformWorkStackCursor, fiber);
              pop(contextStackCursor, fiber);
            }
          }
          function popTopLevelContextObject(fiber) {
            {
              pop(didPerformWorkStackCursor, fiber);
              pop(contextStackCursor, fiber);
            }
          }
          function pushTopLevelContextObject(fiber, context, didChange) {
            {
              if (!(contextStackCursor.current === emptyContextObject)) {
                {
                  throw Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
              push(contextStackCursor, context, fiber);
              push(didPerformWorkStackCursor, didChange, fiber);
            }
          }
          function processChildContext(fiber, type5, parentContext) {
            {
              var instance2 = fiber.stateNode;
              var childContextTypes = type5.childContextTypes;
              if (typeof instance2.getChildContext !== "function") {
                {
                  var componentName = getComponentName(type5) || "Unknown";
                  if (!warnedAboutMissingGetChildContext[componentName]) {
                    warnedAboutMissingGetChildContext[componentName] = true;
                    error2("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName);
                  }
                }
                return parentContext;
              }
              var childContext = instance2.getChildContext();
              for (var contextKey in childContext) {
                if (!(contextKey in childContextTypes)) {
                  {
                    throw Error((getComponentName(type5) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
                  }
                }
              }
              {
                var name2 = getComponentName(type5) || "Unknown";
                checkPropTypes(childContextTypes, childContext, "child context", name2);
              }
              return _assign({}, parentContext, childContext);
            }
          }
          function pushContextProvider(workInProgress2) {
            {
              var instance2 = workInProgress2.stateNode;
              var memoizedMergedChildContext = instance2 && instance2.__reactInternalMemoizedMergedChildContext || emptyContextObject;
              previousContext = contextStackCursor.current;
              push(contextStackCursor, memoizedMergedChildContext, workInProgress2);
              push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress2);
              return true;
            }
          }
          function invalidateContextProvider(workInProgress2, type5, didChange) {
            {
              var instance2 = workInProgress2.stateNode;
              if (!instance2) {
                {
                  throw Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
              if (didChange) {
                var mergedContext = processChildContext(workInProgress2, type5, previousContext);
                instance2.__reactInternalMemoizedMergedChildContext = mergedContext;
                pop(didPerformWorkStackCursor, workInProgress2);
                pop(contextStackCursor, workInProgress2);
                push(contextStackCursor, mergedContext, workInProgress2);
                push(didPerformWorkStackCursor, didChange, workInProgress2);
              } else {
                pop(didPerformWorkStackCursor, workInProgress2);
                push(didPerformWorkStackCursor, didChange, workInProgress2);
              }
            }
          }
          function findCurrentUnmaskedContext(fiber) {
            {
              if (!(isFiberMounted(fiber) && fiber.tag === ClassComponent)) {
                {
                  throw Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
              var node = fiber;
              do {
                switch (node.tag) {
                  case HostRoot:
                    return node.stateNode.context;
                  case ClassComponent: {
                    var Component = node.type;
                    if (isContextProvider(Component)) {
                      return node.stateNode.__reactInternalMemoizedMergedChildContext;
                    }
                    break;
                  }
                }
                node = node.return;
              } while (node !== null);
              {
                {
                  throw Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
            }
          }
          var LegacyRoot = 0;
          var BlockingRoot = 1;
          var ConcurrentRoot = 2;
          var rendererID = null;
          var injectedHook = null;
          var hasLoggedError = false;
          var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined";
          function injectInternals(internals) {
            if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined") {
              return false;
            }
            var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
            if (hook.isDisabled) {
              return true;
            }
            if (!hook.supportsFiber) {
              {
                error2("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools");
              }
              return true;
            }
            try {
              rendererID = hook.inject(internals);
              injectedHook = hook;
            } catch (err2) {
              {
                error2("React instrumentation encountered an error: %s.", err2);
              }
            }
            return true;
          }
          function onScheduleRoot(root2, children) {
            {
              if (injectedHook && typeof injectedHook.onScheduleFiberRoot === "function") {
                try {
                  injectedHook.onScheduleFiberRoot(rendererID, root2, children);
                } catch (err2) {
                  if (!hasLoggedError) {
                    hasLoggedError = true;
                    error2("React instrumentation encountered an error: %s", err2);
                  }
                }
              }
            }
          }
          function onCommitRoot(root2, priorityLevel) {
            if (injectedHook && typeof injectedHook.onCommitFiberRoot === "function") {
              try {
                var didError = (root2.current.flags & DidCapture) === DidCapture;
                if (enableProfilerTimer) {
                  injectedHook.onCommitFiberRoot(rendererID, root2, priorityLevel, didError);
                } else {
                  injectedHook.onCommitFiberRoot(rendererID, root2, void 0, didError);
                }
              } catch (err2) {
                {
                  if (!hasLoggedError) {
                    hasLoggedError = true;
                    error2("React instrumentation encountered an error: %s", err2);
                  }
                }
              }
            }
          }
          function onCommitUnmount(fiber) {
            if (injectedHook && typeof injectedHook.onCommitFiberUnmount === "function") {
              try {
                injectedHook.onCommitFiberUnmount(rendererID, fiber);
              } catch (err2) {
                {
                  if (!hasLoggedError) {
                    hasLoggedError = true;
                    error2("React instrumentation encountered an error: %s", err2);
                  }
                }
              }
            }
          }
          var Scheduler_now = Scheduler.unstable_now;
          {
            if (!(tracing.__interactionsRef != null && tracing.__interactionsRef.current != null)) {
              {
                throw Error("It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) without also replacing the `scheduler/tracing` module with `scheduler/tracing-profiling`. Your bundler might have a setting for aliasing both modules. Learn more at https://reactjs.org/link/profiling");
              }
            }
          }
          var ImmediatePriority = 99;
          var UserBlockingPriority = 98;
          var NormalPriority = 97;
          var LowPriority = 96;
          var IdlePriority = 95;
          var NoPriority = 90;
          var initialTimeMs = Scheduler_now();
          var SyncLanePriority = 15;
          var SyncBatchedLanePriority = 14;
          var InputDiscreteHydrationLanePriority = 13;
          var InputDiscreteLanePriority = 12;
          var InputContinuousHydrationLanePriority = 11;
          var InputContinuousLanePriority = 10;
          var DefaultHydrationLanePriority = 9;
          var DefaultLanePriority = 8;
          var TransitionHydrationPriority = 7;
          var TransitionPriority = 6;
          var RetryLanePriority = 5;
          var SelectiveHydrationLanePriority = 4;
          var IdleHydrationLanePriority = 3;
          var IdleLanePriority = 2;
          var OffscreenLanePriority = 1;
          var NoLanePriority = 0;
          var TotalLanes = 31;
          var NoLanes = 0;
          var NoLane = 0;
          var SyncLane = 1;
          var SyncBatchedLane = 2;
          var InputDiscreteHydrationLane = 4;
          var InputDiscreteLanes = 24;
          var InputContinuousHydrationLane = 32;
          var InputContinuousLanes = 192;
          var DefaultHydrationLane = 256;
          var DefaultLanes = 3584;
          var TransitionHydrationLane = 4096;
          var TransitionLanes = 4186112;
          var RetryLanes = 62914560;
          var SomeRetryLane = 33554432;
          var SelectiveHydrationLane = 67108864;
          var NonIdleLanes = 134217727;
          var IdleHydrationLane = 134217728;
          var IdleLanes = 805306368;
          var OffscreenLane = 1073741824;
          var NoTimestamp = -1;
          var currentUpdateLanePriority = NoLanePriority;
          function getCurrentUpdateLanePriority() {
            return currentUpdateLanePriority;
          }
          function setCurrentUpdateLanePriority(newLanePriority) {
            currentUpdateLanePriority = newLanePriority;
          }
          var return_highestLanePriority = DefaultLanePriority;
          function getHighestPriorityLanes(lanes) {
            if ((SyncLane & lanes) !== NoLanes) {
              return_highestLanePriority = SyncLanePriority;
              return SyncLane;
            }
            if ((SyncBatchedLane & lanes) !== NoLanes) {
              return_highestLanePriority = SyncBatchedLanePriority;
              return SyncBatchedLane;
            }
            if ((InputDiscreteHydrationLane & lanes) !== NoLanes) {
              return_highestLanePriority = InputDiscreteHydrationLanePriority;
              return InputDiscreteHydrationLane;
            }
            var inputDiscreteLanes = InputDiscreteLanes & lanes;
            if (inputDiscreteLanes !== NoLanes) {
              return_highestLanePriority = InputDiscreteLanePriority;
              return inputDiscreteLanes;
            }
            if ((lanes & InputContinuousHydrationLane) !== NoLanes) {
              return_highestLanePriority = InputContinuousHydrationLanePriority;
              return InputContinuousHydrationLane;
            }
            var inputContinuousLanes = InputContinuousLanes & lanes;
            if (inputContinuousLanes !== NoLanes) {
              return_highestLanePriority = InputContinuousLanePriority;
              return inputContinuousLanes;
            }
            if ((lanes & DefaultHydrationLane) !== NoLanes) {
              return_highestLanePriority = DefaultHydrationLanePriority;
              return DefaultHydrationLane;
            }
            var defaultLanes = DefaultLanes & lanes;
            if (defaultLanes !== NoLanes) {
              return_highestLanePriority = DefaultLanePriority;
              return defaultLanes;
            }
            if ((lanes & TransitionHydrationLane) !== NoLanes) {
              return_highestLanePriority = TransitionHydrationPriority;
              return TransitionHydrationLane;
            }
            var transitionLanes = TransitionLanes & lanes;
            if (transitionLanes !== NoLanes) {
              return_highestLanePriority = TransitionPriority;
              return transitionLanes;
            }
            var retryLanes = RetryLanes & lanes;
            if (retryLanes !== NoLanes) {
              return_highestLanePriority = RetryLanePriority;
              return retryLanes;
            }
            if (lanes & SelectiveHydrationLane) {
              return_highestLanePriority = SelectiveHydrationLanePriority;
              return SelectiveHydrationLane;
            }
            if ((lanes & IdleHydrationLane) !== NoLanes) {
              return_highestLanePriority = IdleHydrationLanePriority;
              return IdleHydrationLane;
            }
            var idleLanes = IdleLanes & lanes;
            if (idleLanes !== NoLanes) {
              return_highestLanePriority = IdleLanePriority;
              return idleLanes;
            }
            if ((OffscreenLane & lanes) !== NoLanes) {
              return_highestLanePriority = OffscreenLanePriority;
              return OffscreenLane;
            }
            {
              error2("Should have found matching lanes. This is a bug in React.");
            }
            return_highestLanePriority = DefaultLanePriority;
            return lanes;
          }
          function schedulerPriorityToLanePriority(schedulerPriorityLevel) {
            switch (schedulerPriorityLevel) {
              case ImmediatePriority:
                return SyncLanePriority;
              case UserBlockingPriority:
                return InputContinuousLanePriority;
              case NormalPriority:
              case LowPriority:
                return DefaultLanePriority;
              case IdlePriority:
                return IdleLanePriority;
              default:
                return NoLanePriority;
            }
          }
          function lanePriorityToSchedulerPriority(lanePriority) {
            switch (lanePriority) {
              case SyncLanePriority:
              case SyncBatchedLanePriority:
                return ImmediatePriority;
              case InputDiscreteHydrationLanePriority:
              case InputDiscreteLanePriority:
              case InputContinuousHydrationLanePriority:
              case InputContinuousLanePriority:
                return UserBlockingPriority;
              case DefaultHydrationLanePriority:
              case DefaultLanePriority:
              case TransitionHydrationPriority:
              case TransitionPriority:
              case SelectiveHydrationLanePriority:
              case RetryLanePriority:
                return NormalPriority;
              case IdleHydrationLanePriority:
              case IdleLanePriority:
              case OffscreenLanePriority:
                return IdlePriority;
              case NoLanePriority:
                return NoPriority;
              default: {
                {
                  throw Error("Invalid update priority: " + lanePriority + ". This is a bug in React.");
                }
              }
            }
          }
          function getNextLanes(root2, wipLanes) {
            var pendingLanes = root2.pendingLanes;
            if (pendingLanes === NoLanes) {
              return_highestLanePriority = NoLanePriority;
              return NoLanes;
            }
            var nextLanes = NoLanes;
            var nextLanePriority = NoLanePriority;
            var expiredLanes = root2.expiredLanes;
            var suspendedLanes = root2.suspendedLanes;
            var pingedLanes = root2.pingedLanes;
            if (expiredLanes !== NoLanes) {
              nextLanes = expiredLanes;
              nextLanePriority = return_highestLanePriority = SyncLanePriority;
            } else {
              var nonIdlePendingLanes = pendingLanes & NonIdleLanes;
              if (nonIdlePendingLanes !== NoLanes) {
                var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;
                if (nonIdleUnblockedLanes !== NoLanes) {
                  nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);
                  nextLanePriority = return_highestLanePriority;
                } else {
                  var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;
                  if (nonIdlePingedLanes !== NoLanes) {
                    nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);
                    nextLanePriority = return_highestLanePriority;
                  }
                }
              } else {
                var unblockedLanes = pendingLanes & ~suspendedLanes;
                if (unblockedLanes !== NoLanes) {
                  nextLanes = getHighestPriorityLanes(unblockedLanes);
                  nextLanePriority = return_highestLanePriority;
                } else {
                  if (pingedLanes !== NoLanes) {
                    nextLanes = getHighestPriorityLanes(pingedLanes);
                    nextLanePriority = return_highestLanePriority;
                  }
                }
              }
            }
            if (nextLanes === NoLanes) {
              return NoLanes;
            }
            nextLanes = pendingLanes & getEqualOrHigherPriorityLanes(nextLanes);
            if (wipLanes !== NoLanes && wipLanes !== nextLanes && (wipLanes & suspendedLanes) === NoLanes) {
              getHighestPriorityLanes(wipLanes);
              var wipLanePriority = return_highestLanePriority;
              if (nextLanePriority <= wipLanePriority) {
                return wipLanes;
              } else {
                return_highestLanePriority = nextLanePriority;
              }
            }
            var entangledLanes = root2.entangledLanes;
            if (entangledLanes !== NoLanes) {
              var entanglements = root2.entanglements;
              var lanes = nextLanes & entangledLanes;
              while (lanes > 0) {
                var index2 = pickArbitraryLaneIndex(lanes);
                var lane = 1 << index2;
                nextLanes |= entanglements[index2];
                lanes &= ~lane;
              }
            }
            return nextLanes;
          }
          function getMostRecentEventTime(root2, lanes) {
            var eventTimes = root2.eventTimes;
            var mostRecentEventTime = NoTimestamp;
            while (lanes > 0) {
              var index2 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index2;
              var eventTime = eventTimes[index2];
              if (eventTime > mostRecentEventTime) {
                mostRecentEventTime = eventTime;
              }
              lanes &= ~lane;
            }
            return mostRecentEventTime;
          }
          function computeExpirationTime(lane, currentTime) {
            getHighestPriorityLanes(lane);
            var priority = return_highestLanePriority;
            if (priority >= InputContinuousLanePriority) {
              return currentTime + 250;
            } else if (priority >= TransitionPriority) {
              return currentTime + 5e3;
            } else {
              return NoTimestamp;
            }
          }
          function markStarvedLanesAsExpired(root2, currentTime) {
            var pendingLanes = root2.pendingLanes;
            var suspendedLanes = root2.suspendedLanes;
            var pingedLanes = root2.pingedLanes;
            var expirationTimes = root2.expirationTimes;
            var lanes = pendingLanes;
            while (lanes > 0) {
              var index2 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index2;
              var expirationTime = expirationTimes[index2];
              if (expirationTime === NoTimestamp) {
                if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {
                  expirationTimes[index2] = computeExpirationTime(lane, currentTime);
                }
              } else if (expirationTime <= currentTime) {
                root2.expiredLanes |= lane;
              }
              lanes &= ~lane;
            }
          }
          function getHighestPriorityPendingLanes(root2) {
            return getHighestPriorityLanes(root2.pendingLanes);
          }
          function getLanesToRetrySynchronouslyOnError(root2) {
            var everythingButOffscreen = root2.pendingLanes & ~OffscreenLane;
            if (everythingButOffscreen !== NoLanes) {
              return everythingButOffscreen;
            }
            if (everythingButOffscreen & OffscreenLane) {
              return OffscreenLane;
            }
            return NoLanes;
          }
          function returnNextLanesPriority() {
            return return_highestLanePriority;
          }
          function includesNonIdleWork(lanes) {
            return (lanes & NonIdleLanes) !== NoLanes;
          }
          function includesOnlyRetries(lanes) {
            return (lanes & RetryLanes) === lanes;
          }
          function includesOnlyTransitions(lanes) {
            return (lanes & TransitionLanes) === lanes;
          }
          function findUpdateLane(lanePriority, wipLanes) {
            switch (lanePriority) {
              case NoLanePriority:
                break;
              case SyncLanePriority:
                return SyncLane;
              case SyncBatchedLanePriority:
                return SyncBatchedLane;
              case InputDiscreteLanePriority: {
                var _lane = pickArbitraryLane(InputDiscreteLanes & ~wipLanes);
                if (_lane === NoLane) {
                  return findUpdateLane(InputContinuousLanePriority, wipLanes);
                }
                return _lane;
              }
              case InputContinuousLanePriority: {
                var _lane2 = pickArbitraryLane(InputContinuousLanes & ~wipLanes);
                if (_lane2 === NoLane) {
                  return findUpdateLane(DefaultLanePriority, wipLanes);
                }
                return _lane2;
              }
              case DefaultLanePriority: {
                var _lane3 = pickArbitraryLane(DefaultLanes & ~wipLanes);
                if (_lane3 === NoLane) {
                  _lane3 = pickArbitraryLane(TransitionLanes & ~wipLanes);
                  if (_lane3 === NoLane) {
                    _lane3 = pickArbitraryLane(DefaultLanes);
                  }
                }
                return _lane3;
              }
              case TransitionPriority:
              case RetryLanePriority:
                break;
              case IdleLanePriority:
                var lane = pickArbitraryLane(IdleLanes & ~wipLanes);
                if (lane === NoLane) {
                  lane = pickArbitraryLane(IdleLanes);
                }
                return lane;
            }
            {
              {
                throw Error("Invalid update priority: " + lanePriority + ". This is a bug in React.");
              }
            }
          }
          function findTransitionLane(wipLanes, pendingLanes) {
            var lane = pickArbitraryLane(TransitionLanes & ~pendingLanes);
            if (lane === NoLane) {
              lane = pickArbitraryLane(TransitionLanes & ~wipLanes);
              if (lane === NoLane) {
                lane = pickArbitraryLane(TransitionLanes);
              }
            }
            return lane;
          }
          function findRetryLane(wipLanes) {
            var lane = pickArbitraryLane(RetryLanes & ~wipLanes);
            if (lane === NoLane) {
              lane = pickArbitraryLane(RetryLanes);
            }
            return lane;
          }
          function getHighestPriorityLane(lanes) {
            return lanes & -lanes;
          }
          function getLowestPriorityLane(lanes) {
            var index2 = 31 - clz32(lanes);
            return index2 < 0 ? NoLanes : 1 << index2;
          }
          function getEqualOrHigherPriorityLanes(lanes) {
            return (getLowestPriorityLane(lanes) << 1) - 1;
          }
          function pickArbitraryLane(lanes) {
            return getHighestPriorityLane(lanes);
          }
          function pickArbitraryLaneIndex(lanes) {
            return 31 - clz32(lanes);
          }
          function laneToIndex(lane) {
            return pickArbitraryLaneIndex(lane);
          }
          function includesSomeLane(a, b2) {
            return (a & b2) !== NoLanes;
          }
          function isSubsetOfLanes(set2, subset) {
            return (set2 & subset) === subset;
          }
          function mergeLanes(a, b2) {
            return a | b2;
          }
          function removeLanes(set2, subset) {
            return set2 & ~subset;
          }
          function laneToLanes(lane) {
            return lane;
          }
          function higherPriorityLane(a, b2) {
            return a !== NoLane && a < b2 ? a : b2;
          }
          function createLaneMap(initial) {
            var laneMap = [];
            for (var i = 0; i < TotalLanes; i++) {
              laneMap.push(initial);
            }
            return laneMap;
          }
          function markRootUpdated(root2, updateLane, eventTime) {
            root2.pendingLanes |= updateLane;
            var higherPriorityLanes = updateLane - 1;
            root2.suspendedLanes &= higherPriorityLanes;
            root2.pingedLanes &= higherPriorityLanes;
            var eventTimes = root2.eventTimes;
            var index2 = laneToIndex(updateLane);
            eventTimes[index2] = eventTime;
          }
          function markRootSuspended(root2, suspendedLanes) {
            root2.suspendedLanes |= suspendedLanes;
            root2.pingedLanes &= ~suspendedLanes;
            var expirationTimes = root2.expirationTimes;
            var lanes = suspendedLanes;
            while (lanes > 0) {
              var index2 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index2;
              expirationTimes[index2] = NoTimestamp;
              lanes &= ~lane;
            }
          }
          function markRootPinged(root2, pingedLanes, eventTime) {
            root2.pingedLanes |= root2.suspendedLanes & pingedLanes;
          }
          function markRootExpired(root2, expiredLanes) {
            root2.expiredLanes |= expiredLanes & root2.pendingLanes;
          }
          function markDiscreteUpdatesExpired(root2) {
            root2.expiredLanes |= InputDiscreteLanes & root2.pendingLanes;
          }
          function hasDiscreteLanes(lanes) {
            return (lanes & InputDiscreteLanes) !== NoLanes;
          }
          function markRootMutableRead(root2, updateLane) {
            root2.mutableReadLanes |= updateLane & root2.pendingLanes;
          }
          function markRootFinished(root2, remainingLanes) {
            var noLongerPendingLanes = root2.pendingLanes & ~remainingLanes;
            root2.pendingLanes = remainingLanes;
            root2.suspendedLanes = 0;
            root2.pingedLanes = 0;
            root2.expiredLanes &= remainingLanes;
            root2.mutableReadLanes &= remainingLanes;
            root2.entangledLanes &= remainingLanes;
            var entanglements = root2.entanglements;
            var eventTimes = root2.eventTimes;
            var expirationTimes = root2.expirationTimes;
            var lanes = noLongerPendingLanes;
            while (lanes > 0) {
              var index2 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index2;
              entanglements[index2] = NoLanes;
              eventTimes[index2] = NoTimestamp;
              expirationTimes[index2] = NoTimestamp;
              lanes &= ~lane;
            }
          }
          function markRootEntangled(root2, entangledLanes) {
            root2.entangledLanes |= entangledLanes;
            var entanglements = root2.entanglements;
            var lanes = entangledLanes;
            while (lanes > 0) {
              var index2 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index2;
              entanglements[index2] |= entangledLanes;
              lanes &= ~lane;
            }
          }
          var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
          var log2 = Math.log;
          var LN2 = Math.LN2;
          function clz32Fallback(lanes) {
            if (lanes === 0) {
              return 32;
            }
            return 31 - (log2(lanes) / LN2 | 0) | 0;
          }
          var Scheduler_runWithPriority = Scheduler.unstable_runWithPriority, Scheduler_scheduleCallback = Scheduler.unstable_scheduleCallback, Scheduler_cancelCallback = Scheduler.unstable_cancelCallback, Scheduler_shouldYield = Scheduler.unstable_shouldYield, Scheduler_requestPaint = Scheduler.unstable_requestPaint, Scheduler_now$1 = Scheduler.unstable_now, Scheduler_getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel, Scheduler_ImmediatePriority = Scheduler.unstable_ImmediatePriority, Scheduler_UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, Scheduler_NormalPriority = Scheduler.unstable_NormalPriority, Scheduler_LowPriority = Scheduler.unstable_LowPriority, Scheduler_IdlePriority = Scheduler.unstable_IdlePriority;
          {
            if (!(tracing.__interactionsRef != null && tracing.__interactionsRef.current != null)) {
              {
                throw Error("It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) without also replacing the `scheduler/tracing` module with `scheduler/tracing-profiling`. Your bundler might have a setting for aliasing both modules. Learn more at https://reactjs.org/link/profiling");
              }
            }
          }
          var fakeCallbackNode = {};
          var ImmediatePriority$1 = 99;
          var UserBlockingPriority$1 = 98;
          var NormalPriority$1 = 97;
          var LowPriority$1 = 96;
          var IdlePriority$1 = 95;
          var NoPriority$1 = 90;
          var shouldYield = Scheduler_shouldYield;
          var requestPaint = Scheduler_requestPaint !== void 0 ? Scheduler_requestPaint : function() {
          };
          var syncQueue = null;
          var immediateQueueCallbackNode = null;
          var isFlushingSyncQueue = false;
          var initialTimeMs$1 = Scheduler_now$1();
          var now$1 = initialTimeMs$1 < 1e4 ? Scheduler_now$1 : function() {
            return Scheduler_now$1() - initialTimeMs$1;
          };
          function getCurrentPriorityLevel() {
            switch (Scheduler_getCurrentPriorityLevel()) {
              case Scheduler_ImmediatePriority:
                return ImmediatePriority$1;
              case Scheduler_UserBlockingPriority:
                return UserBlockingPriority$1;
              case Scheduler_NormalPriority:
                return NormalPriority$1;
              case Scheduler_LowPriority:
                return LowPriority$1;
              case Scheduler_IdlePriority:
                return IdlePriority$1;
              default: {
                {
                  throw Error("Unknown priority level.");
                }
              }
            }
          }
          function reactPriorityToSchedulerPriority(reactPriorityLevel) {
            switch (reactPriorityLevel) {
              case ImmediatePriority$1:
                return Scheduler_ImmediatePriority;
              case UserBlockingPriority$1:
                return Scheduler_UserBlockingPriority;
              case NormalPriority$1:
                return Scheduler_NormalPriority;
              case LowPriority$1:
                return Scheduler_LowPriority;
              case IdlePriority$1:
                return Scheduler_IdlePriority;
              default: {
                {
                  throw Error("Unknown priority level.");
                }
              }
            }
          }
          function runWithPriority(reactPriorityLevel, fn2) {
            var priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);
            return Scheduler_runWithPriority(priorityLevel, fn2);
          }
          function scheduleCallback(reactPriorityLevel, callback, options) {
            var priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);
            return Scheduler_scheduleCallback(priorityLevel, callback, options);
          }
          function scheduleSyncCallback(callback) {
            if (syncQueue === null) {
              syncQueue = [callback];
              immediateQueueCallbackNode = Scheduler_scheduleCallback(Scheduler_ImmediatePriority, flushSyncCallbackQueueImpl);
            } else {
              syncQueue.push(callback);
            }
            return fakeCallbackNode;
          }
          function cancelCallback(callbackNode) {
            if (callbackNode !== fakeCallbackNode) {
              Scheduler_cancelCallback(callbackNode);
            }
          }
          function flushSyncCallbackQueue() {
            if (immediateQueueCallbackNode !== null) {
              var node = immediateQueueCallbackNode;
              immediateQueueCallbackNode = null;
              Scheduler_cancelCallback(node);
            }
            flushSyncCallbackQueueImpl();
          }
          function flushSyncCallbackQueueImpl() {
            if (!isFlushingSyncQueue && syncQueue !== null) {
              isFlushingSyncQueue = true;
              var i = 0;
              {
                try {
                  var _isSync2 = true;
                  var _queue = syncQueue;
                  runWithPriority(ImmediatePriority$1, function() {
                    for (; i < _queue.length; i++) {
                      var callback = _queue[i];
                      do {
                        callback = callback(_isSync2);
                      } while (callback !== null);
                    }
                  });
                  syncQueue = null;
                } catch (error3) {
                  if (syncQueue !== null) {
                    syncQueue = syncQueue.slice(i + 1);
                  }
                  Scheduler_scheduleCallback(Scheduler_ImmediatePriority, flushSyncCallbackQueue);
                  throw error3;
                } finally {
                  isFlushingSyncQueue = false;
                }
              }
            }
          }
          var NoMode = 0;
          var StrictMode = 1;
          var BlockingMode = 2;
          var ConcurrentMode = 4;
          var ProfileMode = 8;
          var DebugTracingMode = 16;
          var ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;
          var NoTransition = 0;
          function requestCurrentTransition() {
            return ReactCurrentBatchConfig.transition;
          }
          function is4(x2, y2) {
            return x2 === y2 && (x2 !== 0 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
          }
          var objectIs = typeof Object.is === "function" ? Object.is : is4;
          var hasOwnProperty2 = Object.prototype.hasOwnProperty;
          function shallowEqual(objA, objB) {
            if (objectIs(objA, objB)) {
              return true;
            }
            if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
              return false;
            }
            var keysA = Object.keys(objA);
            var keysB = Object.keys(objB);
            if (keysA.length !== keysB.length) {
              return false;
            }
            for (var i = 0; i < keysA.length; i++) {
              if (!hasOwnProperty2.call(objB, keysA[i]) || !objectIs(objA[keysA[i]], objB[keysA[i]])) {
                return false;
              }
            }
            return true;
          }
          function describeFiber(fiber) {
            var owner = fiber._debugOwner ? fiber._debugOwner.type : null;
            var source = fiber._debugSource;
            switch (fiber.tag) {
              case HostComponent:
                return describeBuiltInComponentFrame(fiber.type);
              case LazyComponent:
                return describeBuiltInComponentFrame("Lazy");
              case SuspenseComponent:
                return describeBuiltInComponentFrame("Suspense");
              case SuspenseListComponent:
                return describeBuiltInComponentFrame("SuspenseList");
              case FunctionComponent:
              case IndeterminateComponent:
              case SimpleMemoComponent:
                return describeFunctionComponentFrame(fiber.type);
              case ForwardRef:
                return describeFunctionComponentFrame(fiber.type.render);
              case Block:
                return describeFunctionComponentFrame(fiber.type._render);
              case ClassComponent:
                return describeClassComponentFrame(fiber.type);
              default:
                return "";
            }
          }
          function getStackByFiberInDevAndProd(workInProgress2) {
            try {
              var info = "";
              var node = workInProgress2;
              do {
                info += describeFiber(node);
                node = node.return;
              } while (node);
              return info;
            } catch (x2) {
              return "\nError generating stack: " + x2.message + "\n" + x2.stack;
            }
          }
          var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
          var current = null;
          var isRendering = false;
          function getCurrentFiberOwnerNameInDevOrNull() {
            {
              if (current === null) {
                return null;
              }
              var owner = current._debugOwner;
              if (owner !== null && typeof owner !== "undefined") {
                return getComponentName(owner.type);
              }
            }
            return null;
          }
          function getCurrentFiberStackInDev() {
            {
              if (current === null) {
                return "";
              }
              return getStackByFiberInDevAndProd(current);
            }
          }
          function resetCurrentFiber() {
            {
              ReactDebugCurrentFrame$1.getCurrentStack = null;
              current = null;
              isRendering = false;
            }
          }
          function setCurrentFiber(fiber) {
            {
              ReactDebugCurrentFrame$1.getCurrentStack = getCurrentFiberStackInDev;
              current = fiber;
              isRendering = false;
            }
          }
          function setIsRendering(rendering) {
            {
              isRendering = rendering;
            }
          }
          function getIsRendering() {
            {
              return isRendering;
            }
          }
          var ReactStrictModeWarnings = {
            recordUnsafeLifecycleWarnings: function(fiber, instance2) {
            },
            flushPendingUnsafeLifecycleWarnings: function() {
            },
            recordLegacyContextWarning: function(fiber, instance2) {
            },
            flushLegacyContextWarning: function() {
            },
            discardPendingWarnings: function() {
            }
          };
          {
            var findStrictRoot = function(fiber) {
              var maybeStrictRoot = null;
              var node = fiber;
              while (node !== null) {
                if (node.mode & StrictMode) {
                  maybeStrictRoot = node;
                }
                node = node.return;
              }
              return maybeStrictRoot;
            };
            var setToSortedString = function(set2) {
              var array6 = [];
              set2.forEach(function(value) {
                array6.push(value);
              });
              return array6.sort().join(", ");
            };
            var pendingComponentWillMountWarnings = [];
            var pendingUNSAFE_ComponentWillMountWarnings = [];
            var pendingComponentWillReceivePropsWarnings = [];
            var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
            var pendingComponentWillUpdateWarnings = [];
            var pendingUNSAFE_ComponentWillUpdateWarnings = [];
            var didWarnAboutUnsafeLifecycles = /* @__PURE__ */ new Set();
            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance2) {
              if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {
                return;
              }
              if (typeof instance2.componentWillMount === "function" && instance2.componentWillMount.__suppressDeprecationWarning !== true) {
                pendingComponentWillMountWarnings.push(fiber);
              }
              if (fiber.mode & StrictMode && typeof instance2.UNSAFE_componentWillMount === "function") {
                pendingUNSAFE_ComponentWillMountWarnings.push(fiber);
              }
              if (typeof instance2.componentWillReceiveProps === "function" && instance2.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                pendingComponentWillReceivePropsWarnings.push(fiber);
              }
              if (fiber.mode & StrictMode && typeof instance2.UNSAFE_componentWillReceiveProps === "function") {
                pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);
              }
              if (typeof instance2.componentWillUpdate === "function" && instance2.componentWillUpdate.__suppressDeprecationWarning !== true) {
                pendingComponentWillUpdateWarnings.push(fiber);
              }
              if (fiber.mode & StrictMode && typeof instance2.UNSAFE_componentWillUpdate === "function") {
                pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);
              }
            };
            ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
              var componentWillMountUniqueNames = /* @__PURE__ */ new Set();
              if (pendingComponentWillMountWarnings.length > 0) {
                pendingComponentWillMountWarnings.forEach(function(fiber) {
                  componentWillMountUniqueNames.add(getComponentName(fiber.type) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingComponentWillMountWarnings = [];
              }
              var UNSAFE_componentWillMountUniqueNames = /* @__PURE__ */ new Set();
              if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {
                pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
                  UNSAFE_componentWillMountUniqueNames.add(getComponentName(fiber.type) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingUNSAFE_ComponentWillMountWarnings = [];
              }
              var componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
              if (pendingComponentWillReceivePropsWarnings.length > 0) {
                pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
                  componentWillReceivePropsUniqueNames.add(getComponentName(fiber.type) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingComponentWillReceivePropsWarnings = [];
              }
              var UNSAFE_componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
              if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {
                pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {
                  UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentName(fiber.type) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
              }
              var componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
              if (pendingComponentWillUpdateWarnings.length > 0) {
                pendingComponentWillUpdateWarnings.forEach(function(fiber) {
                  componentWillUpdateUniqueNames.add(getComponentName(fiber.type) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingComponentWillUpdateWarnings = [];
              }
              var UNSAFE_componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
              if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {
                pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
                  UNSAFE_componentWillUpdateUniqueNames.add(getComponentName(fiber.type) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingUNSAFE_ComponentWillUpdateWarnings = [];
              }
              if (UNSAFE_componentWillMountUniqueNames.size > 0) {
                var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);
                error2("Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s", sortedNames);
              }
              if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {
                var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);
                error2("Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n\nPlease update the following components: %s", _sortedNames);
              }
              if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {
                var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);
                error2("Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s", _sortedNames2);
              }
              if (componentWillMountUniqueNames.size > 0) {
                var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);
                warn("componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames3);
              }
              if (componentWillReceivePropsUniqueNames.size > 0) {
                var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);
                warn("componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames4);
              }
              if (componentWillUpdateUniqueNames.size > 0) {
                var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);
                warn("componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames5);
              }
            };
            var pendingLegacyContextWarning = /* @__PURE__ */ new Map();
            var didWarnAboutLegacyContext = /* @__PURE__ */ new Set();
            ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance2) {
              var strictRoot = findStrictRoot(fiber);
              if (strictRoot === null) {
                error2("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
                return;
              }
              if (didWarnAboutLegacyContext.has(fiber.type)) {
                return;
              }
              var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);
              if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance2 !== null && typeof instance2.getChildContext === "function") {
                if (warningsForRoot === void 0) {
                  warningsForRoot = [];
                  pendingLegacyContextWarning.set(strictRoot, warningsForRoot);
                }
                warningsForRoot.push(fiber);
              }
            };
            ReactStrictModeWarnings.flushLegacyContextWarning = function() {
              pendingLegacyContextWarning.forEach(function(fiberArray, strictRoot) {
                if (fiberArray.length === 0) {
                  return;
                }
                var firstFiber = fiberArray[0];
                var uniqueNames = /* @__PURE__ */ new Set();
                fiberArray.forEach(function(fiber) {
                  uniqueNames.add(getComponentName(fiber.type) || "Component");
                  didWarnAboutLegacyContext.add(fiber.type);
                });
                var sortedNames = setToSortedString(uniqueNames);
                try {
                  setCurrentFiber(firstFiber);
                  error2("Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context", sortedNames);
                } finally {
                  resetCurrentFiber();
                }
              });
            };
            ReactStrictModeWarnings.discardPendingWarnings = function() {
              pendingComponentWillMountWarnings = [];
              pendingUNSAFE_ComponentWillMountWarnings = [];
              pendingComponentWillReceivePropsWarnings = [];
              pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
              pendingComponentWillUpdateWarnings = [];
              pendingUNSAFE_ComponentWillUpdateWarnings = [];
              pendingLegacyContextWarning = /* @__PURE__ */ new Map();
            };
          }
          function resolveDefaultProps(Component, baseProps) {
            if (Component && Component.defaultProps) {
              var props = _assign({}, baseProps);
              var defaultProps = Component.defaultProps;
              for (var propName in defaultProps) {
                if (props[propName] === void 0) {
                  props[propName] = defaultProps[propName];
                }
              }
              return props;
            }
            return baseProps;
          }
          var MAX_SIGNED_31_BIT_INT = 1073741823;
          var valueCursor = createCursor(null);
          var rendererSigil;
          {
            rendererSigil = {};
          }
          var currentlyRenderingFiber = null;
          var lastContextDependency = null;
          var lastContextWithAllBitsObserved = null;
          var isDisallowedContextReadInDEV = false;
          function resetContextDependencies() {
            currentlyRenderingFiber = null;
            lastContextDependency = null;
            lastContextWithAllBitsObserved = null;
            {
              isDisallowedContextReadInDEV = false;
            }
          }
          function enterDisallowedContextReadInDEV() {
            {
              isDisallowedContextReadInDEV = true;
            }
          }
          function exitDisallowedContextReadInDEV() {
            {
              isDisallowedContextReadInDEV = false;
            }
          }
          function pushProvider(providerFiber, nextValue) {
            var context = providerFiber.type._context;
            if (isPrimaryRenderer) {
              push(valueCursor, context._currentValue, providerFiber);
              context._currentValue = nextValue;
              {
                if (context._currentRenderer !== void 0 && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
                  error2("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
                }
                context._currentRenderer = rendererSigil;
              }
            } else {
              push(valueCursor, context._currentValue2, providerFiber);
              context._currentValue2 = nextValue;
              {
                if (context._currentRenderer2 !== void 0 && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil) {
                  error2("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
                }
                context._currentRenderer2 = rendererSigil;
              }
            }
          }
          function popProvider(providerFiber) {
            var currentValue = valueCursor.current;
            pop(valueCursor, providerFiber);
            var context = providerFiber.type._context;
            if (isPrimaryRenderer) {
              context._currentValue = currentValue;
            } else {
              context._currentValue2 = currentValue;
            }
          }
          function calculateChangedBits(context, newValue, oldValue) {
            if (objectIs(oldValue, newValue)) {
              return 0;
            } else {
              var changedBits = typeof context._calculateChangedBits === "function" ? context._calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;
              {
                if ((changedBits & MAX_SIGNED_31_BIT_INT) !== changedBits) {
                  error2("calculateChangedBits: Expected the return value to be a 31-bit integer. Instead received: %s", changedBits);
                }
              }
              return changedBits | 0;
            }
          }
          function scheduleWorkOnParentPath(parent, renderLanes2) {
            var node = parent;
            while (node !== null) {
              var alternate = node.alternate;
              if (!isSubsetOfLanes(node.childLanes, renderLanes2)) {
                node.childLanes = mergeLanes(node.childLanes, renderLanes2);
                if (alternate !== null) {
                  alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
                }
              } else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes2)) {
                alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
              } else {
                break;
              }
              node = node.return;
            }
          }
          function propagateContextChange(workInProgress2, context, changedBits, renderLanes2) {
            var fiber = workInProgress2.child;
            if (fiber !== null) {
              fiber.return = workInProgress2;
            }
            while (fiber !== null) {
              var nextFiber = void 0;
              var list = fiber.dependencies;
              if (list !== null) {
                nextFiber = fiber.child;
                var dependency = list.firstContext;
                while (dependency !== null) {
                  if (dependency.context === context && (dependency.observedBits & changedBits) !== 0) {
                    if (fiber.tag === ClassComponent) {
                      var update = createUpdate(NoTimestamp, pickArbitraryLane(renderLanes2));
                      update.tag = ForceUpdate;
                      enqueueUpdate(fiber, update);
                    }
                    fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
                    var alternate = fiber.alternate;
                    if (alternate !== null) {
                      alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
                    }
                    scheduleWorkOnParentPath(fiber.return, renderLanes2);
                    list.lanes = mergeLanes(list.lanes, renderLanes2);
                    break;
                  }
                  dependency = dependency.next;
                }
              } else if (fiber.tag === ContextProvider) {
                nextFiber = fiber.type === workInProgress2.type ? null : fiber.child;
              } else {
                nextFiber = fiber.child;
              }
              if (nextFiber !== null) {
                nextFiber.return = fiber;
              } else {
                nextFiber = fiber;
                while (nextFiber !== null) {
                  if (nextFiber === workInProgress2) {
                    nextFiber = null;
                    break;
                  }
                  var sibling = nextFiber.sibling;
                  if (sibling !== null) {
                    sibling.return = nextFiber.return;
                    nextFiber = sibling;
                    break;
                  }
                  nextFiber = nextFiber.return;
                }
              }
              fiber = nextFiber;
            }
          }
          function prepareToReadContext(workInProgress2, renderLanes2) {
            currentlyRenderingFiber = workInProgress2;
            lastContextDependency = null;
            lastContextWithAllBitsObserved = null;
            var dependencies = workInProgress2.dependencies;
            if (dependencies !== null) {
              var firstContext = dependencies.firstContext;
              if (firstContext !== null) {
                if (includesSomeLane(dependencies.lanes, renderLanes2)) {
                  markWorkInProgressReceivedUpdate();
                }
                dependencies.firstContext = null;
              }
            }
          }
          function readContext(context, observedBits) {
            {
              if (isDisallowedContextReadInDEV) {
                error2("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
              }
            }
            if (lastContextWithAllBitsObserved === context)
              ;
            else if (observedBits === false || observedBits === 0)
              ;
            else {
              var resolvedObservedBits;
              if (typeof observedBits !== "number" || observedBits === MAX_SIGNED_31_BIT_INT) {
                lastContextWithAllBitsObserved = context;
                resolvedObservedBits = MAX_SIGNED_31_BIT_INT;
              } else {
                resolvedObservedBits = observedBits;
              }
              var contextItem = {
                context,
                observedBits: resolvedObservedBits,
                next: null
              };
              if (lastContextDependency === null) {
                if (!(currentlyRenderingFiber !== null)) {
                  {
                    throw Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
                  }
                }
                lastContextDependency = contextItem;
                currentlyRenderingFiber.dependencies = {
                  lanes: NoLanes,
                  firstContext: contextItem,
                  responders: null
                };
              } else {
                lastContextDependency = lastContextDependency.next = contextItem;
              }
            }
            return isPrimaryRenderer ? context._currentValue : context._currentValue2;
          }
          var UpdateState = 0;
          var ReplaceState = 1;
          var ForceUpdate = 2;
          var CaptureUpdate = 3;
          var hasForceUpdate = false;
          var didWarnUpdateInsideUpdate;
          var currentlyProcessingQueue;
          {
            didWarnUpdateInsideUpdate = false;
            currentlyProcessingQueue = null;
          }
          function initializeUpdateQueue(fiber) {
            var queue2 = {
              baseState: fiber.memoizedState,
              firstBaseUpdate: null,
              lastBaseUpdate: null,
              shared: {
                pending: null
              },
              effects: null
            };
            fiber.updateQueue = queue2;
          }
          function cloneUpdateQueue(current2, workInProgress2) {
            var queue2 = workInProgress2.updateQueue;
            var currentQueue2 = current2.updateQueue;
            if (queue2 === currentQueue2) {
              var clone = {
                baseState: currentQueue2.baseState,
                firstBaseUpdate: currentQueue2.firstBaseUpdate,
                lastBaseUpdate: currentQueue2.lastBaseUpdate,
                shared: currentQueue2.shared,
                effects: currentQueue2.effects
              };
              workInProgress2.updateQueue = clone;
            }
          }
          function createUpdate(eventTime, lane) {
            var update = {
              eventTime,
              lane,
              tag: UpdateState,
              payload: null,
              callback: null,
              next: null
            };
            return update;
          }
          function enqueueUpdate(fiber, update) {
            var updateQueue = fiber.updateQueue;
            if (updateQueue === null) {
              return;
            }
            var sharedQueue = updateQueue.shared;
            var pending = sharedQueue.pending;
            if (pending === null) {
              update.next = update;
            } else {
              update.next = pending.next;
              pending.next = update;
            }
            sharedQueue.pending = update;
            {
              if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {
                error2("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.");
                didWarnUpdateInsideUpdate = true;
              }
            }
          }
          function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
            var queue2 = workInProgress2.updateQueue;
            var current2 = workInProgress2.alternate;
            if (current2 !== null) {
              var currentQueue2 = current2.updateQueue;
              if (queue2 === currentQueue2) {
                var newFirst = null;
                var newLast = null;
                var firstBaseUpdate = queue2.firstBaseUpdate;
                if (firstBaseUpdate !== null) {
                  var update = firstBaseUpdate;
                  do {
                    var clone = {
                      eventTime: update.eventTime,
                      lane: update.lane,
                      tag: update.tag,
                      payload: update.payload,
                      callback: update.callback,
                      next: null
                    };
                    if (newLast === null) {
                      newFirst = newLast = clone;
                    } else {
                      newLast.next = clone;
                      newLast = clone;
                    }
                    update = update.next;
                  } while (update !== null);
                  if (newLast === null) {
                    newFirst = newLast = capturedUpdate;
                  } else {
                    newLast.next = capturedUpdate;
                    newLast = capturedUpdate;
                  }
                } else {
                  newFirst = newLast = capturedUpdate;
                }
                queue2 = {
                  baseState: currentQueue2.baseState,
                  firstBaseUpdate: newFirst,
                  lastBaseUpdate: newLast,
                  shared: currentQueue2.shared,
                  effects: currentQueue2.effects
                };
                workInProgress2.updateQueue = queue2;
                return;
              }
            }
            var lastBaseUpdate = queue2.lastBaseUpdate;
            if (lastBaseUpdate === null) {
              queue2.firstBaseUpdate = capturedUpdate;
            } else {
              lastBaseUpdate.next = capturedUpdate;
            }
            queue2.lastBaseUpdate = capturedUpdate;
          }
          function getStateFromUpdate(workInProgress2, queue2, update, prevState, nextProps, instance2) {
            switch (update.tag) {
              case ReplaceState: {
                var payload = update.payload;
                if (typeof payload === "function") {
                  {
                    enterDisallowedContextReadInDEV();
                  }
                  var nextState = payload.call(instance2, prevState, nextProps);
                  {
                    if (workInProgress2.mode & StrictMode) {
                      disableLogs();
                      try {
                        payload.call(instance2, prevState, nextProps);
                      } finally {
                        reenableLogs();
                      }
                    }
                    exitDisallowedContextReadInDEV();
                  }
                  return nextState;
                }
                return payload;
              }
              case CaptureUpdate: {
                workInProgress2.flags = workInProgress2.flags & ~ShouldCapture | DidCapture;
              }
              case UpdateState: {
                var _payload = update.payload;
                var partialState;
                if (typeof _payload === "function") {
                  {
                    enterDisallowedContextReadInDEV();
                  }
                  partialState = _payload.call(instance2, prevState, nextProps);
                  {
                    if (workInProgress2.mode & StrictMode) {
                      disableLogs();
                      try {
                        _payload.call(instance2, prevState, nextProps);
                      } finally {
                        reenableLogs();
                      }
                    }
                    exitDisallowedContextReadInDEV();
                  }
                } else {
                  partialState = _payload;
                }
                if (partialState === null || partialState === void 0) {
                  return prevState;
                }
                return _assign({}, prevState, partialState);
              }
              case ForceUpdate: {
                hasForceUpdate = true;
                return prevState;
              }
            }
            return prevState;
          }
          function processUpdateQueue(workInProgress2, props, instance2, renderLanes2) {
            var queue2 = workInProgress2.updateQueue;
            hasForceUpdate = false;
            {
              currentlyProcessingQueue = queue2.shared;
            }
            var firstBaseUpdate = queue2.firstBaseUpdate;
            var lastBaseUpdate = queue2.lastBaseUpdate;
            var pendingQueue = queue2.shared.pending;
            if (pendingQueue !== null) {
              queue2.shared.pending = null;
              var lastPendingUpdate = pendingQueue;
              var firstPendingUpdate = lastPendingUpdate.next;
              lastPendingUpdate.next = null;
              if (lastBaseUpdate === null) {
                firstBaseUpdate = firstPendingUpdate;
              } else {
                lastBaseUpdate.next = firstPendingUpdate;
              }
              lastBaseUpdate = lastPendingUpdate;
              var current2 = workInProgress2.alternate;
              if (current2 !== null) {
                var currentQueue2 = current2.updateQueue;
                var currentLastBaseUpdate = currentQueue2.lastBaseUpdate;
                if (currentLastBaseUpdate !== lastBaseUpdate) {
                  if (currentLastBaseUpdate === null) {
                    currentQueue2.firstBaseUpdate = firstPendingUpdate;
                  } else {
                    currentLastBaseUpdate.next = firstPendingUpdate;
                  }
                  currentQueue2.lastBaseUpdate = lastPendingUpdate;
                }
              }
            }
            if (firstBaseUpdate !== null) {
              var newState = queue2.baseState;
              var newLanes = NoLanes;
              var newBaseState = null;
              var newFirstBaseUpdate = null;
              var newLastBaseUpdate = null;
              var update = firstBaseUpdate;
              do {
                var updateLane = update.lane;
                var updateEventTime = update.eventTime;
                if (!isSubsetOfLanes(renderLanes2, updateLane)) {
                  var clone = {
                    eventTime: updateEventTime,
                    lane: updateLane,
                    tag: update.tag,
                    payload: update.payload,
                    callback: update.callback,
                    next: null
                  };
                  if (newLastBaseUpdate === null) {
                    newFirstBaseUpdate = newLastBaseUpdate = clone;
                    newBaseState = newState;
                  } else {
                    newLastBaseUpdate = newLastBaseUpdate.next = clone;
                  }
                  newLanes = mergeLanes(newLanes, updateLane);
                } else {
                  if (newLastBaseUpdate !== null) {
                    var _clone = {
                      eventTime: updateEventTime,
                      lane: NoLane,
                      tag: update.tag,
                      payload: update.payload,
                      callback: update.callback,
                      next: null
                    };
                    newLastBaseUpdate = newLastBaseUpdate.next = _clone;
                  }
                  newState = getStateFromUpdate(workInProgress2, queue2, update, newState, props, instance2);
                  var callback = update.callback;
                  if (callback !== null) {
                    workInProgress2.flags |= Callback;
                    var effects = queue2.effects;
                    if (effects === null) {
                      queue2.effects = [update];
                    } else {
                      effects.push(update);
                    }
                  }
                }
                update = update.next;
                if (update === null) {
                  pendingQueue = queue2.shared.pending;
                  if (pendingQueue === null) {
                    break;
                  } else {
                    var _lastPendingUpdate = pendingQueue;
                    var _firstPendingUpdate = _lastPendingUpdate.next;
                    _lastPendingUpdate.next = null;
                    update = _firstPendingUpdate;
                    queue2.lastBaseUpdate = _lastPendingUpdate;
                    queue2.shared.pending = null;
                  }
                }
              } while (true);
              if (newLastBaseUpdate === null) {
                newBaseState = newState;
              }
              queue2.baseState = newBaseState;
              queue2.firstBaseUpdate = newFirstBaseUpdate;
              queue2.lastBaseUpdate = newLastBaseUpdate;
              markSkippedUpdateLanes(newLanes);
              workInProgress2.lanes = newLanes;
              workInProgress2.memoizedState = newState;
            }
            {
              currentlyProcessingQueue = null;
            }
          }
          function callCallback(callback, context) {
            if (!(typeof callback === "function")) {
              {
                throw Error("Invalid argument passed as callback. Expected a function. Instead received: " + callback);
              }
            }
            callback.call(context);
          }
          function resetHasForceUpdateBeforeProcessing() {
            hasForceUpdate = false;
          }
          function checkHasForceUpdateAfterProcessing() {
            return hasForceUpdate;
          }
          function commitUpdateQueue(finishedWork, finishedQueue, instance2) {
            var effects = finishedQueue.effects;
            finishedQueue.effects = null;
            if (effects !== null) {
              for (var i = 0; i < effects.length; i++) {
                var effect = effects[i];
                var callback = effect.callback;
                if (callback !== null) {
                  effect.callback = null;
                  callCallback(callback, instance2);
                }
              }
            }
          }
          var fakeInternalInstance = {};
          var isArray2 = Array.isArray;
          var emptyRefsObject = new React15.Component().refs;
          var didWarnAboutStateAssignmentForComponent;
          var didWarnAboutUninitializedState;
          var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
          var didWarnAboutLegacyLifecyclesAndDerivedState;
          var didWarnAboutUndefinedDerivedState;
          var warnOnUndefinedDerivedState;
          var warnOnInvalidCallback;
          var didWarnAboutDirectlyAssigningPropsToState;
          var didWarnAboutContextTypeAndContextTypes;
          var didWarnAboutInvalidateContextType;
          {
            didWarnAboutStateAssignmentForComponent = /* @__PURE__ */ new Set();
            didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
            didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
            didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
            didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
            didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set();
            didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
            var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
            warnOnInvalidCallback = function(callback, callerName) {
              if (callback === null || typeof callback === "function") {
                return;
              }
              var key = callerName + "_" + callback;
              if (!didWarnOnInvalidCallback.has(key)) {
                didWarnOnInvalidCallback.add(key);
                error2("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
              }
            };
            warnOnUndefinedDerivedState = function(type5, partialState) {
              if (partialState === void 0) {
                var componentName = getComponentName(type5) || "Component";
                if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
                  didWarnAboutUndefinedDerivedState.add(componentName);
                  error2("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName);
                }
              }
            };
            Object.defineProperty(fakeInternalInstance, "_processChildContext", {
              enumerable: false,
              value: function() {
                {
                  {
                    throw Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
                  }
                }
              }
            });
            Object.freeze(fakeInternalInstance);
          }
          function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
            var prevState = workInProgress2.memoizedState;
            {
              if (workInProgress2.mode & StrictMode) {
                disableLogs();
                try {
                  getDerivedStateFromProps(nextProps, prevState);
                } finally {
                  reenableLogs();
                }
              }
            }
            var partialState = getDerivedStateFromProps(nextProps, prevState);
            {
              warnOnUndefinedDerivedState(ctor, partialState);
            }
            var memoizedState = partialState === null || partialState === void 0 ? prevState : _assign({}, prevState, partialState);
            workInProgress2.memoizedState = memoizedState;
            if (workInProgress2.lanes === NoLanes) {
              var updateQueue = workInProgress2.updateQueue;
              updateQueue.baseState = memoizedState;
            }
          }
          var classComponentUpdater = {
            isMounted,
            enqueueSetState: function(inst, payload, callback) {
              var fiber = get(inst);
              var eventTime = requestEventTime();
              var lane = requestUpdateLane(fiber);
              var update = createUpdate(eventTime, lane);
              update.payload = payload;
              if (callback !== void 0 && callback !== null) {
                {
                  warnOnInvalidCallback(callback, "setState");
                }
                update.callback = callback;
              }
              enqueueUpdate(fiber, update);
              scheduleUpdateOnFiber(fiber, lane, eventTime);
            },
            enqueueReplaceState: function(inst, payload, callback) {
              var fiber = get(inst);
              var eventTime = requestEventTime();
              var lane = requestUpdateLane(fiber);
              var update = createUpdate(eventTime, lane);
              update.tag = ReplaceState;
              update.payload = payload;
              if (callback !== void 0 && callback !== null) {
                {
                  warnOnInvalidCallback(callback, "replaceState");
                }
                update.callback = callback;
              }
              enqueueUpdate(fiber, update);
              scheduleUpdateOnFiber(fiber, lane, eventTime);
            },
            enqueueForceUpdate: function(inst, callback) {
              var fiber = get(inst);
              var eventTime = requestEventTime();
              var lane = requestUpdateLane(fiber);
              var update = createUpdate(eventTime, lane);
              update.tag = ForceUpdate;
              if (callback !== void 0 && callback !== null) {
                {
                  warnOnInvalidCallback(callback, "forceUpdate");
                }
                update.callback = callback;
              }
              enqueueUpdate(fiber, update);
              scheduleUpdateOnFiber(fiber, lane, eventTime);
            }
          };
          function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
            var instance2 = workInProgress2.stateNode;
            if (typeof instance2.shouldComponentUpdate === "function") {
              {
                if (workInProgress2.mode & StrictMode) {
                  disableLogs();
                  try {
                    instance2.shouldComponentUpdate(newProps, newState, nextContext);
                  } finally {
                    reenableLogs();
                  }
                }
              }
              var shouldUpdate = instance2.shouldComponentUpdate(newProps, newState, nextContext);
              {
                if (shouldUpdate === void 0) {
                  error2("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", getComponentName(ctor) || "Component");
                }
              }
              return shouldUpdate;
            }
            if (ctor.prototype && ctor.prototype.isPureReactComponent) {
              return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);
            }
            return true;
          }
          function checkClassInstance(workInProgress2, ctor, newProps) {
            var instance2 = workInProgress2.stateNode;
            {
              var name2 = getComponentName(ctor) || "Component";
              var renderPresent = instance2.render;
              if (!renderPresent) {
                if (ctor.prototype && typeof ctor.prototype.render === "function") {
                  error2("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name2);
                } else {
                  error2("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name2);
                }
              }
              if (instance2.getInitialState && !instance2.getInitialState.isReactClassApproved && !instance2.state) {
                error2("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name2);
              }
              if (instance2.getDefaultProps && !instance2.getDefaultProps.isReactClassApproved) {
                error2("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name2);
              }
              if (instance2.propTypes) {
                error2("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name2);
              }
              if (instance2.contextType) {
                error2("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name2);
              }
              {
                if (instance2.contextTypes) {
                  error2("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name2);
                }
                if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
                  didWarnAboutContextTypeAndContextTypes.add(ctor);
                  error2("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name2);
                }
              }
              if (typeof instance2.componentShouldUpdate === "function") {
                error2("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name2);
              }
              if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance2.shouldComponentUpdate !== "undefined") {
                error2("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentName(ctor) || "A pure component");
              }
              if (typeof instance2.componentDidUnmount === "function") {
                error2("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name2);
              }
              if (typeof instance2.componentDidReceiveProps === "function") {
                error2("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name2);
              }
              if (typeof instance2.componentWillRecieveProps === "function") {
                error2("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name2);
              }
              if (typeof instance2.UNSAFE_componentWillRecieveProps === "function") {
                error2("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name2);
              }
              var hasMutatedProps = instance2.props !== newProps;
              if (instance2.props !== void 0 && hasMutatedProps) {
                error2("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name2, name2);
              }
              if (instance2.defaultProps) {
                error2("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name2, name2);
              }
              if (typeof instance2.getSnapshotBeforeUpdate === "function" && typeof instance2.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
                didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
                error2("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentName(ctor));
              }
              if (typeof instance2.getDerivedStateFromProps === "function") {
                error2("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name2);
              }
              if (typeof instance2.getDerivedStateFromError === "function") {
                error2("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name2);
              }
              if (typeof ctor.getSnapshotBeforeUpdate === "function") {
                error2("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name2);
              }
              var _state = instance2.state;
              if (_state && (typeof _state !== "object" || isArray2(_state))) {
                error2("%s.state: must be set to an object or null", name2);
              }
              if (typeof instance2.getChildContext === "function" && typeof ctor.childContextTypes !== "object") {
                error2("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name2);
              }
            }
          }
          function adoptClassInstance(workInProgress2, instance2) {
            instance2.updater = classComponentUpdater;
            workInProgress2.stateNode = instance2;
            set(instance2, workInProgress2);
            {
              instance2._reactInternalInstance = fakeInternalInstance;
            }
          }
          function constructClassInstance(workInProgress2, ctor, props) {
            var isLegacyContextConsumer = false;
            var unmaskedContext = emptyContextObject;
            var context = emptyContextObject;
            var contextType = ctor.contextType;
            {
              if ("contextType" in ctor) {
                var isValid = contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0;
                if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
                  didWarnAboutInvalidateContextType.add(ctor);
                  var addendum = "";
                  if (contextType === void 0) {
                    addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
                  } else if (typeof contextType !== "object") {
                    addendum = " However, it is set to a " + typeof contextType + ".";
                  } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                    addendum = " Did you accidentally pass the Context.Provider instead?";
                  } else if (contextType._context !== void 0) {
                    addendum = " Did you accidentally pass the Context.Consumer instead?";
                  } else {
                    addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
                  }
                  error2("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentName(ctor) || "Component", addendum);
                }
              }
            }
            if (typeof contextType === "object" && contextType !== null) {
              context = readContext(contextType);
            } else {
              unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
              var contextTypes = ctor.contextTypes;
              isLegacyContextConsumer = contextTypes !== null && contextTypes !== void 0;
              context = isLegacyContextConsumer ? getMaskedContext(workInProgress2, unmaskedContext) : emptyContextObject;
            }
            {
              if (workInProgress2.mode & StrictMode) {
                disableLogs();
                try {
                  new ctor(props, context);
                } finally {
                  reenableLogs();
                }
              }
            }
            var instance2 = new ctor(props, context);
            var state = workInProgress2.memoizedState = instance2.state !== null && instance2.state !== void 0 ? instance2.state : null;
            adoptClassInstance(workInProgress2, instance2);
            {
              if (typeof ctor.getDerivedStateFromProps === "function" && state === null) {
                var componentName = getComponentName(ctor) || "Component";
                if (!didWarnAboutUninitializedState.has(componentName)) {
                  didWarnAboutUninitializedState.add(componentName);
                  error2("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance2.state === null ? "null" : "undefined", componentName);
                }
              }
              if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance2.getSnapshotBeforeUpdate === "function") {
                var foundWillMountName = null;
                var foundWillReceivePropsName = null;
                var foundWillUpdateName = null;
                if (typeof instance2.componentWillMount === "function" && instance2.componentWillMount.__suppressDeprecationWarning !== true) {
                  foundWillMountName = "componentWillMount";
                } else if (typeof instance2.UNSAFE_componentWillMount === "function") {
                  foundWillMountName = "UNSAFE_componentWillMount";
                }
                if (typeof instance2.componentWillReceiveProps === "function" && instance2.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                  foundWillReceivePropsName = "componentWillReceiveProps";
                } else if (typeof instance2.UNSAFE_componentWillReceiveProps === "function") {
                  foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
                }
                if (typeof instance2.componentWillUpdate === "function" && instance2.componentWillUpdate.__suppressDeprecationWarning !== true) {
                  foundWillUpdateName = "componentWillUpdate";
                } else if (typeof instance2.UNSAFE_componentWillUpdate === "function") {
                  foundWillUpdateName = "UNSAFE_componentWillUpdate";
                }
                if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
                  var _componentName = getComponentName(ctor) || "Component";
                  var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                  if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                    didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                    error2("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
                  }
                }
              }
            }
            if (isLegacyContextConsumer) {
              cacheContext(workInProgress2, unmaskedContext, context);
            }
            return instance2;
          }
          function callComponentWillMount(workInProgress2, instance2) {
            var oldState = instance2.state;
            if (typeof instance2.componentWillMount === "function") {
              instance2.componentWillMount();
            }
            if (typeof instance2.UNSAFE_componentWillMount === "function") {
              instance2.UNSAFE_componentWillMount();
            }
            if (oldState !== instance2.state) {
              {
                error2("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentName(workInProgress2.type) || "Component");
              }
              classComponentUpdater.enqueueReplaceState(instance2, instance2.state, null);
            }
          }
          function callComponentWillReceiveProps(workInProgress2, instance2, newProps, nextContext) {
            var oldState = instance2.state;
            if (typeof instance2.componentWillReceiveProps === "function") {
              instance2.componentWillReceiveProps(newProps, nextContext);
            }
            if (typeof instance2.UNSAFE_componentWillReceiveProps === "function") {
              instance2.UNSAFE_componentWillReceiveProps(newProps, nextContext);
            }
            if (instance2.state !== oldState) {
              {
                var componentName = getComponentName(workInProgress2.type) || "Component";
                if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {
                  didWarnAboutStateAssignmentForComponent.add(componentName);
                  error2("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", componentName);
                }
              }
              classComponentUpdater.enqueueReplaceState(instance2, instance2.state, null);
            }
          }
          function mountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
            {
              checkClassInstance(workInProgress2, ctor, newProps);
            }
            var instance2 = workInProgress2.stateNode;
            instance2.props = newProps;
            instance2.state = workInProgress2.memoizedState;
            instance2.refs = emptyRefsObject;
            initializeUpdateQueue(workInProgress2);
            var contextType = ctor.contextType;
            if (typeof contextType === "object" && contextType !== null) {
              instance2.context = readContext(contextType);
            } else {
              var unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
              instance2.context = getMaskedContext(workInProgress2, unmaskedContext);
            }
            {
              if (instance2.state === newProps) {
                var componentName = getComponentName(ctor) || "Component";
                if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
                  didWarnAboutDirectlyAssigningPropsToState.add(componentName);
                  error2("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName);
                }
              }
              if (workInProgress2.mode & StrictMode) {
                ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, instance2);
              }
              {
                ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress2, instance2);
              }
            }
            processUpdateQueue(workInProgress2, newProps, instance2, renderLanes2);
            instance2.state = workInProgress2.memoizedState;
            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
            if (typeof getDerivedStateFromProps === "function") {
              applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
              instance2.state = workInProgress2.memoizedState;
            }
            if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance2.getSnapshotBeforeUpdate !== "function" && (typeof instance2.UNSAFE_componentWillMount === "function" || typeof instance2.componentWillMount === "function")) {
              callComponentWillMount(workInProgress2, instance2);
              processUpdateQueue(workInProgress2, newProps, instance2, renderLanes2);
              instance2.state = workInProgress2.memoizedState;
            }
            if (typeof instance2.componentDidMount === "function") {
              workInProgress2.flags |= Update;
            }
          }
          function resumeMountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
            var instance2 = workInProgress2.stateNode;
            var oldProps = workInProgress2.memoizedProps;
            instance2.props = oldProps;
            var oldContext = instance2.context;
            var contextType = ctor.contextType;
            var nextContext = emptyContextObject;
            if (typeof contextType === "object" && contextType !== null) {
              nextContext = readContext(contextType);
            } else {
              var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
              nextContext = getMaskedContext(workInProgress2, nextLegacyUnmaskedContext);
            }
            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
            var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance2.getSnapshotBeforeUpdate === "function";
            if (!hasNewLifecycles && (typeof instance2.UNSAFE_componentWillReceiveProps === "function" || typeof instance2.componentWillReceiveProps === "function")) {
              if (oldProps !== newProps || oldContext !== nextContext) {
                callComponentWillReceiveProps(workInProgress2, instance2, newProps, nextContext);
              }
            }
            resetHasForceUpdateBeforeProcessing();
            var oldState = workInProgress2.memoizedState;
            var newState = instance2.state = oldState;
            processUpdateQueue(workInProgress2, newProps, instance2, renderLanes2);
            newState = workInProgress2.memoizedState;
            if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
              if (typeof instance2.componentDidMount === "function") {
                workInProgress2.flags |= Update;
              }
              return false;
            }
            if (typeof getDerivedStateFromProps === "function") {
              applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
              newState = workInProgress2.memoizedState;
            }
            var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext);
            if (shouldUpdate) {
              if (!hasNewLifecycles && (typeof instance2.UNSAFE_componentWillMount === "function" || typeof instance2.componentWillMount === "function")) {
                if (typeof instance2.componentWillMount === "function") {
                  instance2.componentWillMount();
                }
                if (typeof instance2.UNSAFE_componentWillMount === "function") {
                  instance2.UNSAFE_componentWillMount();
                }
              }
              if (typeof instance2.componentDidMount === "function") {
                workInProgress2.flags |= Update;
              }
            } else {
              if (typeof instance2.componentDidMount === "function") {
                workInProgress2.flags |= Update;
              }
              workInProgress2.memoizedProps = newProps;
              workInProgress2.memoizedState = newState;
            }
            instance2.props = newProps;
            instance2.state = newState;
            instance2.context = nextContext;
            return shouldUpdate;
          }
          function updateClassInstance(current2, workInProgress2, ctor, newProps, renderLanes2) {
            var instance2 = workInProgress2.stateNode;
            cloneUpdateQueue(current2, workInProgress2);
            var unresolvedOldProps = workInProgress2.memoizedProps;
            var oldProps = workInProgress2.type === workInProgress2.elementType ? unresolvedOldProps : resolveDefaultProps(workInProgress2.type, unresolvedOldProps);
            instance2.props = oldProps;
            var unresolvedNewProps = workInProgress2.pendingProps;
            var oldContext = instance2.context;
            var contextType = ctor.contextType;
            var nextContext = emptyContextObject;
            if (typeof contextType === "object" && contextType !== null) {
              nextContext = readContext(contextType);
            } else {
              var nextUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
              nextContext = getMaskedContext(workInProgress2, nextUnmaskedContext);
            }
            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
            var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance2.getSnapshotBeforeUpdate === "function";
            if (!hasNewLifecycles && (typeof instance2.UNSAFE_componentWillReceiveProps === "function" || typeof instance2.componentWillReceiveProps === "function")) {
              if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {
                callComponentWillReceiveProps(workInProgress2, instance2, newProps, nextContext);
              }
            }
            resetHasForceUpdateBeforeProcessing();
            var oldState = workInProgress2.memoizedState;
            var newState = instance2.state = oldState;
            processUpdateQueue(workInProgress2, newProps, instance2, renderLanes2);
            newState = workInProgress2.memoizedState;
            if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
              if (typeof instance2.componentDidUpdate === "function") {
                if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                  workInProgress2.flags |= Update;
                }
              }
              if (typeof instance2.getSnapshotBeforeUpdate === "function") {
                if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                  workInProgress2.flags |= Snapshot;
                }
              }
              return false;
            }
            if (typeof getDerivedStateFromProps === "function") {
              applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
              newState = workInProgress2.memoizedState;
            }
            var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext);
            if (shouldUpdate) {
              if (!hasNewLifecycles && (typeof instance2.UNSAFE_componentWillUpdate === "function" || typeof instance2.componentWillUpdate === "function")) {
                if (typeof instance2.componentWillUpdate === "function") {
                  instance2.componentWillUpdate(newProps, newState, nextContext);
                }
                if (typeof instance2.UNSAFE_componentWillUpdate === "function") {
                  instance2.UNSAFE_componentWillUpdate(newProps, newState, nextContext);
                }
              }
              if (typeof instance2.componentDidUpdate === "function") {
                workInProgress2.flags |= Update;
              }
              if (typeof instance2.getSnapshotBeforeUpdate === "function") {
                workInProgress2.flags |= Snapshot;
              }
            } else {
              if (typeof instance2.componentDidUpdate === "function") {
                if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                  workInProgress2.flags |= Update;
                }
              }
              if (typeof instance2.getSnapshotBeforeUpdate === "function") {
                if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                  workInProgress2.flags |= Snapshot;
                }
              }
              workInProgress2.memoizedProps = newProps;
              workInProgress2.memoizedState = newState;
            }
            instance2.props = newProps;
            instance2.state = newState;
            instance2.context = nextContext;
            return shouldUpdate;
          }
          var didWarnAboutMaps;
          var didWarnAboutGenerators;
          var didWarnAboutStringRefs;
          var ownerHasKeyUseWarning;
          var ownerHasFunctionTypeWarning;
          var warnForMissingKey = function(child, returnFiber) {
          };
          {
            didWarnAboutMaps = false;
            didWarnAboutGenerators = false;
            didWarnAboutStringRefs = {};
            ownerHasKeyUseWarning = {};
            ownerHasFunctionTypeWarning = {};
            warnForMissingKey = function(child, returnFiber) {
              if (child === null || typeof child !== "object") {
                return;
              }
              if (!child._store || child._store.validated || child.key != null) {
                return;
              }
              if (!(typeof child._store === "object")) {
                {
                  throw Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
              child._store.validated = true;
              var componentName = getComponentName(returnFiber.type) || "Component";
              if (ownerHasKeyUseWarning[componentName]) {
                return;
              }
              ownerHasKeyUseWarning[componentName] = true;
              error2('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.');
            };
          }
          var isArray$1 = Array.isArray;
          function coerceRef(returnFiber, current2, element) {
            var mixedRef = element.ref;
            if (mixedRef !== null && typeof mixedRef !== "function" && typeof mixedRef !== "object") {
              {
                if ((returnFiber.mode & StrictMode || warnAboutStringRefs) && !(element._owner && element._self && element._owner.stateNode !== element._self)) {
                  var componentName = getComponentName(returnFiber.type) || "Component";
                  if (!didWarnAboutStringRefs[componentName]) {
                    {
                      error2('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', mixedRef);
                    }
                    didWarnAboutStringRefs[componentName] = true;
                  }
                }
              }
              if (element._owner) {
                var owner = element._owner;
                var inst;
                if (owner) {
                  var ownerFiber = owner;
                  if (!(ownerFiber.tag === ClassComponent)) {
                    {
                      throw Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
                    }
                  }
                  inst = ownerFiber.stateNode;
                }
                if (!inst) {
                  {
                    throw Error("Missing owner for string ref " + mixedRef + ". This error is likely caused by a bug in React. Please file an issue.");
                  }
                }
                var stringRef = "" + mixedRef;
                if (current2 !== null && current2.ref !== null && typeof current2.ref === "function" && current2.ref._stringRef === stringRef) {
                  return current2.ref;
                }
                var ref = function(value) {
                  var refs = inst.refs;
                  if (refs === emptyRefsObject) {
                    refs = inst.refs = {};
                  }
                  if (value === null) {
                    delete refs[stringRef];
                  } else {
                    refs[stringRef] = value;
                  }
                };
                ref._stringRef = stringRef;
                return ref;
              } else {
                if (!(typeof mixedRef === "string")) {
                  {
                    throw Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
                  }
                }
                if (!element._owner) {
                  {
                    throw Error("Element ref was specified as a string (" + mixedRef + ") but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://reactjs.org/link/refs-must-have-owner for more information.");
                  }
                }
              }
            }
            return mixedRef;
          }
          function throwOnInvalidObjectType(returnFiber, newChild) {
            if (returnFiber.type !== "textarea") {
              {
                {
                  throw Error("Objects are not valid as a React child (found: " + (Object.prototype.toString.call(newChild) === "[object Object]" ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : newChild) + "). If you meant to render a collection of children, use an array instead.");
                }
              }
            }
          }
          function warnOnFunctionType(returnFiber) {
            {
              var componentName = getComponentName(returnFiber.type) || "Component";
              if (ownerHasFunctionTypeWarning[componentName]) {
                return;
              }
              ownerHasFunctionTypeWarning[componentName] = true;
              error2("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
            }
          }
          function ChildReconciler(shouldTrackSideEffects) {
            function deleteChild(returnFiber, childToDelete) {
              if (!shouldTrackSideEffects) {
                return;
              }
              var last = returnFiber.lastEffect;
              if (last !== null) {
                last.nextEffect = childToDelete;
                returnFiber.lastEffect = childToDelete;
              } else {
                returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
              }
              childToDelete.nextEffect = null;
              childToDelete.flags = Deletion;
            }
            function deleteRemainingChildren(returnFiber, currentFirstChild) {
              if (!shouldTrackSideEffects) {
                return null;
              }
              var childToDelete = currentFirstChild;
              while (childToDelete !== null) {
                deleteChild(returnFiber, childToDelete);
                childToDelete = childToDelete.sibling;
              }
              return null;
            }
            function mapRemainingChildren(returnFiber, currentFirstChild) {
              var existingChildren = /* @__PURE__ */ new Map();
              var existingChild = currentFirstChild;
              while (existingChild !== null) {
                if (existingChild.key !== null) {
                  existingChildren.set(existingChild.key, existingChild);
                } else {
                  existingChildren.set(existingChild.index, existingChild);
                }
                existingChild = existingChild.sibling;
              }
              return existingChildren;
            }
            function useFiber(fiber, pendingProps) {
              var clone = createWorkInProgress(fiber, pendingProps);
              clone.index = 0;
              clone.sibling = null;
              return clone;
            }
            function placeChild(newFiber, lastPlacedIndex, newIndex) {
              newFiber.index = newIndex;
              if (!shouldTrackSideEffects) {
                return lastPlacedIndex;
              }
              var current2 = newFiber.alternate;
              if (current2 !== null) {
                var oldIndex = current2.index;
                if (oldIndex < lastPlacedIndex) {
                  newFiber.flags = Placement;
                  return lastPlacedIndex;
                } else {
                  return oldIndex;
                }
              } else {
                newFiber.flags = Placement;
                return lastPlacedIndex;
              }
            }
            function placeSingleChild(newFiber) {
              if (shouldTrackSideEffects && newFiber.alternate === null) {
                newFiber.flags = Placement;
              }
              return newFiber;
            }
            function updateTextNode(returnFiber, current2, textContent, lanes) {
              if (current2 === null || current2.tag !== HostText) {
                var created = createFiberFromText(textContent, returnFiber.mode, lanes);
                created.return = returnFiber;
                return created;
              } else {
                var existing = useFiber(current2, textContent);
                existing.return = returnFiber;
                return existing;
              }
            }
            function updateElement(returnFiber, current2, element, lanes) {
              if (current2 !== null) {
                if (current2.elementType === element.type || isCompatibleFamilyForHotReloading(current2, element)) {
                  var existing = useFiber(current2, element.props);
                  existing.ref = coerceRef(returnFiber, current2, element);
                  existing.return = returnFiber;
                  {
                    existing._debugSource = element._source;
                    existing._debugOwner = element._owner;
                  }
                  return existing;
                }
              }
              var created = createFiberFromElement(element, returnFiber.mode, lanes);
              created.ref = coerceRef(returnFiber, current2, element);
              created.return = returnFiber;
              return created;
            }
            function updatePortal(returnFiber, current2, portal, lanes) {
              if (current2 === null || current2.tag !== HostPortal || current2.stateNode.containerInfo !== portal.containerInfo || current2.stateNode.implementation !== portal.implementation) {
                var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
                created.return = returnFiber;
                return created;
              } else {
                var existing = useFiber(current2, portal.children || []);
                existing.return = returnFiber;
                return existing;
              }
            }
            function updateFragment2(returnFiber, current2, fragment, lanes, key) {
              if (current2 === null || current2.tag !== Fragment) {
                var created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key);
                created.return = returnFiber;
                return created;
              } else {
                var existing = useFiber(current2, fragment);
                existing.return = returnFiber;
                return existing;
              }
            }
            function createChild(returnFiber, newChild, lanes) {
              if (typeof newChild === "string" || typeof newChild === "number") {
                var created = createFiberFromText("" + newChild, returnFiber.mode, lanes);
                created.return = returnFiber;
                return created;
              }
              if (typeof newChild === "object" && newChild !== null) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE: {
                    var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);
                    _created.ref = coerceRef(returnFiber, null, newChild);
                    _created.return = returnFiber;
                    return _created;
                  }
                  case REACT_PORTAL_TYPE: {
                    var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                    _created2.return = returnFiber;
                    return _created2;
                  }
                }
                if (isArray$1(newChild) || getIteratorFn(newChild)) {
                  var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);
                  _created3.return = returnFiber;
                  return _created3;
                }
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              {
                if (typeof newChild === "function") {
                  warnOnFunctionType(returnFiber);
                }
              }
              return null;
            }
            function updateSlot(returnFiber, oldFiber, newChild, lanes) {
              var key = oldFiber !== null ? oldFiber.key : null;
              if (typeof newChild === "string" || typeof newChild === "number") {
                if (key !== null) {
                  return null;
                }
                return updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
              }
              if (typeof newChild === "object" && newChild !== null) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE: {
                    if (newChild.key === key) {
                      if (newChild.type === REACT_FRAGMENT_TYPE) {
                        return updateFragment2(returnFiber, oldFiber, newChild.props.children, lanes, key);
                      }
                      return updateElement(returnFiber, oldFiber, newChild, lanes);
                    } else {
                      return null;
                    }
                  }
                  case REACT_PORTAL_TYPE: {
                    if (newChild.key === key) {
                      return updatePortal(returnFiber, oldFiber, newChild, lanes);
                    } else {
                      return null;
                    }
                  }
                }
                if (isArray$1(newChild) || getIteratorFn(newChild)) {
                  if (key !== null) {
                    return null;
                  }
                  return updateFragment2(returnFiber, oldFiber, newChild, lanes, null);
                }
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              {
                if (typeof newChild === "function") {
                  warnOnFunctionType(returnFiber);
                }
              }
              return null;
            }
            function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
              if (typeof newChild === "string" || typeof newChild === "number") {
                var matchedFiber = existingChildren.get(newIdx) || null;
                return updateTextNode(returnFiber, matchedFiber, "" + newChild, lanes);
              }
              if (typeof newChild === "object" && newChild !== null) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE: {
                    var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                    if (newChild.type === REACT_FRAGMENT_TYPE) {
                      return updateFragment2(returnFiber, _matchedFiber, newChild.props.children, lanes, newChild.key);
                    }
                    return updateElement(returnFiber, _matchedFiber, newChild, lanes);
                  }
                  case REACT_PORTAL_TYPE: {
                    var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                    return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);
                  }
                }
                if (isArray$1(newChild) || getIteratorFn(newChild)) {
                  var _matchedFiber3 = existingChildren.get(newIdx) || null;
                  return updateFragment2(returnFiber, _matchedFiber3, newChild, lanes, null);
                }
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              {
                if (typeof newChild === "function") {
                  warnOnFunctionType(returnFiber);
                }
              }
              return null;
            }
            function warnOnInvalidKey(child, knownKeys, returnFiber) {
              {
                if (typeof child !== "object" || child === null) {
                  return knownKeys;
                }
                switch (child.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    warnForMissingKey(child, returnFiber);
                    var key = child.key;
                    if (typeof key !== "string") {
                      break;
                    }
                    if (knownKeys === null) {
                      knownKeys = /* @__PURE__ */ new Set();
                      knownKeys.add(key);
                      break;
                    }
                    if (!knownKeys.has(key)) {
                      knownKeys.add(key);
                      break;
                    }
                    error2("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.", key);
                    break;
                }
              }
              return knownKeys;
            }
            function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
              {
                var knownKeys = null;
                for (var i = 0; i < newChildren.length; i++) {
                  var child = newChildren[i];
                  knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
                }
              }
              var resultingFirstChild = null;
              var previousNewFiber = null;
              var oldFiber = currentFirstChild;
              var lastPlacedIndex = 0;
              var newIdx = 0;
              var nextOldFiber = null;
              for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
                if (oldFiber.index > newIdx) {
                  nextOldFiber = oldFiber;
                  oldFiber = null;
                } else {
                  nextOldFiber = oldFiber.sibling;
                }
                var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);
                if (newFiber === null) {
                  if (oldFiber === null) {
                    oldFiber = nextOldFiber;
                  }
                  break;
                }
                if (shouldTrackSideEffects) {
                  if (oldFiber && newFiber.alternate === null) {
                    deleteChild(returnFiber, oldFiber);
                  }
                }
                lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = newFiber;
                } else {
                  previousNewFiber.sibling = newFiber;
                }
                previousNewFiber = newFiber;
                oldFiber = nextOldFiber;
              }
              if (newIdx === newChildren.length) {
                deleteRemainingChildren(returnFiber, oldFiber);
                return resultingFirstChild;
              }
              if (oldFiber === null) {
                for (; newIdx < newChildren.length; newIdx++) {
                  var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);
                  if (_newFiber === null) {
                    continue;
                  }
                  lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);
                  if (previousNewFiber === null) {
                    resultingFirstChild = _newFiber;
                  } else {
                    previousNewFiber.sibling = _newFiber;
                  }
                  previousNewFiber = _newFiber;
                }
                return resultingFirstChild;
              }
              var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
              for (; newIdx < newChildren.length; newIdx++) {
                var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);
                if (_newFiber2 !== null) {
                  if (shouldTrackSideEffects) {
                    if (_newFiber2.alternate !== null) {
                      existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);
                    }
                  }
                  lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);
                  if (previousNewFiber === null) {
                    resultingFirstChild = _newFiber2;
                  } else {
                    previousNewFiber.sibling = _newFiber2;
                  }
                  previousNewFiber = _newFiber2;
                }
              }
              if (shouldTrackSideEffects) {
                existingChildren.forEach(function(child2) {
                  return deleteChild(returnFiber, child2);
                });
              }
              return resultingFirstChild;
            }
            function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {
              var iteratorFn = getIteratorFn(newChildrenIterable);
              if (!(typeof iteratorFn === "function")) {
                {
                  throw Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
              {
                if (typeof Symbol === "function" && newChildrenIterable[Symbol.toStringTag] === "Generator") {
                  if (!didWarnAboutGenerators) {
                    error2("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.");
                  }
                  didWarnAboutGenerators = true;
                }
                if (newChildrenIterable.entries === iteratorFn) {
                  if (!didWarnAboutMaps) {
                    error2("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                  }
                  didWarnAboutMaps = true;
                }
                var _newChildren = iteratorFn.call(newChildrenIterable);
                if (_newChildren) {
                  var knownKeys = null;
                  var _step = _newChildren.next();
                  for (; !_step.done; _step = _newChildren.next()) {
                    var child = _step.value;
                    knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
                  }
                }
              }
              var newChildren = iteratorFn.call(newChildrenIterable);
              if (!(newChildren != null)) {
                {
                  throw Error("An iterable object provided no iterator.");
                }
              }
              var resultingFirstChild = null;
              var previousNewFiber = null;
              var oldFiber = currentFirstChild;
              var lastPlacedIndex = 0;
              var newIdx = 0;
              var nextOldFiber = null;
              var step = newChildren.next();
              for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
                if (oldFiber.index > newIdx) {
                  nextOldFiber = oldFiber;
                  oldFiber = null;
                } else {
                  nextOldFiber = oldFiber.sibling;
                }
                var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
                if (newFiber === null) {
                  if (oldFiber === null) {
                    oldFiber = nextOldFiber;
                  }
                  break;
                }
                if (shouldTrackSideEffects) {
                  if (oldFiber && newFiber.alternate === null) {
                    deleteChild(returnFiber, oldFiber);
                  }
                }
                lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = newFiber;
                } else {
                  previousNewFiber.sibling = newFiber;
                }
                previousNewFiber = newFiber;
                oldFiber = nextOldFiber;
              }
              if (step.done) {
                deleteRemainingChildren(returnFiber, oldFiber);
                return resultingFirstChild;
              }
              if (oldFiber === null) {
                for (; !step.done; newIdx++, step = newChildren.next()) {
                  var _newFiber3 = createChild(returnFiber, step.value, lanes);
                  if (_newFiber3 === null) {
                    continue;
                  }
                  lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);
                  if (previousNewFiber === null) {
                    resultingFirstChild = _newFiber3;
                  } else {
                    previousNewFiber.sibling = _newFiber3;
                  }
                  previousNewFiber = _newFiber3;
                }
                return resultingFirstChild;
              }
              var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
              for (; !step.done; newIdx++, step = newChildren.next()) {
                var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes);
                if (_newFiber4 !== null) {
                  if (shouldTrackSideEffects) {
                    if (_newFiber4.alternate !== null) {
                      existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);
                    }
                  }
                  lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);
                  if (previousNewFiber === null) {
                    resultingFirstChild = _newFiber4;
                  } else {
                    previousNewFiber.sibling = _newFiber4;
                  }
                  previousNewFiber = _newFiber4;
                }
              }
              if (shouldTrackSideEffects) {
                existingChildren.forEach(function(child2) {
                  return deleteChild(returnFiber, child2);
                });
              }
              return resultingFirstChild;
            }
            function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {
              if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
                deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                var existing = useFiber(currentFirstChild, textContent);
                existing.return = returnFiber;
                return existing;
              }
              deleteRemainingChildren(returnFiber, currentFirstChild);
              var created = createFiberFromText(textContent, returnFiber.mode, lanes);
              created.return = returnFiber;
              return created;
            }
            function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {
              var key = element.key;
              var child = currentFirstChild;
              while (child !== null) {
                if (child.key === key) {
                  switch (child.tag) {
                    case Fragment: {
                      if (element.type === REACT_FRAGMENT_TYPE) {
                        deleteRemainingChildren(returnFiber, child.sibling);
                        var existing = useFiber(child, element.props.children);
                        existing.return = returnFiber;
                        {
                          existing._debugSource = element._source;
                          existing._debugOwner = element._owner;
                        }
                        return existing;
                      }
                      break;
                    }
                    case Block:
                    default: {
                      if (child.elementType === element.type || isCompatibleFamilyForHotReloading(child, element)) {
                        deleteRemainingChildren(returnFiber, child.sibling);
                        var _existing3 = useFiber(child, element.props);
                        _existing3.ref = coerceRef(returnFiber, child, element);
                        _existing3.return = returnFiber;
                        {
                          _existing3._debugSource = element._source;
                          _existing3._debugOwner = element._owner;
                        }
                        return _existing3;
                      }
                      break;
                    }
                  }
                  deleteRemainingChildren(returnFiber, child);
                  break;
                } else {
                  deleteChild(returnFiber, child);
                }
                child = child.sibling;
              }
              if (element.type === REACT_FRAGMENT_TYPE) {
                var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);
                created.return = returnFiber;
                return created;
              } else {
                var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);
                _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
                _created4.return = returnFiber;
                return _created4;
              }
            }
            function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {
              var key = portal.key;
              var child = currentFirstChild;
              while (child !== null) {
                if (child.key === key) {
                  if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
                    deleteRemainingChildren(returnFiber, child.sibling);
                    var existing = useFiber(child, portal.children || []);
                    existing.return = returnFiber;
                    return existing;
                  } else {
                    deleteRemainingChildren(returnFiber, child);
                    break;
                  }
                } else {
                  deleteChild(returnFiber, child);
                }
                child = child.sibling;
              }
              var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
              created.return = returnFiber;
              return created;
            }
            function reconcileChildFibers2(returnFiber, currentFirstChild, newChild, lanes) {
              var isUnkeyedTopLevelFragment = typeof newChild === "object" && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;
              if (isUnkeyedTopLevelFragment) {
                newChild = newChild.props.children;
              }
              var isObject5 = typeof newChild === "object" && newChild !== null;
              if (isObject5) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                    return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));
                  case REACT_PORTAL_TYPE:
                    return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));
                }
              }
              if (typeof newChild === "string" || typeof newChild === "number") {
                return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, "" + newChild, lanes));
              }
              if (isArray$1(newChild)) {
                return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);
              }
              if (getIteratorFn(newChild)) {
                return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);
              }
              if (isObject5) {
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              {
                if (typeof newChild === "function") {
                  warnOnFunctionType(returnFiber);
                }
              }
              if (typeof newChild === "undefined" && !isUnkeyedTopLevelFragment) {
                switch (returnFiber.tag) {
                  case ClassComponent: {
                    {
                      var instance2 = returnFiber.stateNode;
                      if (instance2.render._isMockFunction) {
                        break;
                      }
                    }
                  }
                  case Block:
                  case FunctionComponent:
                  case ForwardRef:
                  case SimpleMemoComponent: {
                    {
                      {
                        throw Error((getComponentName(returnFiber.type) || "Component") + "(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.");
                      }
                    }
                  }
                }
              }
              return deleteRemainingChildren(returnFiber, currentFirstChild);
            }
            return reconcileChildFibers2;
          }
          var reconcileChildFibers = ChildReconciler(true);
          var mountChildFibers = ChildReconciler(false);
          function cloneChildFibers(current2, workInProgress2) {
            if (!(current2 === null || workInProgress2.child === current2.child)) {
              {
                throw Error("Resuming work not yet implemented.");
              }
            }
            if (workInProgress2.child === null) {
              return;
            }
            var currentChild = workInProgress2.child;
            var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);
            workInProgress2.child = newChild;
            newChild.return = workInProgress2;
            while (currentChild.sibling !== null) {
              currentChild = currentChild.sibling;
              newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);
              newChild.return = workInProgress2;
            }
            newChild.sibling = null;
          }
          function resetChildFibers(workInProgress2, lanes) {
            var child = workInProgress2.child;
            while (child !== null) {
              resetWorkInProgress(child, lanes);
              child = child.sibling;
            }
          }
          var NO_CONTEXT = {};
          var contextStackCursor$1 = createCursor(NO_CONTEXT);
          var contextFiberStackCursor = createCursor(NO_CONTEXT);
          var rootInstanceStackCursor = createCursor(NO_CONTEXT);
          function requiredContext(c2) {
            if (!(c2 !== NO_CONTEXT)) {
              {
                throw Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            return c2;
          }
          function getRootHostContainer() {
            var rootInstance = requiredContext(rootInstanceStackCursor.current);
            return rootInstance;
          }
          function pushHostContainer(fiber, nextRootInstance) {
            push(rootInstanceStackCursor, nextRootInstance, fiber);
            push(contextFiberStackCursor, fiber, fiber);
            push(contextStackCursor$1, NO_CONTEXT, fiber);
            var nextRootContext = getRootHostContext(nextRootInstance);
            pop(contextStackCursor$1, fiber);
            push(contextStackCursor$1, nextRootContext, fiber);
          }
          function popHostContainer(fiber) {
            pop(contextStackCursor$1, fiber);
            pop(contextFiberStackCursor, fiber);
            pop(rootInstanceStackCursor, fiber);
          }
          function getHostContext() {
            var context = requiredContext(contextStackCursor$1.current);
            return context;
          }
          function pushHostContext(fiber) {
            var rootInstance = requiredContext(rootInstanceStackCursor.current);
            var context = requiredContext(contextStackCursor$1.current);
            var nextContext = getChildHostContext(context, fiber.type, rootInstance);
            if (context === nextContext) {
              return;
            }
            push(contextFiberStackCursor, fiber, fiber);
            push(contextStackCursor$1, nextContext, fiber);
          }
          function popHostContext(fiber) {
            if (contextFiberStackCursor.current !== fiber) {
              return;
            }
            pop(contextStackCursor$1, fiber);
            pop(contextFiberStackCursor, fiber);
          }
          var DefaultSuspenseContext = 0;
          var SubtreeSuspenseContextMask = 1;
          var InvisibleParentSuspenseContext = 1;
          var ForceSuspenseFallback = 2;
          var suspenseStackCursor = createCursor(DefaultSuspenseContext);
          function hasSuspenseContext(parentContext, flag) {
            return (parentContext & flag) !== 0;
          }
          function setDefaultShallowSuspenseContext(parentContext) {
            return parentContext & SubtreeSuspenseContextMask;
          }
          function setShallowSuspenseContext(parentContext, shallowContext) {
            return parentContext & SubtreeSuspenseContextMask | shallowContext;
          }
          function addSubtreeSuspenseContext(parentContext, subtreeContext) {
            return parentContext | subtreeContext;
          }
          function pushSuspenseContext(fiber, newContext) {
            push(suspenseStackCursor, newContext, fiber);
          }
          function popSuspenseContext(fiber) {
            pop(suspenseStackCursor, fiber);
          }
          function shouldCaptureSuspense(workInProgress2, hasInvisibleParent) {
            var nextState = workInProgress2.memoizedState;
            if (nextState !== null) {
              if (nextState.dehydrated !== null) {
                return true;
              }
              return false;
            }
            var props = workInProgress2.memoizedProps;
            if (props.fallback === void 0) {
              return false;
            }
            if (props.unstable_avoidThisFallback !== true) {
              return true;
            }
            if (hasInvisibleParent) {
              return false;
            }
            return true;
          }
          function findFirstSuspended(row) {
            var node = row;
            while (node !== null) {
              if (node.tag === SuspenseComponent) {
                var state = node.memoizedState;
                if (state !== null) {
                  var dehydrated = state.dehydrated;
                  if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {
                    return node;
                  }
                }
              } else if (node.tag === SuspenseListComponent && node.memoizedProps.revealOrder !== void 0) {
                var didSuspend = (node.flags & DidCapture) !== NoFlags;
                if (didSuspend) {
                  return node;
                }
              } else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === row) {
                return null;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === row) {
                  return null;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
            return null;
          }
          var NoFlags$1 = 0;
          var HasEffect = 1;
          var Layout3 = 2;
          var Passive$1 = 4;
          var hydrationParentFiber = null;
          var nextHydratableInstance = null;
          var isHydrating = false;
          function enterHydrationState(fiber) {
            if (!supportsHydration) {
              return false;
            }
            var parentInstance = fiber.stateNode.containerInfo;
            nextHydratableInstance = getFirstHydratableChild(parentInstance);
            hydrationParentFiber = fiber;
            isHydrating = true;
            return true;
          }
          function deleteHydratableInstance(returnFiber, instance2) {
            {
              switch (returnFiber.tag) {
                case HostRoot:
                  didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo, instance2);
                  break;
                case HostComponent:
                  didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance2);
                  break;
              }
            }
            var childToDelete = createFiberFromHostInstanceForDeletion();
            childToDelete.stateNode = instance2;
            childToDelete.return = returnFiber;
            childToDelete.flags = Deletion;
            if (returnFiber.lastEffect !== null) {
              returnFiber.lastEffect.nextEffect = childToDelete;
              returnFiber.lastEffect = childToDelete;
            } else {
              returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
            }
          }
          function insertNonHydratedInstance(returnFiber, fiber) {
            fiber.flags = fiber.flags & ~Hydrating | Placement;
            {
              switch (returnFiber.tag) {
                case HostRoot: {
                  var parentContainer = returnFiber.stateNode.containerInfo;
                  switch (fiber.tag) {
                    case HostComponent:
                      var type5 = fiber.type;
                      var props = fiber.pendingProps;
                      didNotFindHydratableContainerInstance(parentContainer, type5, props);
                      break;
                    case HostText:
                      var text = fiber.pendingProps;
                      didNotFindHydratableContainerTextInstance(parentContainer, text);
                      break;
                    case SuspenseComponent:
                      didNotFindHydratableContainerSuspenseInstance(parentContainer);
                      break;
                  }
                  break;
                }
                case HostComponent: {
                  var parentType = returnFiber.type;
                  var parentProps = returnFiber.memoizedProps;
                  var parentInstance = returnFiber.stateNode;
                  switch (fiber.tag) {
                    case HostComponent:
                      var _type = fiber.type;
                      var _props = fiber.pendingProps;
                      didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type, _props);
                      break;
                    case HostText:
                      var _text = fiber.pendingProps;
                      didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);
                      break;
                    case SuspenseComponent:
                      didNotFindHydratableSuspenseInstance(parentType, parentProps, parentInstance);
                      break;
                  }
                  break;
                }
                default:
                  return;
              }
            }
          }
          function tryHydrate(fiber, nextInstance) {
            switch (fiber.tag) {
              case HostComponent: {
                var type5 = fiber.type;
                var props = fiber.pendingProps;
                var instance2 = canHydrateInstance(nextInstance, type5, props);
                if (instance2 !== null) {
                  fiber.stateNode = instance2;
                  return true;
                }
                return false;
              }
              case HostText: {
                var text = fiber.pendingProps;
                var textInstance = canHydrateTextInstance(nextInstance, text);
                if (textInstance !== null) {
                  fiber.stateNode = textInstance;
                  return true;
                }
                return false;
              }
              case SuspenseComponent: {
                return false;
              }
              default:
                return false;
            }
          }
          function tryToClaimNextHydratableInstance(fiber) {
            if (!isHydrating) {
              return;
            }
            var nextInstance = nextHydratableInstance;
            if (!nextInstance) {
              insertNonHydratedInstance(hydrationParentFiber, fiber);
              isHydrating = false;
              hydrationParentFiber = fiber;
              return;
            }
            var firstAttemptedInstance = nextInstance;
            if (!tryHydrate(fiber, nextInstance)) {
              nextInstance = getNextHydratableSibling(firstAttemptedInstance);
              if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
                insertNonHydratedInstance(hydrationParentFiber, fiber);
                isHydrating = false;
                hydrationParentFiber = fiber;
                return;
              }
              deleteHydratableInstance(hydrationParentFiber, firstAttemptedInstance);
            }
            hydrationParentFiber = fiber;
            nextHydratableInstance = getFirstHydratableChild(nextInstance);
          }
          function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
            if (!supportsHydration) {
              {
                {
                  throw Error("Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
            }
            var instance2 = fiber.stateNode;
            var updatePayload = hydrateInstance(instance2, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber);
            fiber.updateQueue = updatePayload;
            if (updatePayload !== null) {
              return true;
            }
            return false;
          }
          function prepareToHydrateHostTextInstance(fiber) {
            if (!supportsHydration) {
              {
                {
                  throw Error("Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
            }
            var textInstance = fiber.stateNode;
            var textContent = fiber.memoizedProps;
            var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
            {
              if (shouldUpdate) {
                var returnFiber = hydrationParentFiber;
                if (returnFiber !== null) {
                  switch (returnFiber.tag) {
                    case HostRoot: {
                      var parentContainer = returnFiber.stateNode.containerInfo;
                      didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);
                      break;
                    }
                    case HostComponent: {
                      var parentType = returnFiber.type;
                      var parentProps = returnFiber.memoizedProps;
                      var parentInstance = returnFiber.stateNode;
                      didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);
                      break;
                    }
                  }
                }
              }
            }
            return shouldUpdate;
          }
          function skipPastDehydratedSuspenseInstance(fiber) {
            if (!supportsHydration) {
              {
                {
                  throw Error("Expected skipPastDehydratedSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
            }
            var suspenseState = fiber.memoizedState;
            var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
            if (!suspenseInstance) {
              {
                throw Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);
          }
          function popToNextHostParent(fiber) {
            var parent = fiber.return;
            while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== SuspenseComponent) {
              parent = parent.return;
            }
            hydrationParentFiber = parent;
          }
          function popHydrationState(fiber) {
            if (!supportsHydration) {
              return false;
            }
            if (fiber !== hydrationParentFiber) {
              return false;
            }
            if (!isHydrating) {
              popToNextHostParent(fiber);
              isHydrating = true;
              return false;
            }
            var type5 = fiber.type;
            if (fiber.tag !== HostComponent || type5 !== "head" && type5 !== "body" && !shouldSetTextContent(type5, fiber.memoizedProps)) {
              var nextInstance = nextHydratableInstance;
              while (nextInstance) {
                deleteHydratableInstance(fiber, nextInstance);
                nextInstance = getNextHydratableSibling(nextInstance);
              }
            }
            popToNextHostParent(fiber);
            if (fiber.tag === SuspenseComponent) {
              nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);
            } else {
              nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
            }
            return true;
          }
          function resetHydrationState() {
            if (!supportsHydration) {
              return;
            }
            hydrationParentFiber = null;
            nextHydratableInstance = null;
            isHydrating = false;
          }
          function getIsHydrating() {
            return isHydrating;
          }
          var workInProgressSources = [];
          var rendererSigil$1;
          {
            rendererSigil$1 = {};
          }
          function markSourceAsDirty(mutableSource) {
            workInProgressSources.push(mutableSource);
          }
          function resetWorkInProgressVersions() {
            for (var i = 0; i < workInProgressSources.length; i++) {
              var mutableSource = workInProgressSources[i];
              if (isPrimaryRenderer) {
                mutableSource._workInProgressVersionPrimary = null;
              } else {
                mutableSource._workInProgressVersionSecondary = null;
              }
            }
            workInProgressSources.length = 0;
          }
          function getWorkInProgressVersion(mutableSource) {
            if (isPrimaryRenderer) {
              return mutableSource._workInProgressVersionPrimary;
            } else {
              return mutableSource._workInProgressVersionSecondary;
            }
          }
          function setWorkInProgressVersion(mutableSource, version4) {
            if (isPrimaryRenderer) {
              mutableSource._workInProgressVersionPrimary = version4;
            } else {
              mutableSource._workInProgressVersionSecondary = version4;
            }
            workInProgressSources.push(mutableSource);
          }
          function warnAboutMultipleRenderersDEV(mutableSource) {
            {
              if (isPrimaryRenderer) {
                if (mutableSource._currentPrimaryRenderer == null) {
                  mutableSource._currentPrimaryRenderer = rendererSigil$1;
                } else if (mutableSource._currentPrimaryRenderer !== rendererSigil$1) {
                  error2("Detected multiple renderers concurrently rendering the same mutable source. This is currently unsupported.");
                }
              } else {
                if (mutableSource._currentSecondaryRenderer == null) {
                  mutableSource._currentSecondaryRenderer = rendererSigil$1;
                } else if (mutableSource._currentSecondaryRenderer !== rendererSigil$1) {
                  error2("Detected multiple renderers concurrently rendering the same mutable source. This is currently unsupported.");
                }
              }
            }
          }
          var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;
          var didWarnAboutMismatchedHooksForComponent;
          var didWarnAboutUseOpaqueIdentifier;
          {
            didWarnAboutUseOpaqueIdentifier = {};
            didWarnAboutMismatchedHooksForComponent = /* @__PURE__ */ new Set();
          }
          var renderLanes = NoLanes;
          var currentlyRenderingFiber$1 = null;
          var currentHook = null;
          var workInProgressHook = null;
          var didScheduleRenderPhaseUpdate = false;
          var didScheduleRenderPhaseUpdateDuringThisPass = false;
          var RE_RENDER_LIMIT = 25;
          var currentHookNameInDev = null;
          var hookTypesDev = null;
          var hookTypesUpdateIndexDev = -1;
          var ignorePreviousDependencies = false;
          function mountHookTypesDev() {
            {
              var hookName = currentHookNameInDev;
              if (hookTypesDev === null) {
                hookTypesDev = [hookName];
              } else {
                hookTypesDev.push(hookName);
              }
            }
          }
          function updateHookTypesDev() {
            {
              var hookName = currentHookNameInDev;
              if (hookTypesDev !== null) {
                hookTypesUpdateIndexDev++;
                if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {
                  warnOnHookMismatchInDev(hookName);
                }
              }
            }
          }
          function checkDepsAreArrayDev(deps) {
            {
              if (deps !== void 0 && deps !== null && !Array.isArray(deps)) {
                error2("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", currentHookNameInDev, typeof deps);
              }
            }
          }
          function warnOnHookMismatchInDev(currentHookName) {
            {
              var componentName = getComponentName(currentlyRenderingFiber$1.type);
              if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {
                didWarnAboutMismatchedHooksForComponent.add(componentName);
                if (hookTypesDev !== null) {
                  var table = "";
                  var secondColumnStart = 30;
                  for (var i = 0; i <= hookTypesUpdateIndexDev; i++) {
                    var oldHookName = hookTypesDev[i];
                    var newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName;
                    var row = i + 1 + ". " + oldHookName;
                    while (row.length < secondColumnStart) {
                      row += " ";
                    }
                    row += newHookName + "\n";
                    table += row;
                  }
                  error2("React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n", componentName, table);
                }
              }
            }
          }
          function throwInvalidHookError() {
            {
              {
                throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
              }
            }
          }
          function areHookInputsEqual(nextDeps, prevDeps) {
            {
              if (ignorePreviousDependencies) {
                return false;
              }
            }
            if (prevDeps === null) {
              {
                error2("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
              }
              return false;
            }
            {
              if (nextDeps.length !== prevDeps.length) {
                error2("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + prevDeps.join(", ") + "]", "[" + nextDeps.join(", ") + "]");
              }
            }
            for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
              if (objectIs(nextDeps[i], prevDeps[i])) {
                continue;
              }
              return false;
            }
            return true;
          }
          function renderWithHooks(current2, workInProgress2, Component, props, secondArg, nextRenderLanes) {
            renderLanes = nextRenderLanes;
            currentlyRenderingFiber$1 = workInProgress2;
            {
              hookTypesDev = current2 !== null ? current2._debugHookTypes : null;
              hookTypesUpdateIndexDev = -1;
              ignorePreviousDependencies = current2 !== null && current2.type !== workInProgress2.type;
            }
            workInProgress2.memoizedState = null;
            workInProgress2.updateQueue = null;
            workInProgress2.lanes = NoLanes;
            {
              if (current2 !== null && current2.memoizedState !== null) {
                ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;
              } else if (hookTypesDev !== null) {
                ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV;
              } else {
                ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;
              }
            }
            var children = Component(props, secondArg);
            if (didScheduleRenderPhaseUpdateDuringThisPass) {
              var numberOfReRenders = 0;
              do {
                didScheduleRenderPhaseUpdateDuringThisPass = false;
                if (!(numberOfReRenders < RE_RENDER_LIMIT)) {
                  {
                    throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
                  }
                }
                numberOfReRenders += 1;
                {
                  ignorePreviousDependencies = false;
                }
                currentHook = null;
                workInProgressHook = null;
                workInProgress2.updateQueue = null;
                {
                  hookTypesUpdateIndexDev = -1;
                }
                ReactCurrentDispatcher$1.current = HooksDispatcherOnRerenderInDEV;
                children = Component(props, secondArg);
              } while (didScheduleRenderPhaseUpdateDuringThisPass);
            }
            ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
            {
              workInProgress2._debugHookTypes = hookTypesDev;
            }
            var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
            renderLanes = NoLanes;
            currentlyRenderingFiber$1 = null;
            currentHook = null;
            workInProgressHook = null;
            {
              currentHookNameInDev = null;
              hookTypesDev = null;
              hookTypesUpdateIndexDev = -1;
            }
            didScheduleRenderPhaseUpdate = false;
            if (!!didRenderTooFewHooks) {
              {
                throw Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
              }
            }
            return children;
          }
          function bailoutHooks(current2, workInProgress2, lanes) {
            workInProgress2.updateQueue = current2.updateQueue;
            workInProgress2.flags &= ~(Passive | Update);
            current2.lanes = removeLanes(current2.lanes, lanes);
          }
          function resetHooksAfterThrow() {
            ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
            if (didScheduleRenderPhaseUpdate) {
              var hook = currentlyRenderingFiber$1.memoizedState;
              while (hook !== null) {
                var queue2 = hook.queue;
                if (queue2 !== null) {
                  queue2.pending = null;
                }
                hook = hook.next;
              }
              didScheduleRenderPhaseUpdate = false;
            }
            renderLanes = NoLanes;
            currentlyRenderingFiber$1 = null;
            currentHook = null;
            workInProgressHook = null;
            {
              hookTypesDev = null;
              hookTypesUpdateIndexDev = -1;
              currentHookNameInDev = null;
              isUpdatingOpaqueValueInRenderPhase = false;
            }
            didScheduleRenderPhaseUpdateDuringThisPass = false;
          }
          function mountWorkInProgressHook() {
            var hook = {
              memoizedState: null,
              baseState: null,
              baseQueue: null,
              queue: null,
              next: null
            };
            if (workInProgressHook === null) {
              currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;
            } else {
              workInProgressHook = workInProgressHook.next = hook;
            }
            return workInProgressHook;
          }
          function updateWorkInProgressHook() {
            var nextCurrentHook;
            if (currentHook === null) {
              var current2 = currentlyRenderingFiber$1.alternate;
              if (current2 !== null) {
                nextCurrentHook = current2.memoizedState;
              } else {
                nextCurrentHook = null;
              }
            } else {
              nextCurrentHook = currentHook.next;
            }
            var nextWorkInProgressHook;
            if (workInProgressHook === null) {
              nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;
            } else {
              nextWorkInProgressHook = workInProgressHook.next;
            }
            if (nextWorkInProgressHook !== null) {
              workInProgressHook = nextWorkInProgressHook;
              nextWorkInProgressHook = workInProgressHook.next;
              currentHook = nextCurrentHook;
            } else {
              if (!(nextCurrentHook !== null)) {
                {
                  throw Error("Rendered more hooks than during the previous render.");
                }
              }
              currentHook = nextCurrentHook;
              var newHook = {
                memoizedState: currentHook.memoizedState,
                baseState: currentHook.baseState,
                baseQueue: currentHook.baseQueue,
                queue: currentHook.queue,
                next: null
              };
              if (workInProgressHook === null) {
                currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;
              } else {
                workInProgressHook = workInProgressHook.next = newHook;
              }
            }
            return workInProgressHook;
          }
          function createFunctionComponentUpdateQueue() {
            return {
              lastEffect: null
            };
          }
          function basicStateReducer(state, action) {
            return typeof action === "function" ? action(state) : action;
          }
          function mountReducer(reducer2, initialArg, init2) {
            var hook = mountWorkInProgressHook();
            var initialState2;
            if (init2 !== void 0) {
              initialState2 = init2(initialArg);
            } else {
              initialState2 = initialArg;
            }
            hook.memoizedState = hook.baseState = initialState2;
            var queue2 = hook.queue = {
              pending: null,
              dispatch: null,
              lastRenderedReducer: reducer2,
              lastRenderedState: initialState2
            };
            var dispatch = queue2.dispatch = dispatchAction.bind(null, currentlyRenderingFiber$1, queue2);
            return [hook.memoizedState, dispatch];
          }
          function updateReducer(reducer2, initialArg, init2) {
            var hook = updateWorkInProgressHook();
            var queue2 = hook.queue;
            if (!(queue2 !== null)) {
              {
                throw Error("Should have a queue. This is likely a bug in React. Please file an issue.");
              }
            }
            queue2.lastRenderedReducer = reducer2;
            var current2 = currentHook;
            var baseQueue = current2.baseQueue;
            var pendingQueue = queue2.pending;
            if (pendingQueue !== null) {
              if (baseQueue !== null) {
                var baseFirst = baseQueue.next;
                var pendingFirst = pendingQueue.next;
                baseQueue.next = pendingFirst;
                pendingQueue.next = baseFirst;
              }
              {
                if (current2.baseQueue !== baseQueue) {
                  error2("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React.");
                }
              }
              current2.baseQueue = baseQueue = pendingQueue;
              queue2.pending = null;
            }
            if (baseQueue !== null) {
              var first = baseQueue.next;
              var newState = current2.baseState;
              var newBaseState = null;
              var newBaseQueueFirst = null;
              var newBaseQueueLast = null;
              var update = first;
              do {
                var updateLane = update.lane;
                if (!isSubsetOfLanes(renderLanes, updateLane)) {
                  var clone = {
                    lane: updateLane,
                    action: update.action,
                    eagerReducer: update.eagerReducer,
                    eagerState: update.eagerState,
                    next: null
                  };
                  if (newBaseQueueLast === null) {
                    newBaseQueueFirst = newBaseQueueLast = clone;
                    newBaseState = newState;
                  } else {
                    newBaseQueueLast = newBaseQueueLast.next = clone;
                  }
                  currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane);
                  markSkippedUpdateLanes(updateLane);
                } else {
                  if (newBaseQueueLast !== null) {
                    var _clone = {
                      lane: NoLane,
                      action: update.action,
                      eagerReducer: update.eagerReducer,
                      eagerState: update.eagerState,
                      next: null
                    };
                    newBaseQueueLast = newBaseQueueLast.next = _clone;
                  }
                  if (update.eagerReducer === reducer2) {
                    newState = update.eagerState;
                  } else {
                    var action = update.action;
                    newState = reducer2(newState, action);
                  }
                }
                update = update.next;
              } while (update !== null && update !== first);
              if (newBaseQueueLast === null) {
                newBaseState = newState;
              } else {
                newBaseQueueLast.next = newBaseQueueFirst;
              }
              if (!objectIs(newState, hook.memoizedState)) {
                markWorkInProgressReceivedUpdate();
              }
              hook.memoizedState = newState;
              hook.baseState = newBaseState;
              hook.baseQueue = newBaseQueueLast;
              queue2.lastRenderedState = newState;
            }
            var dispatch = queue2.dispatch;
            return [hook.memoizedState, dispatch];
          }
          function rerenderReducer(reducer2, initialArg, init2) {
            var hook = updateWorkInProgressHook();
            var queue2 = hook.queue;
            if (!(queue2 !== null)) {
              {
                throw Error("Should have a queue. This is likely a bug in React. Please file an issue.");
              }
            }
            queue2.lastRenderedReducer = reducer2;
            var dispatch = queue2.dispatch;
            var lastRenderPhaseUpdate = queue2.pending;
            var newState = hook.memoizedState;
            if (lastRenderPhaseUpdate !== null) {
              queue2.pending = null;
              var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;
              var update = firstRenderPhaseUpdate;
              do {
                var action = update.action;
                newState = reducer2(newState, action);
                update = update.next;
              } while (update !== firstRenderPhaseUpdate);
              if (!objectIs(newState, hook.memoizedState)) {
                markWorkInProgressReceivedUpdate();
              }
              hook.memoizedState = newState;
              if (hook.baseQueue === null) {
                hook.baseState = newState;
              }
              queue2.lastRenderedState = newState;
            }
            return [newState, dispatch];
          }
          function readFromUnsubcribedMutableSource(root2, source, getSnapshot) {
            {
              warnAboutMultipleRenderersDEV(source);
            }
            var getVersion = source._getVersion;
            var version4 = getVersion(source._source);
            var isSafeToReadFromSource = false;
            var currentRenderVersion = getWorkInProgressVersion(source);
            if (currentRenderVersion !== null) {
              isSafeToReadFromSource = currentRenderVersion === version4;
            } else {
              isSafeToReadFromSource = isSubsetOfLanes(renderLanes, root2.mutableReadLanes);
              if (isSafeToReadFromSource) {
                setWorkInProgressVersion(source, version4);
              }
            }
            if (isSafeToReadFromSource) {
              var snapshot = getSnapshot(source._source);
              {
                if (typeof snapshot === "function") {
                  error2("Mutable source should not return a function as the snapshot value. Functions may close over mutable values and cause tearing.");
                }
              }
              return snapshot;
            } else {
              markSourceAsDirty(source);
              {
                {
                  throw Error("Cannot read from mutable source during the current render without tearing. This is a bug in React. Please file an issue.");
                }
              }
            }
          }
          function useMutableSource(hook, source, getSnapshot, subscribe) {
            var root2 = getWorkInProgressRoot();
            if (!(root2 !== null)) {
              {
                throw Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
              }
            }
            var getVersion = source._getVersion;
            var version4 = getVersion(source._source);
            var dispatcher = ReactCurrentDispatcher$1.current;
            var _dispatcher$useState = dispatcher.useState(function() {
              return readFromUnsubcribedMutableSource(root2, source, getSnapshot);
            }), currentSnapshot = _dispatcher$useState[0], setSnapshot = _dispatcher$useState[1];
            var snapshot = currentSnapshot;
            var stateHook = workInProgressHook;
            var memoizedState = hook.memoizedState;
            var refs = memoizedState.refs;
            var prevGetSnapshot = refs.getSnapshot;
            var prevSource = memoizedState.source;
            var prevSubscribe = memoizedState.subscribe;
            var fiber = currentlyRenderingFiber$1;
            hook.memoizedState = {
              refs,
              source,
              subscribe
            };
            dispatcher.useEffect(function() {
              refs.getSnapshot = getSnapshot;
              refs.setSnapshot = setSnapshot;
              var maybeNewVersion = getVersion(source._source);
              if (!objectIs(version4, maybeNewVersion)) {
                var maybeNewSnapshot = getSnapshot(source._source);
                {
                  if (typeof maybeNewSnapshot === "function") {
                    error2("Mutable source should not return a function as the snapshot value. Functions may close over mutable values and cause tearing.");
                  }
                }
                if (!objectIs(snapshot, maybeNewSnapshot)) {
                  setSnapshot(maybeNewSnapshot);
                  var lane = requestUpdateLane(fiber);
                  markRootMutableRead(root2, lane);
                }
                markRootEntangled(root2, root2.mutableReadLanes);
              }
            }, [getSnapshot, source, subscribe]);
            dispatcher.useEffect(function() {
              var handleChange = function() {
                var latestGetSnapshot = refs.getSnapshot;
                var latestSetSnapshot = refs.setSnapshot;
                try {
                  latestSetSnapshot(latestGetSnapshot(source._source));
                  var lane = requestUpdateLane(fiber);
                  markRootMutableRead(root2, lane);
                } catch (error3) {
                  latestSetSnapshot(function() {
                    throw error3;
                  });
                }
              };
              var unsubscribe = subscribe(source._source, handleChange);
              {
                if (typeof unsubscribe !== "function") {
                  error2("Mutable source subscribe function must return an unsubscribe function.");
                }
              }
              return unsubscribe;
            }, [source, subscribe]);
            if (!objectIs(prevGetSnapshot, getSnapshot) || !objectIs(prevSource, source) || !objectIs(prevSubscribe, subscribe)) {
              var newQueue = {
                pending: null,
                dispatch: null,
                lastRenderedReducer: basicStateReducer,
                lastRenderedState: snapshot
              };
              newQueue.dispatch = setSnapshot = dispatchAction.bind(null, currentlyRenderingFiber$1, newQueue);
              stateHook.queue = newQueue;
              stateHook.baseQueue = null;
              snapshot = readFromUnsubcribedMutableSource(root2, source, getSnapshot);
              stateHook.memoizedState = stateHook.baseState = snapshot;
            }
            return snapshot;
          }
          function mountMutableSource(source, getSnapshot, subscribe) {
            var hook = mountWorkInProgressHook();
            hook.memoizedState = {
              refs: {
                getSnapshot,
                setSnapshot: null
              },
              source,
              subscribe
            };
            return useMutableSource(hook, source, getSnapshot, subscribe);
          }
          function updateMutableSource(source, getSnapshot, subscribe) {
            var hook = updateWorkInProgressHook();
            return useMutableSource(hook, source, getSnapshot, subscribe);
          }
          function mountState(initialState2) {
            var hook = mountWorkInProgressHook();
            if (typeof initialState2 === "function") {
              initialState2 = initialState2();
            }
            hook.memoizedState = hook.baseState = initialState2;
            var queue2 = hook.queue = {
              pending: null,
              dispatch: null,
              lastRenderedReducer: basicStateReducer,
              lastRenderedState: initialState2
            };
            var dispatch = queue2.dispatch = dispatchAction.bind(null, currentlyRenderingFiber$1, queue2);
            return [hook.memoizedState, dispatch];
          }
          function updateState(initialState2) {
            return updateReducer(basicStateReducer);
          }
          function rerenderState(initialState2) {
            return rerenderReducer(basicStateReducer);
          }
          function pushEffect(tag, create5, destroy, deps) {
            var effect = {
              tag,
              create: create5,
              destroy,
              deps,
              next: null
            };
            var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
            if (componentUpdateQueue === null) {
              componentUpdateQueue = createFunctionComponentUpdateQueue();
              currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
              componentUpdateQueue.lastEffect = effect.next = effect;
            } else {
              var lastEffect = componentUpdateQueue.lastEffect;
              if (lastEffect === null) {
                componentUpdateQueue.lastEffect = effect.next = effect;
              } else {
                var firstEffect = lastEffect.next;
                lastEffect.next = effect;
                effect.next = firstEffect;
                componentUpdateQueue.lastEffect = effect;
              }
            }
            return effect;
          }
          function mountRef(initialValue) {
            var hook = mountWorkInProgressHook();
            var ref = {
              current: initialValue
            };
            {
              Object.seal(ref);
            }
            hook.memoizedState = ref;
            return ref;
          }
          function updateRef(initialValue) {
            var hook = updateWorkInProgressHook();
            return hook.memoizedState;
          }
          function mountEffectImpl(fiberFlags, hookFlags, create5, deps) {
            var hook = mountWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            currentlyRenderingFiber$1.flags |= fiberFlags;
            hook.memoizedState = pushEffect(HasEffect | hookFlags, create5, void 0, nextDeps);
          }
          function updateEffectImpl(fiberFlags, hookFlags, create5, deps) {
            var hook = updateWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            var destroy = void 0;
            if (currentHook !== null) {
              var prevEffect = currentHook.memoizedState;
              destroy = prevEffect.destroy;
              if (nextDeps !== null) {
                var prevDeps = prevEffect.deps;
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  pushEffect(hookFlags, create5, destroy, nextDeps);
                  return;
                }
              }
            }
            currentlyRenderingFiber$1.flags |= fiberFlags;
            hook.memoizedState = pushEffect(HasEffect | hookFlags, create5, destroy, nextDeps);
          }
          function mountEffect(create5, deps) {
            {
              if ("undefined" !== typeof jest) {
                warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber$1);
              }
            }
            return mountEffectImpl(Update | Passive, Passive$1, create5, deps);
          }
          function updateEffect(create5, deps) {
            {
              if ("undefined" !== typeof jest) {
                warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber$1);
              }
            }
            return updateEffectImpl(Update | Passive, Passive$1, create5, deps);
          }
          function mountLayoutEffect(create5, deps) {
            return mountEffectImpl(Update, Layout3, create5, deps);
          }
          function updateLayoutEffect(create5, deps) {
            return updateEffectImpl(Update, Layout3, create5, deps);
          }
          function imperativeHandleEffect(create5, ref) {
            if (typeof ref === "function") {
              var refCallback = ref;
              var _inst = create5();
              refCallback(_inst);
              return function() {
                refCallback(null);
              };
            } else if (ref !== null && ref !== void 0) {
              var refObject = ref;
              {
                if (!refObject.hasOwnProperty("current")) {
                  error2("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(refObject).join(", ") + "}");
                }
              }
              var _inst2 = create5();
              refObject.current = _inst2;
              return function() {
                refObject.current = null;
              };
            }
          }
          function mountImperativeHandle(ref, create5, deps) {
            {
              if (typeof create5 !== "function") {
                error2("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create5 !== null ? typeof create5 : "null");
              }
            }
            var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref]) : null;
            return mountEffectImpl(Update, Layout3, imperativeHandleEffect.bind(null, create5, ref), effectDeps);
          }
          function updateImperativeHandle(ref, create5, deps) {
            {
              if (typeof create5 !== "function") {
                error2("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create5 !== null ? typeof create5 : "null");
              }
            }
            var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref]) : null;
            return updateEffectImpl(Update, Layout3, imperativeHandleEffect.bind(null, create5, ref), effectDeps);
          }
          function mountDebugValue(value, formatterFn) {
          }
          var updateDebugValue = mountDebugValue;
          function mountCallback(callback, deps) {
            var hook = mountWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            hook.memoizedState = [callback, nextDeps];
            return callback;
          }
          function updateCallback(callback, deps) {
            var hook = updateWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            var prevState = hook.memoizedState;
            if (prevState !== null) {
              if (nextDeps !== null) {
                var prevDeps = prevState[1];
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  return prevState[0];
                }
              }
            }
            hook.memoizedState = [callback, nextDeps];
            return callback;
          }
          function mountMemo(nextCreate, deps) {
            var hook = mountWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            var nextValue = nextCreate();
            hook.memoizedState = [nextValue, nextDeps];
            return nextValue;
          }
          function updateMemo(nextCreate, deps) {
            var hook = updateWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            var prevState = hook.memoizedState;
            if (prevState !== null) {
              if (nextDeps !== null) {
                var prevDeps = prevState[1];
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  return prevState[0];
                }
              }
            }
            var nextValue = nextCreate();
            hook.memoizedState = [nextValue, nextDeps];
            return nextValue;
          }
          function mountDeferredValue(value) {
            var _mountState = mountState(value), prevValue = _mountState[0], setValue = _mountState[1];
            mountEffect(function() {
              var prevTransition = ReactCurrentBatchConfig$1.transition;
              ReactCurrentBatchConfig$1.transition = 1;
              try {
                setValue(value);
              } finally {
                ReactCurrentBatchConfig$1.transition = prevTransition;
              }
            }, [value]);
            return prevValue;
          }
          function updateDeferredValue(value) {
            var _updateState = updateState(), prevValue = _updateState[0], setValue = _updateState[1];
            updateEffect(function() {
              var prevTransition = ReactCurrentBatchConfig$1.transition;
              ReactCurrentBatchConfig$1.transition = 1;
              try {
                setValue(value);
              } finally {
                ReactCurrentBatchConfig$1.transition = prevTransition;
              }
            }, [value]);
            return prevValue;
          }
          function rerenderDeferredValue(value) {
            var _rerenderState = rerenderState(), prevValue = _rerenderState[0], setValue = _rerenderState[1];
            updateEffect(function() {
              var prevTransition = ReactCurrentBatchConfig$1.transition;
              ReactCurrentBatchConfig$1.transition = 1;
              try {
                setValue(value);
              } finally {
                ReactCurrentBatchConfig$1.transition = prevTransition;
              }
            }, [value]);
            return prevValue;
          }
          function startTransition(setPending, callback) {
            var priorityLevel = getCurrentPriorityLevel();
            {
              runWithPriority(priorityLevel < UserBlockingPriority$1 ? UserBlockingPriority$1 : priorityLevel, function() {
                setPending(true);
              });
              runWithPriority(priorityLevel > NormalPriority$1 ? NormalPriority$1 : priorityLevel, function() {
                var prevTransition = ReactCurrentBatchConfig$1.transition;
                ReactCurrentBatchConfig$1.transition = 1;
                try {
                  setPending(false);
                  callback();
                } finally {
                  ReactCurrentBatchConfig$1.transition = prevTransition;
                }
              });
            }
          }
          function mountTransition() {
            var _mountState2 = mountState(false), isPending = _mountState2[0], setPending = _mountState2[1];
            var start = startTransition.bind(null, setPending);
            mountRef(start);
            return [start, isPending];
          }
          function updateTransition() {
            var _updateState2 = updateState(), isPending = _updateState2[0];
            var startRef = updateRef();
            var start = startRef.current;
            return [start, isPending];
          }
          function rerenderTransition() {
            var _rerenderState2 = rerenderState(), isPending = _rerenderState2[0];
            var startRef = updateRef();
            var start = startRef.current;
            return [start, isPending];
          }
          var isUpdatingOpaqueValueInRenderPhase = false;
          function getIsUpdatingOpaqueValueInRenderPhaseInDEV() {
            {
              return isUpdatingOpaqueValueInRenderPhase;
            }
          }
          function warnOnOpaqueIdentifierAccessInDEV(fiber) {
            {
              var name2 = getComponentName(fiber.type) || "Unknown";
              if (getIsRendering() && !didWarnAboutUseOpaqueIdentifier[name2]) {
                error2("The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly.");
                didWarnAboutUseOpaqueIdentifier[name2] = true;
              }
            }
          }
          function mountOpaqueIdentifier() {
            var makeId = makeClientIdInDEV.bind(null, warnOnOpaqueIdentifierAccessInDEV.bind(null, currentlyRenderingFiber$1));
            if (getIsHydrating()) {
              var didUpgrade = false;
              var fiber = currentlyRenderingFiber$1;
              var readValue = function() {
                if (!didUpgrade) {
                  didUpgrade = true;
                  {
                    isUpdatingOpaqueValueInRenderPhase = true;
                    setId(makeId());
                    isUpdatingOpaqueValueInRenderPhase = false;
                    warnOnOpaqueIdentifierAccessInDEV(fiber);
                  }
                }
                {
                  {
                    throw Error("The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly.");
                  }
                }
              };
              var id = makeOpaqueHydratingObject(readValue);
              var setId = mountState(id)[1];
              if ((currentlyRenderingFiber$1.mode & BlockingMode) === NoMode) {
                currentlyRenderingFiber$1.flags |= Update | Passive;
                pushEffect(HasEffect | Passive$1, function() {
                  setId(makeId());
                }, void 0, null);
              }
              return id;
            } else {
              var _id = makeId();
              mountState(_id);
              return _id;
            }
          }
          function updateOpaqueIdentifier() {
            var id = updateState()[0];
            return id;
          }
          function rerenderOpaqueIdentifier() {
            var id = rerenderState()[0];
            return id;
          }
          function dispatchAction(fiber, queue2, action) {
            {
              if (typeof arguments[3] === "function") {
                error2("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
              }
            }
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(fiber);
            var update = {
              lane,
              action,
              eagerReducer: null,
              eagerState: null,
              next: null
            };
            var pending = queue2.pending;
            if (pending === null) {
              update.next = update;
            } else {
              update.next = pending.next;
              pending.next = update;
            }
            queue2.pending = update;
            var alternate = fiber.alternate;
            if (fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1) {
              didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
            } else {
              if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {
                var lastRenderedReducer = queue2.lastRenderedReducer;
                if (lastRenderedReducer !== null) {
                  var prevDispatcher;
                  {
                    prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                  }
                  try {
                    var currentState = queue2.lastRenderedState;
                    var eagerState = lastRenderedReducer(currentState, action);
                    update.eagerReducer = lastRenderedReducer;
                    update.eagerState = eagerState;
                    if (objectIs(eagerState, currentState)) {
                      return;
                    }
                  } catch (error3) {
                  } finally {
                    {
                      ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                  }
                }
              }
              {
                if ("undefined" !== typeof jest) {
                  warnIfNotScopedWithMatchingAct(fiber);
                  warnIfNotCurrentlyActingUpdatesInDev(fiber);
                }
              }
              scheduleUpdateOnFiber(fiber, lane, eventTime);
            }
          }
          var ContextOnlyDispatcher = {
            readContext,
            useCallback: throwInvalidHookError,
            useContext: throwInvalidHookError,
            useEffect: throwInvalidHookError,
            useImperativeHandle: throwInvalidHookError,
            useLayoutEffect: throwInvalidHookError,
            useMemo: throwInvalidHookError,
            useReducer: throwInvalidHookError,
            useRef: throwInvalidHookError,
            useState: throwInvalidHookError,
            useDebugValue: throwInvalidHookError,
            useDeferredValue: throwInvalidHookError,
            useTransition: throwInvalidHookError,
            useMutableSource: throwInvalidHookError,
            useOpaqueIdentifier: throwInvalidHookError,
            unstable_isNewReconciler: enableNewReconciler
          };
          var HooksDispatcherOnMountInDEV = null;
          var HooksDispatcherOnMountWithHookTypesInDEV = null;
          var HooksDispatcherOnUpdateInDEV = null;
          var HooksDispatcherOnRerenderInDEV = null;
          var InvalidNestedHooksDispatcherOnMountInDEV = null;
          var InvalidNestedHooksDispatcherOnUpdateInDEV = null;
          var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
          {
            var warnInvalidContextAccess = function() {
              error2("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
            };
            var warnInvalidHookAccess = function() {
              error2("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
            };
            HooksDispatcherOnMountInDEV = {
              readContext: function(context, observedBits) {
                return readContext(context, observedBits);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountCallback(callback, deps);
              },
              useContext: function(context, observedBits) {
                currentHookNameInDev = "useContext";
                mountHookTypesDev();
                return readContext(context, observedBits);
              },
              useEffect: function(create5, deps) {
                currentHookNameInDev = "useEffect";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountEffect(create5, deps);
              },
              useImperativeHandle: function(ref, create5, deps) {
                currentHookNameInDev = "useImperativeHandle";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountImperativeHandle(ref, create5, deps);
              },
              useLayoutEffect: function(create5, deps) {
                currentHookNameInDev = "useLayoutEffect";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountLayoutEffect(create5, deps);
              },
              useMemo: function(create5, deps) {
                currentHookNameInDev = "useMemo";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountMemo(create5, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer2, initialArg, init2) {
                currentHookNameInDev = "useReducer";
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountReducer(reducer2, initialArg, init2);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                mountHookTypesDev();
                return mountRef(initialValue);
              },
              useState: function(initialState2) {
                currentHookNameInDev = "useState";
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountState(initialState2);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                mountHookTypesDev();
                return mountDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                mountHookTypesDev();
                return mountDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                mountHookTypesDev();
                return mountTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                mountHookTypesDev();
                return mountMutableSource(source, getSnapshot, subscribe);
              },
              useOpaqueIdentifier: function() {
                currentHookNameInDev = "useOpaqueIdentifier";
                mountHookTypesDev();
                return mountOpaqueIdentifier();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            HooksDispatcherOnMountWithHookTypesInDEV = {
              readContext: function(context, observedBits) {
                return readContext(context, observedBits);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                updateHookTypesDev();
                return mountCallback(callback, deps);
              },
              useContext: function(context, observedBits) {
                currentHookNameInDev = "useContext";
                updateHookTypesDev();
                return readContext(context, observedBits);
              },
              useEffect: function(create5, deps) {
                currentHookNameInDev = "useEffect";
                updateHookTypesDev();
                return mountEffect(create5, deps);
              },
              useImperativeHandle: function(ref, create5, deps) {
                currentHookNameInDev = "useImperativeHandle";
                updateHookTypesDev();
                return mountImperativeHandle(ref, create5, deps);
              },
              useLayoutEffect: function(create5, deps) {
                currentHookNameInDev = "useLayoutEffect";
                updateHookTypesDev();
                return mountLayoutEffect(create5, deps);
              },
              useMemo: function(create5, deps) {
                currentHookNameInDev = "useMemo";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountMemo(create5, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer2, initialArg, init2) {
                currentHookNameInDev = "useReducer";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountReducer(reducer2, initialArg, init2);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                updateHookTypesDev();
                return mountRef(initialValue);
              },
              useState: function(initialState2) {
                currentHookNameInDev = "useState";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountState(initialState2);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                updateHookTypesDev();
                return mountDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                updateHookTypesDev();
                return mountDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                updateHookTypesDev();
                return mountTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                updateHookTypesDev();
                return mountMutableSource(source, getSnapshot, subscribe);
              },
              useOpaqueIdentifier: function() {
                currentHookNameInDev = "useOpaqueIdentifier";
                updateHookTypesDev();
                return mountOpaqueIdentifier();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            HooksDispatcherOnUpdateInDEV = {
              readContext: function(context, observedBits) {
                return readContext(context, observedBits);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                updateHookTypesDev();
                return updateCallback(callback, deps);
              },
              useContext: function(context, observedBits) {
                currentHookNameInDev = "useContext";
                updateHookTypesDev();
                return readContext(context, observedBits);
              },
              useEffect: function(create5, deps) {
                currentHookNameInDev = "useEffect";
                updateHookTypesDev();
                return updateEffect(create5, deps);
              },
              useImperativeHandle: function(ref, create5, deps) {
                currentHookNameInDev = "useImperativeHandle";
                updateHookTypesDev();
                return updateImperativeHandle(ref, create5, deps);
              },
              useLayoutEffect: function(create5, deps) {
                currentHookNameInDev = "useLayoutEffect";
                updateHookTypesDev();
                return updateLayoutEffect(create5, deps);
              },
              useMemo: function(create5, deps) {
                currentHookNameInDev = "useMemo";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateMemo(create5, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer2, initialArg, init2) {
                currentHookNameInDev = "useReducer";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateReducer(reducer2, initialArg, init2);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                updateHookTypesDev();
                return updateRef();
              },
              useState: function(initialState2) {
                currentHookNameInDev = "useState";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateState(initialState2);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                updateHookTypesDev();
                return updateDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                updateHookTypesDev();
                return updateDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                updateHookTypesDev();
                return updateTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                updateHookTypesDev();
                return updateMutableSource(source, getSnapshot, subscribe);
              },
              useOpaqueIdentifier: function() {
                currentHookNameInDev = "useOpaqueIdentifier";
                updateHookTypesDev();
                return updateOpaqueIdentifier();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            HooksDispatcherOnRerenderInDEV = {
              readContext: function(context, observedBits) {
                return readContext(context, observedBits);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                updateHookTypesDev();
                return updateCallback(callback, deps);
              },
              useContext: function(context, observedBits) {
                currentHookNameInDev = "useContext";
                updateHookTypesDev();
                return readContext(context, observedBits);
              },
              useEffect: function(create5, deps) {
                currentHookNameInDev = "useEffect";
                updateHookTypesDev();
                return updateEffect(create5, deps);
              },
              useImperativeHandle: function(ref, create5, deps) {
                currentHookNameInDev = "useImperativeHandle";
                updateHookTypesDev();
                return updateImperativeHandle(ref, create5, deps);
              },
              useLayoutEffect: function(create5, deps) {
                currentHookNameInDev = "useLayoutEffect";
                updateHookTypesDev();
                return updateLayoutEffect(create5, deps);
              },
              useMemo: function(create5, deps) {
                currentHookNameInDev = "useMemo";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
                try {
                  return updateMemo(create5, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer2, initialArg, init2) {
                currentHookNameInDev = "useReducer";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
                try {
                  return rerenderReducer(reducer2, initialArg, init2);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                updateHookTypesDev();
                return updateRef();
              },
              useState: function(initialState2) {
                currentHookNameInDev = "useState";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
                try {
                  return rerenderState(initialState2);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                updateHookTypesDev();
                return updateDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                updateHookTypesDev();
                return rerenderDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                updateHookTypesDev();
                return rerenderTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                updateHookTypesDev();
                return updateMutableSource(source, getSnapshot, subscribe);
              },
              useOpaqueIdentifier: function() {
                currentHookNameInDev = "useOpaqueIdentifier";
                updateHookTypesDev();
                return rerenderOpaqueIdentifier();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            InvalidNestedHooksDispatcherOnMountInDEV = {
              readContext: function(context, observedBits) {
                warnInvalidContextAccess();
                return readContext(context, observedBits);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountCallback(callback, deps);
              },
              useContext: function(context, observedBits) {
                currentHookNameInDev = "useContext";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return readContext(context, observedBits);
              },
              useEffect: function(create5, deps) {
                currentHookNameInDev = "useEffect";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountEffect(create5, deps);
              },
              useImperativeHandle: function(ref, create5, deps) {
                currentHookNameInDev = "useImperativeHandle";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountImperativeHandle(ref, create5, deps);
              },
              useLayoutEffect: function(create5, deps) {
                currentHookNameInDev = "useLayoutEffect";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountLayoutEffect(create5, deps);
              },
              useMemo: function(create5, deps) {
                currentHookNameInDev = "useMemo";
                warnInvalidHookAccess();
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountMemo(create5, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer2, initialArg, init2) {
                currentHookNameInDev = "useReducer";
                warnInvalidHookAccess();
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountReducer(reducer2, initialArg, init2);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountRef(initialValue);
              },
              useState: function(initialState2) {
                currentHookNameInDev = "useState";
                warnInvalidHookAccess();
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountState(initialState2);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountMutableSource(source, getSnapshot, subscribe);
              },
              useOpaqueIdentifier: function() {
                currentHookNameInDev = "useOpaqueIdentifier";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountOpaqueIdentifier();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            InvalidNestedHooksDispatcherOnUpdateInDEV = {
              readContext: function(context, observedBits) {
                warnInvalidContextAccess();
                return readContext(context, observedBits);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateCallback(callback, deps);
              },
              useContext: function(context, observedBits) {
                currentHookNameInDev = "useContext";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return readContext(context, observedBits);
              },
              useEffect: function(create5, deps) {
                currentHookNameInDev = "useEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateEffect(create5, deps);
              },
              useImperativeHandle: function(ref, create5, deps) {
                currentHookNameInDev = "useImperativeHandle";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateImperativeHandle(ref, create5, deps);
              },
              useLayoutEffect: function(create5, deps) {
                currentHookNameInDev = "useLayoutEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateLayoutEffect(create5, deps);
              },
              useMemo: function(create5, deps) {
                currentHookNameInDev = "useMemo";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateMemo(create5, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer2, initialArg, init2) {
                currentHookNameInDev = "useReducer";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateReducer(reducer2, initialArg, init2);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateRef();
              },
              useState: function(initialState2) {
                currentHookNameInDev = "useState";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateState(initialState2);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateMutableSource(source, getSnapshot, subscribe);
              },
              useOpaqueIdentifier: function() {
                currentHookNameInDev = "useOpaqueIdentifier";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateOpaqueIdentifier();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            InvalidNestedHooksDispatcherOnRerenderInDEV = {
              readContext: function(context, observedBits) {
                warnInvalidContextAccess();
                return readContext(context, observedBits);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateCallback(callback, deps);
              },
              useContext: function(context, observedBits) {
                currentHookNameInDev = "useContext";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return readContext(context, observedBits);
              },
              useEffect: function(create5, deps) {
                currentHookNameInDev = "useEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateEffect(create5, deps);
              },
              useImperativeHandle: function(ref, create5, deps) {
                currentHookNameInDev = "useImperativeHandle";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateImperativeHandle(ref, create5, deps);
              },
              useLayoutEffect: function(create5, deps) {
                currentHookNameInDev = "useLayoutEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateLayoutEffect(create5, deps);
              },
              useMemo: function(create5, deps) {
                currentHookNameInDev = "useMemo";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateMemo(create5, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer2, initialArg, init2) {
                currentHookNameInDev = "useReducer";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return rerenderReducer(reducer2, initialArg, init2);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateRef();
              },
              useState: function(initialState2) {
                currentHookNameInDev = "useState";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return rerenderState(initialState2);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return rerenderDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return rerenderTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateMutableSource(source, getSnapshot, subscribe);
              },
              useOpaqueIdentifier: function() {
                currentHookNameInDev = "useOpaqueIdentifier";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return rerenderOpaqueIdentifier();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
          }
          var now$2 = Scheduler.unstable_now;
          var commitTime = 0;
          var profilerStartTime = -1;
          function getCommitTime() {
            return commitTime;
          }
          function recordCommitTime() {
            commitTime = now$2();
          }
          function startProfilerTimer(fiber) {
            profilerStartTime = now$2();
            if (fiber.actualStartTime < 0) {
              fiber.actualStartTime = now$2();
            }
          }
          function stopProfilerTimerIfRunning(fiber) {
            profilerStartTime = -1;
          }
          function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
            if (profilerStartTime >= 0) {
              var elapsedTime = now$2() - profilerStartTime;
              fiber.actualDuration += elapsedTime;
              if (overrideBaseTime) {
                fiber.selfBaseDuration = elapsedTime;
              }
              profilerStartTime = -1;
            }
          }
          function transferActualDuration(fiber) {
            var child = fiber.child;
            while (child) {
              fiber.actualDuration += child.actualDuration;
              child = child.sibling;
            }
          }
          var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
          var didReceiveUpdate = false;
          var didWarnAboutBadClass;
          var didWarnAboutModulePatternComponent;
          var didWarnAboutContextTypeOnFunctionComponent;
          var didWarnAboutGetDerivedStateOnFunctionComponent;
          var didWarnAboutFunctionRefs;
          var didWarnAboutReassigningProps;
          var didWarnAboutRevealOrder;
          var didWarnAboutTailOptions;
          {
            didWarnAboutBadClass = {};
            didWarnAboutModulePatternComponent = {};
            didWarnAboutContextTypeOnFunctionComponent = {};
            didWarnAboutGetDerivedStateOnFunctionComponent = {};
            didWarnAboutFunctionRefs = {};
            didWarnAboutReassigningProps = false;
            didWarnAboutRevealOrder = {};
            didWarnAboutTailOptions = {};
          }
          function reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2) {
            if (current2 === null) {
              workInProgress2.child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
            } else {
              workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, nextChildren, renderLanes2);
            }
          }
          function forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2) {
            workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
            workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
          }
          function updateForwardRef(current2, workInProgress2, Component, nextProps, renderLanes2) {
            {
              if (workInProgress2.type !== workInProgress2.elementType) {
                var innerPropTypes = Component.propTypes;
                if (innerPropTypes) {
                  checkPropTypes(
                    innerPropTypes,
                    nextProps,
                    "prop",
                    getComponentName(Component)
                  );
                }
              }
            }
            var render = Component.render;
            var ref = workInProgress2.ref;
            var nextChildren;
            prepareToReadContext(workInProgress2, renderLanes2);
            {
              ReactCurrentOwner$1.current = workInProgress2;
              setIsRendering(true);
              nextChildren = renderWithHooks(current2, workInProgress2, render, nextProps, ref, renderLanes2);
              if (workInProgress2.mode & StrictMode) {
                disableLogs();
                try {
                  nextChildren = renderWithHooks(current2, workInProgress2, render, nextProps, ref, renderLanes2);
                } finally {
                  reenableLogs();
                }
              }
              setIsRendering(false);
            }
            if (current2 !== null && !didReceiveUpdate) {
              bailoutHooks(current2, workInProgress2, renderLanes2);
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            }
            workInProgress2.flags |= PerformedWork;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateMemoComponent(current2, workInProgress2, Component, nextProps, updateLanes, renderLanes2) {
            if (current2 === null) {
              var type5 = Component.type;
              if (isSimpleFunctionComponent(type5) && Component.compare === null && Component.defaultProps === void 0) {
                var resolvedType = type5;
                {
                  resolvedType = resolveFunctionForHotReloading(type5);
                }
                workInProgress2.tag = SimpleMemoComponent;
                workInProgress2.type = resolvedType;
                {
                  validateFunctionComponentInDev(workInProgress2, type5);
                }
                return updateSimpleMemoComponent(current2, workInProgress2, resolvedType, nextProps, updateLanes, renderLanes2);
              }
              {
                var innerPropTypes = type5.propTypes;
                if (innerPropTypes) {
                  checkPropTypes(
                    innerPropTypes,
                    nextProps,
                    "prop",
                    getComponentName(type5)
                  );
                }
              }
              var child = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress2, workInProgress2.mode, renderLanes2);
              child.ref = workInProgress2.ref;
              child.return = workInProgress2;
              workInProgress2.child = child;
              return child;
            }
            {
              var _type = Component.type;
              var _innerPropTypes = _type.propTypes;
              if (_innerPropTypes) {
                checkPropTypes(
                  _innerPropTypes,
                  nextProps,
                  "prop",
                  getComponentName(_type)
                );
              }
            }
            var currentChild = current2.child;
            if (!includesSomeLane(updateLanes, renderLanes2)) {
              var prevProps = currentChild.memoizedProps;
              var compare4 = Component.compare;
              compare4 = compare4 !== null ? compare4 : shallowEqual;
              if (compare4(prevProps, nextProps) && current2.ref === workInProgress2.ref) {
                return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
              }
            }
            workInProgress2.flags |= PerformedWork;
            var newChild = createWorkInProgress(currentChild, nextProps);
            newChild.ref = workInProgress2.ref;
            newChild.return = workInProgress2;
            workInProgress2.child = newChild;
            return newChild;
          }
          function updateSimpleMemoComponent(current2, workInProgress2, Component, nextProps, updateLanes, renderLanes2) {
            {
              if (workInProgress2.type !== workInProgress2.elementType) {
                var outerMemoType = workInProgress2.elementType;
                if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {
                  var lazyComponent = outerMemoType;
                  var payload = lazyComponent._payload;
                  var init2 = lazyComponent._init;
                  try {
                    outerMemoType = init2(payload);
                  } catch (x2) {
                    outerMemoType = null;
                  }
                  var outerPropTypes = outerMemoType && outerMemoType.propTypes;
                  if (outerPropTypes) {
                    checkPropTypes(
                      outerPropTypes,
                      nextProps,
                      "prop",
                      getComponentName(outerMemoType)
                    );
                  }
                }
              }
            }
            if (current2 !== null) {
              var prevProps = current2.memoizedProps;
              if (shallowEqual(prevProps, nextProps) && current2.ref === workInProgress2.ref && workInProgress2.type === current2.type) {
                didReceiveUpdate = false;
                if (!includesSomeLane(renderLanes2, updateLanes)) {
                  workInProgress2.lanes = current2.lanes;
                  return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                } else if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
                  didReceiveUpdate = true;
                }
              }
            }
            return updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2);
          }
          function updateOffscreenComponent(current2, workInProgress2, renderLanes2) {
            var nextProps = workInProgress2.pendingProps;
            var nextChildren = nextProps.children;
            var prevState = current2 !== null ? current2.memoizedState : null;
            if (nextProps.mode === "hidden" || nextProps.mode === "unstable-defer-without-hiding") {
              if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
                var nextState = {
                  baseLanes: NoLanes
                };
                workInProgress2.memoizedState = nextState;
                pushRenderLanes(workInProgress2, renderLanes2);
              } else if (!includesSomeLane(renderLanes2, OffscreenLane)) {
                var nextBaseLanes;
                if (prevState !== null) {
                  var prevBaseLanes = prevState.baseLanes;
                  nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes2);
                } else {
                  nextBaseLanes = renderLanes2;
                }
                {
                  markSpawnedWork(OffscreenLane);
                }
                workInProgress2.lanes = workInProgress2.childLanes = laneToLanes(OffscreenLane);
                var _nextState = {
                  baseLanes: nextBaseLanes
                };
                workInProgress2.memoizedState = _nextState;
                pushRenderLanes(workInProgress2, nextBaseLanes);
                return null;
              } else {
                var _nextState2 = {
                  baseLanes: NoLanes
                };
                workInProgress2.memoizedState = _nextState2;
                var subtreeRenderLanes2 = prevState !== null ? prevState.baseLanes : renderLanes2;
                pushRenderLanes(workInProgress2, subtreeRenderLanes2);
              }
            } else {
              var _subtreeRenderLanes;
              if (prevState !== null) {
                _subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes2);
                workInProgress2.memoizedState = null;
              } else {
                _subtreeRenderLanes = renderLanes2;
              }
              pushRenderLanes(workInProgress2, _subtreeRenderLanes);
            }
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          var updateLegacyHiddenComponent = updateOffscreenComponent;
          function updateFragment(current2, workInProgress2, renderLanes2) {
            var nextChildren = workInProgress2.pendingProps;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateMode(current2, workInProgress2, renderLanes2) {
            var nextChildren = workInProgress2.pendingProps.children;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateProfiler(current2, workInProgress2, renderLanes2) {
            {
              workInProgress2.flags |= Update;
              var stateNode = workInProgress2.stateNode;
              stateNode.effectDuration = 0;
              stateNode.passiveEffectDuration = 0;
            }
            var nextProps = workInProgress2.pendingProps;
            var nextChildren = nextProps.children;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function markRef(current2, workInProgress2) {
            var ref = workInProgress2.ref;
            if (current2 === null && ref !== null || current2 !== null && current2.ref !== ref) {
              workInProgress2.flags |= Ref;
            }
          }
          function updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
            {
              if (workInProgress2.type !== workInProgress2.elementType) {
                var innerPropTypes = Component.propTypes;
                if (innerPropTypes) {
                  checkPropTypes(
                    innerPropTypes,
                    nextProps,
                    "prop",
                    getComponentName(Component)
                  );
                }
              }
            }
            var context;
            {
              var unmaskedContext = getUnmaskedContext(workInProgress2, Component, true);
              context = getMaskedContext(workInProgress2, unmaskedContext);
            }
            var nextChildren;
            prepareToReadContext(workInProgress2, renderLanes2);
            {
              ReactCurrentOwner$1.current = workInProgress2;
              setIsRendering(true);
              nextChildren = renderWithHooks(current2, workInProgress2, Component, nextProps, context, renderLanes2);
              if (workInProgress2.mode & StrictMode) {
                disableLogs();
                try {
                  nextChildren = renderWithHooks(current2, workInProgress2, Component, nextProps, context, renderLanes2);
                } finally {
                  reenableLogs();
                }
              }
              setIsRendering(false);
            }
            if (current2 !== null && !didReceiveUpdate) {
              bailoutHooks(current2, workInProgress2, renderLanes2);
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            }
            workInProgress2.flags |= PerformedWork;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateClassComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
            {
              if (workInProgress2.type !== workInProgress2.elementType) {
                var innerPropTypes = Component.propTypes;
                if (innerPropTypes) {
                  checkPropTypes(
                    innerPropTypes,
                    nextProps,
                    "prop",
                    getComponentName(Component)
                  );
                }
              }
            }
            var hasContext;
            if (isContextProvider(Component)) {
              hasContext = true;
              pushContextProvider(workInProgress2);
            } else {
              hasContext = false;
            }
            prepareToReadContext(workInProgress2, renderLanes2);
            var instance2 = workInProgress2.stateNode;
            var shouldUpdate;
            if (instance2 === null) {
              if (current2 !== null) {
                current2.alternate = null;
                workInProgress2.alternate = null;
                workInProgress2.flags |= Placement;
              }
              constructClassInstance(workInProgress2, Component, nextProps);
              mountClassInstance(workInProgress2, Component, nextProps, renderLanes2);
              shouldUpdate = true;
            } else if (current2 === null) {
              shouldUpdate = resumeMountClassInstance(workInProgress2, Component, nextProps, renderLanes2);
            } else {
              shouldUpdate = updateClassInstance(current2, workInProgress2, Component, nextProps, renderLanes2);
            }
            var nextUnitOfWork = finishClassComponent(current2, workInProgress2, Component, shouldUpdate, hasContext, renderLanes2);
            {
              var inst = workInProgress2.stateNode;
              if (shouldUpdate && inst.props !== nextProps) {
                if (!didWarnAboutReassigningProps) {
                  error2("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentName(workInProgress2.type) || "a component");
                }
                didWarnAboutReassigningProps = true;
              }
            }
            return nextUnitOfWork;
          }
          function finishClassComponent(current2, workInProgress2, Component, shouldUpdate, hasContext, renderLanes2) {
            markRef(current2, workInProgress2);
            var didCaptureError = (workInProgress2.flags & DidCapture) !== NoFlags;
            if (!shouldUpdate && !didCaptureError) {
              if (hasContext) {
                invalidateContextProvider(workInProgress2, Component, false);
              }
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            }
            var instance2 = workInProgress2.stateNode;
            ReactCurrentOwner$1.current = workInProgress2;
            var nextChildren;
            if (didCaptureError && typeof Component.getDerivedStateFromError !== "function") {
              nextChildren = null;
              {
                stopProfilerTimerIfRunning();
              }
            } else {
              {
                setIsRendering(true);
                nextChildren = instance2.render();
                if (workInProgress2.mode & StrictMode) {
                  disableLogs();
                  try {
                    instance2.render();
                  } finally {
                    reenableLogs();
                  }
                }
                setIsRendering(false);
              }
            }
            workInProgress2.flags |= PerformedWork;
            if (current2 !== null && didCaptureError) {
              forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2);
            } else {
              reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            }
            workInProgress2.memoizedState = instance2.state;
            if (hasContext) {
              invalidateContextProvider(workInProgress2, Component, true);
            }
            return workInProgress2.child;
          }
          function pushHostRootContext(workInProgress2) {
            var root2 = workInProgress2.stateNode;
            if (root2.pendingContext) {
              pushTopLevelContextObject(workInProgress2, root2.pendingContext, root2.pendingContext !== root2.context);
            } else if (root2.context) {
              pushTopLevelContextObject(workInProgress2, root2.context, false);
            }
            pushHostContainer(workInProgress2, root2.containerInfo);
          }
          function updateHostRoot(current2, workInProgress2, renderLanes2) {
            pushHostRootContext(workInProgress2);
            var updateQueue = workInProgress2.updateQueue;
            if (!(current2 !== null && updateQueue !== null)) {
              {
                throw Error("If the root does not have an updateQueue, we should have already bailed out. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            var nextProps = workInProgress2.pendingProps;
            var prevState = workInProgress2.memoizedState;
            var prevChildren = prevState !== null ? prevState.element : null;
            cloneUpdateQueue(current2, workInProgress2);
            processUpdateQueue(workInProgress2, nextProps, null, renderLanes2);
            var nextState = workInProgress2.memoizedState;
            var nextChildren = nextState.element;
            if (nextChildren === prevChildren) {
              resetHydrationState();
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            }
            var root2 = workInProgress2.stateNode;
            if (root2.hydrate && enterHydrationState(workInProgress2)) {
              if (supportsHydration) {
                var mutableSourceEagerHydrationData = root2.mutableSourceEagerHydrationData;
                if (mutableSourceEagerHydrationData != null) {
                  for (var i = 0; i < mutableSourceEagerHydrationData.length; i += 2) {
                    var mutableSource = mutableSourceEagerHydrationData[i];
                    var version4 = mutableSourceEagerHydrationData[i + 1];
                    setWorkInProgressVersion(mutableSource, version4);
                  }
                }
              }
              var child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
              workInProgress2.child = child;
              var node = child;
              while (node) {
                node.flags = node.flags & ~Placement | Hydrating;
                node = node.sibling;
              }
            } else {
              reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
              resetHydrationState();
            }
            return workInProgress2.child;
          }
          function updateHostComponent(current2, workInProgress2, renderLanes2) {
            pushHostContext(workInProgress2);
            if (current2 === null) {
              tryToClaimNextHydratableInstance(workInProgress2);
            }
            var type5 = workInProgress2.type;
            var nextProps = workInProgress2.pendingProps;
            var prevProps = current2 !== null ? current2.memoizedProps : null;
            var nextChildren = nextProps.children;
            var isDirectTextChild = shouldSetTextContent(type5, nextProps);
            if (isDirectTextChild) {
              nextChildren = null;
            } else if (prevProps !== null && shouldSetTextContent(type5, prevProps)) {
              workInProgress2.flags |= ContentReset;
            }
            markRef(current2, workInProgress2);
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateHostText(current2, workInProgress2) {
            if (current2 === null) {
              tryToClaimNextHydratableInstance(workInProgress2);
            }
            return null;
          }
          function mountLazyComponent(_current, workInProgress2, elementType, updateLanes, renderLanes2) {
            if (_current !== null) {
              _current.alternate = null;
              workInProgress2.alternate = null;
              workInProgress2.flags |= Placement;
            }
            var props = workInProgress2.pendingProps;
            var lazyComponent = elementType;
            var payload = lazyComponent._payload;
            var init2 = lazyComponent._init;
            var Component = init2(payload);
            workInProgress2.type = Component;
            var resolvedTag = workInProgress2.tag = resolveLazyComponentTag(Component);
            var resolvedProps = resolveDefaultProps(Component, props);
            var child;
            switch (resolvedTag) {
              case FunctionComponent: {
                {
                  validateFunctionComponentInDev(workInProgress2, Component);
                  workInProgress2.type = Component = resolveFunctionForHotReloading(Component);
                }
                child = updateFunctionComponent(null, workInProgress2, Component, resolvedProps, renderLanes2);
                return child;
              }
              case ClassComponent: {
                {
                  workInProgress2.type = Component = resolveClassForHotReloading(Component);
                }
                child = updateClassComponent(null, workInProgress2, Component, resolvedProps, renderLanes2);
                return child;
              }
              case ForwardRef: {
                {
                  workInProgress2.type = Component = resolveForwardRefForHotReloading(Component);
                }
                child = updateForwardRef(null, workInProgress2, Component, resolvedProps, renderLanes2);
                return child;
              }
              case MemoComponent: {
                {
                  if (workInProgress2.type !== workInProgress2.elementType) {
                    var outerPropTypes = Component.propTypes;
                    if (outerPropTypes) {
                      checkPropTypes(
                        outerPropTypes,
                        resolvedProps,
                        "prop",
                        getComponentName(Component)
                      );
                    }
                  }
                }
                child = updateMemoComponent(
                  null,
                  workInProgress2,
                  Component,
                  resolveDefaultProps(Component.type, resolvedProps),
                  updateLanes,
                  renderLanes2
                );
                return child;
              }
            }
            var hint = "";
            {
              if (Component !== null && typeof Component === "object" && Component.$$typeof === REACT_LAZY_TYPE) {
                hint = " Did you wrap a component in React.lazy() more than once?";
              }
            }
            {
              {
                throw Error("Element type is invalid. Received a promise that resolves to: " + Component + ". Lazy element type must resolve to a class or function." + hint);
              }
            }
          }
          function mountIncompleteClassComponent(_current, workInProgress2, Component, nextProps, renderLanes2) {
            if (_current !== null) {
              _current.alternate = null;
              workInProgress2.alternate = null;
              workInProgress2.flags |= Placement;
            }
            workInProgress2.tag = ClassComponent;
            var hasContext;
            if (isContextProvider(Component)) {
              hasContext = true;
              pushContextProvider(workInProgress2);
            } else {
              hasContext = false;
            }
            prepareToReadContext(workInProgress2, renderLanes2);
            constructClassInstance(workInProgress2, Component, nextProps);
            mountClassInstance(workInProgress2, Component, nextProps, renderLanes2);
            return finishClassComponent(null, workInProgress2, Component, true, hasContext, renderLanes2);
          }
          function mountIndeterminateComponent(_current, workInProgress2, Component, renderLanes2) {
            if (_current !== null) {
              _current.alternate = null;
              workInProgress2.alternate = null;
              workInProgress2.flags |= Placement;
            }
            var props = workInProgress2.pendingProps;
            var context;
            {
              var unmaskedContext = getUnmaskedContext(workInProgress2, Component, false);
              context = getMaskedContext(workInProgress2, unmaskedContext);
            }
            prepareToReadContext(workInProgress2, renderLanes2);
            var value;
            {
              if (Component.prototype && typeof Component.prototype.render === "function") {
                var componentName = getComponentName(Component) || "Unknown";
                if (!didWarnAboutBadClass[componentName]) {
                  error2("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
                  didWarnAboutBadClass[componentName] = true;
                }
              }
              if (workInProgress2.mode & StrictMode) {
                ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, null);
              }
              setIsRendering(true);
              ReactCurrentOwner$1.current = workInProgress2;
              value = renderWithHooks(null, workInProgress2, Component, props, context, renderLanes2);
              setIsRendering(false);
            }
            workInProgress2.flags |= PerformedWork;
            {
              if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0) {
                var _componentName = getComponentName(Component) || "Unknown";
                if (!didWarnAboutModulePatternComponent[_componentName]) {
                  error2("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName);
                  didWarnAboutModulePatternComponent[_componentName] = true;
                }
              }
            }
            if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0) {
              {
                var _componentName2 = getComponentName(Component) || "Unknown";
                if (!didWarnAboutModulePatternComponent[_componentName2]) {
                  error2("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
                  didWarnAboutModulePatternComponent[_componentName2] = true;
                }
              }
              workInProgress2.tag = ClassComponent;
              workInProgress2.memoizedState = null;
              workInProgress2.updateQueue = null;
              var hasContext = false;
              if (isContextProvider(Component)) {
                hasContext = true;
                pushContextProvider(workInProgress2);
              } else {
                hasContext = false;
              }
              workInProgress2.memoizedState = value.state !== null && value.state !== void 0 ? value.state : null;
              initializeUpdateQueue(workInProgress2);
              var getDerivedStateFromProps = Component.getDerivedStateFromProps;
              if (typeof getDerivedStateFromProps === "function") {
                applyDerivedStateFromProps(workInProgress2, Component, getDerivedStateFromProps, props);
              }
              adoptClassInstance(workInProgress2, value);
              mountClassInstance(workInProgress2, Component, props, renderLanes2);
              return finishClassComponent(null, workInProgress2, Component, true, hasContext, renderLanes2);
            } else {
              workInProgress2.tag = FunctionComponent;
              {
                if (workInProgress2.mode & StrictMode) {
                  disableLogs();
                  try {
                    value = renderWithHooks(null, workInProgress2, Component, props, context, renderLanes2);
                  } finally {
                    reenableLogs();
                  }
                }
              }
              reconcileChildren(null, workInProgress2, value, renderLanes2);
              {
                validateFunctionComponentInDev(workInProgress2, Component);
              }
              return workInProgress2.child;
            }
          }
          function validateFunctionComponentInDev(workInProgress2, Component) {
            {
              if (Component) {
                if (Component.childContextTypes) {
                  error2("%s(...): childContextTypes cannot be defined on a function component.", Component.displayName || Component.name || "Component");
                }
              }
              if (workInProgress2.ref !== null) {
                var info = "";
                var ownerName = getCurrentFiberOwnerNameInDevOrNull();
                if (ownerName) {
                  info += "\n\nCheck the render method of `" + ownerName + "`.";
                }
                var warningKey = ownerName || workInProgress2._debugID || "";
                var debugSource = workInProgress2._debugSource;
                if (debugSource) {
                  warningKey = debugSource.fileName + ":" + debugSource.lineNumber;
                }
                if (!didWarnAboutFunctionRefs[warningKey]) {
                  didWarnAboutFunctionRefs[warningKey] = true;
                  error2("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", info);
                }
              }
              if (typeof Component.getDerivedStateFromProps === "function") {
                var _componentName3 = getComponentName(Component) || "Unknown";
                if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
                  error2("%s: Function components do not support getDerivedStateFromProps.", _componentName3);
                  didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
                }
              }
              if (typeof Component.contextType === "object" && Component.contextType !== null) {
                var _componentName4 = getComponentName(Component) || "Unknown";
                if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
                  error2("%s: Function components do not support contextType.", _componentName4);
                  didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
                }
              }
            }
          }
          var SUSPENDED_MARKER = {
            dehydrated: null,
            retryLane: NoLane
          };
          function mountSuspenseOffscreenState(renderLanes2) {
            return {
              baseLanes: renderLanes2
            };
          }
          function updateSuspenseOffscreenState(prevOffscreenState, renderLanes2) {
            return {
              baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes2)
            };
          }
          function shouldRemainOnFallback(suspenseContext, current2, workInProgress2, renderLanes2) {
            if (current2 !== null) {
              var suspenseState = current2.memoizedState;
              if (suspenseState === null) {
                return false;
              }
            }
            return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
          }
          function getRemainingWorkInPrimaryTree(current2, renderLanes2) {
            return removeLanes(current2.childLanes, renderLanes2);
          }
          function updateSuspenseComponent(current2, workInProgress2, renderLanes2) {
            var nextProps = workInProgress2.pendingProps;
            {
              if (shouldSuspend(workInProgress2)) {
                workInProgress2.flags |= DidCapture;
              }
            }
            var suspenseContext = suspenseStackCursor.current;
            var showFallback = false;
            var didSuspend = (workInProgress2.flags & DidCapture) !== NoFlags;
            if (didSuspend || shouldRemainOnFallback(suspenseContext, current2)) {
              showFallback = true;
              workInProgress2.flags &= ~DidCapture;
            } else {
              if (current2 === null || current2.memoizedState !== null) {
                if (nextProps.fallback !== void 0 && nextProps.unstable_avoidThisFallback !== true) {
                  suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);
                }
              }
            }
            suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
            pushSuspenseContext(workInProgress2, suspenseContext);
            if (current2 === null) {
              if (nextProps.fallback !== void 0) {
                tryToClaimNextHydratableInstance(workInProgress2);
              }
              var nextPrimaryChildren = nextProps.children;
              var nextFallbackChildren = nextProps.fallback;
              if (showFallback) {
                var fallbackFragment = mountSuspenseFallbackChildren(workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);
                var primaryChildFragment = workInProgress2.child;
                primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes2);
                workInProgress2.memoizedState = SUSPENDED_MARKER;
                return fallbackFragment;
              } else if (typeof nextProps.unstable_expectedLoadTime === "number") {
                var _fallbackFragment = mountSuspenseFallbackChildren(workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);
                var _primaryChildFragment = workInProgress2.child;
                _primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes2);
                workInProgress2.memoizedState = SUSPENDED_MARKER;
                workInProgress2.lanes = SomeRetryLane;
                {
                  markSpawnedWork(SomeRetryLane);
                }
                return _fallbackFragment;
              } else {
                return mountSuspensePrimaryChildren(workInProgress2, nextPrimaryChildren, renderLanes2);
              }
            } else {
              var prevState = current2.memoizedState;
              if (prevState !== null) {
                if (showFallback) {
                  var _nextFallbackChildren2 = nextProps.fallback;
                  var _nextPrimaryChildren2 = nextProps.children;
                  var _fallbackChildFragment = updateSuspenseFallbackChildren(current2, workInProgress2, _nextPrimaryChildren2, _nextFallbackChildren2, renderLanes2);
                  var _primaryChildFragment3 = workInProgress2.child;
                  var prevOffscreenState = current2.child.memoizedState;
                  _primaryChildFragment3.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes2) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes2);
                  _primaryChildFragment3.childLanes = getRemainingWorkInPrimaryTree(current2, renderLanes2);
                  workInProgress2.memoizedState = SUSPENDED_MARKER;
                  return _fallbackChildFragment;
                } else {
                  var _nextPrimaryChildren3 = nextProps.children;
                  var _primaryChildFragment4 = updateSuspensePrimaryChildren(current2, workInProgress2, _nextPrimaryChildren3, renderLanes2);
                  workInProgress2.memoizedState = null;
                  return _primaryChildFragment4;
                }
              } else {
                if (showFallback) {
                  var _nextFallbackChildren3 = nextProps.fallback;
                  var _nextPrimaryChildren4 = nextProps.children;
                  var _fallbackChildFragment2 = updateSuspenseFallbackChildren(current2, workInProgress2, _nextPrimaryChildren4, _nextFallbackChildren3, renderLanes2);
                  var _primaryChildFragment5 = workInProgress2.child;
                  var _prevOffscreenState = current2.child.memoizedState;
                  _primaryChildFragment5.memoizedState = _prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes2) : updateSuspenseOffscreenState(_prevOffscreenState, renderLanes2);
                  _primaryChildFragment5.childLanes = getRemainingWorkInPrimaryTree(current2, renderLanes2);
                  workInProgress2.memoizedState = SUSPENDED_MARKER;
                  return _fallbackChildFragment2;
                } else {
                  var _nextPrimaryChildren5 = nextProps.children;
                  var _primaryChildFragment6 = updateSuspensePrimaryChildren(current2, workInProgress2, _nextPrimaryChildren5, renderLanes2);
                  workInProgress2.memoizedState = null;
                  return _primaryChildFragment6;
                }
              }
            }
          }
          function mountSuspensePrimaryChildren(workInProgress2, primaryChildren, renderLanes2) {
            var mode = workInProgress2.mode;
            var primaryChildProps = {
              mode: "visible",
              children: primaryChildren
            };
            var primaryChildFragment = createFiberFromOffscreen(primaryChildProps, mode, renderLanes2, null);
            primaryChildFragment.return = workInProgress2;
            workInProgress2.child = primaryChildFragment;
            return primaryChildFragment;
          }
          function mountSuspenseFallbackChildren(workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
            var mode = workInProgress2.mode;
            var progressedPrimaryFragment = workInProgress2.child;
            var primaryChildProps = {
              mode: "hidden",
              children: primaryChildren
            };
            var primaryChildFragment;
            var fallbackChildFragment;
            if ((mode & BlockingMode) === NoMode && progressedPrimaryFragment !== null) {
              primaryChildFragment = progressedPrimaryFragment;
              primaryChildFragment.childLanes = NoLanes;
              primaryChildFragment.pendingProps = primaryChildProps;
              if (workInProgress2.mode & ProfileMode) {
                primaryChildFragment.actualDuration = 0;
                primaryChildFragment.actualStartTime = -1;
                primaryChildFragment.selfBaseDuration = 0;
                primaryChildFragment.treeBaseDuration = 0;
              }
              fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
            } else {
              primaryChildFragment = createFiberFromOffscreen(primaryChildProps, mode, NoLanes, null);
              fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
            }
            primaryChildFragment.return = workInProgress2;
            fallbackChildFragment.return = workInProgress2;
            primaryChildFragment.sibling = fallbackChildFragment;
            workInProgress2.child = primaryChildFragment;
            return fallbackChildFragment;
          }
          function createWorkInProgressOffscreenFiber(current2, offscreenProps) {
            return createWorkInProgress(current2, offscreenProps);
          }
          function updateSuspensePrimaryChildren(current2, workInProgress2, primaryChildren, renderLanes2) {
            var currentPrimaryChildFragment = current2.child;
            var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
            var primaryChildFragment = createWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {
              mode: "visible",
              children: primaryChildren
            });
            if ((workInProgress2.mode & BlockingMode) === NoMode) {
              primaryChildFragment.lanes = renderLanes2;
            }
            primaryChildFragment.return = workInProgress2;
            primaryChildFragment.sibling = null;
            if (currentFallbackChildFragment !== null) {
              currentFallbackChildFragment.nextEffect = null;
              currentFallbackChildFragment.flags = Deletion;
              workInProgress2.firstEffect = workInProgress2.lastEffect = currentFallbackChildFragment;
            }
            workInProgress2.child = primaryChildFragment;
            return primaryChildFragment;
          }
          function updateSuspenseFallbackChildren(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
            var mode = workInProgress2.mode;
            var currentPrimaryChildFragment = current2.child;
            var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
            var primaryChildProps = {
              mode: "hidden",
              children: primaryChildren
            };
            var primaryChildFragment;
            if ((mode & BlockingMode) === NoMode && workInProgress2.child !== currentPrimaryChildFragment) {
              var progressedPrimaryFragment = workInProgress2.child;
              primaryChildFragment = progressedPrimaryFragment;
              primaryChildFragment.childLanes = NoLanes;
              primaryChildFragment.pendingProps = primaryChildProps;
              if (workInProgress2.mode & ProfileMode) {
                primaryChildFragment.actualDuration = 0;
                primaryChildFragment.actualStartTime = -1;
                primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration;
                primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration;
              }
              var progressedLastEffect = primaryChildFragment.lastEffect;
              if (progressedLastEffect !== null) {
                workInProgress2.firstEffect = primaryChildFragment.firstEffect;
                workInProgress2.lastEffect = progressedLastEffect;
                progressedLastEffect.nextEffect = null;
              } else {
                workInProgress2.firstEffect = workInProgress2.lastEffect = null;
              }
            } else {
              primaryChildFragment = createWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps);
            }
            var fallbackChildFragment;
            if (currentFallbackChildFragment !== null) {
              fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);
            } else {
              fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
              fallbackChildFragment.flags |= Placement;
            }
            fallbackChildFragment.return = workInProgress2;
            primaryChildFragment.return = workInProgress2;
            primaryChildFragment.sibling = fallbackChildFragment;
            workInProgress2.child = primaryChildFragment;
            return fallbackChildFragment;
          }
          function scheduleWorkOnFiber(fiber, renderLanes2) {
            fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
            var alternate = fiber.alternate;
            if (alternate !== null) {
              alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
            }
            scheduleWorkOnParentPath(fiber.return, renderLanes2);
          }
          function propagateSuspenseContextChange(workInProgress2, firstChild, renderLanes2) {
            var node = firstChild;
            while (node !== null) {
              if (node.tag === SuspenseComponent) {
                var state = node.memoizedState;
                if (state !== null) {
                  scheduleWorkOnFiber(node, renderLanes2);
                }
              } else if (node.tag === SuspenseListComponent) {
                scheduleWorkOnFiber(node, renderLanes2);
              } else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === workInProgress2) {
                return;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === workInProgress2) {
                  return;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
          }
          function findLastContentRow(firstChild) {
            var row = firstChild;
            var lastContentRow = null;
            while (row !== null) {
              var currentRow = row.alternate;
              if (currentRow !== null && findFirstSuspended(currentRow) === null) {
                lastContentRow = row;
              }
              row = row.sibling;
            }
            return lastContentRow;
          }
          function validateRevealOrder(revealOrder) {
            {
              if (revealOrder !== void 0 && revealOrder !== "forwards" && revealOrder !== "backwards" && revealOrder !== "together" && !didWarnAboutRevealOrder[revealOrder]) {
                didWarnAboutRevealOrder[revealOrder] = true;
                if (typeof revealOrder === "string") {
                  switch (revealOrder.toLowerCase()) {
                    case "together":
                    case "forwards":
                    case "backwards": {
                      error2('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', revealOrder, revealOrder.toLowerCase());
                      break;
                    }
                    case "forward":
                    case "backward": {
                      error2('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', revealOrder, revealOrder.toLowerCase());
                      break;
                    }
                    default:
                      error2('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
                      break;
                  }
                } else {
                  error2('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
                }
              }
            }
          }
          function validateTailOptions(tailMode, revealOrder) {
            {
              if (tailMode !== void 0 && !didWarnAboutTailOptions[tailMode]) {
                if (tailMode !== "collapsed" && tailMode !== "hidden") {
                  didWarnAboutTailOptions[tailMode] = true;
                  error2('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', tailMode);
                } else if (revealOrder !== "forwards" && revealOrder !== "backwards") {
                  didWarnAboutTailOptions[tailMode] = true;
                  error2('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', tailMode);
                }
              }
            }
          }
          function validateSuspenseListNestedChild(childSlot, index2) {
            {
              var isArray3 = Array.isArray(childSlot);
              var isIterable4 = !isArray3 && typeof getIteratorFn(childSlot) === "function";
              if (isArray3 || isIterable4) {
                var type5 = isArray3 ? "array" : "iterable";
                error2("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", type5, index2, type5);
                return false;
              }
            }
            return true;
          }
          function validateSuspenseListChildren(children, revealOrder) {
            {
              if ((revealOrder === "forwards" || revealOrder === "backwards") && children !== void 0 && children !== null && children !== false) {
                if (Array.isArray(children)) {
                  for (var i = 0; i < children.length; i++) {
                    if (!validateSuspenseListNestedChild(children[i], i)) {
                      return;
                    }
                  }
                } else {
                  var iteratorFn = getIteratorFn(children);
                  if (typeof iteratorFn === "function") {
                    var childrenIterator = iteratorFn.call(children);
                    if (childrenIterator) {
                      var step = childrenIterator.next();
                      var _i = 0;
                      for (; !step.done; step = childrenIterator.next()) {
                        if (!validateSuspenseListNestedChild(step.value, _i)) {
                          return;
                        }
                        _i++;
                      }
                    }
                  } else {
                    error2('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', revealOrder);
                  }
                }
              }
            }
          }
          function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode, lastEffectBeforeRendering) {
            var renderState = workInProgress2.memoizedState;
            if (renderState === null) {
              workInProgress2.memoizedState = {
                isBackwards,
                rendering: null,
                renderingStartTime: 0,
                last: lastContentRow,
                tail,
                tailMode,
                lastEffect: lastEffectBeforeRendering
              };
            } else {
              renderState.isBackwards = isBackwards;
              renderState.rendering = null;
              renderState.renderingStartTime = 0;
              renderState.last = lastContentRow;
              renderState.tail = tail;
              renderState.tailMode = tailMode;
              renderState.lastEffect = lastEffectBeforeRendering;
            }
          }
          function updateSuspenseListComponent(current2, workInProgress2, renderLanes2) {
            var nextProps = workInProgress2.pendingProps;
            var revealOrder = nextProps.revealOrder;
            var tailMode = nextProps.tail;
            var newChildren = nextProps.children;
            validateRevealOrder(revealOrder);
            validateTailOptions(tailMode, revealOrder);
            validateSuspenseListChildren(newChildren, revealOrder);
            reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
            var suspenseContext = suspenseStackCursor.current;
            var shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
            if (shouldForceFallback) {
              suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
              workInProgress2.flags |= DidCapture;
            } else {
              var didSuspendBefore = current2 !== null && (current2.flags & DidCapture) !== NoFlags;
              if (didSuspendBefore) {
                propagateSuspenseContextChange(workInProgress2, workInProgress2.child, renderLanes2);
              }
              suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
            }
            pushSuspenseContext(workInProgress2, suspenseContext);
            if ((workInProgress2.mode & BlockingMode) === NoMode) {
              workInProgress2.memoizedState = null;
            } else {
              switch (revealOrder) {
                case "forwards": {
                  var lastContentRow = findLastContentRow(workInProgress2.child);
                  var tail;
                  if (lastContentRow === null) {
                    tail = workInProgress2.child;
                    workInProgress2.child = null;
                  } else {
                    tail = lastContentRow.sibling;
                    lastContentRow.sibling = null;
                  }
                  initSuspenseListRenderState(
                    workInProgress2,
                    false,
                    tail,
                    lastContentRow,
                    tailMode,
                    workInProgress2.lastEffect
                  );
                  break;
                }
                case "backwards": {
                  var _tail = null;
                  var row = workInProgress2.child;
                  workInProgress2.child = null;
                  while (row !== null) {
                    var currentRow = row.alternate;
                    if (currentRow !== null && findFirstSuspended(currentRow) === null) {
                      workInProgress2.child = row;
                      break;
                    }
                    var nextRow = row.sibling;
                    row.sibling = _tail;
                    _tail = row;
                    row = nextRow;
                  }
                  initSuspenseListRenderState(
                    workInProgress2,
                    true,
                    _tail,
                    null,
                    tailMode,
                    workInProgress2.lastEffect
                  );
                  break;
                }
                case "together": {
                  initSuspenseListRenderState(
                    workInProgress2,
                    false,
                    null,
                    null,
                    void 0,
                    workInProgress2.lastEffect
                  );
                  break;
                }
                default: {
                  workInProgress2.memoizedState = null;
                }
              }
            }
            return workInProgress2.child;
          }
          function updatePortalComponent(current2, workInProgress2, renderLanes2) {
            pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
            var nextChildren = workInProgress2.pendingProps;
            if (current2 === null) {
              workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
            } else {
              reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            }
            return workInProgress2.child;
          }
          var hasWarnedAboutUsingNoValuePropOnContextProvider = false;
          function updateContextProvider(current2, workInProgress2, renderLanes2) {
            var providerType = workInProgress2.type;
            var context = providerType._context;
            var newProps = workInProgress2.pendingProps;
            var oldProps = workInProgress2.memoizedProps;
            var newValue = newProps.value;
            {
              if (!("value" in newProps)) {
                if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {
                  hasWarnedAboutUsingNoValuePropOnContextProvider = true;
                  error2("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?");
                }
              }
              var providerPropTypes = workInProgress2.type.propTypes;
              if (providerPropTypes) {
                checkPropTypes(providerPropTypes, newProps, "prop", "Context.Provider");
              }
            }
            pushProvider(workInProgress2, newValue);
            if (oldProps !== null) {
              var oldValue = oldProps.value;
              var changedBits = calculateChangedBits(context, newValue, oldValue);
              if (changedBits === 0) {
                if (oldProps.children === newProps.children && !hasContextChanged()) {
                  return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                }
              } else {
                propagateContextChange(workInProgress2, context, changedBits, renderLanes2);
              }
            }
            var newChildren = newProps.children;
            reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
            return workInProgress2.child;
          }
          var hasWarnedAboutUsingContextAsConsumer = false;
          function updateContextConsumer(current2, workInProgress2, renderLanes2) {
            var context = workInProgress2.type;
            {
              if (context._context === void 0) {
                if (context !== context.Consumer) {
                  if (!hasWarnedAboutUsingContextAsConsumer) {
                    hasWarnedAboutUsingContextAsConsumer = true;
                    error2("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                  }
                }
              } else {
                context = context._context;
              }
            }
            var newProps = workInProgress2.pendingProps;
            var render = newProps.children;
            {
              if (typeof render !== "function") {
                error2("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
              }
            }
            prepareToReadContext(workInProgress2, renderLanes2);
            var newValue = readContext(context, newProps.unstable_observedBits);
            var newChildren;
            {
              ReactCurrentOwner$1.current = workInProgress2;
              setIsRendering(true);
              newChildren = render(newValue);
              setIsRendering(false);
            }
            workInProgress2.flags |= PerformedWork;
            reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
            return workInProgress2.child;
          }
          function markWorkInProgressReceivedUpdate() {
            didReceiveUpdate = true;
          }
          function bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2) {
            if (current2 !== null) {
              workInProgress2.dependencies = current2.dependencies;
            }
            {
              stopProfilerTimerIfRunning();
            }
            markSkippedUpdateLanes(workInProgress2.lanes);
            if (!includesSomeLane(renderLanes2, workInProgress2.childLanes)) {
              return null;
            } else {
              cloneChildFibers(current2, workInProgress2);
              return workInProgress2.child;
            }
          }
          function remountFiber(current2, oldWorkInProgress, newWorkInProgress) {
            {
              var returnFiber = oldWorkInProgress.return;
              if (returnFiber === null) {
                throw new Error("Cannot swap the root fiber.");
              }
              current2.alternate = null;
              oldWorkInProgress.alternate = null;
              newWorkInProgress.index = oldWorkInProgress.index;
              newWorkInProgress.sibling = oldWorkInProgress.sibling;
              newWorkInProgress.return = oldWorkInProgress.return;
              newWorkInProgress.ref = oldWorkInProgress.ref;
              if (oldWorkInProgress === returnFiber.child) {
                returnFiber.child = newWorkInProgress;
              } else {
                var prevSibling = returnFiber.child;
                if (prevSibling === null) {
                  throw new Error("Expected parent to have a child.");
                }
                while (prevSibling.sibling !== oldWorkInProgress) {
                  prevSibling = prevSibling.sibling;
                  if (prevSibling === null) {
                    throw new Error("Expected to find the previous sibling.");
                  }
                }
                prevSibling.sibling = newWorkInProgress;
              }
              var last = returnFiber.lastEffect;
              if (last !== null) {
                last.nextEffect = current2;
                returnFiber.lastEffect = current2;
              } else {
                returnFiber.firstEffect = returnFiber.lastEffect = current2;
              }
              current2.nextEffect = null;
              current2.flags = Deletion;
              newWorkInProgress.flags |= Placement;
              return newWorkInProgress;
            }
          }
          function beginWork(current2, workInProgress2, renderLanes2) {
            var updateLanes = workInProgress2.lanes;
            {
              if (workInProgress2._debugNeedsRemount && current2 !== null) {
                return remountFiber(current2, workInProgress2, createFiberFromTypeAndProps(workInProgress2.type, workInProgress2.key, workInProgress2.pendingProps, workInProgress2._debugOwner || null, workInProgress2.mode, workInProgress2.lanes));
              }
            }
            if (current2 !== null) {
              var oldProps = current2.memoizedProps;
              var newProps = workInProgress2.pendingProps;
              if (oldProps !== newProps || hasContextChanged() || workInProgress2.type !== current2.type) {
                didReceiveUpdate = true;
              } else if (!includesSomeLane(renderLanes2, updateLanes)) {
                didReceiveUpdate = false;
                switch (workInProgress2.tag) {
                  case HostRoot:
                    pushHostRootContext(workInProgress2);
                    resetHydrationState();
                    break;
                  case HostComponent:
                    pushHostContext(workInProgress2);
                    break;
                  case ClassComponent: {
                    var Component = workInProgress2.type;
                    if (isContextProvider(Component)) {
                      pushContextProvider(workInProgress2);
                    }
                    break;
                  }
                  case HostPortal:
                    pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
                    break;
                  case ContextProvider: {
                    var newValue = workInProgress2.memoizedProps.value;
                    pushProvider(workInProgress2, newValue);
                    break;
                  }
                  case Profiler:
                    {
                      var hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
                      if (hasChildWork) {
                        workInProgress2.flags |= Update;
                      }
                      var stateNode = workInProgress2.stateNode;
                      stateNode.effectDuration = 0;
                      stateNode.passiveEffectDuration = 0;
                    }
                    break;
                  case SuspenseComponent: {
                    var state = workInProgress2.memoizedState;
                    if (state !== null) {
                      var primaryChildFragment = workInProgress2.child;
                      var primaryChildLanes = primaryChildFragment.childLanes;
                      if (includesSomeLane(renderLanes2, primaryChildLanes)) {
                        return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
                      } else {
                        pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                        var child = bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                        if (child !== null) {
                          return child.sibling;
                        } else {
                          return null;
                        }
                      }
                    } else {
                      pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                    }
                    break;
                  }
                  case SuspenseListComponent: {
                    var didSuspendBefore = (current2.flags & DidCapture) !== NoFlags;
                    var _hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
                    if (didSuspendBefore) {
                      if (_hasChildWork) {
                        return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
                      }
                      workInProgress2.flags |= DidCapture;
                    }
                    var renderState = workInProgress2.memoizedState;
                    if (renderState !== null) {
                      renderState.rendering = null;
                      renderState.tail = null;
                      renderState.lastEffect = null;
                    }
                    pushSuspenseContext(workInProgress2, suspenseStackCursor.current);
                    if (_hasChildWork) {
                      break;
                    } else {
                      return null;
                    }
                  }
                  case OffscreenComponent:
                  case LegacyHiddenComponent: {
                    workInProgress2.lanes = NoLanes;
                    return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
                  }
                }
                return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
              } else {
                if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
                  didReceiveUpdate = true;
                } else {
                  didReceiveUpdate = false;
                }
              }
            } else {
              didReceiveUpdate = false;
            }
            workInProgress2.lanes = NoLanes;
            switch (workInProgress2.tag) {
              case IndeterminateComponent: {
                return mountIndeterminateComponent(current2, workInProgress2, workInProgress2.type, renderLanes2);
              }
              case LazyComponent: {
                var elementType = workInProgress2.elementType;
                return mountLazyComponent(current2, workInProgress2, elementType, updateLanes, renderLanes2);
              }
              case FunctionComponent: {
                var _Component = workInProgress2.type;
                var unresolvedProps = workInProgress2.pendingProps;
                var resolvedProps = workInProgress2.elementType === _Component ? unresolvedProps : resolveDefaultProps(_Component, unresolvedProps);
                return updateFunctionComponent(current2, workInProgress2, _Component, resolvedProps, renderLanes2);
              }
              case ClassComponent: {
                var _Component2 = workInProgress2.type;
                var _unresolvedProps = workInProgress2.pendingProps;
                var _resolvedProps = workInProgress2.elementType === _Component2 ? _unresolvedProps : resolveDefaultProps(_Component2, _unresolvedProps);
                return updateClassComponent(current2, workInProgress2, _Component2, _resolvedProps, renderLanes2);
              }
              case HostRoot:
                return updateHostRoot(current2, workInProgress2, renderLanes2);
              case HostComponent:
                return updateHostComponent(current2, workInProgress2, renderLanes2);
              case HostText:
                return updateHostText(current2, workInProgress2);
              case SuspenseComponent:
                return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
              case HostPortal:
                return updatePortalComponent(current2, workInProgress2, renderLanes2);
              case ForwardRef: {
                var type5 = workInProgress2.type;
                var _unresolvedProps2 = workInProgress2.pendingProps;
                var _resolvedProps2 = workInProgress2.elementType === type5 ? _unresolvedProps2 : resolveDefaultProps(type5, _unresolvedProps2);
                return updateForwardRef(current2, workInProgress2, type5, _resolvedProps2, renderLanes2);
              }
              case Fragment:
                return updateFragment(current2, workInProgress2, renderLanes2);
              case Mode:
                return updateMode(current2, workInProgress2, renderLanes2);
              case Profiler:
                return updateProfiler(current2, workInProgress2, renderLanes2);
              case ContextProvider:
                return updateContextProvider(current2, workInProgress2, renderLanes2);
              case ContextConsumer:
                return updateContextConsumer(current2, workInProgress2, renderLanes2);
              case MemoComponent: {
                var _type2 = workInProgress2.type;
                var _unresolvedProps3 = workInProgress2.pendingProps;
                var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);
                {
                  if (workInProgress2.type !== workInProgress2.elementType) {
                    var outerPropTypes = _type2.propTypes;
                    if (outerPropTypes) {
                      checkPropTypes(
                        outerPropTypes,
                        _resolvedProps3,
                        "prop",
                        getComponentName(_type2)
                      );
                    }
                  }
                }
                _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);
                return updateMemoComponent(current2, workInProgress2, _type2, _resolvedProps3, updateLanes, renderLanes2);
              }
              case SimpleMemoComponent: {
                return updateSimpleMemoComponent(current2, workInProgress2, workInProgress2.type, workInProgress2.pendingProps, updateLanes, renderLanes2);
              }
              case IncompleteClassComponent: {
                var _Component3 = workInProgress2.type;
                var _unresolvedProps4 = workInProgress2.pendingProps;
                var _resolvedProps4 = workInProgress2.elementType === _Component3 ? _unresolvedProps4 : resolveDefaultProps(_Component3, _unresolvedProps4);
                return mountIncompleteClassComponent(current2, workInProgress2, _Component3, _resolvedProps4, renderLanes2);
              }
              case SuspenseListComponent: {
                return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
              }
              case FundamentalComponent: {
                break;
              }
              case ScopeComponent: {
                break;
              }
              case Block: {
                break;
              }
              case OffscreenComponent: {
                return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
              }
              case LegacyHiddenComponent: {
                return updateLegacyHiddenComponent(current2, workInProgress2, renderLanes2);
              }
            }
            {
              {
                throw Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
              }
            }
          }
          function markUpdate(workInProgress2) {
            workInProgress2.flags |= Update;
          }
          function markRef$1(workInProgress2) {
            workInProgress2.flags |= Ref;
          }
          var appendAllChildren;
          var updateHostContainer;
          var updateHostComponent$1;
          var updateHostText$1;
          if (supportsMutation) {
            appendAllChildren = function(parent, workInProgress2, needsVisibilityToggle, isHidden) {
              var node = workInProgress2.child;
              while (node !== null) {
                if (node.tag === HostComponent || node.tag === HostText) {
                  appendInitialChild(parent, node.stateNode);
                } else if (node.tag === HostPortal)
                  ;
                else if (node.child !== null) {
                  node.child.return = node;
                  node = node.child;
                  continue;
                }
                if (node === workInProgress2) {
                  return;
                }
                while (node.sibling === null) {
                  if (node.return === null || node.return === workInProgress2) {
                    return;
                  }
                  node = node.return;
                }
                node.sibling.return = node.return;
                node = node.sibling;
              }
            };
            updateHostContainer = function(workInProgress2) {
            };
            updateHostComponent$1 = function(current2, workInProgress2, type5, newProps, rootContainerInstance) {
              var oldProps = current2.memoizedProps;
              if (oldProps === newProps) {
                return;
              }
              var instance2 = workInProgress2.stateNode;
              var currentHostContext = getHostContext();
              var updatePayload = prepareUpdate(instance2, type5, oldProps, newProps, rootContainerInstance, currentHostContext);
              workInProgress2.updateQueue = updatePayload;
              if (updatePayload) {
                markUpdate(workInProgress2);
              }
            };
            updateHostText$1 = function(current2, workInProgress2, oldText, newText) {
              if (oldText !== newText) {
                markUpdate(workInProgress2);
              }
            };
          } else if (supportsPersistence) {
            appendAllChildren = function(parent, workInProgress2, needsVisibilityToggle, isHidden) {
              var node = workInProgress2.child;
              while (node !== null) {
                if (node.tag === HostComponent) {
                  var instance2 = node.stateNode;
                  if (needsVisibilityToggle && isHidden) {
                    var props = node.memoizedProps;
                    var type5 = node.type;
                    instance2 = cloneHiddenInstance(instance2, type5, props, node);
                  }
                  appendInitialChild(parent, instance2);
                } else if (node.tag === HostText) {
                  var _instance = node.stateNode;
                  if (needsVisibilityToggle && isHidden) {
                    var text = node.memoizedProps;
                    _instance = cloneHiddenTextInstance(_instance, text, node);
                  }
                  appendInitialChild(parent, _instance);
                } else if (node.tag === HostPortal)
                  ;
                else if (node.tag === SuspenseComponent) {
                  if ((node.flags & Update) !== NoFlags) {
                    var newIsHidden = node.memoizedState !== null;
                    if (newIsHidden) {
                      var primaryChildParent = node.child;
                      if (primaryChildParent !== null) {
                        if (primaryChildParent.child !== null) {
                          primaryChildParent.child.return = primaryChildParent;
                          appendAllChildren(parent, primaryChildParent, true, newIsHidden);
                        }
                        var fallbackChildParent = primaryChildParent.sibling;
                        if (fallbackChildParent !== null) {
                          fallbackChildParent.return = node;
                          node = fallbackChildParent;
                          continue;
                        }
                      }
                    }
                  }
                  if (node.child !== null) {
                    node.child.return = node;
                    node = node.child;
                    continue;
                  }
                } else if (node.child !== null) {
                  node.child.return = node;
                  node = node.child;
                  continue;
                }
                node = node;
                if (node === workInProgress2) {
                  return;
                }
                while (node.sibling === null) {
                  if (node.return === null || node.return === workInProgress2) {
                    return;
                  }
                  node = node.return;
                }
                node.sibling.return = node.return;
                node = node.sibling;
              }
            };
            var appendAllChildrenToContainer = function(containerChildSet, workInProgress2, needsVisibilityToggle, isHidden) {
              var node = workInProgress2.child;
              while (node !== null) {
                if (node.tag === HostComponent) {
                  var instance2 = node.stateNode;
                  if (needsVisibilityToggle && isHidden) {
                    var props = node.memoizedProps;
                    var type5 = node.type;
                    instance2 = cloneHiddenInstance(instance2, type5, props, node);
                  }
                  appendChildToContainerChildSet(containerChildSet, instance2);
                } else if (node.tag === HostText) {
                  var _instance3 = node.stateNode;
                  if (needsVisibilityToggle && isHidden) {
                    var text = node.memoizedProps;
                    _instance3 = cloneHiddenTextInstance(_instance3, text, node);
                  }
                  appendChildToContainerChildSet(containerChildSet, _instance3);
                } else if (node.tag === HostPortal)
                  ;
                else if (node.tag === SuspenseComponent) {
                  if ((node.flags & Update) !== NoFlags) {
                    var newIsHidden = node.memoizedState !== null;
                    if (newIsHidden) {
                      var primaryChildParent = node.child;
                      if (primaryChildParent !== null) {
                        if (primaryChildParent.child !== null) {
                          primaryChildParent.child.return = primaryChildParent;
                          appendAllChildrenToContainer(containerChildSet, primaryChildParent, true, newIsHidden);
                        }
                        var fallbackChildParent = primaryChildParent.sibling;
                        if (fallbackChildParent !== null) {
                          fallbackChildParent.return = node;
                          node = fallbackChildParent;
                          continue;
                        }
                      }
                    }
                  }
                  if (node.child !== null) {
                    node.child.return = node;
                    node = node.child;
                    continue;
                  }
                } else if (node.child !== null) {
                  node.child.return = node;
                  node = node.child;
                  continue;
                }
                node = node;
                if (node === workInProgress2) {
                  return;
                }
                while (node.sibling === null) {
                  if (node.return === null || node.return === workInProgress2) {
                    return;
                  }
                  node = node.return;
                }
                node.sibling.return = node.return;
                node = node.sibling;
              }
            };
            updateHostContainer = function(workInProgress2) {
              var portalOrRoot = workInProgress2.stateNode;
              var childrenUnchanged = workInProgress2.firstEffect === null;
              if (childrenUnchanged)
                ;
              else {
                var container = portalOrRoot.containerInfo;
                var newChildSet = createContainerChildSet(container);
                appendAllChildrenToContainer(newChildSet, workInProgress2, false, false);
                portalOrRoot.pendingChildren = newChildSet;
                markUpdate(workInProgress2);
                finalizeContainerChildren(container, newChildSet);
              }
            };
            updateHostComponent$1 = function(current2, workInProgress2, type5, newProps, rootContainerInstance) {
              var currentInstance = current2.stateNode;
              var oldProps = current2.memoizedProps;
              var childrenUnchanged = workInProgress2.firstEffect === null;
              if (childrenUnchanged && oldProps === newProps) {
                workInProgress2.stateNode = currentInstance;
                return;
              }
              var recyclableInstance = workInProgress2.stateNode;
              var currentHostContext = getHostContext();
              var updatePayload = null;
              if (oldProps !== newProps) {
                updatePayload = prepareUpdate(recyclableInstance, type5, oldProps, newProps, rootContainerInstance, currentHostContext);
              }
              if (childrenUnchanged && updatePayload === null) {
                workInProgress2.stateNode = currentInstance;
                return;
              }
              var newInstance = cloneInstance(currentInstance, updatePayload, type5, oldProps, newProps, workInProgress2, childrenUnchanged, recyclableInstance);
              if (finalizeInitialChildren(newInstance, type5, newProps, rootContainerInstance, currentHostContext)) {
                markUpdate(workInProgress2);
              }
              workInProgress2.stateNode = newInstance;
              if (childrenUnchanged) {
                markUpdate(workInProgress2);
              } else {
                appendAllChildren(newInstance, workInProgress2, false, false);
              }
            };
            updateHostText$1 = function(current2, workInProgress2, oldText, newText) {
              if (oldText !== newText) {
                var rootContainerInstance = getRootHostContainer();
                var currentHostContext = getHostContext();
                workInProgress2.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress2);
                markUpdate(workInProgress2);
              } else {
                workInProgress2.stateNode = current2.stateNode;
              }
            };
          } else {
            updateHostContainer = function(workInProgress2) {
            };
            updateHostComponent$1 = function(current2, workInProgress2, type5, newProps, rootContainerInstance) {
            };
            updateHostText$1 = function(current2, workInProgress2, oldText, newText) {
            };
          }
          function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
            if (getIsHydrating()) {
              return;
            }
            switch (renderState.tailMode) {
              case "hidden": {
                var tailNode = renderState.tail;
                var lastTailNode = null;
                while (tailNode !== null) {
                  if (tailNode.alternate !== null) {
                    lastTailNode = tailNode;
                  }
                  tailNode = tailNode.sibling;
                }
                if (lastTailNode === null) {
                  renderState.tail = null;
                } else {
                  lastTailNode.sibling = null;
                }
                break;
              }
              case "collapsed": {
                var _tailNode = renderState.tail;
                var _lastTailNode = null;
                while (_tailNode !== null) {
                  if (_tailNode.alternate !== null) {
                    _lastTailNode = _tailNode;
                  }
                  _tailNode = _tailNode.sibling;
                }
                if (_lastTailNode === null) {
                  if (!hasRenderedATailFallback && renderState.tail !== null) {
                    renderState.tail.sibling = null;
                  } else {
                    renderState.tail = null;
                  }
                } else {
                  _lastTailNode.sibling = null;
                }
                break;
              }
            }
          }
          function completeWork(current2, workInProgress2, renderLanes2) {
            var newProps = workInProgress2.pendingProps;
            switch (workInProgress2.tag) {
              case IndeterminateComponent:
              case LazyComponent:
              case SimpleMemoComponent:
              case FunctionComponent:
              case ForwardRef:
              case Fragment:
              case Mode:
              case Profiler:
              case ContextConsumer:
              case MemoComponent:
                return null;
              case ClassComponent: {
                var Component = workInProgress2.type;
                if (isContextProvider(Component)) {
                  popContext(workInProgress2);
                }
                return null;
              }
              case HostRoot: {
                popHostContainer(workInProgress2);
                popTopLevelContextObject(workInProgress2);
                resetWorkInProgressVersions();
                var fiberRoot = workInProgress2.stateNode;
                if (fiberRoot.pendingContext) {
                  fiberRoot.context = fiberRoot.pendingContext;
                  fiberRoot.pendingContext = null;
                }
                if (current2 === null || current2.child === null) {
                  var wasHydrated = popHydrationState(workInProgress2);
                  if (wasHydrated) {
                    markUpdate(workInProgress2);
                  } else if (!fiberRoot.hydrate) {
                    workInProgress2.flags |= Snapshot;
                  }
                }
                updateHostContainer(workInProgress2);
                return null;
              }
              case HostComponent: {
                popHostContext(workInProgress2);
                var rootContainerInstance = getRootHostContainer();
                var type5 = workInProgress2.type;
                if (current2 !== null && workInProgress2.stateNode != null) {
                  updateHostComponent$1(current2, workInProgress2, type5, newProps, rootContainerInstance);
                  if (current2.ref !== workInProgress2.ref) {
                    markRef$1(workInProgress2);
                  }
                } else {
                  if (!newProps) {
                    if (!(workInProgress2.stateNode !== null)) {
                      {
                        throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                      }
                    }
                    return null;
                  }
                  var currentHostContext = getHostContext();
                  var _wasHydrated = popHydrationState(workInProgress2);
                  if (_wasHydrated) {
                    if (prepareToHydrateHostInstance(workInProgress2, rootContainerInstance, currentHostContext)) {
                      markUpdate(workInProgress2);
                    }
                  } else {
                    var instance2 = createInstance(type5, newProps, rootContainerInstance, currentHostContext, workInProgress2);
                    appendAllChildren(instance2, workInProgress2, false, false);
                    workInProgress2.stateNode = instance2;
                    if (finalizeInitialChildren(instance2, type5, newProps, rootContainerInstance, currentHostContext)) {
                      markUpdate(workInProgress2);
                    }
                  }
                  if (workInProgress2.ref !== null) {
                    markRef$1(workInProgress2);
                  }
                }
                return null;
              }
              case HostText: {
                var newText = newProps;
                if (current2 && workInProgress2.stateNode != null) {
                  var oldText = current2.memoizedProps;
                  updateHostText$1(current2, workInProgress2, oldText, newText);
                } else {
                  if (typeof newText !== "string") {
                    if (!(workInProgress2.stateNode !== null)) {
                      {
                        throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                      }
                    }
                  }
                  var _rootContainerInstance = getRootHostContainer();
                  var _currentHostContext = getHostContext();
                  var _wasHydrated2 = popHydrationState(workInProgress2);
                  if (_wasHydrated2) {
                    if (prepareToHydrateHostTextInstance(workInProgress2)) {
                      markUpdate(workInProgress2);
                    }
                  } else {
                    workInProgress2.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress2);
                  }
                }
                return null;
              }
              case SuspenseComponent: {
                popSuspenseContext(workInProgress2);
                var nextState = workInProgress2.memoizedState;
                if ((workInProgress2.flags & DidCapture) !== NoFlags) {
                  workInProgress2.lanes = renderLanes2;
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    transferActualDuration(workInProgress2);
                  }
                  return workInProgress2;
                }
                var nextDidTimeout = nextState !== null;
                var prevDidTimeout = false;
                if (current2 === null) {
                  if (workInProgress2.memoizedProps.fallback !== void 0) {
                    popHydrationState(workInProgress2);
                  }
                } else {
                  var prevState = current2.memoizedState;
                  prevDidTimeout = prevState !== null;
                }
                if (nextDidTimeout && !prevDidTimeout) {
                  if ((workInProgress2.mode & BlockingMode) !== NoMode) {
                    var hasInvisibleChildContext = current2 === null && workInProgress2.memoizedProps.unstable_avoidThisFallback !== true;
                    if (hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) {
                      renderDidSuspend();
                    } else {
                      renderDidSuspendDelayIfPossible();
                    }
                  }
                }
                if (supportsPersistence) {
                  if (nextDidTimeout) {
                    workInProgress2.flags |= Update;
                  }
                }
                if (supportsMutation) {
                  if (nextDidTimeout || prevDidTimeout) {
                    workInProgress2.flags |= Update;
                  }
                }
                return null;
              }
              case HostPortal:
                popHostContainer(workInProgress2);
                updateHostContainer(workInProgress2);
                if (current2 === null) {
                  preparePortalMount(workInProgress2.stateNode.containerInfo);
                }
                return null;
              case ContextProvider:
                popProvider(workInProgress2);
                return null;
              case IncompleteClassComponent: {
                var _Component = workInProgress2.type;
                if (isContextProvider(_Component)) {
                  popContext(workInProgress2);
                }
                return null;
              }
              case SuspenseListComponent: {
                popSuspenseContext(workInProgress2);
                var renderState = workInProgress2.memoizedState;
                if (renderState === null) {
                  return null;
                }
                var didSuspendAlready = (workInProgress2.flags & DidCapture) !== NoFlags;
                var renderedTail = renderState.rendering;
                if (renderedTail === null) {
                  if (!didSuspendAlready) {
                    var cannotBeSuspended = renderHasNotSuspendedYet() && (current2 === null || (current2.flags & DidCapture) === NoFlags);
                    if (!cannotBeSuspended) {
                      var row = workInProgress2.child;
                      while (row !== null) {
                        var suspended = findFirstSuspended(row);
                        if (suspended !== null) {
                          didSuspendAlready = true;
                          workInProgress2.flags |= DidCapture;
                          cutOffTailIfNeeded(renderState, false);
                          var newThennables = suspended.updateQueue;
                          if (newThennables !== null) {
                            workInProgress2.updateQueue = newThennables;
                            workInProgress2.flags |= Update;
                          }
                          if (renderState.lastEffect === null) {
                            workInProgress2.firstEffect = null;
                          }
                          workInProgress2.lastEffect = renderState.lastEffect;
                          resetChildFibers(workInProgress2, renderLanes2);
                          pushSuspenseContext(workInProgress2, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback));
                          return workInProgress2.child;
                        }
                        row = row.sibling;
                      }
                    }
                    if (renderState.tail !== null && now$1() > getRenderTargetTime()) {
                      workInProgress2.flags |= DidCapture;
                      didSuspendAlready = true;
                      cutOffTailIfNeeded(renderState, false);
                      workInProgress2.lanes = SomeRetryLane;
                      {
                        markSpawnedWork(SomeRetryLane);
                      }
                    }
                  } else {
                    cutOffTailIfNeeded(renderState, false);
                  }
                } else {
                  if (!didSuspendAlready) {
                    var _suspended = findFirstSuspended(renderedTail);
                    if (_suspended !== null) {
                      workInProgress2.flags |= DidCapture;
                      didSuspendAlready = true;
                      var _newThennables = _suspended.updateQueue;
                      if (_newThennables !== null) {
                        workInProgress2.updateQueue = _newThennables;
                        workInProgress2.flags |= Update;
                      }
                      cutOffTailIfNeeded(renderState, true);
                      if (renderState.tail === null && renderState.tailMode === "hidden" && !renderedTail.alternate && !getIsHydrating()) {
                        var lastEffect = workInProgress2.lastEffect = renderState.lastEffect;
                        if (lastEffect !== null) {
                          lastEffect.nextEffect = null;
                        }
                        return null;
                      }
                    } else if (now$1() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes2 !== OffscreenLane) {
                      workInProgress2.flags |= DidCapture;
                      didSuspendAlready = true;
                      cutOffTailIfNeeded(renderState, false);
                      workInProgress2.lanes = SomeRetryLane;
                      {
                        markSpawnedWork(SomeRetryLane);
                      }
                    }
                  }
                  if (renderState.isBackwards) {
                    renderedTail.sibling = workInProgress2.child;
                    workInProgress2.child = renderedTail;
                  } else {
                    var previousSibling = renderState.last;
                    if (previousSibling !== null) {
                      previousSibling.sibling = renderedTail;
                    } else {
                      workInProgress2.child = renderedTail;
                    }
                    renderState.last = renderedTail;
                  }
                }
                if (renderState.tail !== null) {
                  var next = renderState.tail;
                  renderState.rendering = next;
                  renderState.tail = next.sibling;
                  renderState.lastEffect = workInProgress2.lastEffect;
                  renderState.renderingStartTime = now$1();
                  next.sibling = null;
                  var suspenseContext = suspenseStackCursor.current;
                  if (didSuspendAlready) {
                    suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
                  } else {
                    suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
                  }
                  pushSuspenseContext(workInProgress2, suspenseContext);
                  return next;
                }
                return null;
              }
              case FundamentalComponent: {
                break;
              }
              case ScopeComponent: {
                break;
              }
              case Block:
                break;
              case OffscreenComponent:
              case LegacyHiddenComponent: {
                popRenderLanes(workInProgress2);
                if (current2 !== null) {
                  var _nextState = workInProgress2.memoizedState;
                  var _prevState = current2.memoizedState;
                  var prevIsHidden = _prevState !== null;
                  var nextIsHidden = _nextState !== null;
                  if (prevIsHidden !== nextIsHidden && newProps.mode !== "unstable-defer-without-hiding") {
                    workInProgress2.flags |= Update;
                  }
                }
                return null;
              }
            }
            {
              {
                throw Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
              }
            }
          }
          function unwindWork(workInProgress2, renderLanes2) {
            switch (workInProgress2.tag) {
              case ClassComponent: {
                var Component = workInProgress2.type;
                if (isContextProvider(Component)) {
                  popContext(workInProgress2);
                }
                var flags = workInProgress2.flags;
                if (flags & ShouldCapture) {
                  workInProgress2.flags = flags & ~ShouldCapture | DidCapture;
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    transferActualDuration(workInProgress2);
                  }
                  return workInProgress2;
                }
                return null;
              }
              case HostRoot: {
                popHostContainer(workInProgress2);
                popTopLevelContextObject(workInProgress2);
                resetWorkInProgressVersions();
                var _flags = workInProgress2.flags;
                if (!((_flags & DidCapture) === NoFlags)) {
                  {
                    throw Error("The root failed to unmount after an error. This is likely a bug in React. Please file an issue.");
                  }
                }
                workInProgress2.flags = _flags & ~ShouldCapture | DidCapture;
                return workInProgress2;
              }
              case HostComponent: {
                popHostContext(workInProgress2);
                return null;
              }
              case SuspenseComponent: {
                popSuspenseContext(workInProgress2);
                var _flags2 = workInProgress2.flags;
                if (_flags2 & ShouldCapture) {
                  workInProgress2.flags = _flags2 & ~ShouldCapture | DidCapture;
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    transferActualDuration(workInProgress2);
                  }
                  return workInProgress2;
                }
                return null;
              }
              case SuspenseListComponent: {
                popSuspenseContext(workInProgress2);
                return null;
              }
              case HostPortal:
                popHostContainer(workInProgress2);
                return null;
              case ContextProvider:
                popProvider(workInProgress2);
                return null;
              case OffscreenComponent:
              case LegacyHiddenComponent:
                popRenderLanes(workInProgress2);
                return null;
              default:
                return null;
            }
          }
          function unwindInterruptedWork(interruptedWork) {
            switch (interruptedWork.tag) {
              case ClassComponent: {
                var childContextTypes = interruptedWork.type.childContextTypes;
                if (childContextTypes !== null && childContextTypes !== void 0) {
                  popContext(interruptedWork);
                }
                break;
              }
              case HostRoot: {
                popHostContainer(interruptedWork);
                popTopLevelContextObject(interruptedWork);
                resetWorkInProgressVersions();
                break;
              }
              case HostComponent: {
                popHostContext(interruptedWork);
                break;
              }
              case HostPortal:
                popHostContainer(interruptedWork);
                break;
              case SuspenseComponent:
                popSuspenseContext(interruptedWork);
                break;
              case SuspenseListComponent:
                popSuspenseContext(interruptedWork);
                break;
              case ContextProvider:
                popProvider(interruptedWork);
                break;
              case OffscreenComponent:
              case LegacyHiddenComponent:
                popRenderLanes(interruptedWork);
                break;
            }
          }
          function createCapturedValue(value, source) {
            return {
              value,
              source,
              stack: getStackByFiberInDevAndProd(source)
            };
          }
          function showErrorDialog(boundary, errorInfo) {
            return true;
          }
          function logCapturedError(boundary, errorInfo) {
            try {
              var logError = showErrorDialog(boundary, errorInfo);
              if (logError === false) {
                return;
              }
              var error3 = errorInfo.value;
              if (true) {
                var source = errorInfo.source;
                var stack = errorInfo.stack;
                var componentStack = stack !== null ? stack : "";
                if (error3 != null && error3._suppressLogging) {
                  if (boundary.tag === ClassComponent) {
                    return;
                  }
                  console["error"](error3);
                }
                var componentName = source ? getComponentName(source.type) : null;
                var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component:" : "The above error occurred in one of your React components:";
                var errorBoundaryMessage;
                var errorBoundaryName = getComponentName(boundary.type);
                if (errorBoundaryName) {
                  errorBoundaryMessage = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + errorBoundaryName + ".");
                } else {
                  errorBoundaryMessage = "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://reactjs.org/link/error-boundaries to learn more about error boundaries.";
                }
                var combinedMessage = componentNameMessage + "\n" + componentStack + "\n\n" + ("" + errorBoundaryMessage);
                console["error"](combinedMessage);
              } else {
                console["error"](error3);
              }
            } catch (e) {
              setTimeout(function() {
                throw e;
              });
            }
          }
          var PossiblyWeakMap$1 = typeof WeakMap === "function" ? WeakMap : Map;
          function createRootErrorUpdate(fiber, errorInfo, lane) {
            var update = createUpdate(NoTimestamp, lane);
            update.tag = CaptureUpdate;
            update.payload = {
              element: null
            };
            var error3 = errorInfo.value;
            update.callback = function() {
              onUncaughtError(error3);
              logCapturedError(fiber, errorInfo);
            };
            return update;
          }
          function createClassErrorUpdate(fiber, errorInfo, lane) {
            var update = createUpdate(NoTimestamp, lane);
            update.tag = CaptureUpdate;
            var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
            if (typeof getDerivedStateFromError === "function") {
              var error$1 = errorInfo.value;
              update.payload = function() {
                logCapturedError(fiber, errorInfo);
                return getDerivedStateFromError(error$1);
              };
            }
            var inst = fiber.stateNode;
            if (inst !== null && typeof inst.componentDidCatch === "function") {
              update.callback = function callback() {
                {
                  markFailedErrorBoundaryForHotReloading(fiber);
                }
                if (typeof getDerivedStateFromError !== "function") {
                  markLegacyErrorBoundaryAsFailed(this);
                  logCapturedError(fiber, errorInfo);
                }
                var error$12 = errorInfo.value;
                var stack = errorInfo.stack;
                this.componentDidCatch(error$12, {
                  componentStack: stack !== null ? stack : ""
                });
                {
                  if (typeof getDerivedStateFromError !== "function") {
                    if (!includesSomeLane(fiber.lanes, SyncLane)) {
                      error2("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", getComponentName(fiber.type) || "Unknown");
                    }
                  }
                }
              };
            } else {
              update.callback = function() {
                markFailedErrorBoundaryForHotReloading(fiber);
              };
            }
            return update;
          }
          function attachPingListener(root2, wakeable, lanes) {
            var pingCache = root2.pingCache;
            var threadIDs;
            if (pingCache === null) {
              pingCache = root2.pingCache = new PossiblyWeakMap$1();
              threadIDs = /* @__PURE__ */ new Set();
              pingCache.set(wakeable, threadIDs);
            } else {
              threadIDs = pingCache.get(wakeable);
              if (threadIDs === void 0) {
                threadIDs = /* @__PURE__ */ new Set();
                pingCache.set(wakeable, threadIDs);
              }
            }
            if (!threadIDs.has(lanes)) {
              threadIDs.add(lanes);
              var ping = pingSuspendedRoot.bind(null, root2, wakeable, lanes);
              wakeable.then(ping, ping);
            }
          }
          function throwException(root2, returnFiber, sourceFiber, value, rootRenderLanes) {
            sourceFiber.flags |= Incomplete;
            sourceFiber.firstEffect = sourceFiber.lastEffect = null;
            if (value !== null && typeof value === "object" && typeof value.then === "function") {
              var wakeable = value;
              if ((sourceFiber.mode & BlockingMode) === NoMode) {
                var currentSource = sourceFiber.alternate;
                if (currentSource) {
                  sourceFiber.updateQueue = currentSource.updateQueue;
                  sourceFiber.memoizedState = currentSource.memoizedState;
                  sourceFiber.lanes = currentSource.lanes;
                } else {
                  sourceFiber.updateQueue = null;
                  sourceFiber.memoizedState = null;
                }
              }
              var hasInvisibleParentBoundary = hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext);
              var _workInProgress = returnFiber;
              do {
                if (_workInProgress.tag === SuspenseComponent && shouldCaptureSuspense(_workInProgress, hasInvisibleParentBoundary)) {
                  var wakeables = _workInProgress.updateQueue;
                  if (wakeables === null) {
                    var updateQueue = /* @__PURE__ */ new Set();
                    updateQueue.add(wakeable);
                    _workInProgress.updateQueue = updateQueue;
                  } else {
                    wakeables.add(wakeable);
                  }
                  if ((_workInProgress.mode & BlockingMode) === NoMode) {
                    _workInProgress.flags |= DidCapture;
                    sourceFiber.flags |= ForceUpdateForLegacySuspense;
                    sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete);
                    if (sourceFiber.tag === ClassComponent) {
                      var currentSourceFiber = sourceFiber.alternate;
                      if (currentSourceFiber === null) {
                        sourceFiber.tag = IncompleteClassComponent;
                      } else {
                        var update = createUpdate(NoTimestamp, SyncLane);
                        update.tag = ForceUpdate;
                        enqueueUpdate(sourceFiber, update);
                      }
                    }
                    sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane);
                    return;
                  }
                  attachPingListener(root2, wakeable, rootRenderLanes);
                  _workInProgress.flags |= ShouldCapture;
                  _workInProgress.lanes = rootRenderLanes;
                  return;
                }
                _workInProgress = _workInProgress.return;
              } while (_workInProgress !== null);
              value = new Error((getComponentName(sourceFiber.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.");
            }
            renderDidError();
            value = createCapturedValue(value, sourceFiber);
            var workInProgress2 = returnFiber;
            do {
              switch (workInProgress2.tag) {
                case HostRoot: {
                  var _errorInfo = value;
                  workInProgress2.flags |= ShouldCapture;
                  var lane = pickArbitraryLane(rootRenderLanes);
                  workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
                  var _update = createRootErrorUpdate(workInProgress2, _errorInfo, lane);
                  enqueueCapturedUpdate(workInProgress2, _update);
                  return;
                }
                case ClassComponent:
                  var errorInfo = value;
                  var ctor = workInProgress2.type;
                  var instance2 = workInProgress2.stateNode;
                  if ((workInProgress2.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError === "function" || instance2 !== null && typeof instance2.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance2))) {
                    workInProgress2.flags |= ShouldCapture;
                    var _lane = pickArbitraryLane(rootRenderLanes);
                    workInProgress2.lanes = mergeLanes(workInProgress2.lanes, _lane);
                    var _update2 = createClassErrorUpdate(workInProgress2, errorInfo, _lane);
                    enqueueCapturedUpdate(workInProgress2, _update2);
                    return;
                  }
                  break;
              }
              workInProgress2 = workInProgress2.return;
            } while (workInProgress2 !== null);
          }
          function invokeGuardedCallbackProd(name2, func, context, a, b2, c2, d2, e, f3) {
            var funcArgs = Array.prototype.slice.call(arguments, 3);
            try {
              func.apply(context, funcArgs);
            } catch (error3) {
              this.onError(error3);
            }
          }
          var invokeGuardedCallbackImpl = invokeGuardedCallbackProd;
          {
            if (typeof window !== "undefined" && typeof window.dispatchEvent === "function" && typeof document !== "undefined" && typeof document.createEvent === "function") {
              var fakeNode = document.createElement("react");
              invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(name2, func, context, a, b2, c2, d2, e, f3) {
                if (!(typeof document !== "undefined")) {
                  {
                    throw Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
                  }
                }
                var evt = document.createEvent("Event");
                var didCall = false;
                var didError = true;
                var windowEvent = window.event;
                var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, "event");
                function restoreAfterDispatch() {
                  fakeNode.removeEventListener(evtType, callCallback2, false);
                  if (typeof window.event !== "undefined" && window.hasOwnProperty("event")) {
                    window.event = windowEvent;
                  }
                }
                var funcArgs = Array.prototype.slice.call(arguments, 3);
                function callCallback2() {
                  didCall = true;
                  restoreAfterDispatch();
                  func.apply(context, funcArgs);
                  didError = false;
                }
                var error3;
                var didSetError = false;
                var isCrossOriginError = false;
                function handleWindowError(event) {
                  error3 = event.error;
                  didSetError = true;
                  if (error3 === null && event.colno === 0 && event.lineno === 0) {
                    isCrossOriginError = true;
                  }
                  if (event.defaultPrevented) {
                    if (error3 != null && typeof error3 === "object") {
                      try {
                        error3._suppressLogging = true;
                      } catch (inner) {
                      }
                    }
                  }
                }
                var evtType = "react-" + (name2 ? name2 : "invokeguardedcallback");
                window.addEventListener("error", handleWindowError);
                fakeNode.addEventListener(evtType, callCallback2, false);
                evt.initEvent(evtType, false, false);
                fakeNode.dispatchEvent(evt);
                if (windowEventDescriptor) {
                  Object.defineProperty(window, "event", windowEventDescriptor);
                }
                if (didCall && didError) {
                  if (!didSetError) {
                    error3 = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`);
                  } else if (isCrossOriginError) {
                    error3 = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.");
                  }
                  this.onError(error3);
                }
                window.removeEventListener("error", handleWindowError);
                if (!didCall) {
                  restoreAfterDispatch();
                  return invokeGuardedCallbackProd.apply(this, arguments);
                }
              };
            }
          }
          var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;
          var hasError = false;
          var caughtError = null;
          var reporter = {
            onError: function(error3) {
              hasError = true;
              caughtError = error3;
            }
          };
          function invokeGuardedCallback(name2, func, context, a, b2, c2, d2, e, f3) {
            hasError = false;
            caughtError = null;
            invokeGuardedCallbackImpl$1.apply(reporter, arguments);
          }
          function hasCaughtError() {
            return hasError;
          }
          function clearCaughtError() {
            if (hasError) {
              var error3 = caughtError;
              hasError = false;
              caughtError = null;
              return error3;
            } else {
              {
                {
                  throw Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
            }
          }
          var didWarnAboutUndefinedSnapshotBeforeUpdate = null;
          {
            didWarnAboutUndefinedSnapshotBeforeUpdate = /* @__PURE__ */ new Set();
          }
          var PossiblyWeakSet = typeof WeakSet === "function" ? WeakSet : Set;
          var callComponentWillUnmountWithTimer = function(current2, instance2) {
            instance2.props = current2.memoizedProps;
            instance2.state = current2.memoizedState;
            {
              instance2.componentWillUnmount();
            }
          };
          function safelyCallComponentWillUnmount(current2, instance2) {
            {
              invokeGuardedCallback(null, callComponentWillUnmountWithTimer, null, current2, instance2);
              if (hasCaughtError()) {
                var unmountError = clearCaughtError();
                captureCommitPhaseError(current2, unmountError);
              }
            }
          }
          function safelyDetachRef(current2) {
            var ref = current2.ref;
            if (ref !== null) {
              if (typeof ref === "function") {
                {
                  invokeGuardedCallback(null, ref, null, null);
                  if (hasCaughtError()) {
                    var refError = clearCaughtError();
                    captureCommitPhaseError(current2, refError);
                  }
                }
              } else {
                ref.current = null;
              }
            }
          }
          function safelyCallDestroy(current2, destroy) {
            {
              invokeGuardedCallback(null, destroy, null);
              if (hasCaughtError()) {
                var error3 = clearCaughtError();
                captureCommitPhaseError(current2, error3);
              }
            }
          }
          function commitBeforeMutationLifeCycles(current2, finishedWork) {
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent:
              case Block: {
                return;
              }
              case ClassComponent: {
                if (finishedWork.flags & Snapshot) {
                  if (current2 !== null) {
                    var prevProps = current2.memoizedProps;
                    var prevState = current2.memoizedState;
                    var instance2 = finishedWork.stateNode;
                    {
                      if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                        if (instance2.props !== finishedWork.memoizedProps) {
                          error2("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentName(finishedWork.type) || "instance");
                        }
                        if (instance2.state !== finishedWork.memoizedState) {
                          error2("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentName(finishedWork.type) || "instance");
                        }
                      }
                    }
                    var snapshot = instance2.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);
                    {
                      var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;
                      if (snapshot === void 0 && !didWarnSet.has(finishedWork.type)) {
                        didWarnSet.add(finishedWork.type);
                        error2("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", getComponentName(finishedWork.type));
                      }
                    }
                    instance2.__reactInternalSnapshotBeforeUpdate = snapshot;
                  }
                }
                return;
              }
              case HostRoot: {
                if (supportsMutation) {
                  if (finishedWork.flags & Snapshot) {
                    var root2 = finishedWork.stateNode;
                    clearContainer(root2.containerInfo);
                  }
                }
                return;
              }
              case HostComponent:
              case HostText:
              case HostPortal:
              case IncompleteClassComponent:
                return;
            }
            {
              {
                throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
          }
          function commitHookEffectListUnmount(tag, finishedWork) {
            var updateQueue = finishedWork.updateQueue;
            var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
            if (lastEffect !== null) {
              var firstEffect = lastEffect.next;
              var effect = firstEffect;
              do {
                if ((effect.tag & tag) === tag) {
                  var destroy = effect.destroy;
                  effect.destroy = void 0;
                  if (destroy !== void 0) {
                    destroy();
                  }
                }
                effect = effect.next;
              } while (effect !== firstEffect);
            }
          }
          function commitHookEffectListMount(tag, finishedWork) {
            var updateQueue = finishedWork.updateQueue;
            var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
            if (lastEffect !== null) {
              var firstEffect = lastEffect.next;
              var effect = firstEffect;
              do {
                if ((effect.tag & tag) === tag) {
                  var create5 = effect.create;
                  effect.destroy = create5();
                  {
                    var destroy = effect.destroy;
                    if (destroy !== void 0 && typeof destroy !== "function") {
                      var addendum = void 0;
                      if (destroy === null) {
                        addendum = " You returned null. If your effect does not require clean up, return undefined (or nothing).";
                      } else if (typeof destroy.then === "function") {
                        addendum = "\n\nIt looks like you wrote useEffect(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\nuseEffect(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching";
                      } else {
                        addendum = " You returned: " + destroy;
                      }
                      error2("An effect function must not return anything besides a function, which is used for clean-up.%s", addendum);
                    }
                  }
                }
                effect = effect.next;
              } while (effect !== firstEffect);
            }
          }
          function schedulePassiveEffects(finishedWork) {
            var updateQueue = finishedWork.updateQueue;
            var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
            if (lastEffect !== null) {
              var firstEffect = lastEffect.next;
              var effect = firstEffect;
              do {
                var _effect = effect, next = _effect.next, tag = _effect.tag;
                if ((tag & Passive$1) !== NoFlags$1 && (tag & HasEffect) !== NoFlags$1) {
                  enqueuePendingPassiveHookEffectUnmount(finishedWork, effect);
                  enqueuePendingPassiveHookEffectMount(finishedWork, effect);
                }
                effect = next;
              } while (effect !== firstEffect);
            }
          }
          function commitLifeCycles(finishedRoot, current2, finishedWork, committedLanes) {
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent:
              case Block: {
                {
                  commitHookEffectListMount(Layout3 | HasEffect, finishedWork);
                }
                schedulePassiveEffects(finishedWork);
                return;
              }
              case ClassComponent: {
                var instance2 = finishedWork.stateNode;
                if (finishedWork.flags & Update) {
                  if (current2 === null) {
                    {
                      if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                        if (instance2.props !== finishedWork.memoizedProps) {
                          error2("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentName(finishedWork.type) || "instance");
                        }
                        if (instance2.state !== finishedWork.memoizedState) {
                          error2("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentName(finishedWork.type) || "instance");
                        }
                      }
                    }
                    {
                      instance2.componentDidMount();
                    }
                  } else {
                    var prevProps = finishedWork.elementType === finishedWork.type ? current2.memoizedProps : resolveDefaultProps(finishedWork.type, current2.memoizedProps);
                    var prevState = current2.memoizedState;
                    {
                      if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                        if (instance2.props !== finishedWork.memoizedProps) {
                          error2("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentName(finishedWork.type) || "instance");
                        }
                        if (instance2.state !== finishedWork.memoizedState) {
                          error2("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentName(finishedWork.type) || "instance");
                        }
                      }
                    }
                    {
                      instance2.componentDidUpdate(prevProps, prevState, instance2.__reactInternalSnapshotBeforeUpdate);
                    }
                  }
                }
                var updateQueue = finishedWork.updateQueue;
                if (updateQueue !== null) {
                  {
                    if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                      if (instance2.props !== finishedWork.memoizedProps) {
                        error2("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentName(finishedWork.type) || "instance");
                      }
                      if (instance2.state !== finishedWork.memoizedState) {
                        error2("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentName(finishedWork.type) || "instance");
                      }
                    }
                  }
                  commitUpdateQueue(finishedWork, updateQueue, instance2);
                }
                return;
              }
              case HostRoot: {
                var _updateQueue = finishedWork.updateQueue;
                if (_updateQueue !== null) {
                  var _instance = null;
                  if (finishedWork.child !== null) {
                    switch (finishedWork.child.tag) {
                      case HostComponent:
                        _instance = getPublicInstance(finishedWork.child.stateNode);
                        break;
                      case ClassComponent:
                        _instance = finishedWork.child.stateNode;
                        break;
                    }
                  }
                  commitUpdateQueue(finishedWork, _updateQueue, _instance);
                }
                return;
              }
              case HostComponent: {
                var _instance2 = finishedWork.stateNode;
                if (current2 === null && finishedWork.flags & Update) {
                  var type5 = finishedWork.type;
                  var props = finishedWork.memoizedProps;
                  commitMount(_instance2, type5, props, finishedWork);
                }
                return;
              }
              case HostText: {
                return;
              }
              case HostPortal: {
                return;
              }
              case Profiler: {
                {
                  var _finishedWork$memoize2 = finishedWork.memoizedProps, onCommit = _finishedWork$memoize2.onCommit, onRender = _finishedWork$memoize2.onRender;
                  var effectDuration = finishedWork.stateNode.effectDuration;
                  var commitTime2 = getCommitTime();
                  if (typeof onRender === "function") {
                    {
                      onRender(finishedWork.memoizedProps.id, current2 === null ? "mount" : "update", finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime2, finishedRoot.memoizedInteractions);
                    }
                  }
                }
                return;
              }
              case SuspenseComponent: {
                commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
                return;
              }
              case SuspenseListComponent:
              case IncompleteClassComponent:
              case FundamentalComponent:
              case ScopeComponent:
              case OffscreenComponent:
              case LegacyHiddenComponent:
                return;
            }
            {
              {
                throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
          }
          function hideOrUnhideAllChildren(finishedWork, isHidden) {
            if (supportsMutation) {
              var node = finishedWork;
              while (true) {
                if (node.tag === HostComponent) {
                  var instance2 = node.stateNode;
                  if (isHidden) {
                    hideInstance(instance2);
                  } else {
                    unhideInstance(node.stateNode, node.memoizedProps);
                  }
                } else if (node.tag === HostText) {
                  var _instance3 = node.stateNode;
                  if (isHidden) {
                    hideTextInstance(_instance3);
                  } else {
                    unhideTextInstance(_instance3, node.memoizedProps);
                  }
                } else if ((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) && node.memoizedState !== null && node !== finishedWork)
                  ;
                else if (node.child !== null) {
                  node.child.return = node;
                  node = node.child;
                  continue;
                }
                if (node === finishedWork) {
                  return;
                }
                while (node.sibling === null) {
                  if (node.return === null || node.return === finishedWork) {
                    return;
                  }
                  node = node.return;
                }
                node.sibling.return = node.return;
                node = node.sibling;
              }
            }
          }
          function commitAttachRef(finishedWork) {
            var ref = finishedWork.ref;
            if (ref !== null) {
              var instance2 = finishedWork.stateNode;
              var instanceToUse;
              switch (finishedWork.tag) {
                case HostComponent:
                  instanceToUse = getPublicInstance(instance2);
                  break;
                default:
                  instanceToUse = instance2;
              }
              if (typeof ref === "function") {
                ref(instanceToUse);
              } else {
                {
                  if (!ref.hasOwnProperty("current")) {
                    error2("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", getComponentName(finishedWork.type));
                  }
                }
                ref.current = instanceToUse;
              }
            }
          }
          function commitDetachRef(current2) {
            var currentRef = current2.ref;
            if (currentRef !== null) {
              if (typeof currentRef === "function") {
                currentRef(null);
              } else {
                currentRef.current = null;
              }
            }
          }
          function commitUnmount(finishedRoot, current2, renderPriorityLevel) {
            onCommitUnmount(current2);
            switch (current2.tag) {
              case FunctionComponent:
              case ForwardRef:
              case MemoComponent:
              case SimpleMemoComponent:
              case Block: {
                var updateQueue = current2.updateQueue;
                if (updateQueue !== null) {
                  var lastEffect = updateQueue.lastEffect;
                  if (lastEffect !== null) {
                    var firstEffect = lastEffect.next;
                    var effect = firstEffect;
                    do {
                      var _effect2 = effect, destroy = _effect2.destroy, tag = _effect2.tag;
                      if (destroy !== void 0) {
                        if ((tag & Passive$1) !== NoFlags$1) {
                          enqueuePendingPassiveHookEffectUnmount(current2, effect);
                        } else {
                          {
                            safelyCallDestroy(current2, destroy);
                          }
                        }
                      }
                      effect = effect.next;
                    } while (effect !== firstEffect);
                  }
                }
                return;
              }
              case ClassComponent: {
                safelyDetachRef(current2);
                var instance2 = current2.stateNode;
                if (typeof instance2.componentWillUnmount === "function") {
                  safelyCallComponentWillUnmount(current2, instance2);
                }
                return;
              }
              case HostComponent: {
                safelyDetachRef(current2);
                return;
              }
              case HostPortal: {
                if (supportsMutation) {
                  unmountHostComponents(finishedRoot, current2);
                } else if (supportsPersistence) {
                  emptyPortalContainer(current2);
                }
                return;
              }
              case FundamentalComponent: {
                return;
              }
              case DehydratedFragment: {
                return;
              }
              case ScopeComponent: {
                return;
              }
            }
          }
          function commitNestedUnmounts(finishedRoot, root2, renderPriorityLevel) {
            var node = root2;
            while (true) {
              commitUnmount(finishedRoot, node);
              if (node.child !== null && (!supportsMutation || node.tag !== HostPortal)) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === root2) {
                return;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === root2) {
                  return;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
          }
          function detachFiberMutation(fiber) {
            fiber.alternate = null;
            fiber.child = null;
            fiber.dependencies = null;
            fiber.firstEffect = null;
            fiber.lastEffect = null;
            fiber.memoizedProps = null;
            fiber.memoizedState = null;
            fiber.pendingProps = null;
            fiber.return = null;
            fiber.updateQueue = null;
            {
              fiber._debugOwner = null;
            }
          }
          function emptyPortalContainer(current2) {
            if (!supportsPersistence) {
              return;
            }
            var portal = current2.stateNode;
            var containerInfo = portal.containerInfo;
            var emptyChildSet = createContainerChildSet(containerInfo);
            replaceContainerChildren(containerInfo, emptyChildSet);
          }
          function commitContainer(finishedWork) {
            if (!supportsPersistence) {
              return;
            }
            switch (finishedWork.tag) {
              case ClassComponent:
              case HostComponent:
              case HostText:
              case FundamentalComponent: {
                return;
              }
              case HostRoot:
              case HostPortal: {
                var portalOrRoot = finishedWork.stateNode;
                var containerInfo = portalOrRoot.containerInfo, pendingChildren = portalOrRoot.pendingChildren;
                replaceContainerChildren(containerInfo, pendingChildren);
                return;
              }
            }
            {
              {
                throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
          }
          function getHostParentFiber(fiber) {
            var parent = fiber.return;
            while (parent !== null) {
              if (isHostParent(parent)) {
                return parent;
              }
              parent = parent.return;
            }
            {
              {
                throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
          }
          function isHostParent(fiber) {
            return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
          }
          function getHostSibling(fiber) {
            var node = fiber;
            siblings:
              while (true) {
                while (node.sibling === null) {
                  if (node.return === null || isHostParent(node.return)) {
                    return null;
                  }
                  node = node.return;
                }
                node.sibling.return = node.return;
                node = node.sibling;
                while (node.tag !== HostComponent && node.tag !== HostText && node.tag !== DehydratedFragment) {
                  if (node.flags & Placement) {
                    continue siblings;
                  }
                  if (node.child === null || node.tag === HostPortal) {
                    continue siblings;
                  } else {
                    node.child.return = node;
                    node = node.child;
                  }
                }
                if (!(node.flags & Placement)) {
                  return node.stateNode;
                }
              }
          }
          function commitPlacement(finishedWork) {
            if (!supportsMutation) {
              return;
            }
            var parentFiber = getHostParentFiber(finishedWork);
            var parent;
            var isContainer;
            var parentStateNode = parentFiber.stateNode;
            switch (parentFiber.tag) {
              case HostComponent:
                parent = parentStateNode;
                isContainer = false;
                break;
              case HostRoot:
                parent = parentStateNode.containerInfo;
                isContainer = true;
                break;
              case HostPortal:
                parent = parentStateNode.containerInfo;
                isContainer = true;
                break;
              case FundamentalComponent:
              default: {
                {
                  throw Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
            }
            if (parentFiber.flags & ContentReset) {
              resetTextContent(parent);
              parentFiber.flags &= ~ContentReset;
            }
            var before = getHostSibling(finishedWork);
            if (isContainer) {
              insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent);
            } else {
              insertOrAppendPlacementNode(finishedWork, before, parent);
            }
          }
          function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
            var tag = node.tag;
            var isHost = tag === HostComponent || tag === HostText;
            if (isHost || enableFundamentalAPI) {
              var stateNode = isHost ? node.stateNode : node.stateNode.instance;
              if (before) {
                insertInContainerBefore(parent, stateNode, before);
              } else {
                appendChildToContainer(parent, stateNode);
              }
            } else if (tag === HostPortal)
              ;
            else {
              var child = node.child;
              if (child !== null) {
                insertOrAppendPlacementNodeIntoContainer(child, before, parent);
                var sibling = child.sibling;
                while (sibling !== null) {
                  insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);
                  sibling = sibling.sibling;
                }
              }
            }
          }
          function insertOrAppendPlacementNode(node, before, parent) {
            var tag = node.tag;
            var isHost = tag === HostComponent || tag === HostText;
            if (isHost || enableFundamentalAPI) {
              var stateNode = isHost ? node.stateNode : node.stateNode.instance;
              if (before) {
                insertBefore(parent, stateNode, before);
              } else {
                appendChild(parent, stateNode);
              }
            } else if (tag === HostPortal)
              ;
            else {
              var child = node.child;
              if (child !== null) {
                insertOrAppendPlacementNode(child, before, parent);
                var sibling = child.sibling;
                while (sibling !== null) {
                  insertOrAppendPlacementNode(sibling, before, parent);
                  sibling = sibling.sibling;
                }
              }
            }
          }
          function unmountHostComponents(finishedRoot, current2, renderPriorityLevel) {
            var node = current2;
            var currentParentIsValid = false;
            var currentParent;
            var currentParentIsContainer;
            while (true) {
              if (!currentParentIsValid) {
                var parent = node.return;
                findParent:
                  while (true) {
                    if (!(parent !== null)) {
                      {
                        throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
                      }
                    }
                    var parentStateNode = parent.stateNode;
                    switch (parent.tag) {
                      case HostComponent:
                        currentParent = parentStateNode;
                        currentParentIsContainer = false;
                        break findParent;
                      case HostRoot:
                        currentParent = parentStateNode.containerInfo;
                        currentParentIsContainer = true;
                        break findParent;
                      case HostPortal:
                        currentParent = parentStateNode.containerInfo;
                        currentParentIsContainer = true;
                        break findParent;
                    }
                    parent = parent.return;
                  }
                currentParentIsValid = true;
              }
              if (node.tag === HostComponent || node.tag === HostText) {
                commitNestedUnmounts(finishedRoot, node);
                if (currentParentIsContainer) {
                  removeChildFromContainer(currentParent, node.stateNode);
                } else {
                  removeChild(currentParent, node.stateNode);
                }
              } else if (node.tag === HostPortal) {
                if (node.child !== null) {
                  currentParent = node.stateNode.containerInfo;
                  currentParentIsContainer = true;
                  node.child.return = node;
                  node = node.child;
                  continue;
                }
              } else {
                commitUnmount(finishedRoot, node);
                if (node.child !== null) {
                  node.child.return = node;
                  node = node.child;
                  continue;
                }
              }
              if (node === current2) {
                return;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === current2) {
                  return;
                }
                node = node.return;
                if (node.tag === HostPortal) {
                  currentParentIsValid = false;
                }
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
          }
          function commitDeletion(finishedRoot, current2, renderPriorityLevel) {
            if (supportsMutation) {
              unmountHostComponents(finishedRoot, current2);
            } else {
              commitNestedUnmounts(finishedRoot, current2);
            }
            var alternate = current2.alternate;
            detachFiberMutation(current2);
            if (alternate !== null) {
              detachFiberMutation(alternate);
            }
          }
          function commitWork(current2, finishedWork) {
            if (!supportsMutation) {
              switch (finishedWork.tag) {
                case FunctionComponent:
                case ForwardRef:
                case MemoComponent:
                case SimpleMemoComponent:
                case Block: {
                  {
                    commitHookEffectListUnmount(Layout3 | HasEffect, finishedWork);
                  }
                  return;
                }
                case Profiler: {
                  return;
                }
                case SuspenseComponent: {
                  commitSuspenseComponent(finishedWork);
                  attachSuspenseRetryListeners(finishedWork);
                  return;
                }
                case SuspenseListComponent: {
                  attachSuspenseRetryListeners(finishedWork);
                  return;
                }
                case HostRoot: {
                  if (supportsHydration) {
                    var root2 = finishedWork.stateNode;
                    if (root2.hydrate) {
                      root2.hydrate = false;
                      commitHydratedContainer(root2.containerInfo);
                    }
                  }
                  break;
                }
                case OffscreenComponent:
                case LegacyHiddenComponent: {
                  return;
                }
              }
              commitContainer(finishedWork);
              return;
            }
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef:
              case MemoComponent:
              case SimpleMemoComponent:
              case Block: {
                {
                  commitHookEffectListUnmount(Layout3 | HasEffect, finishedWork);
                }
                return;
              }
              case ClassComponent: {
                return;
              }
              case HostComponent: {
                var instance2 = finishedWork.stateNode;
                if (instance2 != null) {
                  var newProps = finishedWork.memoizedProps;
                  var oldProps = current2 !== null ? current2.memoizedProps : newProps;
                  var type5 = finishedWork.type;
                  var updatePayload = finishedWork.updateQueue;
                  finishedWork.updateQueue = null;
                  if (updatePayload !== null) {
                    commitUpdate(instance2, updatePayload, type5, oldProps, newProps, finishedWork);
                  }
                }
                return;
              }
              case HostText: {
                if (!(finishedWork.stateNode !== null)) {
                  {
                    throw Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
                  }
                }
                var textInstance = finishedWork.stateNode;
                var newText = finishedWork.memoizedProps;
                var oldText = current2 !== null ? current2.memoizedProps : newText;
                commitTextUpdate(textInstance, oldText, newText);
                return;
              }
              case HostRoot: {
                if (supportsHydration) {
                  var _root = finishedWork.stateNode;
                  if (_root.hydrate) {
                    _root.hydrate = false;
                    commitHydratedContainer(_root.containerInfo);
                  }
                }
                return;
              }
              case Profiler: {
                return;
              }
              case SuspenseComponent: {
                commitSuspenseComponent(finishedWork);
                attachSuspenseRetryListeners(finishedWork);
                return;
              }
              case SuspenseListComponent: {
                attachSuspenseRetryListeners(finishedWork);
                return;
              }
              case IncompleteClassComponent: {
                return;
              }
              case FundamentalComponent: {
                break;
              }
              case ScopeComponent: {
                break;
              }
              case OffscreenComponent:
              case LegacyHiddenComponent: {
                var newState = finishedWork.memoizedState;
                var isHidden = newState !== null;
                hideOrUnhideAllChildren(finishedWork, isHidden);
                return;
              }
            }
            {
              {
                throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
          }
          function commitSuspenseComponent(finishedWork) {
            var newState = finishedWork.memoizedState;
            if (newState !== null) {
              markCommitTimeOfFallback();
              if (supportsMutation) {
                var primaryChildParent = finishedWork.child;
                hideOrUnhideAllChildren(primaryChildParent, true);
              }
            }
          }
          function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
            if (!supportsHydration) {
              return;
            }
            var newState = finishedWork.memoizedState;
            if (newState === null) {
              var current2 = finishedWork.alternate;
              if (current2 !== null) {
                var prevState = current2.memoizedState;
                if (prevState !== null) {
                  var suspenseInstance = prevState.dehydrated;
                  if (suspenseInstance !== null) {
                    commitHydratedSuspenseInstance(suspenseInstance);
                  }
                }
              }
            }
          }
          function attachSuspenseRetryListeners(finishedWork) {
            var wakeables = finishedWork.updateQueue;
            if (wakeables !== null) {
              finishedWork.updateQueue = null;
              var retryCache = finishedWork.stateNode;
              if (retryCache === null) {
                retryCache = finishedWork.stateNode = new PossiblyWeakSet();
              }
              wakeables.forEach(function(wakeable) {
                var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
                if (!retryCache.has(wakeable)) {
                  {
                    if (wakeable.__reactDoNotTraceInteractions !== true) {
                      retry = tracing.unstable_wrap(retry);
                    }
                  }
                  retryCache.add(wakeable);
                  wakeable.then(retry, retry);
                }
              });
            }
          }
          function isSuspenseBoundaryBeingHidden(current2, finishedWork) {
            if (current2 !== null) {
              var oldState = current2.memoizedState;
              if (oldState === null || oldState.dehydrated !== null) {
                var newState = finishedWork.memoizedState;
                return newState !== null && newState.dehydrated === null;
              }
            }
            return false;
          }
          function commitResetTextContent(current2) {
            if (!supportsMutation) {
              return;
            }
            resetTextContent(current2.stateNode);
          }
          var COMPONENT_TYPE = 0;
          var HAS_PSEUDO_CLASS_TYPE = 1;
          var ROLE_TYPE = 2;
          var TEST_NAME_TYPE = 3;
          var TEXT_TYPE = 4;
          if (typeof Symbol === "function" && Symbol.for) {
            var symbolFor$1 = Symbol.for;
            COMPONENT_TYPE = symbolFor$1("selector.component");
            HAS_PSEUDO_CLASS_TYPE = symbolFor$1("selector.has_pseudo_class");
            ROLE_TYPE = symbolFor$1("selector.role");
            TEST_NAME_TYPE = symbolFor$1("selector.test_id");
            TEXT_TYPE = symbolFor$1("selector.text");
          }
          function createComponentSelector(component) {
            return {
              $$typeof: COMPONENT_TYPE,
              value: component
            };
          }
          function createHasPsuedoClassSelector(selectors) {
            return {
              $$typeof: HAS_PSEUDO_CLASS_TYPE,
              value: selectors
            };
          }
          function createRoleSelector(role) {
            return {
              $$typeof: ROLE_TYPE,
              value: role
            };
          }
          function createTextSelector(text) {
            return {
              $$typeof: TEXT_TYPE,
              value: text
            };
          }
          function createTestNameSelector(id) {
            return {
              $$typeof: TEST_NAME_TYPE,
              value: id
            };
          }
          function findFiberRootForHostRoot(hostRoot) {
            var maybeFiber = getInstanceFromNode(hostRoot);
            if (maybeFiber != null) {
              if (!(typeof maybeFiber.memoizedProps["data-testname"] === "string")) {
                {
                  throw Error("Invalid host root specified. Should be either a React container or a node with a testname attribute.");
                }
              }
              return maybeFiber;
            } else {
              var fiberRoot = findFiberRoot(hostRoot);
              if (!(fiberRoot !== null)) {
                {
                  throw Error("Could not find React container within specified host subtree.");
                }
              }
              return fiberRoot.stateNode.current;
            }
          }
          function matchSelector(fiber, selector4) {
            switch (selector4.$$typeof) {
              case COMPONENT_TYPE:
                if (fiber.type === selector4.value) {
                  return true;
                }
                break;
              case HAS_PSEUDO_CLASS_TYPE:
                return hasMatchingPaths(fiber, selector4.value);
              case ROLE_TYPE:
                if (fiber.tag === HostComponent) {
                  var node = fiber.stateNode;
                  if (matchAccessibilityRole(node, selector4.value)) {
                    return true;
                  }
                }
                break;
              case TEXT_TYPE:
                if (fiber.tag === HostComponent || fiber.tag === HostText) {
                  var textContent = getTextContent(fiber);
                  if (textContent !== null && textContent.indexOf(selector4.value) >= 0) {
                    return true;
                  }
                }
                break;
              case TEST_NAME_TYPE:
                if (fiber.tag === HostComponent) {
                  var dataTestID = fiber.memoizedProps["data-testname"];
                  if (typeof dataTestID === "string" && dataTestID.toLowerCase() === selector4.value.toLowerCase()) {
                    return true;
                  }
                }
                break;
              default: {
                {
                  throw Error("Invalid selector type " + selector4 + " specified.");
                }
              }
            }
            return false;
          }
          function selectorToString(selector4) {
            switch (selector4.$$typeof) {
              case COMPONENT_TYPE:
                var displayName = getComponentName(selector4.value) || "Unknown";
                return "<" + displayName + ">";
              case HAS_PSEUDO_CLASS_TYPE:
                return ":has(" + (selectorToString(selector4) || "") + ")";
              case ROLE_TYPE:
                return '[role="' + selector4.value + '"]';
              case TEXT_TYPE:
                return '"' + selector4.value + '"';
              case TEST_NAME_TYPE:
                return '[data-testname="' + selector4.value + '"]';
              default: {
                {
                  throw Error("Invalid selector type " + selector4 + " specified.");
                }
              }
            }
          }
          function findPaths(root2, selectors) {
            var matchingFibers = [];
            var stack = [root2, 0];
            var index2 = 0;
            while (index2 < stack.length) {
              var fiber = stack[index2++];
              var selectorIndex = stack[index2++];
              var selector4 = selectors[selectorIndex];
              if (fiber.tag === HostComponent && isHiddenSubtree(fiber)) {
                continue;
              } else {
                while (selector4 != null && matchSelector(fiber, selector4)) {
                  selectorIndex++;
                  selector4 = selectors[selectorIndex];
                }
              }
              if (selectorIndex === selectors.length) {
                matchingFibers.push(fiber);
              } else {
                var child = fiber.child;
                while (child !== null) {
                  stack.push(child, selectorIndex);
                  child = child.sibling;
                }
              }
            }
            return matchingFibers;
          }
          function hasMatchingPaths(root2, selectors) {
            var stack = [root2, 0];
            var index2 = 0;
            while (index2 < stack.length) {
              var fiber = stack[index2++];
              var selectorIndex = stack[index2++];
              var selector4 = selectors[selectorIndex];
              if (fiber.tag === HostComponent && isHiddenSubtree(fiber)) {
                continue;
              } else {
                while (selector4 != null && matchSelector(fiber, selector4)) {
                  selectorIndex++;
                  selector4 = selectors[selectorIndex];
                }
              }
              if (selectorIndex === selectors.length) {
                return true;
              } else {
                var child = fiber.child;
                while (child !== null) {
                  stack.push(child, selectorIndex);
                  child = child.sibling;
                }
              }
            }
            return false;
          }
          function findAllNodes(hostRoot, selectors) {
            if (!supportsTestSelectors) {
              {
                {
                  throw Error("Test selector API is not supported by this renderer.");
                }
              }
            }
            var root2 = findFiberRootForHostRoot(hostRoot);
            var matchingFibers = findPaths(root2, selectors);
            var instanceRoots = [];
            var stack = Array.from(matchingFibers);
            var index2 = 0;
            while (index2 < stack.length) {
              var node = stack[index2++];
              if (node.tag === HostComponent) {
                if (isHiddenSubtree(node)) {
                  continue;
                }
                instanceRoots.push(node.stateNode);
              } else {
                var child = node.child;
                while (child !== null) {
                  stack.push(child);
                  child = child.sibling;
                }
              }
            }
            return instanceRoots;
          }
          function getFindAllNodesFailureDescription(hostRoot, selectors) {
            if (!supportsTestSelectors) {
              {
                {
                  throw Error("Test selector API is not supported by this renderer.");
                }
              }
            }
            var root2 = findFiberRootForHostRoot(hostRoot);
            var maxSelectorIndex = 0;
            var matchedNames = [];
            var stack = [root2, 0];
            var index2 = 0;
            while (index2 < stack.length) {
              var fiber = stack[index2++];
              var selectorIndex = stack[index2++];
              var selector4 = selectors[selectorIndex];
              if (fiber.tag === HostComponent && isHiddenSubtree(fiber)) {
                continue;
              } else if (matchSelector(fiber, selector4)) {
                matchedNames.push(selectorToString(selector4));
                selectorIndex++;
                if (selectorIndex > maxSelectorIndex) {
                  maxSelectorIndex = selectorIndex;
                }
              }
              if (selectorIndex < selectors.length) {
                var child = fiber.child;
                while (child !== null) {
                  stack.push(child, selectorIndex);
                  child = child.sibling;
                }
              }
            }
            if (maxSelectorIndex < selectors.length) {
              var unmatchedNames = [];
              for (var i = maxSelectorIndex; i < selectors.length; i++) {
                unmatchedNames.push(selectorToString(selectors[i]));
              }
              return "findAllNodes was able to match part of the selector:\n" + ("  " + matchedNames.join(" > ") + "\n\n") + "No matching component was found for:\n" + ("  " + unmatchedNames.join(" > "));
            }
            return null;
          }
          function findBoundingRects(hostRoot, selectors) {
            if (!supportsTestSelectors) {
              {
                {
                  throw Error("Test selector API is not supported by this renderer.");
                }
              }
            }
            var instanceRoots = findAllNodes(hostRoot, selectors);
            var boundingRects = [];
            for (var i = 0; i < instanceRoots.length; i++) {
              boundingRects.push(getBoundingRect(instanceRoots[i]));
            }
            for (var _i = boundingRects.length - 1; _i > 0; _i--) {
              var targetRect = boundingRects[_i];
              var targetLeft = targetRect.x;
              var targetRight = targetLeft + targetRect.width;
              var targetTop = targetRect.y;
              var targetBottom = targetTop + targetRect.height;
              for (var j2 = _i - 1; j2 >= 0; j2--) {
                if (_i !== j2) {
                  var otherRect = boundingRects[j2];
                  var otherLeft = otherRect.x;
                  var otherRight = otherLeft + otherRect.width;
                  var otherTop = otherRect.y;
                  var otherBottom = otherTop + otherRect.height;
                  if (targetLeft >= otherLeft && targetTop >= otherTop && targetRight <= otherRight && targetBottom <= otherBottom) {
                    boundingRects.splice(_i, 1);
                    break;
                  } else if (targetLeft === otherLeft && targetRect.width === otherRect.width && !(otherBottom < targetTop) && !(otherTop > targetBottom)) {
                    if (otherTop > targetTop) {
                      otherRect.height += otherTop - targetTop;
                      otherRect.y = targetTop;
                    }
                    if (otherBottom < targetBottom) {
                      otherRect.height = targetBottom - otherTop;
                    }
                    boundingRects.splice(_i, 1);
                    break;
                  } else if (targetTop === otherTop && targetRect.height === otherRect.height && !(otherRight < targetLeft) && !(otherLeft > targetRight)) {
                    if (otherLeft > targetLeft) {
                      otherRect.width += otherLeft - targetLeft;
                      otherRect.x = targetLeft;
                    }
                    if (otherRight < targetRight) {
                      otherRect.width = targetRight - otherLeft;
                    }
                    boundingRects.splice(_i, 1);
                    break;
                  }
                }
              }
            }
            return boundingRects;
          }
          function focusWithin(hostRoot, selectors) {
            if (!supportsTestSelectors) {
              {
                {
                  throw Error("Test selector API is not supported by this renderer.");
                }
              }
            }
            var root2 = findFiberRootForHostRoot(hostRoot);
            var matchingFibers = findPaths(root2, selectors);
            var stack = Array.from(matchingFibers);
            var index2 = 0;
            while (index2 < stack.length) {
              var fiber = stack[index2++];
              if (isHiddenSubtree(fiber)) {
                continue;
              }
              if (fiber.tag === HostComponent) {
                var node = fiber.stateNode;
                if (setFocusIfFocusable(node)) {
                  return true;
                }
              }
              var child = fiber.child;
              while (child !== null) {
                stack.push(child);
                child = child.sibling;
              }
            }
            return false;
          }
          var commitHooks = [];
          function onCommitRoot$1() {
            if (supportsTestSelectors) {
              commitHooks.forEach(function(commitHook) {
                return commitHook();
              });
            }
          }
          function observeVisibleRects(hostRoot, selectors, callback, options) {
            if (!supportsTestSelectors) {
              {
                {
                  throw Error("Test selector API is not supported by this renderer.");
                }
              }
            }
            var instanceRoots = findAllNodes(hostRoot, selectors);
            var _setupIntersectionObs = setupIntersectionObserver(instanceRoots, callback, options), disconnect = _setupIntersectionObs.disconnect, observe = _setupIntersectionObs.observe, unobserve = _setupIntersectionObs.unobserve;
            var commitHook = function() {
              var nextInstanceRoots = findAllNodes(hostRoot, selectors);
              instanceRoots.forEach(function(target) {
                if (nextInstanceRoots.indexOf(target) < 0) {
                  unobserve(target);
                }
              });
              nextInstanceRoots.forEach(function(target) {
                if (instanceRoots.indexOf(target) < 0) {
                  observe(target);
                }
              });
            };
            commitHooks.push(commitHook);
            return {
              disconnect: function() {
                var index2 = commitHooks.indexOf(commitHook);
                if (index2 >= 0) {
                  commitHooks.splice(index2, 1);
                }
                disconnect();
              }
            };
          }
          var didWarnAboutMessageChannel = false;
          var enqueueTaskImpl = null;
          function enqueueTask(task) {
            if (enqueueTaskImpl === null) {
              try {
                var requireString = ("require" + Math.random()).slice(0, 7);
                var nodeRequire = module2 && module2[requireString];
                enqueueTaskImpl = nodeRequire.call(module2, "timers").setImmediate;
              } catch (_err) {
                enqueueTaskImpl = function(callback) {
                  {
                    if (didWarnAboutMessageChannel === false) {
                      didWarnAboutMessageChannel = true;
                      if (typeof MessageChannel === "undefined") {
                        error2("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning.");
                      }
                    }
                  }
                  var channel = new MessageChannel();
                  channel.port1.onmessage = callback;
                  channel.port2.postMessage(void 0);
                };
              }
            }
            return enqueueTaskImpl(task);
          }
          var ceil = Math.ceil;
          var ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner, IsSomeRendererActing = ReactSharedInternals.IsSomeRendererActing;
          var NoContext = 0;
          var BatchedContext = 1;
          var EventContext = 2;
          var DiscreteEventContext = 4;
          var LegacyUnbatchedContext = 8;
          var RenderContext = 16;
          var CommitContext = 32;
          var RetryAfterError = 64;
          var RootIncomplete = 0;
          var RootFatalErrored = 1;
          var RootErrored = 2;
          var RootSuspended = 3;
          var RootSuspendedWithDelay = 4;
          var RootCompleted = 5;
          var executionContext = NoContext;
          var workInProgressRoot = null;
          var workInProgress = null;
          var workInProgressRootRenderLanes = NoLanes;
          var subtreeRenderLanes = NoLanes;
          var subtreeRenderLanesCursor = createCursor(NoLanes);
          var workInProgressRootExitStatus = RootIncomplete;
          var workInProgressRootFatalError = null;
          var workInProgressRootIncludedLanes = NoLanes;
          var workInProgressRootSkippedLanes = NoLanes;
          var workInProgressRootUpdatedLanes = NoLanes;
          var workInProgressRootPingedLanes = NoLanes;
          var mostRecentlyUpdatedRoot = null;
          var globalMostRecentFallbackTime = 0;
          var FALLBACK_THROTTLE_MS = 500;
          var workInProgressRootRenderTargetTime = Infinity;
          var RENDER_TIMEOUT_MS = 500;
          function resetRenderTimer() {
            workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS;
          }
          function getRenderTargetTime() {
            return workInProgressRootRenderTargetTime;
          }
          var nextEffect = null;
          var hasUncaughtError = false;
          var firstUncaughtError = null;
          var legacyErrorBoundariesThatAlreadyFailed = null;
          var rootDoesHavePassiveEffects = false;
          var rootWithPendingPassiveEffects = null;
          var pendingPassiveEffectsRenderPriority = NoPriority$1;
          var pendingPassiveEffectsLanes = NoLanes;
          var pendingPassiveHookEffectsMount = [];
          var pendingPassiveHookEffectsUnmount = [];
          var rootsWithPendingDiscreteUpdates = null;
          var NESTED_UPDATE_LIMIT = 50;
          var nestedUpdateCount = 0;
          var rootWithNestedUpdates = null;
          var NESTED_PASSIVE_UPDATE_LIMIT = 50;
          var nestedPassiveUpdateCount = 0;
          var spawnedWorkDuringRender = null;
          var currentEventTime = NoTimestamp;
          var currentEventWipLanes = NoLanes;
          var currentEventPendingLanes = NoLanes;
          var isFlushingPassiveEffects = false;
          var focusedInstanceHandle = null;
          var shouldFireAfterActiveInstanceBlur = false;
          function getWorkInProgressRoot() {
            return workInProgressRoot;
          }
          function requestEventTime() {
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
              return now$1();
            }
            if (currentEventTime !== NoTimestamp) {
              return currentEventTime;
            }
            currentEventTime = now$1();
            return currentEventTime;
          }
          function requestUpdateLane(fiber) {
            var mode = fiber.mode;
            if ((mode & BlockingMode) === NoMode) {
              return SyncLane;
            } else if ((mode & ConcurrentMode) === NoMode) {
              return getCurrentPriorityLevel() === ImmediatePriority$1 ? SyncLane : SyncBatchedLane;
            }
            if (currentEventWipLanes === NoLanes) {
              currentEventWipLanes = workInProgressRootIncludedLanes;
            }
            var isTransition = requestCurrentTransition() !== NoTransition;
            if (isTransition) {
              if (currentEventPendingLanes !== NoLanes) {
                currentEventPendingLanes = mostRecentlyUpdatedRoot !== null ? mostRecentlyUpdatedRoot.pendingLanes : NoLanes;
              }
              return findTransitionLane(currentEventWipLanes, currentEventPendingLanes);
            }
            var schedulerPriority = getCurrentPriorityLevel();
            var lane;
            if ((executionContext & DiscreteEventContext) !== NoContext && schedulerPriority === UserBlockingPriority$1) {
              lane = findUpdateLane(InputDiscreteLanePriority, currentEventWipLanes);
            } else {
              var schedulerLanePriority = schedulerPriorityToLanePriority(schedulerPriority);
              lane = findUpdateLane(schedulerLanePriority, currentEventWipLanes);
            }
            return lane;
          }
          function requestRetryLane(fiber) {
            var mode = fiber.mode;
            if ((mode & BlockingMode) === NoMode) {
              return SyncLane;
            } else if ((mode & ConcurrentMode) === NoMode) {
              return getCurrentPriorityLevel() === ImmediatePriority$1 ? SyncLane : SyncBatchedLane;
            }
            if (currentEventWipLanes === NoLanes) {
              currentEventWipLanes = workInProgressRootIncludedLanes;
            }
            return findRetryLane(currentEventWipLanes);
          }
          function scheduleUpdateOnFiber(fiber, lane, eventTime) {
            checkForNestedUpdates();
            warnAboutRenderPhaseUpdatesInDEV(fiber);
            var root2 = markUpdateLaneFromFiberToRoot(fiber, lane);
            if (root2 === null) {
              warnAboutUpdateOnUnmountedFiberInDEV(fiber);
              return null;
            }
            markRootUpdated(root2, lane, eventTime);
            if (root2 === workInProgressRoot) {
              {
                workInProgressRootUpdatedLanes = mergeLanes(workInProgressRootUpdatedLanes, lane);
              }
              if (workInProgressRootExitStatus === RootSuspendedWithDelay) {
                markRootSuspended$1(root2, workInProgressRootRenderLanes);
              }
            }
            var priorityLevel = getCurrentPriorityLevel();
            if (lane === SyncLane) {
              if ((executionContext & LegacyUnbatchedContext) !== NoContext && (executionContext & (RenderContext | CommitContext)) === NoContext) {
                schedulePendingInteractions(root2, lane);
                performSyncWorkOnRoot(root2);
              } else {
                ensureRootIsScheduled(root2, eventTime);
                schedulePendingInteractions(root2, lane);
                if (executionContext === NoContext) {
                  resetRenderTimer();
                  flushSyncCallbackQueue();
                }
              }
            } else {
              if ((executionContext & DiscreteEventContext) !== NoContext && (priorityLevel === UserBlockingPriority$1 || priorityLevel === ImmediatePriority$1)) {
                if (rootsWithPendingDiscreteUpdates === null) {
                  rootsWithPendingDiscreteUpdates = /* @__PURE__ */ new Set([root2]);
                } else {
                  rootsWithPendingDiscreteUpdates.add(root2);
                }
              }
              ensureRootIsScheduled(root2, eventTime);
              schedulePendingInteractions(root2, lane);
            }
            mostRecentlyUpdatedRoot = root2;
          }
          function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {
            sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);
            var alternate = sourceFiber.alternate;
            if (alternate !== null) {
              alternate.lanes = mergeLanes(alternate.lanes, lane);
            }
            {
              if (alternate === null && (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags) {
                warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
              }
            }
            var node = sourceFiber;
            var parent = sourceFiber.return;
            while (parent !== null) {
              parent.childLanes = mergeLanes(parent.childLanes, lane);
              alternate = parent.alternate;
              if (alternate !== null) {
                alternate.childLanes = mergeLanes(alternate.childLanes, lane);
              } else {
                {
                  if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {
                    warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
                  }
                }
              }
              node = parent;
              parent = parent.return;
            }
            if (node.tag === HostRoot) {
              var root2 = node.stateNode;
              return root2;
            } else {
              return null;
            }
          }
          function ensureRootIsScheduled(root2, currentTime) {
            var existingCallbackNode = root2.callbackNode;
            markStarvedLanesAsExpired(root2, currentTime);
            var nextLanes = getNextLanes(root2, root2 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
            var newCallbackPriority = returnNextLanesPriority();
            if (nextLanes === NoLanes) {
              if (existingCallbackNode !== null) {
                cancelCallback(existingCallbackNode);
                root2.callbackNode = null;
                root2.callbackPriority = NoLanePriority;
              }
              return;
            }
            if (existingCallbackNode !== null) {
              var existingCallbackPriority = root2.callbackPriority;
              if (existingCallbackPriority === newCallbackPriority) {
                return;
              }
              cancelCallback(existingCallbackNode);
            }
            var newCallbackNode;
            if (newCallbackPriority === SyncLanePriority) {
              newCallbackNode = scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root2));
            } else if (newCallbackPriority === SyncBatchedLanePriority) {
              newCallbackNode = scheduleCallback(ImmediatePriority$1, performSyncWorkOnRoot.bind(null, root2));
            } else {
              var schedulerPriorityLevel = lanePriorityToSchedulerPriority(newCallbackPriority);
              newCallbackNode = scheduleCallback(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root2));
            }
            root2.callbackPriority = newCallbackPriority;
            root2.callbackNode = newCallbackNode;
          }
          function performConcurrentWorkOnRoot(root2) {
            currentEventTime = NoTimestamp;
            currentEventWipLanes = NoLanes;
            currentEventPendingLanes = NoLanes;
            if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
              {
                throw Error("Should not already be working.");
              }
            }
            var originalCallbackNode = root2.callbackNode;
            var didFlushPassiveEffects = flushPassiveEffects();
            if (didFlushPassiveEffects) {
              if (root2.callbackNode !== originalCallbackNode) {
                return null;
              }
            }
            var lanes = getNextLanes(root2, root2 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
            if (lanes === NoLanes) {
              return null;
            }
            var exitStatus = renderRootConcurrent(root2, lanes);
            if (includesSomeLane(workInProgressRootIncludedLanes, workInProgressRootUpdatedLanes)) {
              prepareFreshStack(root2, NoLanes);
            } else if (exitStatus !== RootIncomplete) {
              if (exitStatus === RootErrored) {
                executionContext |= RetryAfterError;
                if (root2.hydrate) {
                  root2.hydrate = false;
                  clearContainer(root2.containerInfo);
                }
                lanes = getLanesToRetrySynchronouslyOnError(root2);
                if (lanes !== NoLanes) {
                  exitStatus = renderRootSync(root2, lanes);
                }
              }
              if (exitStatus === RootFatalErrored) {
                var fatalError = workInProgressRootFatalError;
                prepareFreshStack(root2, NoLanes);
                markRootSuspended$1(root2, lanes);
                ensureRootIsScheduled(root2, now$1());
                throw fatalError;
              }
              var finishedWork = root2.current.alternate;
              root2.finishedWork = finishedWork;
              root2.finishedLanes = lanes;
              finishConcurrentRender(root2, exitStatus, lanes);
            }
            ensureRootIsScheduled(root2, now$1());
            if (root2.callbackNode === originalCallbackNode) {
              return performConcurrentWorkOnRoot.bind(null, root2);
            }
            return null;
          }
          function finishConcurrentRender(root2, exitStatus, lanes) {
            switch (exitStatus) {
              case RootIncomplete:
              case RootFatalErrored: {
                {
                  {
                    throw Error("Root did not complete. This is a bug in React.");
                  }
                }
              }
              case RootErrored: {
                commitRoot(root2);
                break;
              }
              case RootSuspended: {
                markRootSuspended$1(root2, lanes);
                if (includesOnlyRetries(lanes) && !shouldForceFlushFallbacksInDEV()) {
                  var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now$1();
                  if (msUntilTimeout > 10) {
                    var nextLanes = getNextLanes(root2, NoLanes);
                    if (nextLanes !== NoLanes) {
                      break;
                    }
                    var suspendedLanes = root2.suspendedLanes;
                    if (!isSubsetOfLanes(suspendedLanes, lanes)) {
                      var eventTime = requestEventTime();
                      markRootPinged(root2, suspendedLanes);
                      break;
                    }
                    root2.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root2), msUntilTimeout);
                    break;
                  }
                }
                commitRoot(root2);
                break;
              }
              case RootSuspendedWithDelay: {
                markRootSuspended$1(root2, lanes);
                if (includesOnlyTransitions(lanes)) {
                  break;
                }
                if (!shouldForceFlushFallbacksInDEV()) {
                  var mostRecentEventTime = getMostRecentEventTime(root2, lanes);
                  var eventTimeMs = mostRecentEventTime;
                  var timeElapsedMs = now$1() - eventTimeMs;
                  var _msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;
                  if (_msUntilTimeout > 10) {
                    root2.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root2), _msUntilTimeout);
                    break;
                  }
                }
                commitRoot(root2);
                break;
              }
              case RootCompleted: {
                commitRoot(root2);
                break;
              }
              default: {
                {
                  {
                    throw Error("Unknown root exit status.");
                  }
                }
              }
            }
          }
          function markRootSuspended$1(root2, suspendedLanes) {
            suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);
            suspendedLanes = removeLanes(suspendedLanes, workInProgressRootUpdatedLanes);
            markRootSuspended(root2, suspendedLanes);
          }
          function performSyncWorkOnRoot(root2) {
            if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
              {
                throw Error("Should not already be working.");
              }
            }
            flushPassiveEffects();
            var lanes;
            var exitStatus;
            if (root2 === workInProgressRoot && includesSomeLane(root2.expiredLanes, workInProgressRootRenderLanes)) {
              lanes = workInProgressRootRenderLanes;
              exitStatus = renderRootSync(root2, lanes);
              if (includesSomeLane(workInProgressRootIncludedLanes, workInProgressRootUpdatedLanes)) {
                lanes = getNextLanes(root2, lanes);
                exitStatus = renderRootSync(root2, lanes);
              }
            } else {
              lanes = getNextLanes(root2, NoLanes);
              exitStatus = renderRootSync(root2, lanes);
            }
            if (root2.tag !== LegacyRoot && exitStatus === RootErrored) {
              executionContext |= RetryAfterError;
              if (root2.hydrate) {
                root2.hydrate = false;
                clearContainer(root2.containerInfo);
              }
              lanes = getLanesToRetrySynchronouslyOnError(root2);
              if (lanes !== NoLanes) {
                exitStatus = renderRootSync(root2, lanes);
              }
            }
            if (exitStatus === RootFatalErrored) {
              var fatalError = workInProgressRootFatalError;
              prepareFreshStack(root2, NoLanes);
              markRootSuspended$1(root2, lanes);
              ensureRootIsScheduled(root2, now$1());
              throw fatalError;
            }
            var finishedWork = root2.current.alternate;
            root2.finishedWork = finishedWork;
            root2.finishedLanes = lanes;
            commitRoot(root2);
            ensureRootIsScheduled(root2, now$1());
            return null;
          }
          function flushRoot(root2, lanes) {
            markRootExpired(root2, lanes);
            ensureRootIsScheduled(root2, now$1());
            if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
              resetRenderTimer();
              flushSyncCallbackQueue();
            }
          }
          function flushDiscreteUpdates() {
            if ((executionContext & (BatchedContext | RenderContext | CommitContext)) !== NoContext) {
              {
                if ((executionContext & RenderContext) !== NoContext) {
                  error2("unstable_flushDiscreteUpdates: Cannot flush updates when React is already rendering.");
                }
              }
              return;
            }
            flushPendingDiscreteUpdates();
            flushPassiveEffects();
          }
          function deferredUpdates(fn2) {
            {
              return runWithPriority(NormalPriority$1, fn2);
            }
          }
          function flushPendingDiscreteUpdates() {
            if (rootsWithPendingDiscreteUpdates !== null) {
              var roots = rootsWithPendingDiscreteUpdates;
              rootsWithPendingDiscreteUpdates = null;
              roots.forEach(function(root2) {
                markDiscreteUpdatesExpired(root2);
                ensureRootIsScheduled(root2, now$1());
              });
            }
            flushSyncCallbackQueue();
          }
          function batchedUpdates(fn2, a) {
            var prevExecutionContext = executionContext;
            executionContext |= BatchedContext;
            try {
              return fn2(a);
            } finally {
              executionContext = prevExecutionContext;
              if (executionContext === NoContext) {
                resetRenderTimer();
                flushSyncCallbackQueue();
              }
            }
          }
          function batchedEventUpdates(fn2, a) {
            var prevExecutionContext = executionContext;
            executionContext |= EventContext;
            try {
              return fn2(a);
            } finally {
              executionContext = prevExecutionContext;
              if (executionContext === NoContext) {
                resetRenderTimer();
                flushSyncCallbackQueue();
              }
            }
          }
          function discreteUpdates(fn2, a, b2, c2, d2) {
            var prevExecutionContext = executionContext;
            executionContext |= DiscreteEventContext;
            {
              try {
                return runWithPriority(UserBlockingPriority$1, fn2.bind(null, a, b2, c2, d2));
              } finally {
                executionContext = prevExecutionContext;
                if (executionContext === NoContext) {
                  resetRenderTimer();
                  flushSyncCallbackQueue();
                }
              }
            }
          }
          function unbatchedUpdates(fn2, a) {
            var prevExecutionContext = executionContext;
            executionContext &= ~BatchedContext;
            executionContext |= LegacyUnbatchedContext;
            try {
              return fn2(a);
            } finally {
              executionContext = prevExecutionContext;
              if (executionContext === NoContext) {
                resetRenderTimer();
                flushSyncCallbackQueue();
              }
            }
          }
          function flushSync(fn2, a) {
            var prevExecutionContext = executionContext;
            if ((prevExecutionContext & (RenderContext | CommitContext)) !== NoContext) {
              {
                error2("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.");
              }
              return fn2(a);
            }
            executionContext |= BatchedContext;
            {
              try {
                if (fn2) {
                  return runWithPriority(ImmediatePriority$1, fn2.bind(null, a));
                } else {
                  return void 0;
                }
              } finally {
                executionContext = prevExecutionContext;
                flushSyncCallbackQueue();
              }
            }
          }
          function flushControlled(fn2) {
            var prevExecutionContext = executionContext;
            executionContext |= BatchedContext;
            {
              try {
                runWithPriority(ImmediatePriority$1, fn2);
              } finally {
                executionContext = prevExecutionContext;
                if (executionContext === NoContext) {
                  resetRenderTimer();
                  flushSyncCallbackQueue();
                }
              }
            }
          }
          function pushRenderLanes(fiber, lanes) {
            push(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);
            subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);
            workInProgressRootIncludedLanes = mergeLanes(workInProgressRootIncludedLanes, lanes);
          }
          function popRenderLanes(fiber) {
            subtreeRenderLanes = subtreeRenderLanesCursor.current;
            pop(subtreeRenderLanesCursor, fiber);
          }
          function prepareFreshStack(root2, lanes) {
            root2.finishedWork = null;
            root2.finishedLanes = NoLanes;
            var timeoutHandle = root2.timeoutHandle;
            if (timeoutHandle !== noTimeout) {
              root2.timeoutHandle = noTimeout;
              cancelTimeout(timeoutHandle);
            }
            if (workInProgress !== null) {
              var interruptedWork = workInProgress.return;
              while (interruptedWork !== null) {
                unwindInterruptedWork(interruptedWork);
                interruptedWork = interruptedWork.return;
              }
            }
            workInProgressRoot = root2;
            workInProgress = createWorkInProgress(root2.current, null);
            workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;
            workInProgressRootExitStatus = RootIncomplete;
            workInProgressRootFatalError = null;
            workInProgressRootSkippedLanes = NoLanes;
            workInProgressRootUpdatedLanes = NoLanes;
            workInProgressRootPingedLanes = NoLanes;
            {
              spawnedWorkDuringRender = null;
            }
            {
              ReactStrictModeWarnings.discardPendingWarnings();
            }
          }
          function handleError(root2, thrownValue) {
            do {
              var erroredWork = workInProgress;
              try {
                resetContextDependencies();
                resetHooksAfterThrow();
                resetCurrentFiber();
                ReactCurrentOwner$2.current = null;
                if (erroredWork === null || erroredWork.return === null) {
                  workInProgressRootExitStatus = RootFatalErrored;
                  workInProgressRootFatalError = thrownValue;
                  workInProgress = null;
                  return;
                }
                if (enableProfilerTimer && erroredWork.mode & ProfileMode) {
                  stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);
                }
                throwException(root2, erroredWork.return, erroredWork, thrownValue, workInProgressRootRenderLanes);
                completeUnitOfWork(erroredWork);
              } catch (yetAnotherThrownValue) {
                thrownValue = yetAnotherThrownValue;
                if (workInProgress === erroredWork && erroredWork !== null) {
                  erroredWork = erroredWork.return;
                  workInProgress = erroredWork;
                } else {
                  erroredWork = workInProgress;
                }
                continue;
              }
              return;
            } while (true);
          }
          function pushDispatcher() {
            var prevDispatcher = ReactCurrentDispatcher$2.current;
            ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;
            if (prevDispatcher === null) {
              return ContextOnlyDispatcher;
            } else {
              return prevDispatcher;
            }
          }
          function popDispatcher(prevDispatcher) {
            ReactCurrentDispatcher$2.current = prevDispatcher;
          }
          function pushInteractions(root2) {
            {
              var prevInteractions = tracing.__interactionsRef.current;
              tracing.__interactionsRef.current = root2.memoizedInteractions;
              return prevInteractions;
            }
          }
          function popInteractions(prevInteractions) {
            {
              tracing.__interactionsRef.current = prevInteractions;
            }
          }
          function markCommitTimeOfFallback() {
            globalMostRecentFallbackTime = now$1();
          }
          function markSkippedUpdateLanes(lane) {
            workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);
          }
          function renderDidSuspend() {
            if (workInProgressRootExitStatus === RootIncomplete) {
              workInProgressRootExitStatus = RootSuspended;
            }
          }
          function renderDidSuspendDelayIfPossible() {
            if (workInProgressRootExitStatus === RootIncomplete || workInProgressRootExitStatus === RootSuspended) {
              workInProgressRootExitStatus = RootSuspendedWithDelay;
            }
            if (workInProgressRoot !== null && (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootUpdatedLanes))) {
              markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);
            }
          }
          function renderDidError() {
            if (workInProgressRootExitStatus !== RootCompleted) {
              workInProgressRootExitStatus = RootErrored;
            }
          }
          function renderHasNotSuspendedYet() {
            return workInProgressRootExitStatus === RootIncomplete;
          }
          function renderRootSync(root2, lanes) {
            var prevExecutionContext = executionContext;
            executionContext |= RenderContext;
            var prevDispatcher = pushDispatcher();
            if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
              prepareFreshStack(root2, lanes);
              startWorkOnPendingInteractions(root2, lanes);
            }
            var prevInteractions = pushInteractions(root2);
            do {
              try {
                workLoopSync();
                break;
              } catch (thrownValue) {
                handleError(root2, thrownValue);
              }
            } while (true);
            resetContextDependencies();
            {
              popInteractions(prevInteractions);
            }
            executionContext = prevExecutionContext;
            popDispatcher(prevDispatcher);
            if (workInProgress !== null) {
              {
                {
                  throw Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
            }
            workInProgressRoot = null;
            workInProgressRootRenderLanes = NoLanes;
            return workInProgressRootExitStatus;
          }
          function workLoopSync() {
            while (workInProgress !== null) {
              performUnitOfWork(workInProgress);
            }
          }
          function renderRootConcurrent(root2, lanes) {
            var prevExecutionContext = executionContext;
            executionContext |= RenderContext;
            var prevDispatcher = pushDispatcher();
            if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
              resetRenderTimer();
              prepareFreshStack(root2, lanes);
              startWorkOnPendingInteractions(root2, lanes);
            }
            var prevInteractions = pushInteractions(root2);
            do {
              try {
                workLoopConcurrent();
                break;
              } catch (thrownValue) {
                handleError(root2, thrownValue);
              }
            } while (true);
            resetContextDependencies();
            {
              popInteractions(prevInteractions);
            }
            popDispatcher(prevDispatcher);
            executionContext = prevExecutionContext;
            if (workInProgress !== null) {
              return RootIncomplete;
            } else {
              workInProgressRoot = null;
              workInProgressRootRenderLanes = NoLanes;
              return workInProgressRootExitStatus;
            }
          }
          function workLoopConcurrent() {
            while (workInProgress !== null && !shouldYield()) {
              performUnitOfWork(workInProgress);
            }
          }
          function performUnitOfWork(unitOfWork) {
            var current2 = unitOfWork.alternate;
            setCurrentFiber(unitOfWork);
            var next;
            if ((unitOfWork.mode & ProfileMode) !== NoMode) {
              startProfilerTimer(unitOfWork);
              next = beginWork$1(current2, unitOfWork, subtreeRenderLanes);
              stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);
            } else {
              next = beginWork$1(current2, unitOfWork, subtreeRenderLanes);
            }
            resetCurrentFiber();
            unitOfWork.memoizedProps = unitOfWork.pendingProps;
            if (next === null) {
              completeUnitOfWork(unitOfWork);
            } else {
              workInProgress = next;
            }
            ReactCurrentOwner$2.current = null;
          }
          function completeUnitOfWork(unitOfWork) {
            var completedWork = unitOfWork;
            do {
              var current2 = completedWork.alternate;
              var returnFiber = completedWork.return;
              if ((completedWork.flags & Incomplete) === NoFlags) {
                setCurrentFiber(completedWork);
                var next = void 0;
                if ((completedWork.mode & ProfileMode) === NoMode) {
                  next = completeWork(current2, completedWork, subtreeRenderLanes);
                } else {
                  startProfilerTimer(completedWork);
                  next = completeWork(current2, completedWork, subtreeRenderLanes);
                  stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
                }
                resetCurrentFiber();
                if (next !== null) {
                  workInProgress = next;
                  return;
                }
                resetChildLanes(completedWork);
                if (returnFiber !== null && (returnFiber.flags & Incomplete) === NoFlags) {
                  if (returnFiber.firstEffect === null) {
                    returnFiber.firstEffect = completedWork.firstEffect;
                  }
                  if (completedWork.lastEffect !== null) {
                    if (returnFiber.lastEffect !== null) {
                      returnFiber.lastEffect.nextEffect = completedWork.firstEffect;
                    }
                    returnFiber.lastEffect = completedWork.lastEffect;
                  }
                  var flags = completedWork.flags;
                  if (flags > PerformedWork) {
                    if (returnFiber.lastEffect !== null) {
                      returnFiber.lastEffect.nextEffect = completedWork;
                    } else {
                      returnFiber.firstEffect = completedWork;
                    }
                    returnFiber.lastEffect = completedWork;
                  }
                }
              } else {
                var _next = unwindWork(completedWork);
                if (_next !== null) {
                  _next.flags &= HostEffectMask;
                  workInProgress = _next;
                  return;
                }
                if ((completedWork.mode & ProfileMode) !== NoMode) {
                  stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
                  var actualDuration = completedWork.actualDuration;
                  var child = completedWork.child;
                  while (child !== null) {
                    actualDuration += child.actualDuration;
                    child = child.sibling;
                  }
                  completedWork.actualDuration = actualDuration;
                }
                if (returnFiber !== null) {
                  returnFiber.firstEffect = returnFiber.lastEffect = null;
                  returnFiber.flags |= Incomplete;
                }
              }
              var siblingFiber = completedWork.sibling;
              if (siblingFiber !== null) {
                workInProgress = siblingFiber;
                return;
              }
              completedWork = returnFiber;
              workInProgress = completedWork;
            } while (completedWork !== null);
            if (workInProgressRootExitStatus === RootIncomplete) {
              workInProgressRootExitStatus = RootCompleted;
            }
          }
          function resetChildLanes(completedWork) {
            if ((completedWork.tag === LegacyHiddenComponent || completedWork.tag === OffscreenComponent) && completedWork.memoizedState !== null && !includesSomeLane(subtreeRenderLanes, OffscreenLane) && (completedWork.mode & ConcurrentMode) !== NoLanes) {
              return;
            }
            var newChildLanes = NoLanes;
            if ((completedWork.mode & ProfileMode) !== NoMode) {
              var actualDuration = completedWork.actualDuration;
              var treeBaseDuration = completedWork.selfBaseDuration;
              var shouldBubbleActualDurations = completedWork.alternate === null || completedWork.child !== completedWork.alternate.child;
              var child = completedWork.child;
              while (child !== null) {
                newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));
                if (shouldBubbleActualDurations) {
                  actualDuration += child.actualDuration;
                }
                treeBaseDuration += child.treeBaseDuration;
                child = child.sibling;
              }
              var isTimedOutSuspense = completedWork.tag === SuspenseComponent && completedWork.memoizedState !== null;
              if (isTimedOutSuspense) {
                var primaryChildFragment = completedWork.child;
                if (primaryChildFragment !== null) {
                  treeBaseDuration -= primaryChildFragment.treeBaseDuration;
                }
              }
              completedWork.actualDuration = actualDuration;
              completedWork.treeBaseDuration = treeBaseDuration;
            } else {
              var _child = completedWork.child;
              while (_child !== null) {
                newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes));
                _child = _child.sibling;
              }
            }
            completedWork.childLanes = newChildLanes;
          }
          function commitRoot(root2) {
            var renderPriorityLevel = getCurrentPriorityLevel();
            runWithPriority(ImmediatePriority$1, commitRootImpl.bind(null, root2, renderPriorityLevel));
            return null;
          }
          function commitRootImpl(root2, renderPriorityLevel) {
            do {
              flushPassiveEffects();
            } while (rootWithPendingPassiveEffects !== null);
            flushRenderPhaseStrictModeWarningsInDEV();
            if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
              {
                throw Error("Should not already be working.");
              }
            }
            var finishedWork = root2.finishedWork;
            var lanes = root2.finishedLanes;
            if (finishedWork === null) {
              return null;
            }
            root2.finishedWork = null;
            root2.finishedLanes = NoLanes;
            if (!(finishedWork !== root2.current)) {
              {
                throw Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            root2.callbackNode = null;
            var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);
            markRootFinished(root2, remainingLanes);
            if (rootsWithPendingDiscreteUpdates !== null) {
              if (!hasDiscreteLanes(remainingLanes) && rootsWithPendingDiscreteUpdates.has(root2)) {
                rootsWithPendingDiscreteUpdates.delete(root2);
              }
            }
            if (root2 === workInProgressRoot) {
              workInProgressRoot = null;
              workInProgress = null;
              workInProgressRootRenderLanes = NoLanes;
            }
            var firstEffect;
            if (finishedWork.flags > PerformedWork) {
              if (finishedWork.lastEffect !== null) {
                finishedWork.lastEffect.nextEffect = finishedWork;
                firstEffect = finishedWork.firstEffect;
              } else {
                firstEffect = finishedWork;
              }
            } else {
              firstEffect = finishedWork.firstEffect;
            }
            if (firstEffect !== null) {
              var prevExecutionContext = executionContext;
              executionContext |= CommitContext;
              var prevInteractions = pushInteractions(root2);
              ReactCurrentOwner$2.current = null;
              focusedInstanceHandle = prepareForCommit(root2.containerInfo);
              shouldFireAfterActiveInstanceBlur = false;
              nextEffect = firstEffect;
              do {
                {
                  invokeGuardedCallback(null, commitBeforeMutationEffects, null);
                  if (hasCaughtError()) {
                    if (!(nextEffect !== null)) {
                      {
                        throw Error("Should be working on an effect.");
                      }
                    }
                    var error3 = clearCaughtError();
                    captureCommitPhaseError(nextEffect, error3);
                    nextEffect = nextEffect.nextEffect;
                  }
                }
              } while (nextEffect !== null);
              focusedInstanceHandle = null;
              {
                recordCommitTime();
              }
              nextEffect = firstEffect;
              do {
                {
                  invokeGuardedCallback(null, commitMutationEffects, null, root2, renderPriorityLevel);
                  if (hasCaughtError()) {
                    if (!(nextEffect !== null)) {
                      {
                        throw Error("Should be working on an effect.");
                      }
                    }
                    var _error = clearCaughtError();
                    captureCommitPhaseError(nextEffect, _error);
                    nextEffect = nextEffect.nextEffect;
                  }
                }
              } while (nextEffect !== null);
              if (shouldFireAfterActiveInstanceBlur) {
                afterActiveInstanceBlur();
              }
              resetAfterCommit(root2.containerInfo);
              root2.current = finishedWork;
              nextEffect = firstEffect;
              do {
                {
                  invokeGuardedCallback(null, commitLayoutEffects, null, root2, lanes);
                  if (hasCaughtError()) {
                    if (!(nextEffect !== null)) {
                      {
                        throw Error("Should be working on an effect.");
                      }
                    }
                    var _error2 = clearCaughtError();
                    captureCommitPhaseError(nextEffect, _error2);
                    nextEffect = nextEffect.nextEffect;
                  }
                }
              } while (nextEffect !== null);
              nextEffect = null;
              requestPaint();
              {
                popInteractions(prevInteractions);
              }
              executionContext = prevExecutionContext;
            } else {
              root2.current = finishedWork;
              {
                recordCommitTime();
              }
            }
            var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;
            if (rootDoesHavePassiveEffects) {
              rootDoesHavePassiveEffects = false;
              rootWithPendingPassiveEffects = root2;
              pendingPassiveEffectsLanes = lanes;
              pendingPassiveEffectsRenderPriority = renderPriorityLevel;
            } else {
              nextEffect = firstEffect;
              while (nextEffect !== null) {
                var nextNextEffect = nextEffect.nextEffect;
                nextEffect.nextEffect = null;
                if (nextEffect.flags & Deletion) {
                  detachFiberAfterEffects(nextEffect);
                }
                nextEffect = nextNextEffect;
              }
            }
            remainingLanes = root2.pendingLanes;
            if (remainingLanes !== NoLanes) {
              {
                if (spawnedWorkDuringRender !== null) {
                  var expirationTimes = spawnedWorkDuringRender;
                  spawnedWorkDuringRender = null;
                  for (var i = 0; i < expirationTimes.length; i++) {
                    scheduleInteractions(root2, expirationTimes[i], root2.memoizedInteractions);
                  }
                }
                schedulePendingInteractions(root2, remainingLanes);
              }
            } else {
              legacyErrorBoundariesThatAlreadyFailed = null;
            }
            {
              if (!rootDidHavePassiveEffects) {
                finishPendingInteractions(root2, lanes);
              }
            }
            if (remainingLanes === SyncLane) {
              if (root2 === rootWithNestedUpdates) {
                nestedUpdateCount++;
              } else {
                nestedUpdateCount = 0;
                rootWithNestedUpdates = root2;
              }
            } else {
              nestedUpdateCount = 0;
            }
            onCommitRoot(finishedWork.stateNode, renderPriorityLevel);
            {
              onCommitRoot$1();
            }
            ensureRootIsScheduled(root2, now$1());
            if (hasUncaughtError) {
              hasUncaughtError = false;
              var _error3 = firstUncaughtError;
              firstUncaughtError = null;
              throw _error3;
            }
            if ((executionContext & LegacyUnbatchedContext) !== NoContext) {
              return null;
            }
            flushSyncCallbackQueue();
            return null;
          }
          function commitBeforeMutationEffects() {
            while (nextEffect !== null) {
              var current2 = nextEffect.alternate;
              if (!shouldFireAfterActiveInstanceBlur && focusedInstanceHandle !== null) {
                if ((nextEffect.flags & Deletion) !== NoFlags) {
                  if (doesFiberContain(nextEffect, focusedInstanceHandle)) {
                    shouldFireAfterActiveInstanceBlur = true;
                    beforeActiveInstanceBlur();
                  }
                } else {
                  if (nextEffect.tag === SuspenseComponent && isSuspenseBoundaryBeingHidden(current2, nextEffect) && doesFiberContain(nextEffect, focusedInstanceHandle)) {
                    shouldFireAfterActiveInstanceBlur = true;
                    beforeActiveInstanceBlur();
                  }
                }
              }
              var flags = nextEffect.flags;
              if ((flags & Snapshot) !== NoFlags) {
                setCurrentFiber(nextEffect);
                commitBeforeMutationLifeCycles(current2, nextEffect);
                resetCurrentFiber();
              }
              if ((flags & Passive) !== NoFlags) {
                if (!rootDoesHavePassiveEffects) {
                  rootDoesHavePassiveEffects = true;
                  scheduleCallback(NormalPriority$1, function() {
                    flushPassiveEffects();
                    return null;
                  });
                }
              }
              nextEffect = nextEffect.nextEffect;
            }
          }
          function commitMutationEffects(root2, renderPriorityLevel) {
            while (nextEffect !== null) {
              setCurrentFiber(nextEffect);
              var flags = nextEffect.flags;
              if (flags & ContentReset) {
                commitResetTextContent(nextEffect);
              }
              if (flags & Ref) {
                var current2 = nextEffect.alternate;
                if (current2 !== null) {
                  commitDetachRef(current2);
                }
              }
              var primaryFlags = flags & (Placement | Update | Deletion | Hydrating);
              switch (primaryFlags) {
                case Placement: {
                  commitPlacement(nextEffect);
                  nextEffect.flags &= ~Placement;
                  break;
                }
                case PlacementAndUpdate: {
                  commitPlacement(nextEffect);
                  nextEffect.flags &= ~Placement;
                  var _current = nextEffect.alternate;
                  commitWork(_current, nextEffect);
                  break;
                }
                case Hydrating: {
                  nextEffect.flags &= ~Hydrating;
                  break;
                }
                case HydratingAndUpdate: {
                  nextEffect.flags &= ~Hydrating;
                  var _current2 = nextEffect.alternate;
                  commitWork(_current2, nextEffect);
                  break;
                }
                case Update: {
                  var _current3 = nextEffect.alternate;
                  commitWork(_current3, nextEffect);
                  break;
                }
                case Deletion: {
                  commitDeletion(root2, nextEffect);
                  break;
                }
              }
              resetCurrentFiber();
              nextEffect = nextEffect.nextEffect;
            }
          }
          function commitLayoutEffects(root2, committedLanes) {
            while (nextEffect !== null) {
              setCurrentFiber(nextEffect);
              var flags = nextEffect.flags;
              if (flags & (Update | Callback)) {
                var current2 = nextEffect.alternate;
                commitLifeCycles(root2, current2, nextEffect);
              }
              {
                if (flags & Ref) {
                  commitAttachRef(nextEffect);
                }
              }
              resetCurrentFiber();
              nextEffect = nextEffect.nextEffect;
            }
          }
          function flushPassiveEffects() {
            if (pendingPassiveEffectsRenderPriority !== NoPriority$1) {
              var priorityLevel = pendingPassiveEffectsRenderPriority > NormalPriority$1 ? NormalPriority$1 : pendingPassiveEffectsRenderPriority;
              pendingPassiveEffectsRenderPriority = NoPriority$1;
              {
                return runWithPriority(priorityLevel, flushPassiveEffectsImpl);
              }
            }
            return false;
          }
          function enqueuePendingPassiveHookEffectMount(fiber, effect) {
            pendingPassiveHookEffectsMount.push(effect, fiber);
            if (!rootDoesHavePassiveEffects) {
              rootDoesHavePassiveEffects = true;
              scheduleCallback(NormalPriority$1, function() {
                flushPassiveEffects();
                return null;
              });
            }
          }
          function enqueuePendingPassiveHookEffectUnmount(fiber, effect) {
            pendingPassiveHookEffectsUnmount.push(effect, fiber);
            {
              fiber.flags |= PassiveUnmountPendingDev;
              var alternate = fiber.alternate;
              if (alternate !== null) {
                alternate.flags |= PassiveUnmountPendingDev;
              }
            }
            if (!rootDoesHavePassiveEffects) {
              rootDoesHavePassiveEffects = true;
              scheduleCallback(NormalPriority$1, function() {
                flushPassiveEffects();
                return null;
              });
            }
          }
          function invokePassiveEffectCreate(effect) {
            var create5 = effect.create;
            effect.destroy = create5();
          }
          function flushPassiveEffectsImpl() {
            if (rootWithPendingPassiveEffects === null) {
              return false;
            }
            var root2 = rootWithPendingPassiveEffects;
            var lanes = pendingPassiveEffectsLanes;
            rootWithPendingPassiveEffects = null;
            pendingPassiveEffectsLanes = NoLanes;
            if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
              {
                throw Error("Cannot flush passive effects while already rendering.");
              }
            }
            {
              isFlushingPassiveEffects = true;
            }
            var prevExecutionContext = executionContext;
            executionContext |= CommitContext;
            var prevInteractions = pushInteractions(root2);
            var unmountEffects = pendingPassiveHookEffectsUnmount;
            pendingPassiveHookEffectsUnmount = [];
            for (var i = 0; i < unmountEffects.length; i += 2) {
              var _effect = unmountEffects[i];
              var fiber = unmountEffects[i + 1];
              var destroy = _effect.destroy;
              _effect.destroy = void 0;
              {
                fiber.flags &= ~PassiveUnmountPendingDev;
                var alternate = fiber.alternate;
                if (alternate !== null) {
                  alternate.flags &= ~PassiveUnmountPendingDev;
                }
              }
              if (typeof destroy === "function") {
                {
                  setCurrentFiber(fiber);
                  {
                    invokeGuardedCallback(null, destroy, null);
                  }
                  if (hasCaughtError()) {
                    if (!(fiber !== null)) {
                      {
                        throw Error("Should be working on an effect.");
                      }
                    }
                    var error3 = clearCaughtError();
                    captureCommitPhaseError(fiber, error3);
                  }
                  resetCurrentFiber();
                }
              }
            }
            var mountEffects = pendingPassiveHookEffectsMount;
            pendingPassiveHookEffectsMount = [];
            for (var _i = 0; _i < mountEffects.length; _i += 2) {
              var _effect2 = mountEffects[_i];
              var _fiber = mountEffects[_i + 1];
              {
                setCurrentFiber(_fiber);
                {
                  invokeGuardedCallback(null, invokePassiveEffectCreate, null, _effect2);
                }
                if (hasCaughtError()) {
                  if (!(_fiber !== null)) {
                    {
                      throw Error("Should be working on an effect.");
                    }
                  }
                  var _error4 = clearCaughtError();
                  captureCommitPhaseError(_fiber, _error4);
                }
                resetCurrentFiber();
              }
            }
            var effect = root2.current.firstEffect;
            while (effect !== null) {
              var nextNextEffect = effect.nextEffect;
              effect.nextEffect = null;
              if (effect.flags & Deletion) {
                detachFiberAfterEffects(effect);
              }
              effect = nextNextEffect;
            }
            {
              popInteractions(prevInteractions);
              finishPendingInteractions(root2, lanes);
            }
            {
              isFlushingPassiveEffects = false;
            }
            executionContext = prevExecutionContext;
            flushSyncCallbackQueue();
            nestedPassiveUpdateCount = rootWithPendingPassiveEffects === null ? 0 : nestedPassiveUpdateCount + 1;
            return true;
          }
          function isAlreadyFailedLegacyErrorBoundary(instance2) {
            return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance2);
          }
          function markLegacyErrorBoundaryAsFailed(instance2) {
            if (legacyErrorBoundariesThatAlreadyFailed === null) {
              legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([instance2]);
            } else {
              legacyErrorBoundariesThatAlreadyFailed.add(instance2);
            }
          }
          function prepareToThrowUncaughtError(error3) {
            if (!hasUncaughtError) {
              hasUncaughtError = true;
              firstUncaughtError = error3;
            }
          }
          var onUncaughtError = prepareToThrowUncaughtError;
          function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error3) {
            var errorInfo = createCapturedValue(error3, sourceFiber);
            var update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);
            enqueueUpdate(rootFiber, update);
            var eventTime = requestEventTime();
            var root2 = markUpdateLaneFromFiberToRoot(rootFiber, SyncLane);
            if (root2 !== null) {
              markRootUpdated(root2, SyncLane, eventTime);
              ensureRootIsScheduled(root2, eventTime);
              schedulePendingInteractions(root2, SyncLane);
            }
          }
          function captureCommitPhaseError(sourceFiber, error3) {
            if (sourceFiber.tag === HostRoot) {
              captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error3);
              return;
            }
            var fiber = sourceFiber.return;
            while (fiber !== null) {
              if (fiber.tag === HostRoot) {
                captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error3);
                return;
              } else if (fiber.tag === ClassComponent) {
                var ctor = fiber.type;
                var instance2 = fiber.stateNode;
                if (typeof ctor.getDerivedStateFromError === "function" || typeof instance2.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance2)) {
                  var errorInfo = createCapturedValue(error3, sourceFiber);
                  var update = createClassErrorUpdate(fiber, errorInfo, SyncLane);
                  enqueueUpdate(fiber, update);
                  var eventTime = requestEventTime();
                  var root2 = markUpdateLaneFromFiberToRoot(fiber, SyncLane);
                  if (root2 !== null) {
                    markRootUpdated(root2, SyncLane, eventTime);
                    ensureRootIsScheduled(root2, eventTime);
                    schedulePendingInteractions(root2, SyncLane);
                  } else {
                    if (typeof instance2.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance2)) {
                      try {
                        instance2.componentDidCatch(error3, errorInfo);
                      } catch (errorToIgnore) {
                      }
                    }
                  }
                  return;
                }
              }
              fiber = fiber.return;
            }
          }
          function pingSuspendedRoot(root2, wakeable, pingedLanes) {
            var pingCache = root2.pingCache;
            if (pingCache !== null) {
              pingCache.delete(wakeable);
            }
            var eventTime = requestEventTime();
            markRootPinged(root2, pingedLanes);
            if (workInProgressRoot === root2 && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {
              if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now$1() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {
                prepareFreshStack(root2, NoLanes);
              } else {
                workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);
              }
            }
            ensureRootIsScheduled(root2, eventTime);
            schedulePendingInteractions(root2, pingedLanes);
          }
          function retryTimedOutBoundary(boundaryFiber, retryLane) {
            if (retryLane === NoLane) {
              retryLane = requestRetryLane(boundaryFiber);
            }
            var eventTime = requestEventTime();
            var root2 = markUpdateLaneFromFiberToRoot(boundaryFiber, retryLane);
            if (root2 !== null) {
              markRootUpdated(root2, retryLane, eventTime);
              ensureRootIsScheduled(root2, eventTime);
              schedulePendingInteractions(root2, retryLane);
            }
          }
          function resolveRetryWakeable(boundaryFiber, wakeable) {
            var retryLane = NoLane;
            var retryCache;
            {
              retryCache = boundaryFiber.stateNode;
            }
            if (retryCache !== null) {
              retryCache.delete(wakeable);
            }
            retryTimedOutBoundary(boundaryFiber, retryLane);
          }
          function jnd(timeElapsed) {
            return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3e3 ? 3e3 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;
          }
          function checkForNestedUpdates() {
            if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
              nestedUpdateCount = 0;
              rootWithNestedUpdates = null;
              {
                {
                  throw Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
                }
              }
            }
            {
              if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {
                nestedPassiveUpdateCount = 0;
                error2("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.");
              }
            }
          }
          function flushRenderPhaseStrictModeWarningsInDEV() {
            {
              ReactStrictModeWarnings.flushLegacyContextWarning();
              {
                ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
              }
            }
          }
          var didWarnStateUpdateForNotYetMountedComponent = null;
          function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
            {
              if ((executionContext & RenderContext) !== NoContext) {
                return;
              }
              if (!(fiber.mode & (BlockingMode | ConcurrentMode))) {
                return;
              }
              var tag = fiber.tag;
              if (tag !== IndeterminateComponent && tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent && tag !== Block) {
                return;
              }
              var componentName = getComponentName(fiber.type) || "ReactComponent";
              if (didWarnStateUpdateForNotYetMountedComponent !== null) {
                if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {
                  return;
                }
                didWarnStateUpdateForNotYetMountedComponent.add(componentName);
              } else {
                didWarnStateUpdateForNotYetMountedComponent = /* @__PURE__ */ new Set([componentName]);
              }
              var previousFiber = current;
              try {
                setCurrentFiber(fiber);
                error2("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
              } finally {
                if (previousFiber) {
                  setCurrentFiber(fiber);
                } else {
                  resetCurrentFiber();
                }
              }
            }
          }
          var didWarnStateUpdateForUnmountedComponent = null;
          function warnAboutUpdateOnUnmountedFiberInDEV(fiber) {
            {
              var tag = fiber.tag;
              if (tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent && tag !== Block) {
                return;
              }
              if ((fiber.flags & PassiveUnmountPendingDev) !== NoFlags) {
                return;
              }
              var componentName = getComponentName(fiber.type) || "ReactComponent";
              if (didWarnStateUpdateForUnmountedComponent !== null) {
                if (didWarnStateUpdateForUnmountedComponent.has(componentName)) {
                  return;
                }
                didWarnStateUpdateForUnmountedComponent.add(componentName);
              } else {
                didWarnStateUpdateForUnmountedComponent = /* @__PURE__ */ new Set([componentName]);
              }
              if (isFlushingPassiveEffects)
                ;
              else {
                var previousFiber = current;
                try {
                  setCurrentFiber(fiber);
                  error2("Can't perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in %s.", tag === ClassComponent ? "the componentWillUnmount method" : "a useEffect cleanup function");
                } finally {
                  if (previousFiber) {
                    setCurrentFiber(fiber);
                  } else {
                    resetCurrentFiber();
                  }
                }
              }
            }
          }
          var beginWork$1;
          {
            var dummyFiber = null;
            beginWork$1 = function(current2, unitOfWork, lanes) {
              var originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);
              try {
                return beginWork(current2, unitOfWork, lanes);
              } catch (originalError) {
                if (originalError !== null && typeof originalError === "object" && typeof originalError.then === "function") {
                  throw originalError;
                }
                resetContextDependencies();
                resetHooksAfterThrow();
                unwindInterruptedWork(unitOfWork);
                assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);
                if (unitOfWork.mode & ProfileMode) {
                  startProfilerTimer(unitOfWork);
                }
                invokeGuardedCallback(null, beginWork, null, current2, unitOfWork, lanes);
                if (hasCaughtError()) {
                  var replayError = clearCaughtError();
                  throw replayError;
                } else {
                  throw originalError;
                }
              }
            };
          }
          var didWarnAboutUpdateInRender = false;
          var didWarnAboutUpdateInRenderForAnotherComponent;
          {
            didWarnAboutUpdateInRenderForAnotherComponent = /* @__PURE__ */ new Set();
          }
          function warnAboutRenderPhaseUpdatesInDEV(fiber) {
            {
              if (isRendering && (executionContext & RenderContext) !== NoContext && !getIsUpdatingOpaqueValueInRenderPhaseInDEV()) {
                switch (fiber.tag) {
                  case FunctionComponent:
                  case ForwardRef:
                  case SimpleMemoComponent: {
                    var renderingComponentName = workInProgress && getComponentName(workInProgress.type) || "Unknown";
                    var dedupeKey = renderingComponentName;
                    if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {
                      didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);
                      var setStateComponentName = getComponentName(fiber.type) || "Unknown";
                      error2("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", setStateComponentName, renderingComponentName, renderingComponentName);
                    }
                    break;
                  }
                  case ClassComponent: {
                    if (!didWarnAboutUpdateInRender) {
                      error2("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state.");
                      didWarnAboutUpdateInRender = true;
                    }
                    break;
                  }
                }
              }
            }
          }
          var IsThisRendererActing = {
            current: false
          };
          function warnIfNotScopedWithMatchingAct(fiber) {
            {
              if (warnsIfNotActing === true && IsSomeRendererActing.current === true && IsThisRendererActing.current !== true) {
                var previousFiber = current;
                try {
                  setCurrentFiber(fiber);
                  error2("It looks like you're using the wrong act() around your test interactions.\nBe sure to use the matching version of act() corresponding to your renderer:\n\n// for react-dom:\nimport {act} from 'react-dom/test-utils';\n// ...\nact(() => ...);\n\n// for react-test-renderer:\nimport TestRenderer from react-test-renderer';\nconst {act} = TestRenderer;\n// ...\nact(() => ...);");
                } finally {
                  if (previousFiber) {
                    setCurrentFiber(fiber);
                  } else {
                    resetCurrentFiber();
                  }
                }
              }
            }
          }
          function warnIfNotCurrentlyActingEffectsInDEV(fiber) {
            {
              if (warnsIfNotActing === true && (fiber.mode & StrictMode) !== NoMode && IsSomeRendererActing.current === false && IsThisRendererActing.current === false) {
                error2("An update to %s ran an effect, but was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act", getComponentName(fiber.type));
              }
            }
          }
          function warnIfNotCurrentlyActingUpdatesInDEV(fiber) {
            {
              if (warnsIfNotActing === true && executionContext === NoContext && IsSomeRendererActing.current === false && IsThisRendererActing.current === false) {
                var previousFiber = current;
                try {
                  setCurrentFiber(fiber);
                  error2("An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act", getComponentName(fiber.type));
                } finally {
                  if (previousFiber) {
                    setCurrentFiber(fiber);
                  } else {
                    resetCurrentFiber();
                  }
                }
              }
            }
          }
          var warnIfNotCurrentlyActingUpdatesInDev = warnIfNotCurrentlyActingUpdatesInDEV;
          var didWarnAboutUnmockedScheduler = false;
          function warnIfUnmockedScheduler(fiber) {
            {
              if (didWarnAboutUnmockedScheduler === false && Scheduler.unstable_flushAllWithoutAsserting === void 0) {
                if (fiber.mode & BlockingMode || fiber.mode & ConcurrentMode) {
                  didWarnAboutUnmockedScheduler = true;
                  error2(`In Concurrent or Sync modes, the "scheduler" module needs to be mocked to guarantee consistent behaviour across tests and browsers. For example, with jest: 
jest.mock('scheduler', () => require('scheduler/unstable_mock'));

For more info, visit https://reactjs.org/link/mock-scheduler`);
                }
              }
            }
          }
          function computeThreadID(root2, lane) {
            return lane * 1e3 + root2.interactionThreadID;
          }
          function markSpawnedWork(lane) {
            if (spawnedWorkDuringRender === null) {
              spawnedWorkDuringRender = [lane];
            } else {
              spawnedWorkDuringRender.push(lane);
            }
          }
          function scheduleInteractions(root2, lane, interactions) {
            if (interactions.size > 0) {
              var pendingInteractionMap = root2.pendingInteractionMap;
              var pendingInteractions = pendingInteractionMap.get(lane);
              if (pendingInteractions != null) {
                interactions.forEach(function(interaction) {
                  if (!pendingInteractions.has(interaction)) {
                    interaction.__count++;
                  }
                  pendingInteractions.add(interaction);
                });
              } else {
                pendingInteractionMap.set(lane, new Set(interactions));
                interactions.forEach(function(interaction) {
                  interaction.__count++;
                });
              }
              var subscriber = tracing.__subscriberRef.current;
              if (subscriber !== null) {
                var threadID = computeThreadID(root2, lane);
                subscriber.onWorkScheduled(interactions, threadID);
              }
            }
          }
          function schedulePendingInteractions(root2, lane) {
            scheduleInteractions(root2, lane, tracing.__interactionsRef.current);
          }
          function startWorkOnPendingInteractions(root2, lanes) {
            var interactions = /* @__PURE__ */ new Set();
            root2.pendingInteractionMap.forEach(function(scheduledInteractions, scheduledLane) {
              if (includesSomeLane(lanes, scheduledLane)) {
                scheduledInteractions.forEach(function(interaction) {
                  return interactions.add(interaction);
                });
              }
            });
            root2.memoizedInteractions = interactions;
            if (interactions.size > 0) {
              var subscriber = tracing.__subscriberRef.current;
              if (subscriber !== null) {
                var threadID = computeThreadID(root2, lanes);
                try {
                  subscriber.onWorkStarted(interactions, threadID);
                } catch (error3) {
                  scheduleCallback(ImmediatePriority$1, function() {
                    throw error3;
                  });
                }
              }
            }
          }
          function finishPendingInteractions(root2, committedLanes) {
            var remainingLanesAfterCommit = root2.pendingLanes;
            var subscriber;
            try {
              subscriber = tracing.__subscriberRef.current;
              if (subscriber !== null && root2.memoizedInteractions.size > 0) {
                var threadID = computeThreadID(root2, committedLanes);
                subscriber.onWorkStopped(root2.memoizedInteractions, threadID);
              }
            } catch (error3) {
              scheduleCallback(ImmediatePriority$1, function() {
                throw error3;
              });
            } finally {
              var pendingInteractionMap = root2.pendingInteractionMap;
              pendingInteractionMap.forEach(function(scheduledInteractions, lane) {
                if (!includesSomeLane(remainingLanesAfterCommit, lane)) {
                  pendingInteractionMap.delete(lane);
                  scheduledInteractions.forEach(function(interaction) {
                    interaction.__count--;
                    if (subscriber !== null && interaction.__count === 0) {
                      try {
                        subscriber.onInteractionScheduledWorkCompleted(interaction);
                      } catch (error3) {
                        scheduleCallback(ImmediatePriority$1, function() {
                          throw error3;
                        });
                      }
                    }
                  });
                }
              });
            }
          }
          function shouldForceFlushFallbacksInDEV() {
            return actingUpdatesScopeDepth > 0;
          }
          var flushMockScheduler = Scheduler.unstable_flushAllWithoutAsserting;
          var isSchedulerMocked = typeof flushMockScheduler === "function";
          function flushActWork() {
            if (flushMockScheduler !== void 0) {
              try {
                return flushMockScheduler();
              } finally {
              }
            } else {
              try {
                var didFlushWork = false;
                while (flushPassiveEffects()) {
                  didFlushWork = true;
                }
                return didFlushWork;
              } finally {
              }
            }
          }
          function flushWorkAndMicroTasks(onDone) {
            try {
              flushActWork();
              enqueueTask(function() {
                if (flushActWork()) {
                  flushWorkAndMicroTasks(onDone);
                } else {
                  onDone();
                }
              });
            } catch (err2) {
              onDone(err2);
            }
          }
          var actingUpdatesScopeDepth = 0;
          function act(callback) {
            var previousActingUpdatesScopeDepth = actingUpdatesScopeDepth;
            actingUpdatesScopeDepth++;
            var previousIsSomeRendererActing = IsSomeRendererActing.current;
            var previousIsThisRendererActing = IsThisRendererActing.current;
            IsSomeRendererActing.current = true;
            IsThisRendererActing.current = true;
            function onDone() {
              actingUpdatesScopeDepth--;
              IsSomeRendererActing.current = previousIsSomeRendererActing;
              IsThisRendererActing.current = previousIsThisRendererActing;
              {
                if (actingUpdatesScopeDepth > previousActingUpdatesScopeDepth) {
                  error2("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. ");
                }
              }
            }
            var result;
            try {
              result = batchedUpdates(callback);
            } catch (error3) {
              onDone();
              throw error3;
            }
            if (result !== null && typeof result === "object" && typeof result.then === "function") {
              var called = false;
              {
                if (typeof Promise !== "undefined") {
                  Promise.resolve().then(function() {
                  }).then(function() {
                    if (called === false) {
                      error2("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);");
                    }
                  });
                }
              }
              return {
                then: function(resolve, reject) {
                  called = true;
                  result.then(function() {
                    if (actingUpdatesScopeDepth > 1 || isSchedulerMocked === true && previousIsSomeRendererActing === true) {
                      onDone();
                      resolve();
                      return;
                    }
                    flushWorkAndMicroTasks(function(err2) {
                      onDone();
                      if (err2) {
                        reject(err2);
                      } else {
                        resolve();
                      }
                    });
                  }, function(err2) {
                    onDone();
                    reject(err2);
                  });
                }
              };
            } else {
              {
                if (result !== void 0) {
                  error2("The callback passed to act(...) function must return undefined, or a Promise. You returned %s", result);
                }
              }
              try {
                if (actingUpdatesScopeDepth === 1 && (isSchedulerMocked === false || previousIsSomeRendererActing === false)) {
                  flushActWork();
                }
                onDone();
              } catch (err2) {
                onDone();
                throw err2;
              }
              return {
                then: function(resolve) {
                  {
                    error2("Do not await the result of calling act(...) with sync logic, it is not a Promise.");
                  }
                  resolve();
                }
              };
            }
          }
          function detachFiberAfterEffects(fiber) {
            fiber.sibling = null;
            fiber.stateNode = null;
          }
          var resolveFamily = null;
          var failedBoundaries = null;
          var setRefreshHandler = function(handler) {
            {
              resolveFamily = handler;
            }
          };
          function resolveFunctionForHotReloading(type5) {
            {
              if (resolveFamily === null) {
                return type5;
              }
              var family = resolveFamily(type5);
              if (family === void 0) {
                return type5;
              }
              return family.current;
            }
          }
          function resolveClassForHotReloading(type5) {
            return resolveFunctionForHotReloading(type5);
          }
          function resolveForwardRefForHotReloading(type5) {
            {
              if (resolveFamily === null) {
                return type5;
              }
              var family = resolveFamily(type5);
              if (family === void 0) {
                if (type5 !== null && type5 !== void 0 && typeof type5.render === "function") {
                  var currentRender = resolveFunctionForHotReloading(type5.render);
                  if (type5.render !== currentRender) {
                    var syntheticType = {
                      $$typeof: REACT_FORWARD_REF_TYPE,
                      render: currentRender
                    };
                    if (type5.displayName !== void 0) {
                      syntheticType.displayName = type5.displayName;
                    }
                    return syntheticType;
                  }
                }
                return type5;
              }
              return family.current;
            }
          }
          function isCompatibleFamilyForHotReloading(fiber, element) {
            {
              if (resolveFamily === null) {
                return false;
              }
              var prevType = fiber.elementType;
              var nextType = element.type;
              var needsCompareFamilies = false;
              var $$typeofNextType = typeof nextType === "object" && nextType !== null ? nextType.$$typeof : null;
              switch (fiber.tag) {
                case ClassComponent: {
                  if (typeof nextType === "function") {
                    needsCompareFamilies = true;
                  }
                  break;
                }
                case FunctionComponent: {
                  if (typeof nextType === "function") {
                    needsCompareFamilies = true;
                  } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                    needsCompareFamilies = true;
                  }
                  break;
                }
                case ForwardRef: {
                  if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {
                    needsCompareFamilies = true;
                  } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                    needsCompareFamilies = true;
                  }
                  break;
                }
                case MemoComponent:
                case SimpleMemoComponent: {
                  if ($$typeofNextType === REACT_MEMO_TYPE) {
                    needsCompareFamilies = true;
                  } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                    needsCompareFamilies = true;
                  }
                  break;
                }
                default:
                  return false;
              }
              if (needsCompareFamilies) {
                var prevFamily = resolveFamily(prevType);
                if (prevFamily !== void 0 && prevFamily === resolveFamily(nextType)) {
                  return true;
                }
              }
              return false;
            }
          }
          function markFailedErrorBoundaryForHotReloading(fiber) {
            {
              if (resolveFamily === null) {
                return;
              }
              if (typeof WeakSet !== "function") {
                return;
              }
              if (failedBoundaries === null) {
                failedBoundaries = /* @__PURE__ */ new WeakSet();
              }
              failedBoundaries.add(fiber);
            }
          }
          var scheduleRefresh = function(root2, update) {
            {
              if (resolveFamily === null) {
                return;
              }
              var staleFamilies = update.staleFamilies, updatedFamilies = update.updatedFamilies;
              flushPassiveEffects();
              flushSync(function() {
                scheduleFibersWithFamiliesRecursively(root2.current, updatedFamilies, staleFamilies);
              });
            }
          };
          var scheduleRoot = function(root2, element) {
            {
              if (root2.context !== emptyContextObject) {
                return;
              }
              flushPassiveEffects();
              flushSync(function() {
                updateContainer(element, root2, null, null);
              });
            }
          };
          function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
            {
              var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type5 = fiber.type;
              var candidateType = null;
              switch (tag) {
                case FunctionComponent:
                case SimpleMemoComponent:
                case ClassComponent:
                  candidateType = type5;
                  break;
                case ForwardRef:
                  candidateType = type5.render;
                  break;
              }
              if (resolveFamily === null) {
                throw new Error("Expected resolveFamily to be set during hot reload.");
              }
              var needsRender = false;
              var needsRemount = false;
              if (candidateType !== null) {
                var family = resolveFamily(candidateType);
                if (family !== void 0) {
                  if (staleFamilies.has(family)) {
                    needsRemount = true;
                  } else if (updatedFamilies.has(family)) {
                    if (tag === ClassComponent) {
                      needsRemount = true;
                    } else {
                      needsRender = true;
                    }
                  }
                }
              }
              if (failedBoundaries !== null) {
                if (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) {
                  needsRemount = true;
                }
              }
              if (needsRemount) {
                fiber._debugNeedsRemount = true;
              }
              if (needsRemount || needsRender) {
                scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
              }
              if (child !== null && !needsRemount) {
                scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);
              }
              if (sibling !== null) {
                scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);
              }
            }
          }
          var findHostInstancesForRefresh = function(root2, families) {
            {
              var hostInstances = /* @__PURE__ */ new Set();
              var types2 = new Set(families.map(function(family) {
                return family.current;
              }));
              findHostInstancesForMatchingFibersRecursively(root2.current, types2, hostInstances);
              return hostInstances;
            }
          };
          function findHostInstancesForMatchingFibersRecursively(fiber, types2, hostInstances) {
            {
              var child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type5 = fiber.type;
              var candidateType = null;
              switch (tag) {
                case FunctionComponent:
                case SimpleMemoComponent:
                case ClassComponent:
                  candidateType = type5;
                  break;
                case ForwardRef:
                  candidateType = type5.render;
                  break;
              }
              var didMatch = false;
              if (candidateType !== null) {
                if (types2.has(candidateType)) {
                  didMatch = true;
                }
              }
              if (didMatch) {
                findHostInstancesForFiberShallowly(fiber, hostInstances);
              } else {
                if (child !== null) {
                  findHostInstancesForMatchingFibersRecursively(child, types2, hostInstances);
                }
              }
              if (sibling !== null) {
                findHostInstancesForMatchingFibersRecursively(sibling, types2, hostInstances);
              }
            }
          }
          function findHostInstancesForFiberShallowly(fiber, hostInstances) {
            {
              var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);
              if (foundHostInstances) {
                return;
              }
              var node = fiber;
              while (true) {
                switch (node.tag) {
                  case HostComponent:
                    hostInstances.add(node.stateNode);
                    return;
                  case HostPortal:
                    hostInstances.add(node.stateNode.containerInfo);
                    return;
                  case HostRoot:
                    hostInstances.add(node.stateNode.containerInfo);
                    return;
                }
                if (node.return === null) {
                  throw new Error("Expected to reach root first.");
                }
                node = node.return;
              }
            }
          }
          function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {
            {
              var node = fiber;
              var foundHostInstances = false;
              while (true) {
                if (node.tag === HostComponent) {
                  foundHostInstances = true;
                  hostInstances.add(node.stateNode);
                } else if (node.child !== null) {
                  node.child.return = node;
                  node = node.child;
                  continue;
                }
                if (node === fiber) {
                  return foundHostInstances;
                }
                while (node.sibling === null) {
                  if (node.return === null || node.return === fiber) {
                    return foundHostInstances;
                  }
                  node = node.return;
                }
                node.sibling.return = node.return;
                node = node.sibling;
              }
            }
            return false;
          }
          var hasBadMapPolyfill;
          {
            hasBadMapPolyfill = false;
            try {
              var nonExtensibleObject = Object.preventExtensions({});
              /* @__PURE__ */ new Map([[nonExtensibleObject, null]]);
              /* @__PURE__ */ new Set([nonExtensibleObject]);
            } catch (e) {
              hasBadMapPolyfill = true;
            }
          }
          var debugCounter = 1;
          function FiberNode(tag, pendingProps, key, mode) {
            this.tag = tag;
            this.key = key;
            this.elementType = null;
            this.type = null;
            this.stateNode = null;
            this.return = null;
            this.child = null;
            this.sibling = null;
            this.index = 0;
            this.ref = null;
            this.pendingProps = pendingProps;
            this.memoizedProps = null;
            this.updateQueue = null;
            this.memoizedState = null;
            this.dependencies = null;
            this.mode = mode;
            this.flags = NoFlags;
            this.nextEffect = null;
            this.firstEffect = null;
            this.lastEffect = null;
            this.lanes = NoLanes;
            this.childLanes = NoLanes;
            this.alternate = null;
            {
              this.actualDuration = Number.NaN;
              this.actualStartTime = Number.NaN;
              this.selfBaseDuration = Number.NaN;
              this.treeBaseDuration = Number.NaN;
              this.actualDuration = 0;
              this.actualStartTime = -1;
              this.selfBaseDuration = 0;
              this.treeBaseDuration = 0;
            }
            {
              this._debugID = debugCounter++;
              this._debugSource = null;
              this._debugOwner = null;
              this._debugNeedsRemount = false;
              this._debugHookTypes = null;
              if (!hasBadMapPolyfill && typeof Object.preventExtensions === "function") {
                Object.preventExtensions(this);
              }
            }
          }
          var createFiber = function(tag, pendingProps, key, mode) {
            return new FiberNode(tag, pendingProps, key, mode);
          };
          function shouldConstruct$1(Component) {
            var prototype = Component.prototype;
            return !!(prototype && prototype.isReactComponent);
          }
          function isSimpleFunctionComponent(type5) {
            return typeof type5 === "function" && !shouldConstruct$1(type5) && type5.defaultProps === void 0;
          }
          function resolveLazyComponentTag(Component) {
            if (typeof Component === "function") {
              return shouldConstruct$1(Component) ? ClassComponent : FunctionComponent;
            } else if (Component !== void 0 && Component !== null) {
              var $$typeof = Component.$$typeof;
              if ($$typeof === REACT_FORWARD_REF_TYPE) {
                return ForwardRef;
              }
              if ($$typeof === REACT_MEMO_TYPE) {
                return MemoComponent;
              }
            }
            return IndeterminateComponent;
          }
          function createWorkInProgress(current2, pendingProps) {
            var workInProgress2 = current2.alternate;
            if (workInProgress2 === null) {
              workInProgress2 = createFiber(current2.tag, pendingProps, current2.key, current2.mode);
              workInProgress2.elementType = current2.elementType;
              workInProgress2.type = current2.type;
              workInProgress2.stateNode = current2.stateNode;
              {
                workInProgress2._debugID = current2._debugID;
                workInProgress2._debugSource = current2._debugSource;
                workInProgress2._debugOwner = current2._debugOwner;
                workInProgress2._debugHookTypes = current2._debugHookTypes;
              }
              workInProgress2.alternate = current2;
              current2.alternate = workInProgress2;
            } else {
              workInProgress2.pendingProps = pendingProps;
              workInProgress2.type = current2.type;
              workInProgress2.flags = NoFlags;
              workInProgress2.nextEffect = null;
              workInProgress2.firstEffect = null;
              workInProgress2.lastEffect = null;
              {
                workInProgress2.actualDuration = 0;
                workInProgress2.actualStartTime = -1;
              }
            }
            workInProgress2.childLanes = current2.childLanes;
            workInProgress2.lanes = current2.lanes;
            workInProgress2.child = current2.child;
            workInProgress2.memoizedProps = current2.memoizedProps;
            workInProgress2.memoizedState = current2.memoizedState;
            workInProgress2.updateQueue = current2.updateQueue;
            var currentDependencies = current2.dependencies;
            workInProgress2.dependencies = currentDependencies === null ? null : {
              lanes: currentDependencies.lanes,
              firstContext: currentDependencies.firstContext
            };
            workInProgress2.sibling = current2.sibling;
            workInProgress2.index = current2.index;
            workInProgress2.ref = current2.ref;
            {
              workInProgress2.selfBaseDuration = current2.selfBaseDuration;
              workInProgress2.treeBaseDuration = current2.treeBaseDuration;
            }
            {
              workInProgress2._debugNeedsRemount = current2._debugNeedsRemount;
              switch (workInProgress2.tag) {
                case IndeterminateComponent:
                case FunctionComponent:
                case SimpleMemoComponent:
                  workInProgress2.type = resolveFunctionForHotReloading(current2.type);
                  break;
                case ClassComponent:
                  workInProgress2.type = resolveClassForHotReloading(current2.type);
                  break;
                case ForwardRef:
                  workInProgress2.type = resolveForwardRefForHotReloading(current2.type);
                  break;
              }
            }
            return workInProgress2;
          }
          function resetWorkInProgress(workInProgress2, renderLanes2) {
            workInProgress2.flags &= Placement;
            workInProgress2.nextEffect = null;
            workInProgress2.firstEffect = null;
            workInProgress2.lastEffect = null;
            var current2 = workInProgress2.alternate;
            if (current2 === null) {
              workInProgress2.childLanes = NoLanes;
              workInProgress2.lanes = renderLanes2;
              workInProgress2.child = null;
              workInProgress2.memoizedProps = null;
              workInProgress2.memoizedState = null;
              workInProgress2.updateQueue = null;
              workInProgress2.dependencies = null;
              workInProgress2.stateNode = null;
              {
                workInProgress2.selfBaseDuration = 0;
                workInProgress2.treeBaseDuration = 0;
              }
            } else {
              workInProgress2.childLanes = current2.childLanes;
              workInProgress2.lanes = current2.lanes;
              workInProgress2.child = current2.child;
              workInProgress2.memoizedProps = current2.memoizedProps;
              workInProgress2.memoizedState = current2.memoizedState;
              workInProgress2.updateQueue = current2.updateQueue;
              workInProgress2.type = current2.type;
              var currentDependencies = current2.dependencies;
              workInProgress2.dependencies = currentDependencies === null ? null : {
                lanes: currentDependencies.lanes,
                firstContext: currentDependencies.firstContext
              };
              {
                workInProgress2.selfBaseDuration = current2.selfBaseDuration;
                workInProgress2.treeBaseDuration = current2.treeBaseDuration;
              }
            }
            return workInProgress2;
          }
          function createHostRootFiber(tag) {
            var mode;
            if (tag === ConcurrentRoot) {
              mode = ConcurrentMode | BlockingMode | StrictMode;
            } else if (tag === BlockingRoot) {
              mode = BlockingMode | StrictMode;
            } else {
              mode = NoMode;
            }
            if (isDevToolsPresent) {
              mode |= ProfileMode;
            }
            return createFiber(HostRoot, null, null, mode);
          }
          function createFiberFromTypeAndProps(type5, key, pendingProps, owner, mode, lanes) {
            var fiberTag = IndeterminateComponent;
            var resolvedType = type5;
            if (typeof type5 === "function") {
              if (shouldConstruct$1(type5)) {
                fiberTag = ClassComponent;
                {
                  resolvedType = resolveClassForHotReloading(resolvedType);
                }
              } else {
                {
                  resolvedType = resolveFunctionForHotReloading(resolvedType);
                }
              }
            } else if (typeof type5 === "string") {
              fiberTag = HostComponent;
            } else {
              getTag:
                switch (type5) {
                  case REACT_FRAGMENT_TYPE:
                    return createFiberFromFragment(pendingProps.children, mode, lanes, key);
                  case REACT_DEBUG_TRACING_MODE_TYPE:
                    fiberTag = Mode;
                    mode |= DebugTracingMode;
                    break;
                  case REACT_STRICT_MODE_TYPE:
                    fiberTag = Mode;
                    mode |= StrictMode;
                    break;
                  case REACT_PROFILER_TYPE:
                    return createFiberFromProfiler(pendingProps, mode, lanes, key);
                  case REACT_SUSPENSE_TYPE:
                    return createFiberFromSuspense(pendingProps, mode, lanes, key);
                  case REACT_SUSPENSE_LIST_TYPE:
                    return createFiberFromSuspenseList(pendingProps, mode, lanes, key);
                  case REACT_OFFSCREEN_TYPE:
                    return createFiberFromOffscreen(pendingProps, mode, lanes, key);
                  case REACT_LEGACY_HIDDEN_TYPE:
                    return createFiberFromLegacyHidden(pendingProps, mode, lanes, key);
                  case REACT_SCOPE_TYPE:
                  default: {
                    if (typeof type5 === "object" && type5 !== null) {
                      switch (type5.$$typeof) {
                        case REACT_PROVIDER_TYPE:
                          fiberTag = ContextProvider;
                          break getTag;
                        case REACT_CONTEXT_TYPE:
                          fiberTag = ContextConsumer;
                          break getTag;
                        case REACT_FORWARD_REF_TYPE:
                          fiberTag = ForwardRef;
                          {
                            resolvedType = resolveForwardRefForHotReloading(resolvedType);
                          }
                          break getTag;
                        case REACT_MEMO_TYPE:
                          fiberTag = MemoComponent;
                          break getTag;
                        case REACT_LAZY_TYPE:
                          fiberTag = LazyComponent;
                          resolvedType = null;
                          break getTag;
                        case REACT_BLOCK_TYPE:
                          fiberTag = Block;
                          break getTag;
                      }
                    }
                    var info = "";
                    {
                      if (type5 === void 0 || typeof type5 === "object" && type5 !== null && Object.keys(type5).length === 0) {
                        info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                      }
                      var ownerName = owner ? getComponentName(owner.type) : null;
                      if (ownerName) {
                        info += "\n\nCheck the render method of `" + ownerName + "`.";
                      }
                    }
                    {
                      {
                        throw Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (type5 == null ? type5 : typeof type5) + "." + info);
                      }
                    }
                  }
                }
            }
            var fiber = createFiber(fiberTag, pendingProps, key, mode);
            fiber.elementType = type5;
            fiber.type = resolvedType;
            fiber.lanes = lanes;
            {
              fiber._debugOwner = owner;
            }
            return fiber;
          }
          function createFiberFromElement(element, mode, lanes) {
            var owner = null;
            {
              owner = element._owner;
            }
            var type5 = element.type;
            var key = element.key;
            var pendingProps = element.props;
            var fiber = createFiberFromTypeAndProps(type5, key, pendingProps, owner, mode, lanes);
            {
              fiber._debugSource = element._source;
              fiber._debugOwner = element._owner;
            }
            return fiber;
          }
          function createFiberFromFragment(elements, mode, lanes, key) {
            var fiber = createFiber(Fragment, elements, key, mode);
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromProfiler(pendingProps, mode, lanes, key) {
            {
              if (typeof pendingProps.id !== "string") {
                error2('Profiler must specify an "id" as a prop');
              }
            }
            var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);
            fiber.elementType = REACT_PROFILER_TYPE;
            fiber.type = REACT_PROFILER_TYPE;
            fiber.lanes = lanes;
            {
              fiber.stateNode = {
                effectDuration: 0,
                passiveEffectDuration: 0
              };
            }
            return fiber;
          }
          function createFiberFromSuspense(pendingProps, mode, lanes, key) {
            var fiber = createFiber(SuspenseComponent, pendingProps, key, mode);
            fiber.type = REACT_SUSPENSE_TYPE;
            fiber.elementType = REACT_SUSPENSE_TYPE;
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromSuspenseList(pendingProps, mode, lanes, key) {
            var fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);
            {
              fiber.type = REACT_SUSPENSE_LIST_TYPE;
            }
            fiber.elementType = REACT_SUSPENSE_LIST_TYPE;
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromOffscreen(pendingProps, mode, lanes, key) {
            var fiber = createFiber(OffscreenComponent, pendingProps, key, mode);
            {
              fiber.type = REACT_OFFSCREEN_TYPE;
            }
            fiber.elementType = REACT_OFFSCREEN_TYPE;
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromLegacyHidden(pendingProps, mode, lanes, key) {
            var fiber = createFiber(LegacyHiddenComponent, pendingProps, key, mode);
            {
              fiber.type = REACT_LEGACY_HIDDEN_TYPE;
            }
            fiber.elementType = REACT_LEGACY_HIDDEN_TYPE;
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromText(content, mode, lanes) {
            var fiber = createFiber(HostText, content, null, mode);
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromHostInstanceForDeletion() {
            var fiber = createFiber(HostComponent, null, null, NoMode);
            fiber.elementType = "DELETED";
            fiber.type = "DELETED";
            return fiber;
          }
          function createFiberFromPortal(portal, mode, lanes) {
            var pendingProps = portal.children !== null ? portal.children : [];
            var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);
            fiber.lanes = lanes;
            fiber.stateNode = {
              containerInfo: portal.containerInfo,
              pendingChildren: null,
              implementation: portal.implementation
            };
            return fiber;
          }
          function assignFiberPropertiesInDEV(target, source) {
            if (target === null) {
              target = createFiber(IndeterminateComponent, null, null, NoMode);
            }
            target.tag = source.tag;
            target.key = source.key;
            target.elementType = source.elementType;
            target.type = source.type;
            target.stateNode = source.stateNode;
            target.return = source.return;
            target.child = source.child;
            target.sibling = source.sibling;
            target.index = source.index;
            target.ref = source.ref;
            target.pendingProps = source.pendingProps;
            target.memoizedProps = source.memoizedProps;
            target.updateQueue = source.updateQueue;
            target.memoizedState = source.memoizedState;
            target.dependencies = source.dependencies;
            target.mode = source.mode;
            target.flags = source.flags;
            target.nextEffect = source.nextEffect;
            target.firstEffect = source.firstEffect;
            target.lastEffect = source.lastEffect;
            target.lanes = source.lanes;
            target.childLanes = source.childLanes;
            target.alternate = source.alternate;
            {
              target.actualDuration = source.actualDuration;
              target.actualStartTime = source.actualStartTime;
              target.selfBaseDuration = source.selfBaseDuration;
              target.treeBaseDuration = source.treeBaseDuration;
            }
            target._debugID = source._debugID;
            target._debugSource = source._debugSource;
            target._debugOwner = source._debugOwner;
            target._debugNeedsRemount = source._debugNeedsRemount;
            target._debugHookTypes = source._debugHookTypes;
            return target;
          }
          function FiberRootNode(containerInfo, tag, hydrate) {
            this.tag = tag;
            this.containerInfo = containerInfo;
            this.pendingChildren = null;
            this.current = null;
            this.pingCache = null;
            this.finishedWork = null;
            this.timeoutHandle = noTimeout;
            this.context = null;
            this.pendingContext = null;
            this.hydrate = hydrate;
            this.callbackNode = null;
            this.callbackPriority = NoLanePriority;
            this.eventTimes = createLaneMap(NoLanes);
            this.expirationTimes = createLaneMap(NoTimestamp);
            this.pendingLanes = NoLanes;
            this.suspendedLanes = NoLanes;
            this.pingedLanes = NoLanes;
            this.expiredLanes = NoLanes;
            this.mutableReadLanes = NoLanes;
            this.finishedLanes = NoLanes;
            this.entangledLanes = NoLanes;
            this.entanglements = createLaneMap(NoLanes);
            if (supportsHydration) {
              this.mutableSourceEagerHydrationData = null;
            }
            {
              this.interactionThreadID = tracing.unstable_getThreadID();
              this.memoizedInteractions = /* @__PURE__ */ new Set();
              this.pendingInteractionMap = /* @__PURE__ */ new Map();
            }
            {
              switch (tag) {
                case BlockingRoot:
                  this._debugRootType = "createBlockingRoot()";
                  break;
                case ConcurrentRoot:
                  this._debugRootType = "createRoot()";
                  break;
                case LegacyRoot:
                  this._debugRootType = "createLegacyRoot()";
                  break;
              }
            }
          }
          function createFiberRoot(containerInfo, tag, hydrate, hydrationCallbacks) {
            var root2 = new FiberRootNode(containerInfo, tag, hydrate);
            var uninitializedFiber = createHostRootFiber(tag);
            root2.current = uninitializedFiber;
            uninitializedFiber.stateNode = root2;
            initializeUpdateQueue(uninitializedFiber);
            return root2;
          }
          function registerMutableSourceForHydration(root2, mutableSource) {
            var getVersion = mutableSource._getVersion;
            var version4 = getVersion(mutableSource._source);
            if (root2.mutableSourceEagerHydrationData == null) {
              root2.mutableSourceEagerHydrationData = [mutableSource, version4];
            } else {
              root2.mutableSourceEagerHydrationData.push(mutableSource, version4);
            }
          }
          function createPortal(children, containerInfo, implementation) {
            var key = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
            return {
              $$typeof: REACT_PORTAL_TYPE,
              key: key == null ? null : "" + key,
              children,
              containerInfo,
              implementation
            };
          }
          var didWarnAboutNestedUpdates;
          var didWarnAboutFindNodeInStrictMode;
          {
            didWarnAboutNestedUpdates = false;
            didWarnAboutFindNodeInStrictMode = {};
          }
          function getContextForSubtree(parentComponent) {
            if (!parentComponent) {
              return emptyContextObject;
            }
            var fiber = get(parentComponent);
            var parentContext = findCurrentUnmaskedContext(fiber);
            if (fiber.tag === ClassComponent) {
              var Component = fiber.type;
              if (isContextProvider(Component)) {
                return processChildContext(fiber, Component, parentContext);
              }
            }
            return parentContext;
          }
          function findHostInstance(component) {
            var fiber = get(component);
            if (fiber === void 0) {
              if (typeof component.render === "function") {
                {
                  {
                    throw Error("Unable to find node on an unmounted component.");
                  }
                }
              } else {
                {
                  {
                    throw Error("Argument appears to not be a ReactComponent. Keys: " + Object.keys(component));
                  }
                }
              }
            }
            var hostFiber = findCurrentHostFiber(fiber);
            if (hostFiber === null) {
              return null;
            }
            return hostFiber.stateNode;
          }
          function findHostInstanceWithWarning(component, methodName) {
            {
              var fiber = get(component);
              if (fiber === void 0) {
                if (typeof component.render === "function") {
                  {
                    {
                      throw Error("Unable to find node on an unmounted component.");
                    }
                  }
                } else {
                  {
                    {
                      throw Error("Argument appears to not be a ReactComponent. Keys: " + Object.keys(component));
                    }
                  }
                }
              }
              var hostFiber = findCurrentHostFiber(fiber);
              if (hostFiber === null) {
                return null;
              }
              if (hostFiber.mode & StrictMode) {
                var componentName = getComponentName(fiber.type) || "Component";
                if (!didWarnAboutFindNodeInStrictMode[componentName]) {
                  didWarnAboutFindNodeInStrictMode[componentName] = true;
                  var previousFiber = current;
                  try {
                    setCurrentFiber(hostFiber);
                    if (fiber.mode & StrictMode) {
                      error2("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                    } else {
                      error2("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                    }
                  } finally {
                    if (previousFiber) {
                      setCurrentFiber(previousFiber);
                    } else {
                      resetCurrentFiber();
                    }
                  }
                }
              }
              return hostFiber.stateNode;
            }
          }
          function createContainer(containerInfo, tag, hydrate, hydrationCallbacks) {
            return createFiberRoot(containerInfo, tag, hydrate);
          }
          function updateContainer(element, container, parentComponent, callback) {
            {
              onScheduleRoot(container, element);
            }
            var current$1 = container.current;
            var eventTime = requestEventTime();
            {
              if ("undefined" !== typeof jest) {
                warnIfUnmockedScheduler(current$1);
                warnIfNotScopedWithMatchingAct(current$1);
              }
            }
            var lane = requestUpdateLane(current$1);
            var context = getContextForSubtree(parentComponent);
            if (container.context === null) {
              container.context = context;
            } else {
              container.pendingContext = context;
            }
            {
              if (isRendering && current !== null && !didWarnAboutNestedUpdates) {
                didWarnAboutNestedUpdates = true;
                error2("Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.", getComponentName(current.type) || "Unknown");
              }
            }
            var update = createUpdate(eventTime, lane);
            update.payload = {
              element
            };
            callback = callback === void 0 ? null : callback;
            if (callback !== null) {
              {
                if (typeof callback !== "function") {
                  error2("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callback);
                }
              }
              update.callback = callback;
            }
            enqueueUpdate(current$1, update);
            scheduleUpdateOnFiber(current$1, lane, eventTime);
            return lane;
          }
          function getPublicRootInstance(container) {
            var containerFiber = container.current;
            if (!containerFiber.child) {
              return null;
            }
            switch (containerFiber.child.tag) {
              case HostComponent:
                return getPublicInstance(containerFiber.child.stateNode);
              default:
                return containerFiber.child.stateNode;
            }
          }
          function attemptSynchronousHydration(fiber) {
            switch (fiber.tag) {
              case HostRoot:
                var root2 = fiber.stateNode;
                if (root2.hydrate) {
                  var lanes = getHighestPriorityPendingLanes(root2);
                  flushRoot(root2, lanes);
                }
                break;
              case SuspenseComponent:
                var eventTime = requestEventTime();
                flushSync(function() {
                  return scheduleUpdateOnFiber(fiber, SyncLane, eventTime);
                });
                var retryLane = InputDiscreteHydrationLane;
                markRetryLaneIfNotHydrated(fiber, retryLane);
                break;
            }
          }
          function markRetryLaneImpl(fiber, retryLane) {
            var suspenseState = fiber.memoizedState;
            if (suspenseState !== null && suspenseState.dehydrated !== null) {
              suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);
            }
          }
          function markRetryLaneIfNotHydrated(fiber, retryLane) {
            markRetryLaneImpl(fiber, retryLane);
            var alternate = fiber.alternate;
            if (alternate) {
              markRetryLaneImpl(alternate, retryLane);
            }
          }
          function attemptUserBlockingHydration(fiber) {
            if (fiber.tag !== SuspenseComponent) {
              return;
            }
            var eventTime = requestEventTime();
            var lane = InputDiscreteHydrationLane;
            scheduleUpdateOnFiber(fiber, lane, eventTime);
            markRetryLaneIfNotHydrated(fiber, lane);
          }
          function attemptContinuousHydration(fiber) {
            if (fiber.tag !== SuspenseComponent) {
              return;
            }
            var eventTime = requestEventTime();
            var lane = SelectiveHydrationLane;
            scheduleUpdateOnFiber(fiber, lane, eventTime);
            markRetryLaneIfNotHydrated(fiber, lane);
          }
          function attemptHydrationAtCurrentPriority(fiber) {
            if (fiber.tag !== SuspenseComponent) {
              return;
            }
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(fiber);
            scheduleUpdateOnFiber(fiber, lane, eventTime);
            markRetryLaneIfNotHydrated(fiber, lane);
          }
          function runWithPriority$1(priority, fn2) {
            var previousPriority = getCurrentUpdateLanePriority();
            try {
              setCurrentUpdateLanePriority(priority);
              return fn2();
            } finally {
              setCurrentUpdateLanePriority(previousPriority);
            }
          }
          function findHostInstanceWithNoPortals(fiber) {
            var hostFiber = findCurrentHostFiberWithNoPortals(fiber);
            if (hostFiber === null) {
              return null;
            }
            if (hostFiber.tag === FundamentalComponent) {
              return hostFiber.stateNode.instance;
            }
            return hostFiber.stateNode;
          }
          var shouldSuspendImpl = function(fiber) {
            return false;
          };
          function shouldSuspend(fiber) {
            return shouldSuspendImpl(fiber);
          }
          var overrideHookState = null;
          var overrideHookStateDeletePath = null;
          var overrideHookStateRenamePath = null;
          var overrideProps = null;
          var overridePropsDeletePath = null;
          var overridePropsRenamePath = null;
          var scheduleUpdate = null;
          var setSuspenseHandler = null;
          {
            var copyWithDeleteImpl = function(obj, path, index2) {
              var key = path[index2];
              var updated = Array.isArray(obj) ? obj.slice() : _assign({}, obj);
              if (index2 + 1 === path.length) {
                if (Array.isArray(updated)) {
                  updated.splice(key, 1);
                } else {
                  delete updated[key];
                }
                return updated;
              }
              updated[key] = copyWithDeleteImpl(obj[key], path, index2 + 1);
              return updated;
            };
            var copyWithDelete = function(obj, path) {
              return copyWithDeleteImpl(obj, path, 0);
            };
            var copyWithRenameImpl = function(obj, oldPath, newPath, index2) {
              var oldKey = oldPath[index2];
              var updated = Array.isArray(obj) ? obj.slice() : _assign({}, obj);
              if (index2 + 1 === oldPath.length) {
                var newKey = newPath[index2];
                updated[newKey] = updated[oldKey];
                if (Array.isArray(updated)) {
                  updated.splice(oldKey, 1);
                } else {
                  delete updated[oldKey];
                }
              } else {
                updated[oldKey] = copyWithRenameImpl(
                  obj[oldKey],
                  oldPath,
                  newPath,
                  index2 + 1
                );
              }
              return updated;
            };
            var copyWithRename = function(obj, oldPath, newPath) {
              if (oldPath.length !== newPath.length) {
                warn("copyWithRename() expects paths of the same length");
                return;
              } else {
                for (var i = 0; i < newPath.length - 1; i++) {
                  if (oldPath[i] !== newPath[i]) {
                    warn("copyWithRename() expects paths to be the same except for the deepest key");
                    return;
                  }
                }
              }
              return copyWithRenameImpl(obj, oldPath, newPath, 0);
            };
            var copyWithSetImpl = function(obj, path, index2, value) {
              if (index2 >= path.length) {
                return value;
              }
              var key = path[index2];
              var updated = Array.isArray(obj) ? obj.slice() : _assign({}, obj);
              updated[key] = copyWithSetImpl(obj[key], path, index2 + 1, value);
              return updated;
            };
            var copyWithSet = function(obj, path, value) {
              return copyWithSetImpl(obj, path, 0, value);
            };
            var findHook = function(fiber, id) {
              var currentHook2 = fiber.memoizedState;
              while (currentHook2 !== null && id > 0) {
                currentHook2 = currentHook2.next;
                id--;
              }
              return currentHook2;
            };
            overrideHookState = function(fiber, id, path, value) {
              var hook = findHook(fiber, id);
              if (hook !== null) {
                var newState = copyWithSet(hook.memoizedState, path, value);
                hook.memoizedState = newState;
                hook.baseState = newState;
                fiber.memoizedProps = _assign({}, fiber.memoizedProps);
                scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
              }
            };
            overrideHookStateDeletePath = function(fiber, id, path) {
              var hook = findHook(fiber, id);
              if (hook !== null) {
                var newState = copyWithDelete(hook.memoizedState, path);
                hook.memoizedState = newState;
                hook.baseState = newState;
                fiber.memoizedProps = _assign({}, fiber.memoizedProps);
                scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
              }
            };
            overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {
              var hook = findHook(fiber, id);
              if (hook !== null) {
                var newState = copyWithRename(hook.memoizedState, oldPath, newPath);
                hook.memoizedState = newState;
                hook.baseState = newState;
                fiber.memoizedProps = _assign({}, fiber.memoizedProps);
                scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
              }
            };
            overrideProps = function(fiber, path, value) {
              fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);
              if (fiber.alternate) {
                fiber.alternate.pendingProps = fiber.pendingProps;
              }
              scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
            };
            overridePropsDeletePath = function(fiber, path) {
              fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);
              if (fiber.alternate) {
                fiber.alternate.pendingProps = fiber.pendingProps;
              }
              scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
            };
            overridePropsRenamePath = function(fiber, oldPath, newPath) {
              fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);
              if (fiber.alternate) {
                fiber.alternate.pendingProps = fiber.pendingProps;
              }
              scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
            };
            scheduleUpdate = function(fiber) {
              scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
            };
            setSuspenseHandler = function(newShouldSuspendImpl) {
              shouldSuspendImpl = newShouldSuspendImpl;
            };
          }
          function findHostInstanceByFiber(fiber) {
            var hostFiber = findCurrentHostFiber(fiber);
            if (hostFiber === null) {
              return null;
            }
            return hostFiber.stateNode;
          }
          function emptyFindFiberByHostInstance(instance2) {
            return null;
          }
          function getCurrentFiberForDevTools() {
            return current;
          }
          function injectIntoDevTools(devToolsConfig) {
            var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
            var ReactCurrentDispatcher2 = ReactSharedInternals.ReactCurrentDispatcher;
            return injectInternals({
              bundleType: devToolsConfig.bundleType,
              version: devToolsConfig.version,
              rendererPackageName: devToolsConfig.rendererPackageName,
              rendererConfig: devToolsConfig.rendererConfig,
              overrideHookState,
              overrideHookStateDeletePath,
              overrideHookStateRenamePath,
              overrideProps,
              overridePropsDeletePath,
              overridePropsRenamePath,
              setSuspenseHandler,
              scheduleUpdate,
              currentDispatcherRef: ReactCurrentDispatcher2,
              findHostInstanceByFiber,
              findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,
              findHostInstancesForRefresh,
              scheduleRefresh,
              scheduleRoot,
              setRefreshHandler,
              getCurrentFiber: getCurrentFiberForDevTools
            });
          }
          exports3.IsThisRendererActing = IsThisRendererActing;
          exports3.act = act;
          exports3.attemptContinuousHydration = attemptContinuousHydration;
          exports3.attemptHydrationAtCurrentPriority = attemptHydrationAtCurrentPriority;
          exports3.attemptSynchronousHydration = attemptSynchronousHydration;
          exports3.attemptUserBlockingHydration = attemptUserBlockingHydration;
          exports3.batchedEventUpdates = batchedEventUpdates;
          exports3.batchedUpdates = batchedUpdates;
          exports3.createComponentSelector = createComponentSelector;
          exports3.createContainer = createContainer;
          exports3.createHasPsuedoClassSelector = createHasPsuedoClassSelector;
          exports3.createPortal = createPortal;
          exports3.createRoleSelector = createRoleSelector;
          exports3.createTestNameSelector = createTestNameSelector;
          exports3.createTextSelector = createTextSelector;
          exports3.deferredUpdates = deferredUpdates;
          exports3.discreteUpdates = discreteUpdates;
          exports3.findAllNodes = findAllNodes;
          exports3.findBoundingRects = findBoundingRects;
          exports3.findHostInstance = findHostInstance;
          exports3.findHostInstanceWithNoPortals = findHostInstanceWithNoPortals;
          exports3.findHostInstanceWithWarning = findHostInstanceWithWarning;
          exports3.flushControlled = flushControlled;
          exports3.flushDiscreteUpdates = flushDiscreteUpdates;
          exports3.flushPassiveEffects = flushPassiveEffects;
          exports3.flushSync = flushSync;
          exports3.focusWithin = focusWithin;
          exports3.getCurrentUpdateLanePriority = getCurrentUpdateLanePriority;
          exports3.getFindAllNodesFailureDescription = getFindAllNodesFailureDescription;
          exports3.getPublicRootInstance = getPublicRootInstance;
          exports3.injectIntoDevTools = injectIntoDevTools;
          exports3.observeVisibleRects = observeVisibleRects;
          exports3.registerMutableSourceForHydration = registerMutableSourceForHydration;
          exports3.runWithPriority = runWithPriority$1;
          exports3.shouldSuspend = shouldSuspend;
          exports3.unbatchedUpdates = unbatchedUpdates;
          exports3.updateContainer = updateContainer;
          return exports3;
        };
      }
    }
  });

  // node_modules/react-reconciler/index.js
  var require_react_reconciler = __commonJS({
    "node_modules/react-reconciler/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      if (false) {
        module2.exports = null;
      } else {
        module2.exports = require_react_reconciler_development();
      }
    }
  });

  // node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
  var require_use_sync_external_store_shim_development = __commonJS({
    "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      if (true) {
        (function() {
          "use strict";
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
          }
          var React15 = require_react();
          var ReactSharedInternals = React15.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
          function error2(format) {
            {
              {
                for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  args[_key2 - 1] = arguments[_key2];
                }
                printWarning("error", format, args);
              }
            }
          }
          function printWarning(level, format, args) {
            {
              var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack = ReactDebugCurrentFrame.getStackAddendum();
              if (stack !== "") {
                format += "%s";
                args = args.concat([stack]);
              }
              var argsWithFormat = args.map(function(item) {
                return String(item);
              });
              argsWithFormat.unshift("Warning: " + format);
              Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
          }
          function is4(x2, y2) {
            return x2 === y2 && (x2 !== 0 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
          }
          var objectIs = typeof Object.is === "function" ? Object.is : is4;
          var useState6 = React15.useState, useEffect6 = React15.useEffect, useLayoutEffect = React15.useLayoutEffect, useDebugValue2 = React15.useDebugValue;
          var didWarnOld18Alpha = false;
          var didWarnUncachedGetSnapshot = false;
          function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
            {
              if (!didWarnOld18Alpha) {
                if (React15.startTransition !== void 0) {
                  didWarnOld18Alpha = true;
                  error2("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.");
                }
              }
            }
            var value = getSnapshot();
            {
              if (!didWarnUncachedGetSnapshot) {
                var cachedValue = getSnapshot();
                if (!objectIs(value, cachedValue)) {
                  error2("The result of getSnapshot should be cached to avoid an infinite loop");
                  didWarnUncachedGetSnapshot = true;
                }
              }
            }
            var _useState = useState6({
              inst: {
                value,
                getSnapshot
              }
            }), inst = _useState[0].inst, forceUpdate = _useState[1];
            useLayoutEffect(function() {
              inst.value = value;
              inst.getSnapshot = getSnapshot;
              if (checkIfSnapshotChanged(inst)) {
                forceUpdate({
                  inst
                });
              }
            }, [subscribe, value, getSnapshot]);
            useEffect6(function() {
              if (checkIfSnapshotChanged(inst)) {
                forceUpdate({
                  inst
                });
              }
              var handleStoreChange = function() {
                if (checkIfSnapshotChanged(inst)) {
                  forceUpdate({
                    inst
                  });
                }
              };
              return subscribe(handleStoreChange);
            }, [subscribe]);
            useDebugValue2(value);
            return value;
          }
          function checkIfSnapshotChanged(inst) {
            var latestGetSnapshot = inst.getSnapshot;
            var prevValue = inst.value;
            try {
              var nextValue = latestGetSnapshot();
              return !objectIs(prevValue, nextValue);
            } catch (error3) {
              return true;
            }
          }
          function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
            return getSnapshot();
          }
          var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
          var isServerEnvironment = !canUseDOM;
          var shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;
          var useSyncExternalStore$2 = React15.useSyncExternalStore !== void 0 ? React15.useSyncExternalStore : shim;
          exports2.useSyncExternalStore = useSyncExternalStore$2;
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
          }
        })();
      }
    }
  });

  // node_modules/use-sync-external-store/shim/index.js
  var require_shim = __commonJS({
    "node_modules/use-sync-external-store/shim/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      if (false) {
        module2.exports = null;
      } else {
        module2.exports = require_use_sync_external_store_shim_development();
      }
    }
  });

  // node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js
  var require_with_selector_development = __commonJS({
    "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      if (true) {
        (function() {
          "use strict";
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
          }
          var React15 = require_react();
          var shim = require_shim();
          function is4(x2, y2) {
            return x2 === y2 && (x2 !== 0 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
          }
          var objectIs = typeof Object.is === "function" ? Object.is : is4;
          var useSyncExternalStore = shim.useSyncExternalStore;
          var useRef2 = React15.useRef, useEffect6 = React15.useEffect, useMemo2 = React15.useMemo, useDebugValue2 = React15.useDebugValue;
          function useSyncExternalStoreWithSelector2(subscribe, getSnapshot, getServerSnapshot, selector4, isEqual) {
            var instRef = useRef2(null);
            var inst;
            if (instRef.current === null) {
              inst = {
                hasValue: false,
                value: null
              };
              instRef.current = inst;
            } else {
              inst = instRef.current;
            }
            var _useMemo = useMemo2(function() {
              var hasMemo = false;
              var memoizedSnapshot;
              var memoizedSelection;
              var memoizedSelector = function(nextSnapshot) {
                if (!hasMemo) {
                  hasMemo = true;
                  memoizedSnapshot = nextSnapshot;
                  var _nextSelection = selector4(nextSnapshot);
                  if (isEqual !== void 0) {
                    if (inst.hasValue) {
                      var currentSelection = inst.value;
                      if (isEqual(currentSelection, _nextSelection)) {
                        memoizedSelection = currentSelection;
                        return currentSelection;
                      }
                    }
                  }
                  memoizedSelection = _nextSelection;
                  return _nextSelection;
                }
                var prevSnapshot = memoizedSnapshot;
                var prevSelection = memoizedSelection;
                if (objectIs(prevSnapshot, nextSnapshot)) {
                  return prevSelection;
                }
                var nextSelection = selector4(nextSnapshot);
                if (isEqual !== void 0 && isEqual(prevSelection, nextSelection)) {
                  return prevSelection;
                }
                memoizedSnapshot = nextSnapshot;
                memoizedSelection = nextSelection;
                return nextSelection;
              };
              var maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;
              var getSnapshotWithSelector = function() {
                return memoizedSelector(getSnapshot());
              };
              var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? void 0 : function() {
                return memoizedSelector(maybeGetServerSnapshot());
              };
              return [getSnapshotWithSelector, getServerSnapshotWithSelector];
            }, [getSnapshot, getServerSnapshot, selector4, isEqual]), getSelection = _useMemo[0], getServerSelection = _useMemo[1];
            var value = useSyncExternalStore(subscribe, getSelection, getServerSelection);
            useEffect6(function() {
              inst.hasValue = true;
              inst.value = value;
            }, [value]);
            useDebugValue2(value);
            return value;
          }
          exports2.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector2;
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
          }
        })();
      }
    }
  });

  // node_modules/use-sync-external-store/shim/with-selector.js
  var require_with_selector = __commonJS({
    "node_modules/use-sync-external-store/shim/with-selector.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      if (false) {
        module2.exports = null;
      } else {
        module2.exports = require_with_selector_development();
      }
    }
  });

  // node_modules/uuid/dist/esm-browser/rng.js
  function rng() {
    if (!getRandomValues) {
      getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
      if (!getRandomValues) {
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      }
    }
    return getRandomValues(rnds8);
  }
  var getRandomValues, rnds8;
  var init_rng = __esm({
    "node_modules/uuid/dist/esm-browser/rng.js"() {
      init_virtual_process_polyfill();
      init_buffer();
      rnds8 = new Uint8Array(16);
    }
  });

  // node_modules/uuid/dist/esm-browser/regex.js
  var regex_default;
  var init_regex = __esm({
    "node_modules/uuid/dist/esm-browser/regex.js"() {
      init_virtual_process_polyfill();
      init_buffer();
      regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
    }
  });

  // node_modules/uuid/dist/esm-browser/validate.js
  function validate(uuid) {
    return typeof uuid === "string" && regex_default.test(uuid);
  }
  var validate_default;
  var init_validate = __esm({
    "node_modules/uuid/dist/esm-browser/validate.js"() {
      init_virtual_process_polyfill();
      init_buffer();
      init_regex();
      validate_default = validate;
    }
  });

  // node_modules/uuid/dist/esm-browser/stringify.js
  function stringify(arr) {
    var offset3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var uuid = (byteToHex[arr[offset3 + 0]] + byteToHex[arr[offset3 + 1]] + byteToHex[arr[offset3 + 2]] + byteToHex[arr[offset3 + 3]] + "-" + byteToHex[arr[offset3 + 4]] + byteToHex[arr[offset3 + 5]] + "-" + byteToHex[arr[offset3 + 6]] + byteToHex[arr[offset3 + 7]] + "-" + byteToHex[arr[offset3 + 8]] + byteToHex[arr[offset3 + 9]] + "-" + byteToHex[arr[offset3 + 10]] + byteToHex[arr[offset3 + 11]] + byteToHex[arr[offset3 + 12]] + byteToHex[arr[offset3 + 13]] + byteToHex[arr[offset3 + 14]] + byteToHex[arr[offset3 + 15]]).toLowerCase();
    if (!validate_default(uuid)) {
      throw TypeError("Stringified UUID is invalid");
    }
    return uuid;
  }
  var byteToHex, i, stringify_default;
  var init_stringify = __esm({
    "node_modules/uuid/dist/esm-browser/stringify.js"() {
      init_virtual_process_polyfill();
      init_buffer();
      init_validate();
      byteToHex = [];
      for (i = 0; i < 256; ++i) {
        byteToHex.push((i + 256).toString(16).substr(1));
      }
      stringify_default = stringify;
    }
  });

  // node_modules/uuid/dist/esm-browser/v1.js
  function v1(options, buf, offset3) {
    var i = buf && offset3 || 0;
    var b2 = buf || new Array(16);
    options = options || {};
    var node = options.node || _nodeId;
    var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
    if (node == null || clockseq == null) {
      var seedBytes = options.random || (options.rng || rng)();
      if (node == null) {
        node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
      }
      if (clockseq == null) {
        clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
      }
    }
    var msecs = options.msecs !== void 0 ? options.msecs : Date.now();
    var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
    var dt2 = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
    if (dt2 < 0 && options.clockseq === void 0) {
      clockseq = clockseq + 1 & 16383;
    }
    if ((dt2 < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
      nsecs = 0;
    }
    if (nsecs >= 1e4) {
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    }
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;
    msecs += 122192928e5;
    var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
    b2[i++] = tl >>> 24 & 255;
    b2[i++] = tl >>> 16 & 255;
    b2[i++] = tl >>> 8 & 255;
    b2[i++] = tl & 255;
    var tmh = msecs / 4294967296 * 1e4 & 268435455;
    b2[i++] = tmh >>> 8 & 255;
    b2[i++] = tmh & 255;
    b2[i++] = tmh >>> 24 & 15 | 16;
    b2[i++] = tmh >>> 16 & 255;
    b2[i++] = clockseq >>> 8 | 128;
    b2[i++] = clockseq & 255;
    for (var n = 0; n < 6; ++n) {
      b2[i + n] = node[n];
    }
    return buf || stringify_default(b2);
  }
  var _nodeId, _clockseq, _lastMSecs, _lastNSecs, v1_default;
  var init_v1 = __esm({
    "node_modules/uuid/dist/esm-browser/v1.js"() {
      init_virtual_process_polyfill();
      init_buffer();
      init_rng();
      init_stringify();
      _lastMSecs = 0;
      _lastNSecs = 0;
      v1_default = v1;
    }
  });

  // node_modules/uuid/dist/esm-browser/parse.js
  function parse(uuid) {
    if (!validate_default(uuid)) {
      throw TypeError("Invalid UUID");
    }
    var v2;
    var arr = new Uint8Array(16);
    arr[0] = (v2 = parseInt(uuid.slice(0, 8), 16)) >>> 24;
    arr[1] = v2 >>> 16 & 255;
    arr[2] = v2 >>> 8 & 255;
    arr[3] = v2 & 255;
    arr[4] = (v2 = parseInt(uuid.slice(9, 13), 16)) >>> 8;
    arr[5] = v2 & 255;
    arr[6] = (v2 = parseInt(uuid.slice(14, 18), 16)) >>> 8;
    arr[7] = v2 & 255;
    arr[8] = (v2 = parseInt(uuid.slice(19, 23), 16)) >>> 8;
    arr[9] = v2 & 255;
    arr[10] = (v2 = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
    arr[11] = v2 / 4294967296 & 255;
    arr[12] = v2 >>> 24 & 255;
    arr[13] = v2 >>> 16 & 255;
    arr[14] = v2 >>> 8 & 255;
    arr[15] = v2 & 255;
    return arr;
  }
  var parse_default;
  var init_parse = __esm({
    "node_modules/uuid/dist/esm-browser/parse.js"() {
      init_virtual_process_polyfill();
      init_buffer();
      init_validate();
      parse_default = parse;
    }
  });

  // node_modules/uuid/dist/esm-browser/v35.js
  function stringToBytes(str3) {
    str3 = unescape(encodeURIComponent(str3));
    var bytes2 = [];
    for (var i = 0; i < str3.length; ++i) {
      bytes2.push(str3.charCodeAt(i));
    }
    return bytes2;
  }
  function v35_default(name2, version4, hashfunc) {
    function generateUUID(value, namespace, buf, offset3) {
      if (typeof value === "string") {
        value = stringToBytes(value);
      }
      if (typeof namespace === "string") {
        namespace = parse_default(namespace);
      }
      if (namespace.length !== 16) {
        throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
      }
      var bytes2 = new Uint8Array(16 + value.length);
      bytes2.set(namespace);
      bytes2.set(value, namespace.length);
      bytes2 = hashfunc(bytes2);
      bytes2[6] = bytes2[6] & 15 | version4;
      bytes2[8] = bytes2[8] & 63 | 128;
      if (buf) {
        offset3 = offset3 || 0;
        for (var i = 0; i < 16; ++i) {
          buf[offset3 + i] = bytes2[i];
        }
        return buf;
      }
      return stringify_default(bytes2);
    }
    try {
      generateUUID.name = name2;
    } catch (err2) {
    }
    generateUUID.DNS = DNS;
    generateUUID.URL = URL;
    return generateUUID;
  }
  var DNS, URL;
  var init_v35 = __esm({
    "node_modules/uuid/dist/esm-browser/v35.js"() {
      init_virtual_process_polyfill();
      init_buffer();
      init_stringify();
      init_parse();
      DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
      URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
    }
  });

  // node_modules/uuid/dist/esm-browser/md5.js
  function md5(bytes2) {
    if (typeof bytes2 === "string") {
      var msg = unescape(encodeURIComponent(bytes2));
      bytes2 = new Uint8Array(msg.length);
      for (var i = 0; i < msg.length; ++i) {
        bytes2[i] = msg.charCodeAt(i);
      }
    }
    return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes2), bytes2.length * 8));
  }
  function md5ToHexEncodedArray(input) {
    var output2 = [];
    var length32 = input.length * 32;
    var hexTab = "0123456789abcdef";
    for (var i = 0; i < length32; i += 8) {
      var x2 = input[i >> 5] >>> i % 32 & 255;
      var hex = parseInt(hexTab.charAt(x2 >>> 4 & 15) + hexTab.charAt(x2 & 15), 16);
      output2.push(hex);
    }
    return output2;
  }
  function getOutputLength(inputLength8) {
    return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
  }
  function wordsToMd5(x2, len) {
    x2[len >> 5] |= 128 << len % 32;
    x2[getOutputLength(len) - 1] = len;
    var a = 1732584193;
    var b2 = -271733879;
    var c2 = -1732584194;
    var d2 = 271733878;
    for (var i = 0; i < x2.length; i += 16) {
      var olda = a;
      var oldb = b2;
      var oldc = c2;
      var oldd = d2;
      a = md5ff(a, b2, c2, d2, x2[i], 7, -680876936);
      d2 = md5ff(d2, a, b2, c2, x2[i + 1], 12, -389564586);
      c2 = md5ff(c2, d2, a, b2, x2[i + 2], 17, 606105819);
      b2 = md5ff(b2, c2, d2, a, x2[i + 3], 22, -1044525330);
      a = md5ff(a, b2, c2, d2, x2[i + 4], 7, -176418897);
      d2 = md5ff(d2, a, b2, c2, x2[i + 5], 12, 1200080426);
      c2 = md5ff(c2, d2, a, b2, x2[i + 6], 17, -1473231341);
      b2 = md5ff(b2, c2, d2, a, x2[i + 7], 22, -45705983);
      a = md5ff(a, b2, c2, d2, x2[i + 8], 7, 1770035416);
      d2 = md5ff(d2, a, b2, c2, x2[i + 9], 12, -1958414417);
      c2 = md5ff(c2, d2, a, b2, x2[i + 10], 17, -42063);
      b2 = md5ff(b2, c2, d2, a, x2[i + 11], 22, -1990404162);
      a = md5ff(a, b2, c2, d2, x2[i + 12], 7, 1804603682);
      d2 = md5ff(d2, a, b2, c2, x2[i + 13], 12, -40341101);
      c2 = md5ff(c2, d2, a, b2, x2[i + 14], 17, -1502002290);
      b2 = md5ff(b2, c2, d2, a, x2[i + 15], 22, 1236535329);
      a = md5gg(a, b2, c2, d2, x2[i + 1], 5, -165796510);
      d2 = md5gg(d2, a, b2, c2, x2[i + 6], 9, -1069501632);
      c2 = md5gg(c2, d2, a, b2, x2[i + 11], 14, 643717713);
      b2 = md5gg(b2, c2, d2, a, x2[i], 20, -373897302);
      a = md5gg(a, b2, c2, d2, x2[i + 5], 5, -701558691);
      d2 = md5gg(d2, a, b2, c2, x2[i + 10], 9, 38016083);
      c2 = md5gg(c2, d2, a, b2, x2[i + 15], 14, -660478335);
      b2 = md5gg(b2, c2, d2, a, x2[i + 4], 20, -405537848);
      a = md5gg(a, b2, c2, d2, x2[i + 9], 5, 568446438);
      d2 = md5gg(d2, a, b2, c2, x2[i + 14], 9, -1019803690);
      c2 = md5gg(c2, d2, a, b2, x2[i + 3], 14, -187363961);
      b2 = md5gg(b2, c2, d2, a, x2[i + 8], 20, 1163531501);
      a = md5gg(a, b2, c2, d2, x2[i + 13], 5, -1444681467);
      d2 = md5gg(d2, a, b2, c2, x2[i + 2], 9, -51403784);
      c2 = md5gg(c2, d2, a, b2, x2[i + 7], 14, 1735328473);
      b2 = md5gg(b2, c2, d2, a, x2[i + 12], 20, -1926607734);
      a = md5hh(a, b2, c2, d2, x2[i + 5], 4, -378558);
      d2 = md5hh(d2, a, b2, c2, x2[i + 8], 11, -2022574463);
      c2 = md5hh(c2, d2, a, b2, x2[i + 11], 16, 1839030562);
      b2 = md5hh(b2, c2, d2, a, x2[i + 14], 23, -35309556);
      a = md5hh(a, b2, c2, d2, x2[i + 1], 4, -1530992060);
      d2 = md5hh(d2, a, b2, c2, x2[i + 4], 11, 1272893353);
      c2 = md5hh(c2, d2, a, b2, x2[i + 7], 16, -155497632);
      b2 = md5hh(b2, c2, d2, a, x2[i + 10], 23, -1094730640);
      a = md5hh(a, b2, c2, d2, x2[i + 13], 4, 681279174);
      d2 = md5hh(d2, a, b2, c2, x2[i], 11, -358537222);
      c2 = md5hh(c2, d2, a, b2, x2[i + 3], 16, -722521979);
      b2 = md5hh(b2, c2, d2, a, x2[i + 6], 23, 76029189);
      a = md5hh(a, b2, c2, d2, x2[i + 9], 4, -640364487);
      d2 = md5hh(d2, a, b2, c2, x2[i + 12], 11, -421815835);
      c2 = md5hh(c2, d2, a, b2, x2[i + 15], 16, 530742520);
      b2 = md5hh(b2, c2, d2, a, x2[i + 2], 23, -995338651);
      a = md5ii(a, b2, c2, d2, x2[i], 6, -198630844);
      d2 = md5ii(d2, a, b2, c2, x2[i + 7], 10, 1126891415);
      c2 = md5ii(c2, d2, a, b2, x2[i + 14], 15, -1416354905);
      b2 = md5ii(b2, c2, d2, a, x2[i + 5], 21, -57434055);
      a = md5ii(a, b2, c2, d2, x2[i + 12], 6, 1700485571);
      d2 = md5ii(d2, a, b2, c2, x2[i + 3], 10, -1894986606);
      c2 = md5ii(c2, d2, a, b2, x2[i + 10], 15, -1051523);
      b2 = md5ii(b2, c2, d2, a, x2[i + 1], 21, -2054922799);
      a = md5ii(a, b2, c2, d2, x2[i + 8], 6, 1873313359);
      d2 = md5ii(d2, a, b2, c2, x2[i + 15], 10, -30611744);
      c2 = md5ii(c2, d2, a, b2, x2[i + 6], 15, -1560198380);
      b2 = md5ii(b2, c2, d2, a, x2[i + 13], 21, 1309151649);
      a = md5ii(a, b2, c2, d2, x2[i + 4], 6, -145523070);
      d2 = md5ii(d2, a, b2, c2, x2[i + 11], 10, -1120210379);
      c2 = md5ii(c2, d2, a, b2, x2[i + 2], 15, 718787259);
      b2 = md5ii(b2, c2, d2, a, x2[i + 9], 21, -343485551);
      a = safeAdd(a, olda);
      b2 = safeAdd(b2, oldb);
      c2 = safeAdd(c2, oldc);
      d2 = safeAdd(d2, oldd);
    }
    return [a, b2, c2, d2];
  }
  function bytesToWords(input) {
    if (input.length === 0) {
      return [];
    }
    var length8 = input.length * 8;
    var output2 = new Uint32Array(getOutputLength(length8));
    for (var i = 0; i < length8; i += 8) {
      output2[i >> 5] |= (input[i / 8] & 255) << i % 32;
    }
    return output2;
  }
  function safeAdd(x2, y2) {
    var lsw = (x2 & 65535) + (y2 & 65535);
    var msw = (x2 >> 16) + (y2 >> 16) + (lsw >> 16);
    return msw << 16 | lsw & 65535;
  }
  function bitRotateLeft(num, cnt) {
    return num << cnt | num >>> 32 - cnt;
  }
  function md5cmn(q2, a, b2, x2, s, t2) {
    return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q2), safeAdd(x2, t2)), s), b2);
  }
  function md5ff(a, b2, c2, d2, x2, s, t2) {
    return md5cmn(b2 & c2 | ~b2 & d2, a, b2, x2, s, t2);
  }
  function md5gg(a, b2, c2, d2, x2, s, t2) {
    return md5cmn(b2 & d2 | c2 & ~d2, a, b2, x2, s, t2);
  }
  function md5hh(a, b2, c2, d2, x2, s, t2) {
    return md5cmn(b2 ^ c2 ^ d2, a, b2, x2, s, t2);
  }
  function md5ii(a, b2, c2, d2, x2, s, t2) {
    return md5cmn(c2 ^ (b2 | ~d2), a, b2, x2, s, t2);
  }
  var md5_default;
  var init_md5 = __esm({
    "node_modules/uuid/dist/esm-browser/md5.js"() {
      init_virtual_process_polyfill();
      init_buffer();
      md5_default = md5;
    }
  });

  // node_modules/uuid/dist/esm-browser/v3.js
  var v3, v3_default;
  var init_v3 = __esm({
    "node_modules/uuid/dist/esm-browser/v3.js"() {
      init_virtual_process_polyfill();
      init_buffer();
      init_v35();
      init_md5();
      v3 = v35_default("v3", 48, md5_default);
      v3_default = v3;
    }
  });

  // node_modules/uuid/dist/esm-browser/v4.js
  function v4(options, buf, offset3) {
    options = options || {};
    var rnds = options.random || (options.rng || rng)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset3 = offset3 || 0;
      for (var i = 0; i < 16; ++i) {
        buf[offset3 + i] = rnds[i];
      }
      return buf;
    }
    return stringify_default(rnds);
  }
  var v4_default;
  var init_v4 = __esm({
    "node_modules/uuid/dist/esm-browser/v4.js"() {
      init_virtual_process_polyfill();
      init_buffer();
      init_rng();
      init_stringify();
      v4_default = v4;
    }
  });

  // node_modules/uuid/dist/esm-browser/sha1.js
  function f(s, x2, y2, z2) {
    switch (s) {
      case 0:
        return x2 & y2 ^ ~x2 & z2;
      case 1:
        return x2 ^ y2 ^ z2;
      case 2:
        return x2 & y2 ^ x2 & z2 ^ y2 & z2;
      case 3:
        return x2 ^ y2 ^ z2;
    }
  }
  function ROTL(x2, n) {
    return x2 << n | x2 >>> 32 - n;
  }
  function sha1(bytes2) {
    var K3 = [1518500249, 1859775393, 2400959708, 3395469782];
    var H2 = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    if (typeof bytes2 === "string") {
      var msg = unescape(encodeURIComponent(bytes2));
      bytes2 = [];
      for (var i = 0; i < msg.length; ++i) {
        bytes2.push(msg.charCodeAt(i));
      }
    } else if (!Array.isArray(bytes2)) {
      bytes2 = Array.prototype.slice.call(bytes2);
    }
    bytes2.push(128);
    var l2 = bytes2.length / 4 + 2;
    var N2 = Math.ceil(l2 / 16);
    var M2 = new Array(N2);
    for (var _i = 0; _i < N2; ++_i) {
      var arr = new Uint32Array(16);
      for (var j2 = 0; j2 < 16; ++j2) {
        arr[j2] = bytes2[_i * 64 + j2 * 4] << 24 | bytes2[_i * 64 + j2 * 4 + 1] << 16 | bytes2[_i * 64 + j2 * 4 + 2] << 8 | bytes2[_i * 64 + j2 * 4 + 3];
      }
      M2[_i] = arr;
    }
    M2[N2 - 1][14] = (bytes2.length - 1) * 8 / Math.pow(2, 32);
    M2[N2 - 1][14] = Math.floor(M2[N2 - 1][14]);
    M2[N2 - 1][15] = (bytes2.length - 1) * 8 & 4294967295;
    for (var _i2 = 0; _i2 < N2; ++_i2) {
      var W2 = new Uint32Array(80);
      for (var t2 = 0; t2 < 16; ++t2) {
        W2[t2] = M2[_i2][t2];
      }
      for (var _t2 = 16; _t2 < 80; ++_t2) {
        W2[_t2] = ROTL(W2[_t2 - 3] ^ W2[_t2 - 8] ^ W2[_t2 - 14] ^ W2[_t2 - 16], 1);
      }
      var a = H2[0];
      var b2 = H2[1];
      var c2 = H2[2];
      var d2 = H2[3];
      var e = H2[4];
      for (var _t22 = 0; _t22 < 80; ++_t22) {
        var s = Math.floor(_t22 / 20);
        var T2 = ROTL(a, 5) + f(s, b2, c2, d2) + e + K3[s] + W2[_t22] >>> 0;
        e = d2;
        d2 = c2;
        c2 = ROTL(b2, 30) >>> 0;
        b2 = a;
        a = T2;
      }
      H2[0] = H2[0] + a >>> 0;
      H2[1] = H2[1] + b2 >>> 0;
      H2[2] = H2[2] + c2 >>> 0;
      H2[3] = H2[3] + d2 >>> 0;
      H2[4] = H2[4] + e >>> 0;
    }
    return [H2[0] >> 24 & 255, H2[0] >> 16 & 255, H2[0] >> 8 & 255, H2[0] & 255, H2[1] >> 24 & 255, H2[1] >> 16 & 255, H2[1] >> 8 & 255, H2[1] & 255, H2[2] >> 24 & 255, H2[2] >> 16 & 255, H2[2] >> 8 & 255, H2[2] & 255, H2[3] >> 24 & 255, H2[3] >> 16 & 255, H2[3] >> 8 & 255, H2[3] & 255, H2[4] >> 24 & 255, H2[4] >> 16 & 255, H2[4] >> 8 & 255, H2[4] & 255];
  }
  var sha1_default;
  var init_sha1 = __esm({
    "node_modules/uuid/dist/esm-browser/sha1.js"() {
      init_virtual_process_polyfill();
      init_buffer();
      sha1_default = sha1;
    }
  });

  // node_modules/uuid/dist/esm-browser/v5.js
  var v5, v5_default;
  var init_v5 = __esm({
    "node_modules/uuid/dist/esm-browser/v5.js"() {
      init_virtual_process_polyfill();
      init_buffer();
      init_v35();
      init_sha1();
      v5 = v35_default("v5", 80, sha1_default);
      v5_default = v5;
    }
  });

  // node_modules/uuid/dist/esm-browser/nil.js
  var nil_default;
  var init_nil = __esm({
    "node_modules/uuid/dist/esm-browser/nil.js"() {
      init_virtual_process_polyfill();
      init_buffer();
      nil_default = "00000000-0000-0000-0000-000000000000";
    }
  });

  // node_modules/uuid/dist/esm-browser/version.js
  function version2(uuid) {
    if (!validate_default(uuid)) {
      throw TypeError("Invalid UUID");
    }
    return parseInt(uuid.substr(14, 1), 16);
  }
  var version_default;
  var init_version = __esm({
    "node_modules/uuid/dist/esm-browser/version.js"() {
      init_virtual_process_polyfill();
      init_buffer();
      init_validate();
      version_default = version2;
    }
  });

  // node_modules/uuid/dist/esm-browser/index.js
  var esm_browser_exports = {};
  __export(esm_browser_exports, {
    NIL: () => nil_default,
    parse: () => parse_default,
    stringify: () => stringify_default,
    v1: () => v1_default,
    v3: () => v3_default,
    v4: () => v4_default,
    v5: () => v5_default,
    validate: () => validate_default,
    version: () => version_default
  });
  var init_esm_browser = __esm({
    "node_modules/uuid/dist/esm-browser/index.js"() {
      init_virtual_process_polyfill();
      init_buffer();
      init_v1();
      init_v3();
      init_v4();
      init_v5();
      init_nil();
      init_version();
      init_validate();
      init_stringify();
      init_parse();
    }
  });

  // node_modules/eventemitter3/index.js
  var require_eventemitter3 = __commonJS({
    "node_modules/eventemitter3/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var has = Object.prototype.hasOwnProperty;
      var prefix = "~";
      function Events() {
      }
      if (Object.create) {
        Events.prototype = /* @__PURE__ */ Object.create(null);
        if (!new Events().__proto__)
          prefix = false;
      }
      function EE(fn2, context, once2) {
        this.fn = fn2;
        this.context = context;
        this.once = once2 || false;
      }
      function addListener2(emitter, event, fn2, context, once2) {
        if (typeof fn2 !== "function") {
          throw new TypeError("The listener must be a function");
        }
        var listener = new EE(fn2, context || emitter, once2), evt = prefix ? prefix + event : event;
        if (!emitter._events[evt])
          emitter._events[evt] = listener, emitter._eventsCount++;
        else if (!emitter._events[evt].fn)
          emitter._events[evt].push(listener);
        else
          emitter._events[evt] = [emitter._events[evt], listener];
        return emitter;
      }
      function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0)
          emitter._events = new Events();
        else
          delete emitter._events[evt];
      }
      function EventEmitter3() {
        this._events = new Events();
        this._eventsCount = 0;
      }
      EventEmitter3.prototype.eventNames = function eventNames() {
        var names = [], events2, name2;
        if (this._eventsCount === 0)
          return names;
        for (name2 in events2 = this._events) {
          if (has.call(events2, name2))
            names.push(prefix ? name2.slice(1) : name2);
        }
        if (Object.getOwnPropertySymbols) {
          return names.concat(Object.getOwnPropertySymbols(events2));
        }
        return names;
      };
      EventEmitter3.prototype.listeners = function listeners(event) {
        var evt = prefix ? prefix + event : event, handlers = this._events[evt];
        if (!handlers)
          return [];
        if (handlers.fn)
          return [handlers.fn];
        for (var i = 0, l2 = handlers.length, ee2 = new Array(l2); i < l2; i++) {
          ee2[i] = handlers[i].fn;
        }
        return ee2;
      };
      EventEmitter3.prototype.listenerCount = function listenerCount(event) {
        var evt = prefix ? prefix + event : event, listeners = this._events[evt];
        if (!listeners)
          return 0;
        if (listeners.fn)
          return 1;
        return listeners.length;
      };
      EventEmitter3.prototype.emit = function emit2(event, a1, a2, a3, a4, a5) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return false;
        var listeners = this._events[evt], len = arguments.length, args, i;
        if (listeners.fn) {
          if (listeners.once)
            this.removeListener(event, listeners.fn, void 0, true);
          switch (len) {
            case 1:
              return listeners.fn.call(listeners.context), true;
            case 2:
              return listeners.fn.call(listeners.context, a1), true;
            case 3:
              return listeners.fn.call(listeners.context, a1, a2), true;
            case 4:
              return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
          }
          for (i = 1, args = new Array(len - 1); i < len; i++) {
            args[i - 1] = arguments[i];
          }
          listeners.fn.apply(listeners.context, args);
        } else {
          var length = listeners.length, j2;
          for (i = 0; i < length; i++) {
            if (listeners[i].once)
              this.removeListener(event, listeners[i].fn, void 0, true);
            switch (len) {
              case 1:
                listeners[i].fn.call(listeners[i].context);
                break;
              case 2:
                listeners[i].fn.call(listeners[i].context, a1);
                break;
              case 3:
                listeners[i].fn.call(listeners[i].context, a1, a2);
                break;
              case 4:
                listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                break;
              default:
                if (!args)
                  for (j2 = 1, args = new Array(len - 1); j2 < len; j2++) {
                    args[j2 - 1] = arguments[j2];
                  }
                listeners[i].fn.apply(listeners[i].context, args);
            }
          }
        }
        return true;
      };
      EventEmitter3.prototype.on = function on3(event, fn2, context) {
        return addListener2(this, event, fn2, context, false);
      };
      EventEmitter3.prototype.once = function once2(event, fn2, context) {
        return addListener2(this, event, fn2, context, true);
      };
      EventEmitter3.prototype.removeListener = function removeListener2(event, fn2, context, once2) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return this;
        if (!fn2) {
          clearEvent(this, evt);
          return this;
        }
        var listeners = this._events[evt];
        if (listeners.fn) {
          if (listeners.fn === fn2 && (!once2 || listeners.once) && (!context || listeners.context === context)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i = 0, events2 = [], length = listeners.length; i < length; i++) {
            if (listeners[i].fn !== fn2 || once2 && !listeners[i].once || context && listeners[i].context !== context) {
              events2.push(listeners[i]);
            }
          }
          if (events2.length)
            this._events[evt] = events2.length === 1 ? events2[0] : events2;
          else
            clearEvent(this, evt);
        }
        return this;
      };
      EventEmitter3.prototype.removeAllListeners = function removeAllListeners2(event) {
        var evt;
        if (event) {
          evt = prefix ? prefix + event : event;
          if (this._events[evt])
            clearEvent(this, evt);
        } else {
          this._events = new Events();
          this._eventsCount = 0;
        }
        return this;
      };
      EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
      EventEmitter3.prototype.addListener = EventEmitter3.prototype.on;
      EventEmitter3.prefixed = prefix;
      EventEmitter3.EventEmitter = EventEmitter3;
      if ("undefined" !== typeof module2) {
        module2.exports = EventEmitter3;
      }
    }
  });

  // node_modules/react/cjs/react-jsx-runtime.development.js
  var require_react_jsx_runtime_development = __commonJS({
    "node_modules/react/cjs/react-jsx-runtime.development.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      if (true) {
        (function() {
          "use strict";
          var React15 = require_react();
          var REACT_ELEMENT_TYPE = Symbol.for("react.element");
          var REACT_PORTAL_TYPE = Symbol.for("react.portal");
          var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
          var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
          var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
          var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
          var REACT_CONTEXT_TYPE = Symbol.for("react.context");
          var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
          var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
          var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
          var REACT_MEMO_TYPE = Symbol.for("react.memo");
          var REACT_LAZY_TYPE = Symbol.for("react.lazy");
          var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
          var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
          var FAUX_ITERATOR_SYMBOL = "@@iterator";
          function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== "object") {
              return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === "function") {
              return maybeIterator;
            }
            return null;
          }
          var ReactSharedInternals = React15.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
          function error2(format) {
            {
              {
                for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  args[_key2 - 1] = arguments[_key2];
                }
                printWarning("error", format, args);
              }
            }
          }
          function printWarning(level, format, args) {
            {
              var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack = ReactDebugCurrentFrame2.getStackAddendum();
              if (stack !== "") {
                format += "%s";
                args = args.concat([stack]);
              }
              var argsWithFormat = args.map(function(item) {
                return String(item);
              });
              argsWithFormat.unshift("Warning: " + format);
              Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
          }
          var enableScopeAPI = false;
          var enableCacheElement = false;
          var enableTransitionTracing = false;
          var enableLegacyHidden = false;
          var enableDebugTracing = false;
          var REACT_MODULE_REFERENCE;
          {
            REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
          }
          function isValidElementType(type5) {
            if (typeof type5 === "string" || typeof type5 === "function") {
              return true;
            }
            if (type5 === REACT_FRAGMENT_TYPE || type5 === REACT_PROFILER_TYPE || enableDebugTracing || type5 === REACT_STRICT_MODE_TYPE || type5 === REACT_SUSPENSE_TYPE || type5 === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type5 === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
              return true;
            }
            if (typeof type5 === "object" && type5 !== null) {
              if (type5.$$typeof === REACT_LAZY_TYPE || type5.$$typeof === REACT_MEMO_TYPE || type5.$$typeof === REACT_PROVIDER_TYPE || type5.$$typeof === REACT_CONTEXT_TYPE || type5.$$typeof === REACT_FORWARD_REF_TYPE || type5.$$typeof === REACT_MODULE_REFERENCE || type5.getModuleId !== void 0) {
                return true;
              }
            }
            return false;
          }
          function getWrappedName(outerType, innerType, wrapperName) {
            var displayName = outerType.displayName;
            if (displayName) {
              return displayName;
            }
            var functionName = innerType.displayName || innerType.name || "";
            return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
          }
          function getContextName(type5) {
            return type5.displayName || "Context";
          }
          function getComponentNameFromType(type5) {
            if (type5 == null) {
              return null;
            }
            {
              if (typeof type5.tag === "number") {
                error2("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
              }
            }
            if (typeof type5 === "function") {
              return type5.displayName || type5.name || null;
            }
            if (typeof type5 === "string") {
              return type5;
            }
            switch (type5) {
              case REACT_FRAGMENT_TYPE:
                return "Fragment";
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_PROFILER_TYPE:
                return "Profiler";
              case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
              case REACT_SUSPENSE_TYPE:
                return "Suspense";
              case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            }
            if (typeof type5 === "object") {
              switch (type5.$$typeof) {
                case REACT_CONTEXT_TYPE:
                  var context = type5;
                  return getContextName(context) + ".Consumer";
                case REACT_PROVIDER_TYPE:
                  var provider = type5;
                  return getContextName(provider._context) + ".Provider";
                case REACT_FORWARD_REF_TYPE:
                  return getWrappedName(type5, type5.render, "ForwardRef");
                case REACT_MEMO_TYPE:
                  var outerName = type5.displayName || null;
                  if (outerName !== null) {
                    return outerName;
                  }
                  return getComponentNameFromType(type5.type) || "Memo";
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type5;
                  var payload = lazyComponent._payload;
                  var init2 = lazyComponent._init;
                  try {
                    return getComponentNameFromType(init2(payload));
                  } catch (x2) {
                    return null;
                  }
                }
              }
            }
            return null;
          }
          var assign2 = Object.assign;
          var disabledDepth = 0;
          var prevLog;
          var prevInfo;
          var prevWarn;
          var prevError;
          var prevGroup;
          var prevGroupCollapsed;
          var prevGroupEnd;
          function disabledLog() {
          }
          disabledLog.__reactDisabledLog = true;
          function disableLogs() {
            {
              if (disabledDepth === 0) {
                prevLog = console.log;
                prevInfo = console.info;
                prevWarn = console.warn;
                prevError = console.error;
                prevGroup = console.group;
                prevGroupCollapsed = console.groupCollapsed;
                prevGroupEnd = console.groupEnd;
                var props = {
                  configurable: true,
                  enumerable: true,
                  value: disabledLog,
                  writable: true
                };
                Object.defineProperties(console, {
                  info: props,
                  log: props,
                  warn: props,
                  error: props,
                  group: props,
                  groupCollapsed: props,
                  groupEnd: props
                });
              }
              disabledDepth++;
            }
          }
          function reenableLogs() {
            {
              disabledDepth--;
              if (disabledDepth === 0) {
                var props = {
                  configurable: true,
                  enumerable: true,
                  writable: true
                };
                Object.defineProperties(console, {
                  log: assign2({}, props, {
                    value: prevLog
                  }),
                  info: assign2({}, props, {
                    value: prevInfo
                  }),
                  warn: assign2({}, props, {
                    value: prevWarn
                  }),
                  error: assign2({}, props, {
                    value: prevError
                  }),
                  group: assign2({}, props, {
                    value: prevGroup
                  }),
                  groupCollapsed: assign2({}, props, {
                    value: prevGroupCollapsed
                  }),
                  groupEnd: assign2({}, props, {
                    value: prevGroupEnd
                  })
                });
              }
              if (disabledDepth < 0) {
                error2("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
              }
            }
          }
          var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
          var prefix;
          function describeBuiltInComponentFrame(name2, source, ownerFn) {
            {
              if (prefix === void 0) {
                try {
                  throw Error();
                } catch (x2) {
                  var match = x2.stack.trim().match(/\n( *(at )?)/);
                  prefix = match && match[1] || "";
                }
              }
              return "\n" + prefix + name2;
            }
          }
          var reentry = false;
          var componentFrameCache;
          {
            var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
            componentFrameCache = new PossiblyWeakMap();
          }
          function describeNativeComponentFrame(fn2, construct) {
            if (!fn2 || reentry) {
              return "";
            }
            {
              var frame = componentFrameCache.get(fn2);
              if (frame !== void 0) {
                return frame;
              }
            }
            var control;
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            var previousDispatcher;
            {
              previousDispatcher = ReactCurrentDispatcher.current;
              ReactCurrentDispatcher.current = null;
              disableLogs();
            }
            try {
              if (construct) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if (typeof Reflect === "object" && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x2) {
                    control = x2;
                  }
                  Reflect.construct(fn2, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x2) {
                    control = x2;
                  }
                  fn2.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x2) {
                  control = x2;
                }
                fn2();
              }
            } catch (sample) {
              if (sample && control && typeof sample.stack === "string") {
                var sampleLines = sample.stack.split("\n");
                var controlLines = control.stack.split("\n");
                var s = sampleLines.length - 1;
                var c2 = controlLines.length - 1;
                while (s >= 1 && c2 >= 0 && sampleLines[s] !== controlLines[c2]) {
                  c2--;
                }
                for (; s >= 1 && c2 >= 0; s--, c2--) {
                  if (sampleLines[s] !== controlLines[c2]) {
                    if (s !== 1 || c2 !== 1) {
                      do {
                        s--;
                        c2--;
                        if (c2 < 0 || sampleLines[s] !== controlLines[c2]) {
                          var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                          if (fn2.displayName && _frame.includes("<anonymous>")) {
                            _frame = _frame.replace("<anonymous>", fn2.displayName);
                          }
                          {
                            if (typeof fn2 === "function") {
                              componentFrameCache.set(fn2, _frame);
                            }
                          }
                          return _frame;
                        }
                      } while (s >= 1 && c2 >= 0);
                    }
                    break;
                  }
                }
              }
            } finally {
              reentry = false;
              {
                ReactCurrentDispatcher.current = previousDispatcher;
                reenableLogs();
              }
              Error.prepareStackTrace = previousPrepareStackTrace;
            }
            var name2 = fn2 ? fn2.displayName || fn2.name : "";
            var syntheticFrame = name2 ? describeBuiltInComponentFrame(name2) : "";
            {
              if (typeof fn2 === "function") {
                componentFrameCache.set(fn2, syntheticFrame);
              }
            }
            return syntheticFrame;
          }
          function describeFunctionComponentFrame(fn2, source, ownerFn) {
            {
              return describeNativeComponentFrame(fn2, false);
            }
          }
          function shouldConstruct(Component) {
            var prototype = Component.prototype;
            return !!(prototype && prototype.isReactComponent);
          }
          function describeUnknownElementTypeFrameInDEV(type5, source, ownerFn) {
            if (type5 == null) {
              return "";
            }
            if (typeof type5 === "function") {
              {
                return describeNativeComponentFrame(type5, shouldConstruct(type5));
              }
            }
            if (typeof type5 === "string") {
              return describeBuiltInComponentFrame(type5);
            }
            switch (type5) {
              case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame("Suspense");
              case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame("SuspenseList");
            }
            if (typeof type5 === "object") {
              switch (type5.$$typeof) {
                case REACT_FORWARD_REF_TYPE:
                  return describeFunctionComponentFrame(type5.render);
                case REACT_MEMO_TYPE:
                  return describeUnknownElementTypeFrameInDEV(type5.type, source, ownerFn);
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type5;
                  var payload = lazyComponent._payload;
                  var init2 = lazyComponent._init;
                  try {
                    return describeUnknownElementTypeFrameInDEV(init2(payload), source, ownerFn);
                  } catch (x2) {
                  }
                }
              }
            }
            return "";
          }
          var hasOwnProperty2 = Object.prototype.hasOwnProperty;
          var loggedTypeFailures = {};
          var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
          function setCurrentlyValidatingElement(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                ReactDebugCurrentFrame.setExtraStackFrame(stack);
              } else {
                ReactDebugCurrentFrame.setExtraStackFrame(null);
              }
            }
          }
          function checkPropTypes(typeSpecs, values, location, componentName, element) {
            {
              var has = Function.call.bind(hasOwnProperty2);
              for (var typeSpecName in typeSpecs) {
                if (has(typeSpecs, typeSpecName)) {
                  var error$1 = void 0;
                  try {
                    if (typeof typeSpecs[typeSpecName] !== "function") {
                      var err2 = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                      err2.name = "Invariant Violation";
                      throw err2;
                    }
                    error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                  } catch (ex) {
                    error$1 = ex;
                  }
                  if (error$1 && !(error$1 instanceof Error)) {
                    setCurrentlyValidatingElement(element);
                    error2("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                    setCurrentlyValidatingElement(null);
                  }
                  if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                    loggedTypeFailures[error$1.message] = true;
                    setCurrentlyValidatingElement(element);
                    error2("Failed %s type: %s", location, error$1.message);
                    setCurrentlyValidatingElement(null);
                  }
                }
              }
            }
          }
          var isArrayImpl = Array.isArray;
          function isArray2(a) {
            return isArrayImpl(a);
          }
          function typeName(value) {
            {
              var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
              var type5 = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
              return type5;
            }
          }
          function willCoercionThrow(value) {
            {
              try {
                testStringCoercion(value);
                return false;
              } catch (e) {
                return true;
              }
            }
          }
          function testStringCoercion(value) {
            return "" + value;
          }
          function checkKeyStringCoercion(value) {
            {
              if (willCoercionThrow(value)) {
                error2("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
          var RESERVED_PROPS = {
            key: true,
            ref: true,
            __self: true,
            __source: true
          };
          var specialPropKeyWarningShown;
          var specialPropRefWarningShown;
          var didWarnAboutStringRefs;
          {
            didWarnAboutStringRefs = {};
          }
          function hasValidRef(config2) {
            {
              if (hasOwnProperty2.call(config2, "ref")) {
                var getter = Object.getOwnPropertyDescriptor(config2, "ref").get;
                if (getter && getter.isReactWarning) {
                  return false;
                }
              }
            }
            return config2.ref !== void 0;
          }
          function hasValidKey(config2) {
            {
              if (hasOwnProperty2.call(config2, "key")) {
                var getter = Object.getOwnPropertyDescriptor(config2, "key").get;
                if (getter && getter.isReactWarning) {
                  return false;
                }
              }
            }
            return config2.key !== void 0;
          }
          function warnIfStringRefCannotBeAutoConverted(config2, self2) {
            {
              if (typeof config2.ref === "string" && ReactCurrentOwner.current && self2 && ReactCurrentOwner.current.stateNode !== self2) {
                var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
                if (!didWarnAboutStringRefs[componentName]) {
                  error2('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config2.ref);
                  didWarnAboutStringRefs[componentName] = true;
                }
              }
            }
          }
          function defineKeyPropWarningGetter(props, displayName) {
            {
              var warnAboutAccessingKey = function() {
                if (!specialPropKeyWarningShown) {
                  specialPropKeyWarningShown = true;
                  error2("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
                }
              };
              warnAboutAccessingKey.isReactWarning = true;
              Object.defineProperty(props, "key", {
                get: warnAboutAccessingKey,
                configurable: true
              });
            }
          }
          function defineRefPropWarningGetter(props, displayName) {
            {
              var warnAboutAccessingRef = function() {
                if (!specialPropRefWarningShown) {
                  specialPropRefWarningShown = true;
                  error2("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
                }
              };
              warnAboutAccessingRef.isReactWarning = true;
              Object.defineProperty(props, "ref", {
                get: warnAboutAccessingRef,
                configurable: true
              });
            }
          }
          var ReactElement = function(type5, key, ref, self2, source, owner, props) {
            var element = {
              $$typeof: REACT_ELEMENT_TYPE,
              type: type5,
              key,
              ref,
              props,
              _owner: owner
            };
            {
              element._store = {};
              Object.defineProperty(element._store, "validated", {
                configurable: false,
                enumerable: false,
                writable: true,
                value: false
              });
              Object.defineProperty(element, "_self", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: self2
              });
              Object.defineProperty(element, "_source", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: source
              });
              if (Object.freeze) {
                Object.freeze(element.props);
                Object.freeze(element);
              }
            }
            return element;
          };
          function jsxDEV(type5, config2, maybeKey, source, self2) {
            {
              var propName;
              var props = {};
              var key = null;
              var ref = null;
              if (maybeKey !== void 0) {
                {
                  checkKeyStringCoercion(maybeKey);
                }
                key = "" + maybeKey;
              }
              if (hasValidKey(config2)) {
                {
                  checkKeyStringCoercion(config2.key);
                }
                key = "" + config2.key;
              }
              if (hasValidRef(config2)) {
                ref = config2.ref;
                warnIfStringRefCannotBeAutoConverted(config2, self2);
              }
              for (propName in config2) {
                if (hasOwnProperty2.call(config2, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                  props[propName] = config2[propName];
                }
              }
              if (type5 && type5.defaultProps) {
                var defaultProps = type5.defaultProps;
                for (propName in defaultProps) {
                  if (props[propName] === void 0) {
                    props[propName] = defaultProps[propName];
                  }
                }
              }
              if (key || ref) {
                var displayName = typeof type5 === "function" ? type5.displayName || type5.name || "Unknown" : type5;
                if (key) {
                  defineKeyPropWarningGetter(props, displayName);
                }
                if (ref) {
                  defineRefPropWarningGetter(props, displayName);
                }
              }
              return ReactElement(type5, key, ref, self2, source, ReactCurrentOwner.current, props);
            }
          }
          var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
          var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
          function setCurrentlyValidatingElement$1(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
              } else {
                ReactDebugCurrentFrame$1.setExtraStackFrame(null);
              }
            }
          }
          var propTypesMisspellWarningShown;
          {
            propTypesMisspellWarningShown = false;
          }
          function isValidElement(object3) {
            {
              return typeof object3 === "object" && object3 !== null && object3.$$typeof === REACT_ELEMENT_TYPE;
            }
          }
          function getDeclarationErrorAddendum() {
            {
              if (ReactCurrentOwner$1.current) {
                var name2 = getComponentNameFromType(ReactCurrentOwner$1.current.type);
                if (name2) {
                  return "\n\nCheck the render method of `" + name2 + "`.";
                }
              }
              return "";
            }
          }
          function getSourceInfoErrorAddendum(source) {
            {
              if (source !== void 0) {
                var fileName = source.fileName.replace(/^.*[\\\/]/, "");
                var lineNumber = source.lineNumber;
                return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
              }
              return "";
            }
          }
          var ownerHasKeyUseWarning = {};
          function getCurrentComponentErrorInfo(parentType) {
            {
              var info = getDeclarationErrorAddendum();
              if (!info) {
                var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
                if (parentName) {
                  info = "\n\nCheck the top-level render call using <" + parentName + ">.";
                }
              }
              return info;
            }
          }
          function validateExplicitKey(element, parentType) {
            {
              if (!element._store || element._store.validated || element.key != null) {
                return;
              }
              element._store.validated = true;
              var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
              if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
                return;
              }
              ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
              var childOwner = "";
              if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
                childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
              }
              setCurrentlyValidatingElement$1(element);
              error2('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
              setCurrentlyValidatingElement$1(null);
            }
          }
          function validateChildKeys(node, parentType) {
            {
              if (typeof node !== "object") {
                return;
              }
              if (isArray2(node)) {
                for (var i = 0; i < node.length; i++) {
                  var child = node[i];
                  if (isValidElement(child)) {
                    validateExplicitKey(child, parentType);
                  }
                }
              } else if (isValidElement(node)) {
                if (node._store) {
                  node._store.validated = true;
                }
              } else if (node) {
                var iteratorFn = getIteratorFn(node);
                if (typeof iteratorFn === "function") {
                  if (iteratorFn !== node.entries) {
                    var iterator = iteratorFn.call(node);
                    var step;
                    while (!(step = iterator.next()).done) {
                      if (isValidElement(step.value)) {
                        validateExplicitKey(step.value, parentType);
                      }
                    }
                  }
                }
              }
            }
          }
          function validatePropTypes(element) {
            {
              var type5 = element.type;
              if (type5 === null || type5 === void 0 || typeof type5 === "string") {
                return;
              }
              var propTypes;
              if (typeof type5 === "function") {
                propTypes = type5.propTypes;
              } else if (typeof type5 === "object" && (type5.$$typeof === REACT_FORWARD_REF_TYPE || type5.$$typeof === REACT_MEMO_TYPE)) {
                propTypes = type5.propTypes;
              } else {
                return;
              }
              if (propTypes) {
                var name2 = getComponentNameFromType(type5);
                checkPropTypes(propTypes, element.props, "prop", name2, element);
              } else if (type5.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
                propTypesMisspellWarningShown = true;
                var _name = getComponentNameFromType(type5);
                error2("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
              }
              if (typeof type5.getDefaultProps === "function" && !type5.getDefaultProps.isReactClassApproved) {
                error2("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
              }
            }
          }
          function validateFragmentProps(fragment) {
            {
              var keys = Object.keys(fragment.props);
              for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                if (key !== "children" && key !== "key") {
                  setCurrentlyValidatingElement$1(fragment);
                  error2("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                  setCurrentlyValidatingElement$1(null);
                  break;
                }
              }
              if (fragment.ref !== null) {
                setCurrentlyValidatingElement$1(fragment);
                error2("Invalid attribute `ref` supplied to `React.Fragment`.");
                setCurrentlyValidatingElement$1(null);
              }
            }
          }
          function jsxWithValidation(type5, props, key, isStaticChildren, source, self2) {
            {
              var validType = isValidElementType(type5);
              if (!validType) {
                var info = "";
                if (type5 === void 0 || typeof type5 === "object" && type5 !== null && Object.keys(type5).length === 0) {
                  info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                }
                var sourceInfo = getSourceInfoErrorAddendum(source);
                if (sourceInfo) {
                  info += sourceInfo;
                } else {
                  info += getDeclarationErrorAddendum();
                }
                var typeString;
                if (type5 === null) {
                  typeString = "null";
                } else if (isArray2(type5)) {
                  typeString = "array";
                } else if (type5 !== void 0 && type5.$$typeof === REACT_ELEMENT_TYPE) {
                  typeString = "<" + (getComponentNameFromType(type5.type) || "Unknown") + " />";
                  info = " Did you accidentally export a JSX literal instead of a component?";
                } else {
                  typeString = typeof type5;
                }
                error2("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
              }
              var element = jsxDEV(type5, props, key, source, self2);
              if (element == null) {
                return element;
              }
              if (validType) {
                var children = props.children;
                if (children !== void 0) {
                  if (isStaticChildren) {
                    if (isArray2(children)) {
                      for (var i = 0; i < children.length; i++) {
                        validateChildKeys(children[i], type5);
                      }
                      if (Object.freeze) {
                        Object.freeze(children);
                      }
                    } else {
                      error2("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
                    }
                  } else {
                    validateChildKeys(children, type5);
                  }
                }
              }
              if (type5 === REACT_FRAGMENT_TYPE) {
                validateFragmentProps(element);
              } else {
                validatePropTypes(element);
              }
              return element;
            }
          }
          function jsxWithValidationStatic(type5, props, key) {
            {
              return jsxWithValidation(type5, props, key, true);
            }
          }
          function jsxWithValidationDynamic(type5, props, key) {
            {
              return jsxWithValidation(type5, props, key, false);
            }
          }
          var jsx = jsxWithValidationDynamic;
          var jsxs = jsxWithValidationStatic;
          exports2.Fragment = REACT_FRAGMENT_TYPE;
          exports2.jsx = jsx;
          exports2.jsxs = jsxs;
        })();
      }
    }
  });

  // node_modules/react/jsx-runtime.js
  var require_jsx_runtime = __commonJS({
    "node_modules/react/jsx-runtime.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      if (false) {
        module2.exports = null;
      } else {
        module2.exports = require_react_jsx_runtime_development();
      }
    }
  });

  // node_modules/@babel/runtime/helpers/esm/typeof.js
  function _typeof(obj) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
      return typeof obj2;
    } : function(obj2) {
      return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    }, _typeof(obj);
  }
  var init_typeof = __esm({
    "node_modules/@babel/runtime/helpers/esm/typeof.js"() {
      init_virtual_process_polyfill();
      init_buffer();
    }
  });

  // node_modules/@babel/runtime/helpers/esm/toPrimitive.js
  function _toPrimitive(input, hint) {
    if (_typeof(input) !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var init_toPrimitive = __esm({
    "node_modules/@babel/runtime/helpers/esm/toPrimitive.js"() {
      init_virtual_process_polyfill();
      init_buffer();
      init_typeof();
    }
  });

  // node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  var init_toPropertyKey = __esm({
    "node_modules/@babel/runtime/helpers/esm/toPropertyKey.js"() {
      init_virtual_process_polyfill();
      init_buffer();
      init_typeof();
      init_toPrimitive();
    }
  });

  // node_modules/debounce/index.js
  var require_debounce = __commonJS({
    "node_modules/debounce/index.js"(exports2, module2) {
      init_virtual_process_polyfill();
      init_buffer();
      function debounce2(func, wait, immediate) {
        var timeout, args, context, timestamp, result;
        if (null == wait)
          wait = 100;
        function later() {
          var last = Date.now() - timestamp;
          if (last < wait && last >= 0) {
            timeout = setTimeout(later, wait - last);
          } else {
            timeout = null;
            if (!immediate) {
              result = func.apply(context, args);
              context = args = null;
            }
          }
        }
        ;
        var debounced = function() {
          context = this;
          args = arguments;
          timestamp = Date.now();
          var callNow = immediate && !timeout;
          if (!timeout)
            timeout = setTimeout(later, wait);
          if (callNow) {
            result = func.apply(context, args);
            context = args = null;
          }
          return result;
        };
        debounced.clear = function() {
          if (timeout) {
            clearTimeout(timeout);
            timeout = null;
          }
        };
        debounced.flush = function() {
          if (timeout) {
            result = func.apply(context, args);
            context = args = null;
            clearTimeout(timeout);
            timeout = null;
          }
        };
        return debounced;
      }
      debounce2.debounce = debounce2;
      module2.exports = debounce2;
    }
  });

  // node_modules/base64-js/index.js
  var require_base64_js = __commonJS({
    "node_modules/base64-js/index.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      exports2.byteLength = byteLength3;
      exports2.toByteArray = toByteArray4;
      exports2.fromByteArray = fromByteArray4;
      var lookup3 = [];
      var revLookup3 = [];
      var Arr3 = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var code2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      for (i = 0, len = code2.length; i < len; ++i) {
        lookup3[i] = code2[i];
        revLookup3[code2.charCodeAt(i)] = i;
      }
      var i;
      var len;
      revLookup3["-".charCodeAt(0)] = 62;
      revLookup3["_".charCodeAt(0)] = 63;
      function getLens2(b64) {
        var len2 = b64.length;
        if (len2 % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        var validLen = b64.indexOf("=");
        if (validLen === -1)
          validLen = len2;
        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      }
      function byteLength3(b64) {
        var lens = getLens2(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function _byteLength2(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function toByteArray4(b64) {
        var tmp;
        var lens = getLens2(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr3(_byteLength2(b64, validLen, placeHoldersLen));
        var curByte = 0;
        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i2;
        for (i2 = 0; i2 < len2; i2 += 4) {
          tmp = revLookup3[b64.charCodeAt(i2)] << 18 | revLookup3[b64.charCodeAt(i2 + 1)] << 12 | revLookup3[b64.charCodeAt(i2 + 2)] << 6 | revLookup3[b64.charCodeAt(i2 + 3)];
          arr[curByte++] = tmp >> 16 & 255;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 2) {
          tmp = revLookup3[b64.charCodeAt(i2)] << 2 | revLookup3[b64.charCodeAt(i2 + 1)] >> 4;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 1) {
          tmp = revLookup3[b64.charCodeAt(i2)] << 10 | revLookup3[b64.charCodeAt(i2 + 1)] << 4 | revLookup3[b64.charCodeAt(i2 + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        return arr;
      }
      function tripletToBase643(num) {
        return lookup3[num >> 18 & 63] + lookup3[num >> 12 & 63] + lookup3[num >> 6 & 63] + lookup3[num & 63];
      }
      function encodeChunk3(uint8, start, end) {
        var tmp;
        var output2 = [];
        for (var i2 = start; i2 < end; i2 += 3) {
          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
          output2.push(tripletToBase643(tmp));
        }
        return output2.join("");
      }
      function fromByteArray4(uint8) {
        var tmp;
        var len2 = uint8.length;
        var extraBytes = len2 % 3;
        var parts = [];
        var maxChunkLength = 16383;
        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
          parts.push(encodeChunk3(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
        }
        if (extraBytes === 1) {
          tmp = uint8[len2 - 1];
          parts.push(
            lookup3[tmp >> 2] + lookup3[tmp << 4 & 63] + "=="
          );
        } else if (extraBytes === 2) {
          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
          parts.push(
            lookup3[tmp >> 10] + lookup3[tmp >> 4 & 63] + lookup3[tmp << 2 & 63] + "="
          );
        }
        return parts.join("");
      }
    }
  });

  // node_modules/ieee754/index.js
  var require_ieee754 = __commonJS({
    "node_modules/ieee754/index.js"(exports2) {
      init_virtual_process_polyfill();
      init_buffer();
      exports2.read = function(buffer2, offset3, isLE2, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE2 ? nBytes - 1 : 0;
        var d2 = isLE2 ? -1 : 1;
        var s = buffer2[offset3 + i];
        i += d2;
        e = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer2[offset3 + i], i += d2, nBits -= 8) {
        }
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer2[offset3 + i], i += d2, nBits -= 8) {
        }
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
      };
      exports2.write = function(buffer2, value, offset3, isLE2, mLen, nBytes) {
        var e, m, c2;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt2 = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE2 ? 0 : nBytes - 1;
        var d2 = isLE2 ? 1 : -1;
        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c2 = Math.pow(2, -e)) < 1) {
            e--;
            c2 *= 2;
          }
          if (e + eBias >= 1) {
            value += rt2 / c2;
          } else {
            value += rt2 * Math.pow(2, 1 - eBias);
          }
          if (value * c2 >= 2) {
            e++;
            c2 /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c2 - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer2[offset3 + i] = m & 255, i += d2, m /= 256, mLen -= 8) {
        }
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer2[offset3 + i] = e & 255, i += d2, e /= 256, eLen -= 8) {
        }
        buffer2[offset3 + i - d2] |= s * 128;
      };
    }
  });

  // node_modules/node-stdlib-browser/node_modules/buffer/index.js
  var require_buffer = __commonJS({
    "node_modules/node-stdlib-browser/node_modules/buffer/index.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var base64 = require_base64_js();
      var ieee7542 = require_ieee754();
      var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
      exports2.Buffer = Buffer3;
      exports2.SlowBuffer = SlowBuffer;
      exports2.INSPECT_MAX_BYTES = 50;
      var K_MAX_LENGTH = 2147483647;
      exports2.kMaxLength = K_MAX_LENGTH;
      Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
      if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error(
          "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
        );
      }
      function typedArraySupport() {
        try {
          var arr = new Uint8Array(1);
          var proto = { foo: function() {
            return 42;
          } };
          Object.setPrototypeOf(proto, Uint8Array.prototype);
          Object.setPrototypeOf(arr, proto);
          return arr.foo() === 42;
        } catch (e) {
          return false;
        }
      }
      Object.defineProperty(Buffer3.prototype, "parent", {
        enumerable: true,
        get: function() {
          if (!Buffer3.isBuffer(this))
            return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer3.prototype, "offset", {
        enumerable: true,
        get: function() {
          if (!Buffer3.isBuffer(this))
            return void 0;
          return this.byteOffset;
        }
      });
      function createBuffer2(length) {
        if (length > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length + '" is invalid for option "size"');
        }
        var buf = new Uint8Array(length);
        Object.setPrototypeOf(buf, Buffer3.prototype);
        return buf;
      }
      function Buffer3(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          }
          return allocUnsafe2(arg);
        }
        return from2(arg, encodingOrOffset, length);
      }
      Buffer3.poolSize = 8192;
      function from2(value, encodingOrOffset, length) {
        if (typeof value === "string") {
          return fromString2(value, encodingOrOffset);
        }
        if (ArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }
        if (value == null) {
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
          );
        }
        if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
          return fromArrayBuffer2(value, encodingOrOffset, length);
        }
        if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
          return fromArrayBuffer2(value, encodingOrOffset, length);
        }
        if (typeof value === "number") {
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        }
        var valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value) {
          return Buffer3.from(valueOf, encodingOrOffset, length);
        }
        var b2 = fromObject2(value);
        if (b2)
          return b2;
        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer3.from(
            value[Symbol.toPrimitive]("string"),
            encodingOrOffset,
            length
          );
        }
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      Buffer3.from = function(value, encodingOrOffset, length) {
        return from2(value, encodingOrOffset, length);
      };
      Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
      Object.setPrototypeOf(Buffer3, Uint8Array);
      function assertSize2(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size < 0) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
      }
      function alloc2(size, fill2, encoding) {
        assertSize2(size);
        if (size <= 0) {
          return createBuffer2(size);
        }
        if (fill2 !== void 0) {
          return typeof encoding === "string" ? createBuffer2(size).fill(fill2, encoding) : createBuffer2(size).fill(fill2);
        }
        return createBuffer2(size);
      }
      Buffer3.alloc = function(size, fill2, encoding) {
        return alloc2(size, fill2, encoding);
      };
      function allocUnsafe2(size) {
        assertSize2(size);
        return createBuffer2(size < 0 ? 0 : checked2(size) | 0);
      }
      Buffer3.allocUnsafe = function(size) {
        return allocUnsafe2(size);
      };
      Buffer3.allocUnsafeSlow = function(size) {
        return allocUnsafe2(size);
      };
      function fromString2(string4, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        var length = byteLength3(string4, encoding) | 0;
        var buf = createBuffer2(length);
        var actual = buf.write(string4, encoding);
        if (actual !== length) {
          buf = buf.slice(0, actual);
        }
        return buf;
      }
      function fromArrayLike2(array6) {
        var length = array6.length < 0 ? 0 : checked2(array6.length) | 0;
        var buf = createBuffer2(length);
        for (var i = 0; i < length; i += 1) {
          buf[i] = array6[i] & 255;
        }
        return buf;
      }
      function fromArrayView(arrayView) {
        if (isInstance(arrayView, Uint8Array)) {
          var copy2 = new Uint8Array(arrayView);
          return fromArrayBuffer2(copy2.buffer, copy2.byteOffset, copy2.byteLength);
        }
        return fromArrayLike2(arrayView);
      }
      function fromArrayBuffer2(array6, byteOffset, length) {
        if (byteOffset < 0 || array6.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }
        if (array6.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }
        var buf;
        if (byteOffset === void 0 && length === void 0) {
          buf = new Uint8Array(array6);
        } else if (length === void 0) {
          buf = new Uint8Array(array6, byteOffset);
        } else {
          buf = new Uint8Array(array6, byteOffset, length);
        }
        Object.setPrototypeOf(buf, Buffer3.prototype);
        return buf;
      }
      function fromObject2(obj) {
        if (Buffer3.isBuffer(obj)) {
          var len = checked2(obj.length) | 0;
          var buf = createBuffer2(len);
          if (buf.length === 0) {
            return buf;
          }
          obj.copy(buf, 0, 0, len);
          return buf;
        }
        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer2(0);
          }
          return fromArrayLike2(obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike2(obj.data);
        }
      }
      function checked2(length) {
        if (length >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }
        return length | 0;
      }
      function SlowBuffer(length) {
        if (+length != length) {
          length = 0;
        }
        return Buffer3.alloc(+length);
      }
      Buffer3.isBuffer = function isBuffer2(b2) {
        return b2 != null && b2._isBuffer === true && b2 !== Buffer3.prototype;
      };
      Buffer3.compare = function compare4(a, b2) {
        if (isInstance(a, Uint8Array))
          a = Buffer3.from(a, a.offset, a.byteLength);
        if (isInstance(b2, Uint8Array))
          b2 = Buffer3.from(b2, b2.offset, b2.byteLength);
        if (!Buffer3.isBuffer(a) || !Buffer3.isBuffer(b2)) {
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        }
        if (a === b2)
          return 0;
        var x2 = a.length;
        var y2 = b2.length;
        for (var i = 0, len = Math.min(x2, y2); i < len; ++i) {
          if (a[i] !== b2[i]) {
            x2 = a[i];
            y2 = b2[i];
            break;
          }
        }
        if (x2 < y2)
          return -1;
        if (y2 < x2)
          return 1;
        return 0;
      };
      Buffer3.isEncoding = function isEncoding2(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer3.concat = function concat2(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer3.alloc(0);
        }
        var i;
        if (length === void 0) {
          length = 0;
          for (i = 0; i < list.length; ++i) {
            length += list[i].length;
          }
        }
        var buffer2 = Buffer3.allocUnsafe(length);
        var pos = 0;
        for (i = 0; i < list.length; ++i) {
          var buf = list[i];
          if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer2.length) {
              Buffer3.from(buf).copy(buffer2, pos);
            } else {
              Uint8Array.prototype.set.call(
                buffer2,
                buf,
                pos
              );
            }
          } else if (!Buffer3.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer2, pos);
          }
          pos += buf.length;
        }
        return buffer2;
      };
      function byteLength3(string4, encoding) {
        if (Buffer3.isBuffer(string4)) {
          return string4.length;
        }
        if (ArrayBuffer.isView(string4) || isInstance(string4, ArrayBuffer)) {
          return string4.byteLength;
        }
        if (typeof string4 !== "string") {
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string4
          );
        }
        var len = string4.length;
        var mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len === 0)
          return 0;
        var loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len;
            case "utf8":
            case "utf-8":
              return utf8ToBytes4(string4).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len * 2;
            case "hex":
              return len >>> 1;
            case "base64":
              return base64ToBytes2(string4).length;
            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes4(string4).length;
              }
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer3.byteLength = byteLength3;
      function slowToString2(encoding, start, end) {
        var loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding)
          encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice2(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice2(this, start, end);
            case "ascii":
              return asciiSlice2(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice2(this, start, end);
            case "base64":
              return base64Slice2(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice2(this, start, end);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer3.prototype._isBuffer = true;
      function swap2(b2, n, m) {
        var i = b2[n];
        b2[n] = b2[m];
        b2[m] = i;
      }
      Buffer3.prototype.swap16 = function swap162() {
        var len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (var i = 0; i < len; i += 2) {
          swap2(this, i, i + 1);
        }
        return this;
      };
      Buffer3.prototype.swap32 = function swap322() {
        var len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (var i = 0; i < len; i += 4) {
          swap2(this, i, i + 3);
          swap2(this, i + 1, i + 2);
        }
        return this;
      };
      Buffer3.prototype.swap64 = function swap642() {
        var len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (var i = 0; i < len; i += 8) {
          swap2(this, i, i + 7);
          swap2(this, i + 1, i + 6);
          swap2(this, i + 2, i + 5);
          swap2(this, i + 3, i + 4);
        }
        return this;
      };
      Buffer3.prototype.toString = function toString3() {
        var length = this.length;
        if (length === 0)
          return "";
        if (arguments.length === 0)
          return utf8Slice2(this, 0, length);
        return slowToString2.apply(this, arguments);
      };
      Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
      Buffer3.prototype.equals = function equals2(b2) {
        if (!Buffer3.isBuffer(b2))
          throw new TypeError("Argument must be a Buffer");
        if (this === b2)
          return true;
        return Buffer3.compare(this, b2) === 0;
      };
      Buffer3.prototype.inspect = function inspect2() {
        var str3 = "";
        var max = exports2.INSPECT_MAX_BYTES;
        str3 = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max)
          str3 += " ... ";
        return "<Buffer " + str3 + ">";
      };
      if (customInspectSymbol) {
        Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
      }
      Buffer3.prototype.compare = function compare4(target, start, end, thisStart, thisEnd) {
        if (isInstance(target, Uint8Array)) {
          target = Buffer3.from(target, target.offset, target.byteLength);
        }
        if (!Buffer3.isBuffer(target)) {
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
          );
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target)
          return 0;
        var x2 = thisEnd - thisStart;
        var y2 = end - start;
        var len = Math.min(x2, y2);
        var thisCopy = this.slice(thisStart, thisEnd);
        var targetCopy = target.slice(start, end);
        for (var i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x2 = thisCopy[i];
            y2 = targetCopy[i];
            break;
          }
        }
        if (x2 < y2)
          return -1;
        if (y2 < x2)
          return 1;
        return 0;
      };
      function bidirectionalIndexOf2(buffer2, val, byteOffset, encoding, dir) {
        if (buffer2.length === 0)
          return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer2.length - 1;
        }
        if (byteOffset < 0)
          byteOffset = buffer2.length + byteOffset;
        if (byteOffset >= buffer2.length) {
          if (dir)
            return -1;
          else
            byteOffset = buffer2.length - 1;
        } else if (byteOffset < 0) {
          if (dir)
            byteOffset = 0;
          else
            return -1;
        }
        if (typeof val === "string") {
          val = Buffer3.from(val, encoding);
        }
        if (Buffer3.isBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf2(buffer2, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) {
              return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
            } else {
              return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
            }
          }
          return arrayIndexOf2(buffer2, [val], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf2(arr, val, byteOffset, encoding, dir) {
        var indexSize = 1;
        var arrLength = arr.length;
        var valLength = val.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read(buf, i2) {
          if (indexSize === 1) {
            return buf[i2];
          } else {
            return buf.readUInt16BE(i2 * indexSize);
          }
        }
        var i;
        if (dir) {
          var foundIndex = -1;
          for (i = byteOffset; i < arrLength; i++) {
            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
              if (foundIndex === -1)
                foundIndex = i;
              if (i - foundIndex + 1 === valLength)
                return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1)
                i -= i - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength)
            byteOffset = arrLength - valLength;
          for (i = byteOffset; i >= 0; i--) {
            var found = true;
            for (var j2 = 0; j2 < valLength; j2++) {
              if (read(arr, i + j2) !== read(val, j2)) {
                found = false;
                break;
              }
            }
            if (found)
              return i;
          }
        }
        return -1;
      }
      Buffer3.prototype.includes = function includes2(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer3.prototype.indexOf = function indexOf2(val, byteOffset, encoding) {
        return bidirectionalIndexOf2(this, val, byteOffset, encoding, true);
      };
      Buffer3.prototype.lastIndexOf = function lastIndexOf2(val, byteOffset, encoding) {
        return bidirectionalIndexOf2(this, val, byteOffset, encoding, false);
      };
      function hexWrite2(buf, string4, offset3, length) {
        offset3 = Number(offset3) || 0;
        var remaining = buf.length - offset3;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        var strLen = string4.length;
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        for (var i = 0; i < length; ++i) {
          var parsed = parseInt(string4.substr(i * 2, 2), 16);
          if (numberIsNaN(parsed))
            return i;
          buf[offset3 + i] = parsed;
        }
        return i;
      }
      function utf8Write2(buf, string4, offset3, length) {
        return blitBuffer2(utf8ToBytes4(string4, buf.length - offset3), buf, offset3, length);
      }
      function asciiWrite2(buf, string4, offset3, length) {
        return blitBuffer2(asciiToBytes2(string4), buf, offset3, length);
      }
      function base64Write2(buf, string4, offset3, length) {
        return blitBuffer2(base64ToBytes2(string4), buf, offset3, length);
      }
      function ucs2Write2(buf, string4, offset3, length) {
        return blitBuffer2(utf16leToBytes2(string4, buf.length - offset3), buf, offset3, length);
      }
      Buffer3.prototype.write = function write2(string4, offset3, length, encoding) {
        if (offset3 === void 0) {
          encoding = "utf8";
          length = this.length;
          offset3 = 0;
        } else if (length === void 0 && typeof offset3 === "string") {
          encoding = offset3;
          length = this.length;
          offset3 = 0;
        } else if (isFinite(offset3)) {
          offset3 = offset3 >>> 0;
          if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === void 0)
              encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        var remaining = this.length - offset3;
        if (length === void 0 || length > remaining)
          length = remaining;
        if (string4.length > 0 && (length < 0 || offset3 < 0) || offset3 > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding)
          encoding = "utf8";
        var loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite2(this, string4, offset3, length);
            case "utf8":
            case "utf-8":
              return utf8Write2(this, string4, offset3, length);
            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite2(this, string4, offset3, length);
            case "base64":
              return base64Write2(this, string4, offset3, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write2(this, string4, offset3, length);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer3.prototype.toJSON = function toJSON2() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice2(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base64.fromByteArray(buf);
        } else {
          return base64.fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice2(buf, start, end) {
        end = Math.min(buf.length, end);
        var res = [];
        var i = start;
        while (i < end) {
          var firstByte = buf[i];
          var codePoint = null;
          var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i + bytesPerSequence <= end) {
            var secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                fourthByte = buf[i + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i += bytesPerSequence;
        }
        return decodeCodePointsArray2(res);
      }
      var MAX_ARGUMENTS_LENGTH2 = 4096;
      function decodeCodePointsArray2(codePoints) {
        var len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH2) {
          return String.fromCharCode.apply(String, codePoints);
        }
        var res = "";
        var i = 0;
        while (i < len) {
          res += String.fromCharCode.apply(
            String,
            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH2)
          );
        }
        return res;
      }
      function asciiSlice2(buf, start, end) {
        var ret = "";
        end = Math.min(buf.length, end);
        for (var i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i] & 127);
        }
        return ret;
      }
      function latin1Slice2(buf, start, end) {
        var ret = "";
        end = Math.min(buf.length, end);
        for (var i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i]);
        }
        return ret;
      }
      function hexSlice2(buf, start, end) {
        var len = buf.length;
        if (!start || start < 0)
          start = 0;
        if (!end || end < 0 || end > len)
          end = len;
        var out = "";
        for (var i = start; i < end; ++i) {
          out += hexSliceLookupTable[buf[i]];
        }
        return out;
      }
      function utf16leSlice2(buf, start, end) {
        var bytes2 = buf.slice(start, end);
        var res = "";
        for (var i = 0; i < bytes2.length - 1; i += 2) {
          res += String.fromCharCode(bytes2[i] + bytes2[i + 1] * 256);
        }
        return res;
      }
      Buffer3.prototype.slice = function slice2(start, end) {
        var len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0)
            start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0)
            end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start)
          end = start;
        var newBuf = this.subarray(start, end);
        Object.setPrototypeOf(newBuf, Buffer3.prototype);
        return newBuf;
      };
      function checkOffset2(offset3, ext, length) {
        if (offset3 % 1 !== 0 || offset3 < 0)
          throw new RangeError("offset is not uint");
        if (offset3 + ext > length)
          throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE2(offset3, byteLength4, noAssert) {
        offset3 = offset3 >>> 0;
        byteLength4 = byteLength4 >>> 0;
        if (!noAssert)
          checkOffset2(offset3, byteLength4, this.length);
        var val = this[offset3];
        var mul = 1;
        var i = 0;
        while (++i < byteLength4 && (mul *= 256)) {
          val += this[offset3 + i] * mul;
        }
        return val;
      };
      Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE2(offset3, byteLength4, noAssert) {
        offset3 = offset3 >>> 0;
        byteLength4 = byteLength4 >>> 0;
        if (!noAssert) {
          checkOffset2(offset3, byteLength4, this.length);
        }
        var val = this[offset3 + --byteLength4];
        var mul = 1;
        while (byteLength4 > 0 && (mul *= 256)) {
          val += this[offset3 + --byteLength4] * mul;
        }
        return val;
      };
      Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt82(offset3, noAssert) {
        offset3 = offset3 >>> 0;
        if (!noAssert)
          checkOffset2(offset3, 1, this.length);
        return this[offset3];
      };
      Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE2(offset3, noAssert) {
        offset3 = offset3 >>> 0;
        if (!noAssert)
          checkOffset2(offset3, 2, this.length);
        return this[offset3] | this[offset3 + 1] << 8;
      };
      Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE2(offset3, noAssert) {
        offset3 = offset3 >>> 0;
        if (!noAssert)
          checkOffset2(offset3, 2, this.length);
        return this[offset3] << 8 | this[offset3 + 1];
      };
      Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE2(offset3, noAssert) {
        offset3 = offset3 >>> 0;
        if (!noAssert)
          checkOffset2(offset3, 4, this.length);
        return (this[offset3] | this[offset3 + 1] << 8 | this[offset3 + 2] << 16) + this[offset3 + 3] * 16777216;
      };
      Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE2(offset3, noAssert) {
        offset3 = offset3 >>> 0;
        if (!noAssert)
          checkOffset2(offset3, 4, this.length);
        return this[offset3] * 16777216 + (this[offset3 + 1] << 16 | this[offset3 + 2] << 8 | this[offset3 + 3]);
      };
      Buffer3.prototype.readIntLE = function readIntLE2(offset3, byteLength4, noAssert) {
        offset3 = offset3 >>> 0;
        byteLength4 = byteLength4 >>> 0;
        if (!noAssert)
          checkOffset2(offset3, byteLength4, this.length);
        var val = this[offset3];
        var mul = 1;
        var i = 0;
        while (++i < byteLength4 && (mul *= 256)) {
          val += this[offset3 + i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength4);
        return val;
      };
      Buffer3.prototype.readIntBE = function readIntBE2(offset3, byteLength4, noAssert) {
        offset3 = offset3 >>> 0;
        byteLength4 = byteLength4 >>> 0;
        if (!noAssert)
          checkOffset2(offset3, byteLength4, this.length);
        var i = byteLength4;
        var mul = 1;
        var val = this[offset3 + --i];
        while (i > 0 && (mul *= 256)) {
          val += this[offset3 + --i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength4);
        return val;
      };
      Buffer3.prototype.readInt8 = function readInt82(offset3, noAssert) {
        offset3 = offset3 >>> 0;
        if (!noAssert)
          checkOffset2(offset3, 1, this.length);
        if (!(this[offset3] & 128))
          return this[offset3];
        return (255 - this[offset3] + 1) * -1;
      };
      Buffer3.prototype.readInt16LE = function readInt16LE2(offset3, noAssert) {
        offset3 = offset3 >>> 0;
        if (!noAssert)
          checkOffset2(offset3, 2, this.length);
        var val = this[offset3] | this[offset3 + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer3.prototype.readInt16BE = function readInt16BE2(offset3, noAssert) {
        offset3 = offset3 >>> 0;
        if (!noAssert)
          checkOffset2(offset3, 2, this.length);
        var val = this[offset3 + 1] | this[offset3] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer3.prototype.readInt32LE = function readInt32LE2(offset3, noAssert) {
        offset3 = offset3 >>> 0;
        if (!noAssert)
          checkOffset2(offset3, 4, this.length);
        return this[offset3] | this[offset3 + 1] << 8 | this[offset3 + 2] << 16 | this[offset3 + 3] << 24;
      };
      Buffer3.prototype.readInt32BE = function readInt32BE2(offset3, noAssert) {
        offset3 = offset3 >>> 0;
        if (!noAssert)
          checkOffset2(offset3, 4, this.length);
        return this[offset3] << 24 | this[offset3 + 1] << 16 | this[offset3 + 2] << 8 | this[offset3 + 3];
      };
      Buffer3.prototype.readFloatLE = function readFloatLE2(offset3, noAssert) {
        offset3 = offset3 >>> 0;
        if (!noAssert)
          checkOffset2(offset3, 4, this.length);
        return ieee7542.read(this, offset3, true, 23, 4);
      };
      Buffer3.prototype.readFloatBE = function readFloatBE2(offset3, noAssert) {
        offset3 = offset3 >>> 0;
        if (!noAssert)
          checkOffset2(offset3, 4, this.length);
        return ieee7542.read(this, offset3, false, 23, 4);
      };
      Buffer3.prototype.readDoubleLE = function readDoubleLE2(offset3, noAssert) {
        offset3 = offset3 >>> 0;
        if (!noAssert)
          checkOffset2(offset3, 8, this.length);
        return ieee7542.read(this, offset3, true, 52, 8);
      };
      Buffer3.prototype.readDoubleBE = function readDoubleBE2(offset3, noAssert) {
        offset3 = offset3 >>> 0;
        if (!noAssert)
          checkOffset2(offset3, 8, this.length);
        return ieee7542.read(this, offset3, false, 52, 8);
      };
      function checkInt2(buf, value, offset3, ext, max, min) {
        if (!Buffer3.isBuffer(buf))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min)
          throw new RangeError('"value" argument is out of bounds');
        if (offset3 + ext > buf.length)
          throw new RangeError("Index out of range");
      }
      Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE2(value, offset3, byteLength4, noAssert) {
        value = +value;
        offset3 = offset3 >>> 0;
        byteLength4 = byteLength4 >>> 0;
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength4) - 1;
          checkInt2(this, value, offset3, byteLength4, maxBytes, 0);
        }
        var mul = 1;
        var i = 0;
        this[offset3] = value & 255;
        while (++i < byteLength4 && (mul *= 256)) {
          this[offset3 + i] = value / mul & 255;
        }
        return offset3 + byteLength4;
      };
      Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE2(value, offset3, byteLength4, noAssert) {
        value = +value;
        offset3 = offset3 >>> 0;
        byteLength4 = byteLength4 >>> 0;
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength4) - 1;
          checkInt2(this, value, offset3, byteLength4, maxBytes, 0);
        }
        var i = byteLength4 - 1;
        var mul = 1;
        this[offset3 + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          this[offset3 + i] = value / mul & 255;
        }
        return offset3 + byteLength4;
      };
      Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt82(value, offset3, noAssert) {
        value = +value;
        offset3 = offset3 >>> 0;
        if (!noAssert)
          checkInt2(this, value, offset3, 1, 255, 0);
        this[offset3] = value & 255;
        return offset3 + 1;
      };
      Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE2(value, offset3, noAssert) {
        value = +value;
        offset3 = offset3 >>> 0;
        if (!noAssert)
          checkInt2(this, value, offset3, 2, 65535, 0);
        this[offset3] = value & 255;
        this[offset3 + 1] = value >>> 8;
        return offset3 + 2;
      };
      Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE2(value, offset3, noAssert) {
        value = +value;
        offset3 = offset3 >>> 0;
        if (!noAssert)
          checkInt2(this, value, offset3, 2, 65535, 0);
        this[offset3] = value >>> 8;
        this[offset3 + 1] = value & 255;
        return offset3 + 2;
      };
      Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE2(value, offset3, noAssert) {
        value = +value;
        offset3 = offset3 >>> 0;
        if (!noAssert)
          checkInt2(this, value, offset3, 4, 4294967295, 0);
        this[offset3 + 3] = value >>> 24;
        this[offset3 + 2] = value >>> 16;
        this[offset3 + 1] = value >>> 8;
        this[offset3] = value & 255;
        return offset3 + 4;
      };
      Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE2(value, offset3, noAssert) {
        value = +value;
        offset3 = offset3 >>> 0;
        if (!noAssert)
          checkInt2(this, value, offset3, 4, 4294967295, 0);
        this[offset3] = value >>> 24;
        this[offset3 + 1] = value >>> 16;
        this[offset3 + 2] = value >>> 8;
        this[offset3 + 3] = value & 255;
        return offset3 + 4;
      };
      Buffer3.prototype.writeIntLE = function writeIntLE2(value, offset3, byteLength4, noAssert) {
        value = +value;
        offset3 = offset3 >>> 0;
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength4 - 1);
          checkInt2(this, value, offset3, byteLength4, limit - 1, -limit);
        }
        var i = 0;
        var mul = 1;
        var sub = 0;
        this[offset3] = value & 255;
        while (++i < byteLength4 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset3 + i - 1] !== 0) {
            sub = 1;
          }
          this[offset3 + i] = (value / mul >> 0) - sub & 255;
        }
        return offset3 + byteLength4;
      };
      Buffer3.prototype.writeIntBE = function writeIntBE2(value, offset3, byteLength4, noAssert) {
        value = +value;
        offset3 = offset3 >>> 0;
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength4 - 1);
          checkInt2(this, value, offset3, byteLength4, limit - 1, -limit);
        }
        var i = byteLength4 - 1;
        var mul = 1;
        var sub = 0;
        this[offset3 + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset3 + i + 1] !== 0) {
            sub = 1;
          }
          this[offset3 + i] = (value / mul >> 0) - sub & 255;
        }
        return offset3 + byteLength4;
      };
      Buffer3.prototype.writeInt8 = function writeInt82(value, offset3, noAssert) {
        value = +value;
        offset3 = offset3 >>> 0;
        if (!noAssert)
          checkInt2(this, value, offset3, 1, 127, -128);
        if (value < 0)
          value = 255 + value + 1;
        this[offset3] = value & 255;
        return offset3 + 1;
      };
      Buffer3.prototype.writeInt16LE = function writeInt16LE2(value, offset3, noAssert) {
        value = +value;
        offset3 = offset3 >>> 0;
        if (!noAssert)
          checkInt2(this, value, offset3, 2, 32767, -32768);
        this[offset3] = value & 255;
        this[offset3 + 1] = value >>> 8;
        return offset3 + 2;
      };
      Buffer3.prototype.writeInt16BE = function writeInt16BE2(value, offset3, noAssert) {
        value = +value;
        offset3 = offset3 >>> 0;
        if (!noAssert)
          checkInt2(this, value, offset3, 2, 32767, -32768);
        this[offset3] = value >>> 8;
        this[offset3 + 1] = value & 255;
        return offset3 + 2;
      };
      Buffer3.prototype.writeInt32LE = function writeInt32LE2(value, offset3, noAssert) {
        value = +value;
        offset3 = offset3 >>> 0;
        if (!noAssert)
          checkInt2(this, value, offset3, 4, 2147483647, -2147483648);
        this[offset3] = value & 255;
        this[offset3 + 1] = value >>> 8;
        this[offset3 + 2] = value >>> 16;
        this[offset3 + 3] = value >>> 24;
        return offset3 + 4;
      };
      Buffer3.prototype.writeInt32BE = function writeInt32BE2(value, offset3, noAssert) {
        value = +value;
        offset3 = offset3 >>> 0;
        if (!noAssert)
          checkInt2(this, value, offset3, 4, 2147483647, -2147483648);
        if (value < 0)
          value = 4294967295 + value + 1;
        this[offset3] = value >>> 24;
        this[offset3 + 1] = value >>> 16;
        this[offset3 + 2] = value >>> 8;
        this[offset3 + 3] = value & 255;
        return offset3 + 4;
      };
      function checkIEEE7542(buf, value, offset3, ext, max, min) {
        if (offset3 + ext > buf.length)
          throw new RangeError("Index out of range");
        if (offset3 < 0)
          throw new RangeError("Index out of range");
      }
      function writeFloat2(buf, value, offset3, littleEndian, noAssert) {
        value = +value;
        offset3 = offset3 >>> 0;
        if (!noAssert) {
          checkIEEE7542(buf, value, offset3, 4, 34028234663852886e22, -34028234663852886e22);
        }
        ieee7542.write(buf, value, offset3, littleEndian, 23, 4);
        return offset3 + 4;
      }
      Buffer3.prototype.writeFloatLE = function writeFloatLE2(value, offset3, noAssert) {
        return writeFloat2(this, value, offset3, true, noAssert);
      };
      Buffer3.prototype.writeFloatBE = function writeFloatBE2(value, offset3, noAssert) {
        return writeFloat2(this, value, offset3, false, noAssert);
      };
      function writeDouble2(buf, value, offset3, littleEndian, noAssert) {
        value = +value;
        offset3 = offset3 >>> 0;
        if (!noAssert) {
          checkIEEE7542(buf, value, offset3, 8, 17976931348623157e292, -17976931348623157e292);
        }
        ieee7542.write(buf, value, offset3, littleEndian, 52, 8);
        return offset3 + 8;
      }
      Buffer3.prototype.writeDoubleLE = function writeDoubleLE2(value, offset3, noAssert) {
        return writeDouble2(this, value, offset3, true, noAssert);
      };
      Buffer3.prototype.writeDoubleBE = function writeDoubleBE2(value, offset3, noAssert) {
        return writeDouble2(this, value, offset3, false, noAssert);
      };
      Buffer3.prototype.copy = function copy2(target, targetStart, start, end) {
        if (!Buffer3.isBuffer(target))
          throw new TypeError("argument should be a Buffer");
        if (!start)
          start = 0;
        if (!end && end !== 0)
          end = this.length;
        if (targetStart >= target.length)
          targetStart = target.length;
        if (!targetStart)
          targetStart = 0;
        if (end > 0 && end < start)
          end = start;
        if (end === start)
          return 0;
        if (target.length === 0 || this.length === 0)
          return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length)
          throw new RangeError("Index out of range");
        if (end < 0)
          throw new RangeError("sourceEnd out of bounds");
        if (end > this.length)
          end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        var len = end - start;
        if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start, end);
        } else {
          Uint8Array.prototype.set.call(
            target,
            this.subarray(start, end),
            targetStart
          );
        }
        return len;
      };
      Buffer3.prototype.fill = function fill2(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
          if (val.length === 1) {
            var code2 = val.charCodeAt(0);
            if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
              val = code2;
            }
          }
        } else if (typeof val === "number") {
          val = val & 255;
        } else if (typeof val === "boolean") {
          val = Number(val);
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val)
          val = 0;
        var i;
        if (typeof val === "number") {
          for (i = start; i < end; ++i) {
            this[i] = val;
          }
        } else {
          var bytes2 = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
          var len = bytes2.length;
          if (len === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
          }
          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes2[i % len];
          }
        }
        return this;
      };
      var INVALID_BASE64_RE2 = /[^+/0-9A-Za-z-_]/g;
      function base64clean2(str3) {
        str3 = str3.split("=")[0];
        str3 = str3.trim().replace(INVALID_BASE64_RE2, "");
        if (str3.length < 2)
          return "";
        while (str3.length % 4 !== 0) {
          str3 = str3 + "=";
        }
        return str3;
      }
      function utf8ToBytes4(string4, units) {
        units = units || Infinity;
        var codePoint;
        var length = string4.length;
        var leadSurrogate = null;
        var bytes2 = [];
        for (var i = 0; i < length; ++i) {
          codePoint = string4.charCodeAt(i);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1)
                  bytes2.push(239, 191, 189);
                continue;
              } else if (i + 1 === length) {
                if ((units -= 3) > -1)
                  bytes2.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1)
                bytes2.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1)
              bytes2.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0)
              break;
            bytes2.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0)
              break;
            bytes2.push(
              codePoint >> 6 | 192,
              codePoint & 63 | 128
            );
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0)
              break;
            bytes2.push(
              codePoint >> 12 | 224,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0)
              break;
            bytes2.push(
              codePoint >> 18 | 240,
              codePoint >> 12 & 63 | 128,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes2;
      }
      function asciiToBytes2(str3) {
        var byteArray = [];
        for (var i = 0; i < str3.length; ++i) {
          byteArray.push(str3.charCodeAt(i) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes2(str3, units) {
        var c2, hi, lo;
        var byteArray = [];
        for (var i = 0; i < str3.length; ++i) {
          if ((units -= 2) < 0)
            break;
          c2 = str3.charCodeAt(i);
          hi = c2 >> 8;
          lo = c2 % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes2(str3) {
        return base64.toByteArray(base64clean2(str3));
      }
      function blitBuffer2(src, dst, offset3, length) {
        for (var i = 0; i < length; ++i) {
          if (i + offset3 >= dst.length || i >= src.length)
            break;
          dst[i + offset3] = src[i];
        }
        return i;
      }
      function isInstance(obj, type5) {
        return obj instanceof type5 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type5.name;
      }
      function numberIsNaN(obj) {
        return obj !== obj;
      }
      var hexSliceLookupTable = function() {
        var alphabet = "0123456789abcdef";
        var table = new Array(256);
        for (var i = 0; i < 16; ++i) {
          var i163 = i * 16;
          for (var j2 = 0; j2 < 16; ++j2) {
            table[i163 + j2] = alphabet[i] + alphabet[j2];
          }
        }
        return table;
      }();
    }
  });

  // node_modules/@noble/hashes/esm/_assert.js
  function number2(n) {
    if (!Number.isSafeInteger(n) || n < 0)
      throw new Error(`Wrong positive integer: ${n}`);
  }
  function bool(b2) {
    if (typeof b2 !== "boolean")
      throw new Error(`Expected boolean, not ${b2}`);
  }
  function bytes(b2, ...lengths) {
    if (!(b2 instanceof Uint8Array))
      throw new Error("Expected Uint8Array");
    if (lengths.length > 0 && !lengths.includes(b2.length))
      throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b2.length}`);
  }
  function hash(hash2) {
    if (typeof hash2 !== "function" || typeof hash2.create !== "function")
      throw new Error("Hash should be wrapped by utils.wrapConstructor");
    number2(hash2.outputLen);
    number2(hash2.blockLen);
  }
  function exists(instance2, checkFinished = true) {
    if (instance2.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance2.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function output(out, instance2) {
    bytes(out);
    const min = instance2.outputLen;
    if (out.length < min) {
      throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
  }
  var assert2, assert_default;
  var init_assert = __esm({
    "node_modules/@noble/hashes/esm/_assert.js"() {
      init_virtual_process_polyfill();
      init_buffer();
      assert2 = {
        number: number2,
        bool,
        bytes,
        hash,
        exists,
        output
      };
      assert_default = assert2;
    }
  });

  // node_modules/@noble/hashes/esm/crypto.js
  var crypto2;
  var init_crypto = __esm({
    "node_modules/@noble/hashes/esm/crypto.js"() {
      init_virtual_process_polyfill();
      init_buffer();
      crypto2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
    }
  });

  // node_modules/@noble/hashes/esm/utils.js
  function utf8ToBytes2(str3) {
    if (typeof str3 !== "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof str3}`);
    return new Uint8Array(new TextEncoder().encode(str3));
  }
  function toBytes(data) {
    if (typeof data === "string")
      data = utf8ToBytes2(data);
    if (!u8a(data))
      throw new Error(`expected Uint8Array, got ${typeof data}`);
    return data;
  }
  function concatBytes(...arrays) {
    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
    let pad = 0;
    arrays.forEach((a) => {
      if (!u8a(a))
        throw new Error("Uint8Array expected");
      r.set(a, pad);
      pad += a.length;
    });
    return r;
  }
  function wrapConstructor(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
  }
  function wrapXOFConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
  }
  function randomBytes(bytesLength = 32) {
    if (crypto2 && typeof crypto2.getRandomValues === "function") {
      return crypto2.getRandomValues(new Uint8Array(bytesLength));
    }
    throw new Error("crypto.getRandomValues must be defined");
  }
  var u8a, u32, createView, rotr, isLE, hexes, Hash;
  var init_utils = __esm({
    "node_modules/@noble/hashes/esm/utils.js"() {
      init_virtual_process_polyfill();
      init_buffer();
      init_crypto();
      u8a = (a) => a instanceof Uint8Array;
      u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
      createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
      rotr = (word, shift) => word << 32 - shift | word >>> shift;
      isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
      if (!isLE)
        throw new Error("Non little-endian hardware is not supported");
      hexes = Array.from({ length: 256 }, (v2, i) => i.toString(16).padStart(2, "0"));
      Hash = class {
        clone() {
          return this._cloneInto();
        }
      };
    }
  });

  // node_modules/@noble/hashes/esm/_sha2.js
  function setBigUint64(view, byteOffset, value, isLE2) {
    if (typeof view.setBigUint64 === "function")
      return view.setBigUint64(byteOffset, value, isLE2);
    const _32n2 = BigInt(32);
    const _u32_max = BigInt(4294967295);
    const wh = Number(value >> _32n2 & _u32_max);
    const wl = Number(value & _u32_max);
    const h2 = isLE2 ? 4 : 0;
    const l2 = isLE2 ? 0 : 4;
    view.setUint32(byteOffset + h2, wh, isLE2);
    view.setUint32(byteOffset + l2, wl, isLE2);
  }
  var SHA2;
  var init_sha2 = __esm({
    "node_modules/@noble/hashes/esm/_sha2.js"() {
      init_virtual_process_polyfill();
      init_buffer();
      init_assert();
      init_utils();
      SHA2 = class extends Hash {
        constructor(blockLen, outputLen, padOffset, isLE2) {
          super();
          this.blockLen = blockLen;
          this.outputLen = outputLen;
          this.padOffset = padOffset;
          this.isLE = isLE2;
          this.finished = false;
          this.length = 0;
          this.pos = 0;
          this.destroyed = false;
          this.buffer = new Uint8Array(blockLen);
          this.view = createView(this.buffer);
        }
        update(data) {
          assert_default.exists(this);
          const { view, buffer: buffer2, blockLen } = this;
          data = toBytes(data);
          const len = data.length;
          for (let pos = 0; pos < len; ) {
            const take = Math.min(blockLen - this.pos, len - pos);
            if (take === blockLen) {
              const dataView = createView(data);
              for (; blockLen <= len - pos; pos += blockLen)
                this.process(dataView, pos);
              continue;
            }
            buffer2.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
              this.process(view, 0);
              this.pos = 0;
            }
          }
          this.length += data.length;
          this.roundClean();
          return this;
        }
        digestInto(out) {
          assert_default.exists(this);
          assert_default.output(out, this);
          this.finished = true;
          const { buffer: buffer2, view, blockLen, isLE: isLE2 } = this;
          let { pos } = this;
          buffer2[pos++] = 128;
          this.buffer.subarray(pos).fill(0);
          if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
          }
          for (let i = pos; i < blockLen; i++)
            buffer2[i] = 0;
          setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
          this.process(view, 0);
          const oview = createView(out);
          const len = this.outputLen;
          if (len % 4)
            throw new Error("_sha2: outputLen should be aligned to 32bit");
          const outLen = len / 4;
          const state = this.get();
          if (outLen > state.length)
            throw new Error("_sha2: outputLen bigger than state");
          for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE2);
        }
        digest() {
          const { buffer: buffer2, outputLen } = this;
          this.digestInto(buffer2);
          const res = buffer2.slice(0, outputLen);
          this.destroy();
          return res;
        }
        _cloneInto(to) {
          to || (to = new this.constructor());
          to.set(...this.get());
          const { blockLen, buffer: buffer2, length, finished, destroyed, pos } = this;
          to.length = length;
          to.pos = pos;
          to.finished = finished;
          to.destroyed = destroyed;
          if (length % blockLen)
            to.buffer.set(buffer2);
          return to;
        }
      };
    }
  });

  // node_modules/@noble/hashes/esm/_u64.js
  function fromBig(n, le2 = false) {
    if (le2)
      return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
    return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
  }
  function split(lst, le2 = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0; i < lst.length; i++) {
      const { h: h2, l: l2 } = fromBig(lst[i], le2);
      [Ah[i], Al[i]] = [h2, l2];
    }
    return [Ah, Al];
  }
  function add(Ah, Al, Bh, Bl) {
    const l2 = (Al >>> 0) + (Bl >>> 0);
    return { h: Ah + Bh + (l2 / 2 ** 32 | 0) | 0, l: l2 | 0 };
  }
  var U32_MASK64, _32n, toBig, shrSH, shrSL, rotrSH, rotrSL, rotrBH, rotrBL, rotr32H, rotr32L, rotlSH, rotlSL, rotlBH, rotlBL, add3L, add3H, add4L, add4H, add5L, add5H, u64, u64_default;
  var init_u64 = __esm({
    "node_modules/@noble/hashes/esm/_u64.js"() {
      init_virtual_process_polyfill();
      init_buffer();
      U32_MASK64 = BigInt(2 ** 32 - 1);
      _32n = BigInt(32);
      toBig = (h2, l2) => BigInt(h2 >>> 0) << _32n | BigInt(l2 >>> 0);
      shrSH = (h2, l2, s) => h2 >>> s;
      shrSL = (h2, l2, s) => h2 << 32 - s | l2 >>> s;
      rotrSH = (h2, l2, s) => h2 >>> s | l2 << 32 - s;
      rotrSL = (h2, l2, s) => h2 << 32 - s | l2 >>> s;
      rotrBH = (h2, l2, s) => h2 << 64 - s | l2 >>> s - 32;
      rotrBL = (h2, l2, s) => h2 >>> s - 32 | l2 << 64 - s;
      rotr32H = (h2, l2) => l2;
      rotr32L = (h2, l2) => h2;
      rotlSH = (h2, l2, s) => h2 << s | l2 >>> 32 - s;
      rotlSL = (h2, l2, s) => l2 << s | h2 >>> 32 - s;
      rotlBH = (h2, l2, s) => l2 << s - 32 | h2 >>> 64 - s;
      rotlBL = (h2, l2, s) => h2 << s - 32 | l2 >>> 64 - s;
      add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
      add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
      add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
      add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
      add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
      add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
      u64 = {
        fromBig,
        split,
        toBig,
        shrSH,
        shrSL,
        rotrSH,
        rotrSL,
        rotrBH,
        rotrBL,
        rotr32H,
        rotr32L,
        rotlSH,
        rotlSL,
        rotlBH,
        rotlBL,
        add,
        add3L,
        add3H,
        add4L,
        add4H,
        add5H,
        add5L
      };
      u64_default = u64;
    }
  });

  // node_modules/@noble/hashes/esm/sha512.js
  var SHA512_Kh, SHA512_Kl, SHA512_W_H, SHA512_W_L, SHA512, SHA512_224, SHA512_256, SHA384, sha512, sha512_224, sha512_256, sha384;
  var init_sha512 = __esm({
    "node_modules/@noble/hashes/esm/sha512.js"() {
      init_virtual_process_polyfill();
      init_buffer();
      init_sha2();
      init_u64();
      init_utils();
      [SHA512_Kh, SHA512_Kl] = u64_default.split([
        "0x428a2f98d728ae22",
        "0x7137449123ef65cd",
        "0xb5c0fbcfec4d3b2f",
        "0xe9b5dba58189dbbc",
        "0x3956c25bf348b538",
        "0x59f111f1b605d019",
        "0x923f82a4af194f9b",
        "0xab1c5ed5da6d8118",
        "0xd807aa98a3030242",
        "0x12835b0145706fbe",
        "0x243185be4ee4b28c",
        "0x550c7dc3d5ffb4e2",
        "0x72be5d74f27b896f",
        "0x80deb1fe3b1696b1",
        "0x9bdc06a725c71235",
        "0xc19bf174cf692694",
        "0xe49b69c19ef14ad2",
        "0xefbe4786384f25e3",
        "0x0fc19dc68b8cd5b5",
        "0x240ca1cc77ac9c65",
        "0x2de92c6f592b0275",
        "0x4a7484aa6ea6e483",
        "0x5cb0a9dcbd41fbd4",
        "0x76f988da831153b5",
        "0x983e5152ee66dfab",
        "0xa831c66d2db43210",
        "0xb00327c898fb213f",
        "0xbf597fc7beef0ee4",
        "0xc6e00bf33da88fc2",
        "0xd5a79147930aa725",
        "0x06ca6351e003826f",
        "0x142929670a0e6e70",
        "0x27b70a8546d22ffc",
        "0x2e1b21385c26c926",
        "0x4d2c6dfc5ac42aed",
        "0x53380d139d95b3df",
        "0x650a73548baf63de",
        "0x766a0abb3c77b2a8",
        "0x81c2c92e47edaee6",
        "0x92722c851482353b",
        "0xa2bfe8a14cf10364",
        "0xa81a664bbc423001",
        "0xc24b8b70d0f89791",
        "0xc76c51a30654be30",
        "0xd192e819d6ef5218",
        "0xd69906245565a910",
        "0xf40e35855771202a",
        "0x106aa07032bbd1b8",
        "0x19a4c116b8d2d0c8",
        "0x1e376c085141ab53",
        "0x2748774cdf8eeb99",
        "0x34b0bcb5e19b48a8",
        "0x391c0cb3c5c95a63",
        "0x4ed8aa4ae3418acb",
        "0x5b9cca4f7763e373",
        "0x682e6ff3d6b2b8a3",
        "0x748f82ee5defb2fc",
        "0x78a5636f43172f60",
        "0x84c87814a1f0ab72",
        "0x8cc702081a6439ec",
        "0x90befffa23631e28",
        "0xa4506cebde82bde9",
        "0xbef9a3f7b2c67915",
        "0xc67178f2e372532b",
        "0xca273eceea26619c",
        "0xd186b8c721c0c207",
        "0xeada7dd6cde0eb1e",
        "0xf57d4f7fee6ed178",
        "0x06f067aa72176fba",
        "0x0a637dc5a2c898a6",
        "0x113f9804bef90dae",
        "0x1b710b35131c471b",
        "0x28db77f523047d84",
        "0x32caab7b40c72493",
        "0x3c9ebe0a15c9bebc",
        "0x431d67c49c100d4c",
        "0x4cc5d4becb3e42b6",
        "0x597f299cfc657e2a",
        "0x5fcb6fab3ad6faec",
        "0x6c44198c4a475817"
      ].map((n) => BigInt(n)));
      SHA512_W_H = new Uint32Array(80);
      SHA512_W_L = new Uint32Array(80);
      SHA512 = class extends SHA2 {
        constructor() {
          super(128, 64, 16, false);
          this.Ah = 1779033703 | 0;
          this.Al = 4089235720 | 0;
          this.Bh = 3144134277 | 0;
          this.Bl = 2227873595 | 0;
          this.Ch = 1013904242 | 0;
          this.Cl = 4271175723 | 0;
          this.Dh = 2773480762 | 0;
          this.Dl = 1595750129 | 0;
          this.Eh = 1359893119 | 0;
          this.El = 2917565137 | 0;
          this.Fh = 2600822924 | 0;
          this.Fl = 725511199 | 0;
          this.Gh = 528734635 | 0;
          this.Gl = 4215389547 | 0;
          this.Hh = 1541459225 | 0;
          this.Hl = 327033209 | 0;
        }
        get() {
          const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
          return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
        }
        set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
          this.Ah = Ah | 0;
          this.Al = Al | 0;
          this.Bh = Bh | 0;
          this.Bl = Bl | 0;
          this.Ch = Ch | 0;
          this.Cl = Cl | 0;
          this.Dh = Dh | 0;
          this.Dl = Dl | 0;
          this.Eh = Eh | 0;
          this.El = El | 0;
          this.Fh = Fh | 0;
          this.Fl = Fl | 0;
          this.Gh = Gh | 0;
          this.Gl = Gl | 0;
          this.Hh = Hh | 0;
          this.Hl = Hl | 0;
        }
        process(view, offset3) {
          for (let i = 0; i < 16; i++, offset3 += 4) {
            SHA512_W_H[i] = view.getUint32(offset3);
            SHA512_W_L[i] = view.getUint32(offset3 += 4);
          }
          for (let i = 16; i < 80; i++) {
            const W15h = SHA512_W_H[i - 15] | 0;
            const W15l = SHA512_W_L[i - 15] | 0;
            const s0h = u64_default.rotrSH(W15h, W15l, 1) ^ u64_default.rotrSH(W15h, W15l, 8) ^ u64_default.shrSH(W15h, W15l, 7);
            const s0l = u64_default.rotrSL(W15h, W15l, 1) ^ u64_default.rotrSL(W15h, W15l, 8) ^ u64_default.shrSL(W15h, W15l, 7);
            const W2h = SHA512_W_H[i - 2] | 0;
            const W2l = SHA512_W_L[i - 2] | 0;
            const s1h = u64_default.rotrSH(W2h, W2l, 19) ^ u64_default.rotrBH(W2h, W2l, 61) ^ u64_default.shrSH(W2h, W2l, 6);
            const s1l = u64_default.rotrSL(W2h, W2l, 19) ^ u64_default.rotrBL(W2h, W2l, 61) ^ u64_default.shrSL(W2h, W2l, 6);
            const SUMl = u64_default.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
            const SUMh = u64_default.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
            SHA512_W_H[i] = SUMh | 0;
            SHA512_W_L[i] = SUMl | 0;
          }
          let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
          for (let i = 0; i < 80; i++) {
            const sigma1h = u64_default.rotrSH(Eh, El, 14) ^ u64_default.rotrSH(Eh, El, 18) ^ u64_default.rotrBH(Eh, El, 41);
            const sigma1l = u64_default.rotrSL(Eh, El, 14) ^ u64_default.rotrSL(Eh, El, 18) ^ u64_default.rotrBL(Eh, El, 41);
            const CHIh = Eh & Fh ^ ~Eh & Gh;
            const CHIl = El & Fl ^ ~El & Gl;
            const T1ll = u64_default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
            const T1h = u64_default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
            const T1l = T1ll | 0;
            const sigma0h = u64_default.rotrSH(Ah, Al, 28) ^ u64_default.rotrBH(Ah, Al, 34) ^ u64_default.rotrBH(Ah, Al, 39);
            const sigma0l = u64_default.rotrSL(Ah, Al, 28) ^ u64_default.rotrBL(Ah, Al, 34) ^ u64_default.rotrBL(Ah, Al, 39);
            const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
            const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
            Hh = Gh | 0;
            Hl = Gl | 0;
            Gh = Fh | 0;
            Gl = Fl | 0;
            Fh = Eh | 0;
            Fl = El | 0;
            ({ h: Eh, l: El } = u64_default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
            Dh = Ch | 0;
            Dl = Cl | 0;
            Ch = Bh | 0;
            Cl = Bl | 0;
            Bh = Ah | 0;
            Bl = Al | 0;
            const All = u64_default.add3L(T1l, sigma0l, MAJl);
            Ah = u64_default.add3H(All, T1h, sigma0h, MAJh);
            Al = All | 0;
          }
          ({ h: Ah, l: Al } = u64_default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
          ({ h: Bh, l: Bl } = u64_default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
          ({ h: Ch, l: Cl } = u64_default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
          ({ h: Dh, l: Dl } = u64_default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
          ({ h: Eh, l: El } = u64_default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
          ({ h: Fh, l: Fl } = u64_default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
          ({ h: Gh, l: Gl } = u64_default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
          ({ h: Hh, l: Hl } = u64_default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
          this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
        }
        roundClean() {
          SHA512_W_H.fill(0);
          SHA512_W_L.fill(0);
        }
        destroy() {
          this.buffer.fill(0);
          this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        }
      };
      SHA512_224 = class extends SHA512 {
        constructor() {
          super();
          this.Ah = 2352822216 | 0;
          this.Al = 424955298 | 0;
          this.Bh = 1944164710 | 0;
          this.Bl = 2312950998 | 0;
          this.Ch = 502970286 | 0;
          this.Cl = 855612546 | 0;
          this.Dh = 1738396948 | 0;
          this.Dl = 1479516111 | 0;
          this.Eh = 258812777 | 0;
          this.El = 2077511080 | 0;
          this.Fh = 2011393907 | 0;
          this.Fl = 79989058 | 0;
          this.Gh = 1067287976 | 0;
          this.Gl = 1780299464 | 0;
          this.Hh = 286451373 | 0;
          this.Hl = 2446758561 | 0;
          this.outputLen = 28;
        }
      };
      SHA512_256 = class extends SHA512 {
        constructor() {
          super();
          this.Ah = 573645204 | 0;
          this.Al = 4230739756 | 0;
          this.Bh = 2673172387 | 0;
          this.Bl = 3360449730 | 0;
          this.Ch = 596883563 | 0;
          this.Cl = 1867755857 | 0;
          this.Dh = 2520282905 | 0;
          this.Dl = 1497426621 | 0;
          this.Eh = 2519219938 | 0;
          this.El = 2827943907 | 0;
          this.Fh = 3193839141 | 0;
          this.Fl = 1401305490 | 0;
          this.Gh = 721525244 | 0;
          this.Gl = 746961066 | 0;
          this.Hh = 246885852 | 0;
          this.Hl = 2177182882 | 0;
          this.outputLen = 32;
        }
      };
      SHA384 = class extends SHA512 {
        constructor() {
          super();
          this.Ah = 3418070365 | 0;
          this.Al = 3238371032 | 0;
          this.Bh = 1654270250 | 0;
          this.Bl = 914150663 | 0;
          this.Ch = 2438529370 | 0;
          this.Cl = 812702999 | 0;
          this.Dh = 355462360 | 0;
          this.Dl = 4144912697 | 0;
          this.Eh = 1731405415 | 0;
          this.El = 4290775857 | 0;
          this.Fh = 2394180231 | 0;
          this.Fl = 1750603025 | 0;
          this.Gh = 3675008525 | 0;
          this.Gl = 1694076839 | 0;
          this.Hh = 1203062813 | 0;
          this.Hl = 3204075428 | 0;
          this.outputLen = 48;
        }
      };
      sha512 = wrapConstructor(() => new SHA512());
      sha512_224 = wrapConstructor(() => new SHA512_224());
      sha512_256 = wrapConstructor(() => new SHA512_256());
      sha384 = wrapConstructor(() => new SHA384());
    }
  });

  // node_modules/@noble/curves/esm/abstract/utils.js
  var utils_exports = {};
  __export(utils_exports, {
    bitGet: () => bitGet,
    bitLen: () => bitLen,
    bitMask: () => bitMask,
    bitSet: () => bitSet,
    bytesToHex: () => bytesToHex,
    bytesToNumberBE: () => bytesToNumberBE,
    bytesToNumberLE: () => bytesToNumberLE,
    concatBytes: () => concatBytes2,
    createHmacDrbg: () => createHmacDrbg,
    ensureBytes: () => ensureBytes,
    equalBytes: () => equalBytes,
    hexToBytes: () => hexToBytes,
    hexToNumber: () => hexToNumber,
    numberToBytesBE: () => numberToBytesBE,
    numberToBytesLE: () => numberToBytesLE,
    numberToHexUnpadded: () => numberToHexUnpadded,
    numberToVarBytesBE: () => numberToVarBytesBE,
    utf8ToBytes: () => utf8ToBytes3,
    validateObject: () => validateObject
  });
  function bytesToHex(bytes2) {
    if (!u8a2(bytes2))
      throw new Error("Uint8Array expected");
    let hex = "";
    for (let i = 0; i < bytes2.length; i++) {
      hex += hexes2[bytes2[i]];
    }
    return hex;
  }
  function numberToHexUnpadded(num) {
    const hex = num.toString(16);
    return hex.length & 1 ? `0${hex}` : hex;
  }
  function hexToNumber(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    return BigInt(hex === "" ? "0" : `0x${hex}`);
  }
  function hexToBytes(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    const len = hex.length;
    if (len % 2)
      throw new Error("padded hex string expected, got unpadded hex of length " + len);
    const array6 = new Uint8Array(len / 2);
    for (let i = 0; i < array6.length; i++) {
      const j2 = i * 2;
      const hexByte = hex.slice(j2, j2 + 2);
      const byte = Number.parseInt(hexByte, 16);
      if (Number.isNaN(byte) || byte < 0)
        throw new Error("Invalid byte sequence");
      array6[i] = byte;
    }
    return array6;
  }
  function bytesToNumberBE(bytes2) {
    return hexToNumber(bytesToHex(bytes2));
  }
  function bytesToNumberLE(bytes2) {
    if (!u8a2(bytes2))
      throw new Error("Uint8Array expected");
    return hexToNumber(bytesToHex(Uint8Array.from(bytes2).reverse()));
  }
  function numberToBytesBE(n, len) {
    return hexToBytes(n.toString(16).padStart(len * 2, "0"));
  }
  function numberToBytesLE(n, len) {
    return numberToBytesBE(n, len).reverse();
  }
  function numberToVarBytesBE(n) {
    return hexToBytes(numberToHexUnpadded(n));
  }
  function ensureBytes(title2, hex, expectedLength) {
    let res;
    if (typeof hex === "string") {
      try {
        res = hexToBytes(hex);
      } catch (e) {
        throw new Error(`${title2} must be valid hex string, got "${hex}". Cause: ${e}`);
      }
    } else if (u8a2(hex)) {
      res = Uint8Array.from(hex);
    } else {
      throw new Error(`${title2} must be hex string or Uint8Array`);
    }
    const len = res.length;
    if (typeof expectedLength === "number" && len !== expectedLength)
      throw new Error(`${title2} expected ${expectedLength} bytes, got ${len}`);
    return res;
  }
  function concatBytes2(...arrays) {
    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
    let pad = 0;
    arrays.forEach((a) => {
      if (!u8a2(a))
        throw new Error("Uint8Array expected");
      r.set(a, pad);
      pad += a.length;
    });
    return r;
  }
  function equalBytes(b1, b2) {
    if (b1.length !== b2.length)
      return false;
    for (let i = 0; i < b1.length; i++)
      if (b1[i] !== b2[i])
        return false;
    return true;
  }
  function utf8ToBytes3(str3) {
    if (typeof str3 !== "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof str3}`);
    return new Uint8Array(new TextEncoder().encode(str3));
  }
  function bitLen(n) {
    let len;
    for (len = 0; n > _0n; n >>= _1n, len += 1)
      ;
    return len;
  }
  function bitGet(n, pos) {
    return n >> BigInt(pos) & _1n;
  }
  function createHmacDrbg(hashLen, qByteLen, hmacFn) {
    if (typeof hashLen !== "number" || hashLen < 2)
      throw new Error("hashLen must be a number");
    if (typeof qByteLen !== "number" || qByteLen < 2)
      throw new Error("qByteLen must be a number");
    if (typeof hmacFn !== "function")
      throw new Error("hmacFn must be a function");
    let v2 = u8n(hashLen);
    let k2 = u8n(hashLen);
    let i = 0;
    const reset = () => {
      v2.fill(1);
      k2.fill(0);
      i = 0;
    };
    const h2 = (...b2) => hmacFn(k2, v2, ...b2);
    const reseed = (seed2 = u8n()) => {
      k2 = h2(u8fr([0]), seed2);
      v2 = h2();
      if (seed2.length === 0)
        return;
      k2 = h2(u8fr([1]), seed2);
      v2 = h2();
    };
    const gen2 = () => {
      if (i++ >= 1e3)
        throw new Error("drbg: tried 1000 values");
      let len = 0;
      const out = [];
      while (len < qByteLen) {
        v2 = h2();
        const sl = v2.slice();
        out.push(sl);
        len += v2.length;
      }
      return concatBytes2(...out);
    };
    const genUntil = (seed2, pred) => {
      reset();
      reseed(seed2);
      let res = void 0;
      while (!(res = pred(gen2())))
        reseed();
      reset();
      return res;
    };
    return genUntil;
  }
  function validateObject(object3, validators, optValidators = {}) {
    const checkField = (fieldName, type5, isOptional) => {
      const checkVal = validatorFns[type5];
      if (typeof checkVal !== "function")
        throw new Error(`Invalid validator "${type5}", expected function`);
      const val = object3[fieldName];
      if (isOptional && val === void 0)
        return;
      if (!checkVal(val, object3)) {
        throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type5}`);
      }
    };
    for (const [fieldName, type5] of Object.entries(validators))
      checkField(fieldName, type5, false);
    for (const [fieldName, type5] of Object.entries(optValidators))
      checkField(fieldName, type5, true);
    return object3;
  }
  var _0n, _1n, _2n, u8a2, hexes2, bitSet, bitMask, u8n, u8fr, validatorFns;
  var init_utils2 = __esm({
    "node_modules/@noble/curves/esm/abstract/utils.js"() {
      init_virtual_process_polyfill();
      init_buffer();
      _0n = BigInt(0);
      _1n = BigInt(1);
      _2n = BigInt(2);
      u8a2 = (a) => a instanceof Uint8Array;
      hexes2 = Array.from({ length: 256 }, (v2, i) => i.toString(16).padStart(2, "0"));
      bitSet = (n, pos, value) => {
        return n | (value ? _1n : _0n) << BigInt(pos);
      };
      bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
      u8n = (data) => new Uint8Array(data);
      u8fr = (arr) => Uint8Array.from(arr);
      validatorFns = {
        bigint: (val) => typeof val === "bigint",
        function: (val) => typeof val === "function",
        boolean: (val) => typeof val === "boolean",
        string: (val) => typeof val === "string",
        isSafeInteger: (val) => Number.isSafeInteger(val),
        array: (val) => Array.isArray(val),
        field: (val, object3) => object3.Fp.isValid(val),
        hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
      };
    }
  });

  // node_modules/@noble/curves/esm/abstract/modular.js
  function mod(a, b2) {
    const result = a % b2;
    return result >= _0n2 ? result : b2 + result;
  }
  function pow(num, power, modulo) {
    if (modulo <= _0n2 || power < _0n2)
      throw new Error("Expected power/modulo > 0");
    if (modulo === _1n2)
      return _0n2;
    let res = _1n2;
    while (power > _0n2) {
      if (power & _1n2)
        res = res * num % modulo;
      num = num * num % modulo;
      power >>= _1n2;
    }
    return res;
  }
  function pow2(x2, power, modulo) {
    let res = x2;
    while (power-- > _0n2) {
      res *= res;
      res %= modulo;
    }
    return res;
  }
  function invert(number5, modulo) {
    if (number5 === _0n2 || modulo <= _0n2) {
      throw new Error(`invert: expected positive integers, got n=${number5} mod=${modulo}`);
    }
    let a = mod(number5, modulo);
    let b2 = modulo;
    let x2 = _0n2, y2 = _1n2, u2 = _1n2, v2 = _0n2;
    while (a !== _0n2) {
      const q2 = b2 / a;
      const r = b2 % a;
      const m = x2 - u2 * q2;
      const n = y2 - v2 * q2;
      b2 = a, a = r, x2 = u2, y2 = v2, u2 = m, v2 = n;
    }
    const gcd = b2;
    if (gcd !== _1n2)
      throw new Error("invert: does not exist");
    return mod(x2, modulo);
  }
  function tonelliShanks(P2) {
    const legendreC = (P2 - _1n2) / _2n2;
    let Q2, S2, Z2;
    for (Q2 = P2 - _1n2, S2 = 0; Q2 % _2n2 === _0n2; Q2 /= _2n2, S2++)
      ;
    for (Z2 = _2n2; Z2 < P2 && pow(Z2, legendreC, P2) !== P2 - _1n2; Z2++)
      ;
    if (S2 === 1) {
      const p1div4 = (P2 + _1n2) / _4n;
      return function tonelliFast(Fp3, n) {
        const root2 = Fp3.pow(n, p1div4);
        if (!Fp3.eql(Fp3.sqr(root2), n))
          throw new Error("Cannot find square root");
        return root2;
      };
    }
    const Q1div2 = (Q2 + _1n2) / _2n2;
    return function tonelliSlow(Fp3, n) {
      if (Fp3.pow(n, legendreC) === Fp3.neg(Fp3.ONE))
        throw new Error("Cannot find square root");
      let r = S2;
      let g2 = Fp3.pow(Fp3.mul(Fp3.ONE, Z2), Q2);
      let x2 = Fp3.pow(n, Q1div2);
      let b2 = Fp3.pow(n, Q2);
      while (!Fp3.eql(b2, Fp3.ONE)) {
        if (Fp3.eql(b2, Fp3.ZERO))
          return Fp3.ZERO;
        let m = 1;
        for (let t2 = Fp3.sqr(b2); m < r; m++) {
          if (Fp3.eql(t2, Fp3.ONE))
            break;
          t2 = Fp3.sqr(t2);
        }
        const ge2 = Fp3.pow(g2, _1n2 << BigInt(r - m - 1));
        g2 = Fp3.sqr(ge2);
        x2 = Fp3.mul(x2, ge2);
        b2 = Fp3.mul(b2, g2);
        r = m;
      }
      return x2;
    };
  }
  function FpSqrt(P2) {
    if (P2 % _4n === _3n) {
      const p1div4 = (P2 + _1n2) / _4n;
      return function sqrt3mod4(Fp3, n) {
        const root2 = Fp3.pow(n, p1div4);
        if (!Fp3.eql(Fp3.sqr(root2), n))
          throw new Error("Cannot find square root");
        return root2;
      };
    }
    if (P2 % _8n === _5n) {
      const c1 = (P2 - _5n) / _8n;
      return function sqrt5mod8(Fp3, n) {
        const n2 = Fp3.mul(n, _2n2);
        const v2 = Fp3.pow(n2, c1);
        const nv = Fp3.mul(n, v2);
        const i = Fp3.mul(Fp3.mul(nv, _2n2), v2);
        const root2 = Fp3.mul(nv, Fp3.sub(i, Fp3.ONE));
        if (!Fp3.eql(Fp3.sqr(root2), n))
          throw new Error("Cannot find square root");
        return root2;
      };
    }
    if (P2 % _16n === _9n) {
    }
    return tonelliShanks(P2);
  }
  function validateField(field) {
    const initial = {
      ORDER: "bigint",
      MASK: "bigint",
      BYTES: "isSafeInteger",
      BITS: "isSafeInteger"
    };
    const opts = FIELD_FIELDS.reduce((map, val) => {
      map[val] = "function";
      return map;
    }, initial);
    return validateObject(field, opts);
  }
  function FpPow(f3, num, power) {
    if (power < _0n2)
      throw new Error("Expected power > 0");
    if (power === _0n2)
      return f3.ONE;
    if (power === _1n2)
      return num;
    let p2 = f3.ONE;
    let d2 = num;
    while (power > _0n2) {
      if (power & _1n2)
        p2 = f3.mul(p2, d2);
      d2 = f3.sqr(d2);
      power >>= _1n2;
    }
    return p2;
  }
  function FpInvertBatch(f3, nums) {
    const tmp = new Array(nums.length);
    const lastMultiplied = nums.reduce((acc, num, i) => {
      if (f3.is0(num))
        return acc;
      tmp[i] = acc;
      return f3.mul(acc, num);
    }, f3.ONE);
    const inverted = f3.inv(lastMultiplied);
    nums.reduceRight((acc, num, i) => {
      if (f3.is0(num))
        return acc;
      tmp[i] = f3.mul(acc, tmp[i]);
      return f3.mul(acc, num);
    }, inverted);
    return tmp;
  }
  function nLength(n, nBitLength) {
    const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
    const nByteLength = Math.ceil(_nBitLength / 8);
    return { nBitLength: _nBitLength, nByteLength };
  }
  function Field(ORDER, bitLen2, isLE2 = false, redef = {}) {
    if (ORDER <= _0n2)
      throw new Error(`Expected Fp ORDER > 0, got ${ORDER}`);
    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
    if (BYTES > 2048)
      throw new Error("Field lengths over 2048 bytes are not supported");
    const sqrtP = FpSqrt(ORDER);
    const f3 = Object.freeze({
      ORDER,
      BITS,
      BYTES,
      MASK: bitMask(BITS),
      ZERO: _0n2,
      ONE: _1n2,
      create: (num) => mod(num, ORDER),
      isValid: (num) => {
        if (typeof num !== "bigint")
          throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
        return _0n2 <= num && num < ORDER;
      },
      is0: (num) => num === _0n2,
      isOdd: (num) => (num & _1n2) === _1n2,
      neg: (num) => mod(-num, ORDER),
      eql: (lhs, rhs) => lhs === rhs,
      sqr: (num) => mod(num * num, ORDER),
      add: (lhs, rhs) => mod(lhs + rhs, ORDER),
      sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
      mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
      pow: (num, power) => FpPow(f3, num, power),
      div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
      sqrN: (num) => num * num,
      addN: (lhs, rhs) => lhs + rhs,
      subN: (lhs, rhs) => lhs - rhs,
      mulN: (lhs, rhs) => lhs * rhs,
      inv: (num) => invert(num, ORDER),
      sqrt: redef.sqrt || ((n) => sqrtP(f3, n)),
      invertBatch: (lst) => FpInvertBatch(f3, lst),
      cmov: (a, b2, c2) => c2 ? b2 : a,
      toBytes: (num) => isLE2 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
      fromBytes: (bytes2) => {
        if (bytes2.length !== BYTES)
          throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes2.length}`);
        return isLE2 ? bytesToNumberLE(bytes2) : bytesToNumberBE(bytes2);
      }
    });
    return Object.freeze(f3);
  }
  function FpSqrtEven(Fp3, elm) {
    if (!Fp3.isOdd)
      throw new Error(`Field doesn't have isOdd`);
    const root2 = Fp3.sqrt(elm);
    return Fp3.isOdd(root2) ? Fp3.neg(root2) : root2;
  }
  function hashToPrivateScalar(hash2, groupOrder, isLE2 = false) {
    hash2 = ensureBytes("privateHash", hash2);
    const hashLen = hash2.length;
    const minLen = nLength(groupOrder).nByteLength + 8;
    if (minLen < 24 || hashLen < minLen || hashLen > 1024)
      throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);
    const num = isLE2 ? bytesToNumberLE(hash2) : bytesToNumberBE(hash2);
    return mod(num, groupOrder - _1n2) + _1n2;
  }
  var _0n2, _1n2, _2n2, _3n, _4n, _5n, _8n, _9n, _16n, isNegativeLE, FIELD_FIELDS;
  var init_modular = __esm({
    "node_modules/@noble/curves/esm/abstract/modular.js"() {
      init_virtual_process_polyfill();
      init_buffer();
      init_utils2();
      _0n2 = BigInt(0);
      _1n2 = BigInt(1);
      _2n2 = BigInt(2);
      _3n = BigInt(3);
      _4n = BigInt(4);
      _5n = BigInt(5);
      _8n = BigInt(8);
      _9n = BigInt(9);
      _16n = BigInt(16);
      isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n2) === _1n2;
      FIELD_FIELDS = [
        "create",
        "isValid",
        "is0",
        "neg",
        "inv",
        "sqrt",
        "sqr",
        "eql",
        "add",
        "sub",
        "mul",
        "pow",
        "div",
        "addN",
        "subN",
        "mulN",
        "sqrN"
      ];
    }
  });

  // node_modules/@noble/curves/esm/abstract/curve.js
  function wNAF(c2, bits) {
    const constTimeNegate = (condition, item) => {
      const neg = item.negate();
      return condition ? neg : item;
    };
    const opts = (W2) => {
      const windows = Math.ceil(bits / W2) + 1;
      const windowSize = 2 ** (W2 - 1);
      return { windows, windowSize };
    };
    return {
      constTimeNegate,
      unsafeLadder(elm, n) {
        let p2 = c2.ZERO;
        let d2 = elm;
        while (n > _0n3) {
          if (n & _1n3)
            p2 = p2.add(d2);
          d2 = d2.double();
          n >>= _1n3;
        }
        return p2;
      },
      precomputeWindow(elm, W2) {
        const { windows, windowSize } = opts(W2);
        const points = [];
        let p2 = elm;
        let base = p2;
        for (let window2 = 0; window2 < windows; window2++) {
          base = p2;
          points.push(base);
          for (let i = 1; i < windowSize; i++) {
            base = base.add(p2);
            points.push(base);
          }
          p2 = base.double();
        }
        return points;
      },
      wNAF(W2, precomputes, n) {
        const { windows, windowSize } = opts(W2);
        let p2 = c2.ZERO;
        let f3 = c2.BASE;
        const mask4 = BigInt(2 ** W2 - 1);
        const maxNumber = 2 ** W2;
        const shiftBy = BigInt(W2);
        for (let window2 = 0; window2 < windows; window2++) {
          const offset3 = window2 * windowSize;
          let wbits = Number(n & mask4);
          n >>= shiftBy;
          if (wbits > windowSize) {
            wbits -= maxNumber;
            n += _1n3;
          }
          const offset1 = offset3;
          const offset22 = offset3 + Math.abs(wbits) - 1;
          const cond1 = window2 % 2 !== 0;
          const cond2 = wbits < 0;
          if (wbits === 0) {
            f3 = f3.add(constTimeNegate(cond1, precomputes[offset1]));
          } else {
            p2 = p2.add(constTimeNegate(cond2, precomputes[offset22]));
          }
        }
        return { p: p2, f: f3 };
      },
      wNAFCached(P2, precomputesMap, n, transform) {
        const W2 = P2._WINDOW_SIZE || 1;
        let comp = precomputesMap.get(P2);
        if (!comp) {
          comp = this.precomputeWindow(P2, W2);
          if (W2 !== 1) {
            precomputesMap.set(P2, transform(comp));
          }
        }
        return this.wNAF(W2, comp, n);
      }
    };
  }
  function validateBasic(curve) {
    validateField(curve.Fp);
    validateObject(curve, {
      n: "bigint",
      h: "bigint",
      Gx: "field",
      Gy: "field"
    }, {
      nBitLength: "isSafeInteger",
      nByteLength: "isSafeInteger"
    });
    return Object.freeze({
      ...nLength(curve.n, curve.nBitLength),
      ...curve,
      ...{ p: curve.Fp.ORDER }
    });
  }
  var _0n3, _1n3;
  var init_curve = __esm({
    "node_modules/@noble/curves/esm/abstract/curve.js"() {
      init_virtual_process_polyfill();
      init_buffer();
      init_modular();
      init_utils2();
      _0n3 = BigInt(0);
      _1n3 = BigInt(1);
    }
  });

  // node_modules/@noble/curves/esm/abstract/edwards.js
  function validateOpts(curve) {
    const opts = validateBasic(curve);
    validateObject(curve, {
      hash: "function",
      a: "bigint",
      d: "bigint",
      randomBytes: "function"
    }, {
      adjustScalarBytes: "function",
      domain: "function",
      uvRatio: "function",
      mapToCurve: "function"
    });
    return Object.freeze({ ...opts });
  }
  function twistedEdwards(curveDef) {
    const CURVE = validateOpts(curveDef);
    const { Fp: Fp3, n: CURVE_ORDER, prehash, hash: cHash, randomBytes: randomBytes2, nByteLength, h: cofactor } = CURVE;
    const MASK = _2n3 << BigInt(nByteLength * 8) - _1n4;
    const modP = Fp3.create;
    const uvRatio2 = CURVE.uvRatio || ((u2, v2) => {
      try {
        return { isValid: true, value: Fp3.sqrt(u2 * Fp3.inv(v2)) };
      } catch (e) {
        return { isValid: false, value: _0n4 };
      }
    });
    const adjustScalarBytes2 = CURVE.adjustScalarBytes || ((bytes2) => bytes2);
    const domain = CURVE.domain || ((data, ctx, phflag) => {
      if (ctx.length || phflag)
        throw new Error("Contexts/pre-hash are not supported");
      return data;
    });
    const inBig = (n) => typeof n === "bigint" && _0n4 < n;
    const inRange = (n, max) => inBig(n) && inBig(max) && n < max;
    const in0MaskRange = (n) => n === _0n4 || inRange(n, MASK);
    function assertInRange(n, max) {
      if (inRange(n, max))
        return n;
      throw new Error(`Expected valid scalar < ${max}, got ${typeof n} ${n}`);
    }
    function assertGE0(n) {
      return n === _0n4 ? n : assertInRange(n, CURVE_ORDER);
    }
    const pointPrecomputes = /* @__PURE__ */ new Map();
    function isPoint(other) {
      if (!(other instanceof Point2))
        throw new Error("ExtendedPoint expected");
    }
    class Point2 {
      constructor(ex, ey, ez, et2) {
        this.ex = ex;
        this.ey = ey;
        this.ez = ez;
        this.et = et2;
        if (!in0MaskRange(ex))
          throw new Error("x required");
        if (!in0MaskRange(ey))
          throw new Error("y required");
        if (!in0MaskRange(ez))
          throw new Error("z required");
        if (!in0MaskRange(et2))
          throw new Error("t required");
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      static fromAffine(p2) {
        if (p2 instanceof Point2)
          throw new Error("extended point not allowed");
        const { x: x2, y: y2 } = p2 || {};
        if (!in0MaskRange(x2) || !in0MaskRange(y2))
          throw new Error("invalid affine point");
        return new Point2(x2, y2, _1n4, modP(x2 * y2));
      }
      static normalizeZ(points) {
        const toInv = Fp3.invertBatch(points.map((p2) => p2.ez));
        return points.map((p2, i) => p2.toAffine(toInv[i])).map(Point2.fromAffine);
      }
      _setWindowSize(windowSize) {
        this._WINDOW_SIZE = windowSize;
        pointPrecomputes.delete(this);
      }
      assertValidity() {
        const { a, d: d2 } = CURVE;
        if (this.is0())
          throw new Error("bad point: ZERO");
        const { ex: X2, ey: Y2, ez: Z2, et: T2 } = this;
        const X22 = modP(X2 * X2);
        const Y22 = modP(Y2 * Y2);
        const Z22 = modP(Z2 * Z2);
        const Z4 = modP(Z22 * Z22);
        const aX2 = modP(X22 * a);
        const left = modP(Z22 * modP(aX2 + Y22));
        const right = modP(Z4 + modP(d2 * modP(X22 * Y22)));
        if (left !== right)
          throw new Error("bad point: equation left != right (1)");
        const XY = modP(X2 * Y2);
        const ZT = modP(Z2 * T2);
        if (XY !== ZT)
          throw new Error("bad point: equation left != right (2)");
      }
      equals(other) {
        isPoint(other);
        const { ex: X1, ey: Y1, ez: Z1 } = this;
        const { ex: X2, ey: Y2, ez: Z2 } = other;
        const X1Z2 = modP(X1 * Z2);
        const X2Z1 = modP(X2 * Z1);
        const Y1Z2 = modP(Y1 * Z2);
        const Y2Z1 = modP(Y2 * Z1);
        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
      }
      is0() {
        return this.equals(Point2.ZERO);
      }
      negate() {
        return new Point2(modP(-this.ex), this.ey, this.ez, modP(-this.et));
      }
      double() {
        const { a } = CURVE;
        const { ex: X1, ey: Y1, ez: Z1 } = this;
        const A2 = modP(X1 * X1);
        const B2 = modP(Y1 * Y1);
        const C2 = modP(_2n3 * modP(Z1 * Z1));
        const D2 = modP(a * A2);
        const x1y1 = X1 + Y1;
        const E2 = modP(modP(x1y1 * x1y1) - A2 - B2);
        const G3 = D2 + B2;
        const F2 = G3 - C2;
        const H2 = D2 - B2;
        const X3 = modP(E2 * F2);
        const Y3 = modP(G3 * H2);
        const T3 = modP(E2 * H2);
        const Z3 = modP(F2 * G3);
        return new Point2(X3, Y3, Z3, T3);
      }
      add(other) {
        isPoint(other);
        const { a, d: d2 } = CURVE;
        const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;
        const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;
        if (a === BigInt(-1)) {
          const A3 = modP((Y1 - X1) * (Y2 + X2));
          const B3 = modP((Y1 + X1) * (Y2 - X2));
          const F3 = modP(B3 - A3);
          if (F3 === _0n4)
            return this.double();
          const C3 = modP(Z1 * _2n3 * T2);
          const D3 = modP(T1 * _2n3 * Z2);
          const E3 = D3 + C3;
          const G4 = B3 + A3;
          const H3 = D3 - C3;
          const X32 = modP(E3 * F3);
          const Y32 = modP(G4 * H3);
          const T32 = modP(E3 * H3);
          const Z32 = modP(F3 * G4);
          return new Point2(X32, Y32, Z32, T32);
        }
        const A2 = modP(X1 * X2);
        const B2 = modP(Y1 * Y2);
        const C2 = modP(T1 * d2 * T2);
        const D2 = modP(Z1 * Z2);
        const E2 = modP((X1 + Y1) * (X2 + Y2) - A2 - B2);
        const F2 = D2 - C2;
        const G3 = D2 + C2;
        const H2 = modP(B2 - a * A2);
        const X3 = modP(E2 * F2);
        const Y3 = modP(G3 * H2);
        const T3 = modP(E2 * H2);
        const Z3 = modP(F2 * G3);
        return new Point2(X3, Y3, Z3, T3);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      wNAF(n) {
        return wnaf.wNAFCached(this, pointPrecomputes, n, Point2.normalizeZ);
      }
      multiply(scalar) {
        const { p: p2, f: f3 } = this.wNAF(assertInRange(scalar, CURVE_ORDER));
        return Point2.normalizeZ([p2, f3])[0];
      }
      multiplyUnsafe(scalar) {
        let n = assertGE0(scalar);
        if (n === _0n4)
          return I2;
        if (this.equals(I2) || n === _1n4)
          return this;
        if (this.equals(G2))
          return this.wNAF(n).p;
        return wnaf.unsafeLadder(this, n);
      }
      isSmallOrder() {
        return this.multiplyUnsafe(cofactor).is0();
      }
      isTorsionFree() {
        return wnaf.unsafeLadder(this, CURVE_ORDER).is0();
      }
      toAffine(iz) {
        const { ex: x2, ey: y2, ez: z2 } = this;
        const is0 = this.is0();
        if (iz == null)
          iz = is0 ? _8n2 : Fp3.inv(z2);
        const ax = modP(x2 * iz);
        const ay = modP(y2 * iz);
        const zz = modP(z2 * iz);
        if (is0)
          return { x: _0n4, y: _1n4 };
        if (zz !== _1n4)
          throw new Error("invZ was invalid");
        return { x: ax, y: ay };
      }
      clearCofactor() {
        const { h: cofactor2 } = CURVE;
        if (cofactor2 === _1n4)
          return this;
        return this.multiplyUnsafe(cofactor2);
      }
      static fromHex(hex, zip215 = false) {
        const { d: d2, a } = CURVE;
        const len = Fp3.BYTES;
        hex = ensureBytes("pointHex", hex, len);
        const normed = hex.slice();
        const lastByte = hex[len - 1];
        normed[len - 1] = lastByte & ~128;
        const y2 = bytesToNumberLE(normed);
        if (y2 === _0n4) {
        } else {
          if (zip215)
            assertInRange(y2, MASK);
          else
            assertInRange(y2, Fp3.ORDER);
        }
        const y22 = modP(y2 * y2);
        const u2 = modP(y22 - _1n4);
        const v2 = modP(d2 * y22 - a);
        let { isValid, value: x2 } = uvRatio2(u2, v2);
        if (!isValid)
          throw new Error("Point.fromHex: invalid y coordinate");
        const isXOdd = (x2 & _1n4) === _1n4;
        const isLastByteOdd = (lastByte & 128) !== 0;
        if (!zip215 && x2 === _0n4 && isLastByteOdd)
          throw new Error("Point.fromHex: x=0 and x_0=1");
        if (isLastByteOdd !== isXOdd)
          x2 = modP(-x2);
        return Point2.fromAffine({ x: x2, y: y2 });
      }
      static fromPrivateKey(privKey) {
        return getExtendedPublicKey(privKey).point;
      }
      toRawBytes() {
        const { x: x2, y: y2 } = this.toAffine();
        const bytes2 = numberToBytesLE(y2, Fp3.BYTES);
        bytes2[bytes2.length - 1] |= x2 & _1n4 ? 128 : 0;
        return bytes2;
      }
      toHex() {
        return bytesToHex(this.toRawBytes());
      }
    }
    Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, _1n4, modP(CURVE.Gx * CURVE.Gy));
    Point2.ZERO = new Point2(_0n4, _1n4, _1n4, _0n4);
    const { BASE: G2, ZERO: I2 } = Point2;
    const wnaf = wNAF(Point2, nByteLength * 8);
    function modN(a) {
      return mod(a, CURVE_ORDER);
    }
    function modN_LE(hash2) {
      return modN(bytesToNumberLE(hash2));
    }
    function getExtendedPublicKey(key) {
      const len = nByteLength;
      key = ensureBytes("private key", key, len);
      const hashed = ensureBytes("hashed private key", cHash(key), 2 * len);
      const head = adjustScalarBytes2(hashed.slice(0, len));
      const prefix = hashed.slice(len, 2 * len);
      const scalar = modN_LE(head);
      const point = G2.multiply(scalar);
      const pointBytes = point.toRawBytes();
      return { head, prefix, scalar, point, pointBytes };
    }
    function getPublicKey2(privKey) {
      return getExtendedPublicKey(privKey).pointBytes;
    }
    function hashDomainToScalar(context = new Uint8Array(), ...msgs) {
      const msg = concatBytes2(...msgs);
      return modN_LE(cHash(domain(msg, ensureBytes("context", context), !!prehash)));
    }
    function sign2(msg, privKey, options = {}) {
      msg = ensureBytes("message", msg);
      if (prehash)
        msg = prehash(msg);
      const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);
      const r = hashDomainToScalar(options.context, prefix, msg);
      const R2 = G2.multiply(r).toRawBytes();
      const k2 = hashDomainToScalar(options.context, R2, pointBytes, msg);
      const s = modN(r + k2 * scalar);
      assertGE0(s);
      const res = concatBytes2(R2, numberToBytesLE(s, Fp3.BYTES));
      return ensureBytes("result", res, nByteLength * 2);
    }
    const verifyOpts = VERIFY_DEFAULT;
    function verify2(sig, msg, publicKey6, options = verifyOpts) {
      const { context, zip215 } = options;
      const len = Fp3.BYTES;
      sig = ensureBytes("signature", sig, 2 * len);
      msg = ensureBytes("message", msg);
      if (prehash)
        msg = prehash(msg);
      const s = bytesToNumberLE(sig.slice(len, 2 * len));
      let A2, R2, SB;
      try {
        A2 = Point2.fromHex(publicKey6, zip215);
        R2 = Point2.fromHex(sig.slice(0, len), zip215);
        SB = G2.multiplyUnsafe(s);
      } catch (error2) {
        return false;
      }
      if (!zip215 && A2.isSmallOrder())
        return false;
      const k2 = hashDomainToScalar(context, R2.toRawBytes(), A2.toRawBytes(), msg);
      const RkA = R2.add(A2.multiplyUnsafe(k2));
      return RkA.subtract(SB).clearCofactor().equals(Point2.ZERO);
    }
    G2._setWindowSize(8);
    const utils = {
      getExtendedPublicKey,
      randomPrivateKey: () => randomBytes2(Fp3.BYTES),
      precompute(windowSize = 8, point = Point2.BASE) {
        point._setWindowSize(windowSize);
        point.multiply(BigInt(3));
        return point;
      }
    };
    return {
      CURVE,
      getPublicKey: getPublicKey2,
      sign: sign2,
      verify: verify2,
      ExtendedPoint: Point2,
      utils
    };
  }
  var _0n4, _1n4, _2n3, _8n2, VERIFY_DEFAULT;
  var init_edwards = __esm({
    "node_modules/@noble/curves/esm/abstract/edwards.js"() {
      init_virtual_process_polyfill();
      init_buffer();
      init_modular();
      init_utils2();
      init_utils2();
      init_curve();
      _0n4 = BigInt(0);
      _1n4 = BigInt(1);
      _2n3 = BigInt(2);
      _8n2 = BigInt(8);
      VERIFY_DEFAULT = { zip215: true };
    }
  });

  // node_modules/@noble/curves/esm/abstract/montgomery.js
  var _0n5, _1n5;
  var init_montgomery = __esm({
    "node_modules/@noble/curves/esm/abstract/montgomery.js"() {
      init_virtual_process_polyfill();
      init_buffer();
      init_modular();
      init_utils2();
      _0n5 = BigInt(0);
      _1n5 = BigInt(1);
    }
  });

  // node_modules/@noble/curves/esm/abstract/hash-to-curve.js
  var init_hash_to_curve = __esm({
    "node_modules/@noble/curves/esm/abstract/hash-to-curve.js"() {
      init_virtual_process_polyfill();
      init_buffer();
      init_modular();
      init_utils2();
    }
  });

  // node_modules/@noble/curves/esm/ed25519.js
  function ed25519_pow_2_252_3(x2) {
    const P2 = ED25519_P;
    const x22 = x2 * x2 % P2;
    const b2 = x22 * x2 % P2;
    const b4 = pow2(b2, _2n4, P2) * b2 % P2;
    const b5 = pow2(b4, _1n6, P2) * x2 % P2;
    const b10 = pow2(b5, _5n2, P2) * b5 % P2;
    const b20 = pow2(b10, _10n, P2) * b10 % P2;
    const b40 = pow2(b20, _20n, P2) * b20 % P2;
    const b80 = pow2(b40, _40n, P2) * b40 % P2;
    const b160 = pow2(b80, _80n, P2) * b80 % P2;
    const b240 = pow2(b160, _80n, P2) * b80 % P2;
    const b250 = pow2(b240, _10n, P2) * b10 % P2;
    const pow_p_5_8 = pow2(b250, _2n4, P2) * x2 % P2;
    return { pow_p_5_8, b2 };
  }
  function adjustScalarBytes(bytes2) {
    bytes2[0] &= 248;
    bytes2[31] &= 127;
    bytes2[31] |= 64;
    return bytes2;
  }
  function uvRatio(u2, v2) {
    const P2 = ED25519_P;
    const v32 = mod(v2 * v2 * v2, P2);
    const v7 = mod(v32 * v32 * v2, P2);
    const pow3 = ed25519_pow_2_252_3(u2 * v7).pow_p_5_8;
    let x2 = mod(u2 * v32 * pow3, P2);
    const vx2 = mod(v2 * x2 * x2, P2);
    const root1 = x2;
    const root2 = mod(x2 * ED25519_SQRT_M1, P2);
    const useRoot1 = vx2 === u2;
    const useRoot2 = vx2 === mod(-u2, P2);
    const noRoot = vx2 === mod(-u2 * ED25519_SQRT_M1, P2);
    if (useRoot1)
      x2 = root1;
    if (useRoot2 || noRoot)
      x2 = root2;
    if (isNegativeLE(x2, P2))
      x2 = mod(-x2, P2);
    return { isValid: useRoot1 || useRoot2, value: x2 };
  }
  function ed25519_domain(data, ctx, phflag) {
    if (ctx.length > 255)
      throw new Error("Context is too big");
    return concatBytes(utf8ToBytes2("SigEd25519 no Ed25519 collisions"), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);
  }
  var ED25519_P, ED25519_SQRT_M1, _0n6, _1n6, _2n4, _5n2, _10n, _20n, _40n, _80n, Fp, ed25519Defaults, ed25519, ed25519ctx, ed25519ph, ELL2_C1, ELL2_C2, ELL2_C3, ELL2_C4, ELL2_J, ELL2_C1_EDWARDS, SQRT_AD_MINUS_ONE, INVSQRT_A_MINUS_D, ONE_MINUS_D_SQ, D_MINUS_ONE_SQ, MAX_255B;
  var init_ed25519 = __esm({
    "node_modules/@noble/curves/esm/ed25519.js"() {
      init_virtual_process_polyfill();
      init_buffer();
      init_sha512();
      init_utils();
      init_edwards();
      init_montgomery();
      init_modular();
      init_utils2();
      init_hash_to_curve();
      ED25519_P = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
      ED25519_SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
      _0n6 = BigInt(0);
      _1n6 = BigInt(1);
      _2n4 = BigInt(2);
      _5n2 = BigInt(5);
      _10n = BigInt(10);
      _20n = BigInt(20);
      _40n = BigInt(40);
      _80n = BigInt(80);
      Fp = Field(ED25519_P, void 0, true);
      ed25519Defaults = {
        a: BigInt(-1),
        d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
        Fp,
        n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
        h: BigInt(8),
        Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
        Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
        hash: sha512,
        randomBytes,
        adjustScalarBytes,
        uvRatio
      };
      ed25519 = twistedEdwards(ed25519Defaults);
      ed25519ctx = twistedEdwards({ ...ed25519Defaults, domain: ed25519_domain });
      ed25519ph = twistedEdwards({
        ...ed25519Defaults,
        domain: ed25519_domain,
        prehash: sha512
      });
      ELL2_C1 = (Fp.ORDER + BigInt(3)) / BigInt(8);
      ELL2_C2 = Fp.pow(_2n4, ELL2_C1);
      ELL2_C3 = Fp.sqrt(Fp.neg(Fp.ONE));
      ELL2_C4 = (Fp.ORDER - BigInt(5)) / BigInt(8);
      ELL2_J = BigInt(486662);
      ELL2_C1_EDWARDS = FpSqrtEven(Fp, Fp.neg(BigInt(486664)));
      SQRT_AD_MINUS_ONE = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
      INVSQRT_A_MINUS_D = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
      ONE_MINUS_D_SQ = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
      D_MINUS_ONE_SQ = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
      MAX_255B = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    }
  });

  // node_modules/bn.js/lib/bn.js
  var require_bn = __commonJS({
    "node_modules/bn.js/lib/bn.js"(exports2, module2) {
      init_virtual_process_polyfill();
      init_buffer();
      (function(module3, exports3) {
        "use strict";
        function assert7(val, msg) {
          if (!val)
            throw new Error(msg || "Assertion failed");
        }
        function inherits2(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
        function BN4(number5, base, endian) {
          if (BN4.isBN(number5)) {
            return number5;
          }
          this.negative = 0;
          this.words = null;
          this.length = 0;
          this.red = null;
          if (number5 !== null) {
            if (base === "le" || base === "be") {
              endian = base;
              base = 10;
            }
            this._init(number5 || 0, base || 10, endian || "be");
          }
        }
        if (typeof module3 === "object") {
          module3.exports = BN4;
        } else {
          exports3.BN = BN4;
        }
        BN4.BN = BN4;
        BN4.wordSize = 26;
        var Buffer3;
        try {
          if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
            Buffer3 = window.Buffer;
          } else {
            Buffer3 = require_buffer().Buffer;
          }
        } catch (e) {
        }
        BN4.isBN = function isBN(num) {
          if (num instanceof BN4) {
            return true;
          }
          return num !== null && typeof num === "object" && num.constructor.wordSize === BN4.wordSize && Array.isArray(num.words);
        };
        BN4.max = function max(left, right) {
          if (left.cmp(right) > 0)
            return left;
          return right;
        };
        BN4.min = function min(left, right) {
          if (left.cmp(right) < 0)
            return left;
          return right;
        };
        BN4.prototype._init = function init2(number5, base, endian) {
          if (typeof number5 === "number") {
            return this._initNumber(number5, base, endian);
          }
          if (typeof number5 === "object") {
            return this._initArray(number5, base, endian);
          }
          if (base === "hex") {
            base = 16;
          }
          assert7(base === (base | 0) && base >= 2 && base <= 36);
          number5 = number5.toString().replace(/\s+/g, "");
          var start = 0;
          if (number5[0] === "-") {
            start++;
            this.negative = 1;
          }
          if (start < number5.length) {
            if (base === 16) {
              this._parseHex(number5, start, endian);
            } else {
              this._parseBase(number5, base, start);
              if (endian === "le") {
                this._initArray(this.toArray(), base, endian);
              }
            }
          }
        };
        BN4.prototype._initNumber = function _initNumber(number5, base, endian) {
          if (number5 < 0) {
            this.negative = 1;
            number5 = -number5;
          }
          if (number5 < 67108864) {
            this.words = [number5 & 67108863];
            this.length = 1;
          } else if (number5 < 4503599627370496) {
            this.words = [
              number5 & 67108863,
              number5 / 67108864 & 67108863
            ];
            this.length = 2;
          } else {
            assert7(number5 < 9007199254740992);
            this.words = [
              number5 & 67108863,
              number5 / 67108864 & 67108863,
              1
            ];
            this.length = 3;
          }
          if (endian !== "le")
            return;
          this._initArray(this.toArray(), base, endian);
        };
        BN4.prototype._initArray = function _initArray(number5, base, endian) {
          assert7(typeof number5.length === "number");
          if (number5.length <= 0) {
            this.words = [0];
            this.length = 1;
            return this;
          }
          this.length = Math.ceil(number5.length / 3);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var j2, w2;
          var off2 = 0;
          if (endian === "be") {
            for (i = number5.length - 1, j2 = 0; i >= 0; i -= 3) {
              w2 = number5[i] | number5[i - 1] << 8 | number5[i - 2] << 16;
              this.words[j2] |= w2 << off2 & 67108863;
              this.words[j2 + 1] = w2 >>> 26 - off2 & 67108863;
              off2 += 24;
              if (off2 >= 26) {
                off2 -= 26;
                j2++;
              }
            }
          } else if (endian === "le") {
            for (i = 0, j2 = 0; i < number5.length; i += 3) {
              w2 = number5[i] | number5[i + 1] << 8 | number5[i + 2] << 16;
              this.words[j2] |= w2 << off2 & 67108863;
              this.words[j2 + 1] = w2 >>> 26 - off2 & 67108863;
              off2 += 24;
              if (off2 >= 26) {
                off2 -= 26;
                j2++;
              }
            }
          }
          return this._strip();
        };
        function parseHex4Bits(string4, index) {
          var c2 = string4.charCodeAt(index);
          if (c2 >= 48 && c2 <= 57) {
            return c2 - 48;
          } else if (c2 >= 65 && c2 <= 70) {
            return c2 - 55;
          } else if (c2 >= 97 && c2 <= 102) {
            return c2 - 87;
          } else {
            assert7(false, "Invalid character in " + string4);
          }
        }
        function parseHexByte(string4, lowerBound, index) {
          var r = parseHex4Bits(string4, index);
          if (index - 1 >= lowerBound) {
            r |= parseHex4Bits(string4, index - 1) << 4;
          }
          return r;
        }
        BN4.prototype._parseHex = function _parseHex(number5, start, endian) {
          this.length = Math.ceil((number5.length - start) / 6);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var off2 = 0;
          var j2 = 0;
          var w2;
          if (endian === "be") {
            for (i = number5.length - 1; i >= start; i -= 2) {
              w2 = parseHexByte(number5, start, i) << off2;
              this.words[j2] |= w2 & 67108863;
              if (off2 >= 18) {
                off2 -= 18;
                j2 += 1;
                this.words[j2] |= w2 >>> 26;
              } else {
                off2 += 8;
              }
            }
          } else {
            var parseLength = number5.length - start;
            for (i = parseLength % 2 === 0 ? start + 1 : start; i < number5.length; i += 2) {
              w2 = parseHexByte(number5, start, i) << off2;
              this.words[j2] |= w2 & 67108863;
              if (off2 >= 18) {
                off2 -= 18;
                j2 += 1;
                this.words[j2] |= w2 >>> 26;
              } else {
                off2 += 8;
              }
            }
          }
          this._strip();
        };
        function parseBase(str3, start, end, mul) {
          var r = 0;
          var b2 = 0;
          var len = Math.min(str3.length, end);
          for (var i = start; i < len; i++) {
            var c2 = str3.charCodeAt(i) - 48;
            r *= mul;
            if (c2 >= 49) {
              b2 = c2 - 49 + 10;
            } else if (c2 >= 17) {
              b2 = c2 - 17 + 10;
            } else {
              b2 = c2;
            }
            assert7(c2 >= 0 && b2 < mul, "Invalid character");
            r += b2;
          }
          return r;
        }
        BN4.prototype._parseBase = function _parseBase(number5, base, start) {
          this.words = [0];
          this.length = 1;
          for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
            limbLen++;
          }
          limbLen--;
          limbPow = limbPow / base | 0;
          var total = number5.length - start;
          var mod2 = total % limbLen;
          var end = Math.min(total, total - mod2) + start;
          var word = 0;
          for (var i = start; i < end; i += limbLen) {
            word = parseBase(number5, i, i + limbLen, base);
            this.imuln(limbPow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          if (mod2 !== 0) {
            var pow3 = 1;
            word = parseBase(number5, i, number5.length, base);
            for (i = 0; i < mod2; i++) {
              pow3 *= base;
            }
            this.imuln(pow3);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          this._strip();
        };
        BN4.prototype.copy = function copy2(dest) {
          dest.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            dest.words[i] = this.words[i];
          }
          dest.length = this.length;
          dest.negative = this.negative;
          dest.red = this.red;
        };
        function move(dest, src) {
          dest.words = src.words;
          dest.length = src.length;
          dest.negative = src.negative;
          dest.red = src.red;
        }
        BN4.prototype._move = function _move(dest) {
          move(dest, this);
        };
        BN4.prototype.clone = function clone() {
          var r = new BN4(null);
          this.copy(r);
          return r;
        };
        BN4.prototype._expand = function _expand(size) {
          while (this.length < size) {
            this.words[this.length++] = 0;
          }
          return this;
        };
        BN4.prototype._strip = function strip() {
          while (this.length > 1 && this.words[this.length - 1] === 0) {
            this.length--;
          }
          return this._normSign();
        };
        BN4.prototype._normSign = function _normSign() {
          if (this.length === 1 && this.words[0] === 0) {
            this.negative = 0;
          }
          return this;
        };
        if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
          try {
            BN4.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect2;
          } catch (e) {
            BN4.prototype.inspect = inspect2;
          }
        } else {
          BN4.prototype.inspect = inspect2;
        }
        function inspect2() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        }
        var zeros = [
          "",
          "0",
          "00",
          "000",
          "0000",
          "00000",
          "000000",
          "0000000",
          "00000000",
          "000000000",
          "0000000000",
          "00000000000",
          "000000000000",
          "0000000000000",
          "00000000000000",
          "000000000000000",
          "0000000000000000",
          "00000000000000000",
          "000000000000000000",
          "0000000000000000000",
          "00000000000000000000",
          "000000000000000000000",
          "0000000000000000000000",
          "00000000000000000000000",
          "000000000000000000000000",
          "0000000000000000000000000"
        ];
        var groupSizes = [
          0,
          0,
          25,
          16,
          12,
          11,
          10,
          9,
          8,
          8,
          7,
          7,
          7,
          7,
          6,
          6,
          6,
          6,
          6,
          6,
          6,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5
        ];
        var groupBases = [
          0,
          0,
          33554432,
          43046721,
          16777216,
          48828125,
          60466176,
          40353607,
          16777216,
          43046721,
          1e7,
          19487171,
          35831808,
          62748517,
          7529536,
          11390625,
          16777216,
          24137569,
          34012224,
          47045881,
          64e6,
          4084101,
          5153632,
          6436343,
          7962624,
          9765625,
          11881376,
          14348907,
          17210368,
          20511149,
          243e5,
          28629151,
          33554432,
          39135393,
          45435424,
          52521875,
          60466176
        ];
        BN4.prototype.toString = function toString3(base, padding) {
          base = base || 10;
          padding = padding | 0 || 1;
          var out;
          if (base === 16 || base === "hex") {
            out = "";
            var off2 = 0;
            var carry = 0;
            for (var i = 0; i < this.length; i++) {
              var w2 = this.words[i];
              var word = ((w2 << off2 | carry) & 16777215).toString(16);
              carry = w2 >>> 24 - off2 & 16777215;
              off2 += 2;
              if (off2 >= 26) {
                off2 -= 26;
                i--;
              }
              if (carry !== 0 || i !== this.length - 1) {
                out = zeros[6 - word.length] + word + out;
              } else {
                out = word + out;
              }
            }
            if (carry !== 0) {
              out = carry.toString(16) + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          if (base === (base | 0) && base >= 2 && base <= 36) {
            var groupSize = groupSizes[base];
            var groupBase = groupBases[base];
            out = "";
            var c2 = this.clone();
            c2.negative = 0;
            while (!c2.isZero()) {
              var r = c2.modrn(groupBase).toString(base);
              c2 = c2.idivn(groupBase);
              if (!c2.isZero()) {
                out = zeros[groupSize - r.length] + r + out;
              } else {
                out = r + out;
              }
            }
            if (this.isZero()) {
              out = "0" + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          assert7(false, "Base should be between 2 and 36");
        };
        BN4.prototype.toNumber = function toNumber() {
          var ret = this.words[0];
          if (this.length === 2) {
            ret += this.words[1] * 67108864;
          } else if (this.length === 3 && this.words[2] === 1) {
            ret += 4503599627370496 + this.words[1] * 67108864;
          } else if (this.length > 2) {
            assert7(false, "Number can only safely store up to 53 bits");
          }
          return this.negative !== 0 ? -ret : ret;
        };
        BN4.prototype.toJSON = function toJSON2() {
          return this.toString(16, 2);
        };
        if (Buffer3) {
          BN4.prototype.toBuffer = function toBuffer2(endian, length) {
            return this.toArrayLike(Buffer3, endian, length);
          };
        }
        BN4.prototype.toArray = function toArray(endian, length) {
          return this.toArrayLike(Array, endian, length);
        };
        var allocate = function allocate2(ArrayType, size) {
          if (ArrayType.allocUnsafe) {
            return ArrayType.allocUnsafe(size);
          }
          return new ArrayType(size);
        };
        BN4.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
          this._strip();
          var byteLength3 = this.byteLength();
          var reqLength = length || Math.max(1, byteLength3);
          assert7(byteLength3 <= reqLength, "byte array longer than desired length");
          assert7(reqLength > 0, "Requested array length <= 0");
          var res = allocate(ArrayType, reqLength);
          var postfix = endian === "le" ? "LE" : "BE";
          this["_toArrayLike" + postfix](res, byteLength3);
          return res;
        };
        BN4.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength3) {
          var position = 0;
          var carry = 0;
          for (var i = 0, shift = 0; i < this.length; i++) {
            var word = this.words[i] << shift | carry;
            res[position++] = word & 255;
            if (position < res.length) {
              res[position++] = word >> 8 & 255;
            }
            if (position < res.length) {
              res[position++] = word >> 16 & 255;
            }
            if (shift === 6) {
              if (position < res.length) {
                res[position++] = word >> 24 & 255;
              }
              carry = 0;
              shift = 0;
            } else {
              carry = word >>> 24;
              shift += 2;
            }
          }
          if (position < res.length) {
            res[position++] = carry;
            while (position < res.length) {
              res[position++] = 0;
            }
          }
        };
        BN4.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength3) {
          var position = res.length - 1;
          var carry = 0;
          for (var i = 0, shift = 0; i < this.length; i++) {
            var word = this.words[i] << shift | carry;
            res[position--] = word & 255;
            if (position >= 0) {
              res[position--] = word >> 8 & 255;
            }
            if (position >= 0) {
              res[position--] = word >> 16 & 255;
            }
            if (shift === 6) {
              if (position >= 0) {
                res[position--] = word >> 24 & 255;
              }
              carry = 0;
              shift = 0;
            } else {
              carry = word >>> 24;
              shift += 2;
            }
          }
          if (position >= 0) {
            res[position--] = carry;
            while (position >= 0) {
              res[position--] = 0;
            }
          }
        };
        if (Math.clz32) {
          BN4.prototype._countBits = function _countBits(w2) {
            return 32 - Math.clz32(w2);
          };
        } else {
          BN4.prototype._countBits = function _countBits(w2) {
            var t2 = w2;
            var r = 0;
            if (t2 >= 4096) {
              r += 13;
              t2 >>>= 13;
            }
            if (t2 >= 64) {
              r += 7;
              t2 >>>= 7;
            }
            if (t2 >= 8) {
              r += 4;
              t2 >>>= 4;
            }
            if (t2 >= 2) {
              r += 2;
              t2 >>>= 2;
            }
            return r + t2;
          };
        }
        BN4.prototype._zeroBits = function _zeroBits(w2) {
          if (w2 === 0)
            return 26;
          var t2 = w2;
          var r = 0;
          if ((t2 & 8191) === 0) {
            r += 13;
            t2 >>>= 13;
          }
          if ((t2 & 127) === 0) {
            r += 7;
            t2 >>>= 7;
          }
          if ((t2 & 15) === 0) {
            r += 4;
            t2 >>>= 4;
          }
          if ((t2 & 3) === 0) {
            r += 2;
            t2 >>>= 2;
          }
          if ((t2 & 1) === 0) {
            r++;
          }
          return r;
        };
        BN4.prototype.bitLength = function bitLength() {
          var w2 = this.words[this.length - 1];
          var hi = this._countBits(w2);
          return (this.length - 1) * 26 + hi;
        };
        function toBitArray(num) {
          var w2 = new Array(num.bitLength());
          for (var bit = 0; bit < w2.length; bit++) {
            var off2 = bit / 26 | 0;
            var wbit = bit % 26;
            w2[bit] = num.words[off2] >>> wbit & 1;
          }
          return w2;
        }
        BN4.prototype.zeroBits = function zeroBits() {
          if (this.isZero())
            return 0;
          var r = 0;
          for (var i = 0; i < this.length; i++) {
            var b2 = this._zeroBits(this.words[i]);
            r += b2;
            if (b2 !== 26)
              break;
          }
          return r;
        };
        BN4.prototype.byteLength = function byteLength3() {
          return Math.ceil(this.bitLength() / 8);
        };
        BN4.prototype.toTwos = function toTwos(width) {
          if (this.negative !== 0) {
            return this.abs().inotn(width).iaddn(1);
          }
          return this.clone();
        };
        BN4.prototype.fromTwos = function fromTwos(width) {
          if (this.testn(width - 1)) {
            return this.notn(width).iaddn(1).ineg();
          }
          return this.clone();
        };
        BN4.prototype.isNeg = function isNeg() {
          return this.negative !== 0;
        };
        BN4.prototype.neg = function neg() {
          return this.clone().ineg();
        };
        BN4.prototype.ineg = function ineg() {
          if (!this.isZero()) {
            this.negative ^= 1;
          }
          return this;
        };
        BN4.prototype.iuor = function iuor(num) {
          while (this.length < num.length) {
            this.words[this.length++] = 0;
          }
          for (var i = 0; i < num.length; i++) {
            this.words[i] = this.words[i] | num.words[i];
          }
          return this._strip();
        };
        BN4.prototype.ior = function ior(num) {
          assert7((this.negative | num.negative) === 0);
          return this.iuor(num);
        };
        BN4.prototype.or = function or(num) {
          if (this.length > num.length)
            return this.clone().ior(num);
          return num.clone().ior(this);
        };
        BN4.prototype.uor = function uor(num) {
          if (this.length > num.length)
            return this.clone().iuor(num);
          return num.clone().iuor(this);
        };
        BN4.prototype.iuand = function iuand(num) {
          var b2;
          if (this.length > num.length) {
            b2 = num;
          } else {
            b2 = this;
          }
          for (var i = 0; i < b2.length; i++) {
            this.words[i] = this.words[i] & num.words[i];
          }
          this.length = b2.length;
          return this._strip();
        };
        BN4.prototype.iand = function iand(num) {
          assert7((this.negative | num.negative) === 0);
          return this.iuand(num);
        };
        BN4.prototype.and = function and(num) {
          if (this.length > num.length)
            return this.clone().iand(num);
          return num.clone().iand(this);
        };
        BN4.prototype.uand = function uand(num) {
          if (this.length > num.length)
            return this.clone().iuand(num);
          return num.clone().iuand(this);
        };
        BN4.prototype.iuxor = function iuxor(num) {
          var a;
          var b2;
          if (this.length > num.length) {
            a = this;
            b2 = num;
          } else {
            a = num;
            b2 = this;
          }
          for (var i = 0; i < b2.length; i++) {
            this.words[i] = a.words[i] ^ b2.words[i];
          }
          if (this !== a) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = a.length;
          return this._strip();
        };
        BN4.prototype.ixor = function ixor(num) {
          assert7((this.negative | num.negative) === 0);
          return this.iuxor(num);
        };
        BN4.prototype.xor = function xor(num) {
          if (this.length > num.length)
            return this.clone().ixor(num);
          return num.clone().ixor(this);
        };
        BN4.prototype.uxor = function uxor(num) {
          if (this.length > num.length)
            return this.clone().iuxor(num);
          return num.clone().iuxor(this);
        };
        BN4.prototype.inotn = function inotn(width) {
          assert7(typeof width === "number" && width >= 0);
          var bytesNeeded = Math.ceil(width / 26) | 0;
          var bitsLeft = width % 26;
          this._expand(bytesNeeded);
          if (bitsLeft > 0) {
            bytesNeeded--;
          }
          for (var i = 0; i < bytesNeeded; i++) {
            this.words[i] = ~this.words[i] & 67108863;
          }
          if (bitsLeft > 0) {
            this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
          }
          return this._strip();
        };
        BN4.prototype.notn = function notn(width) {
          return this.clone().inotn(width);
        };
        BN4.prototype.setn = function setn(bit, val) {
          assert7(typeof bit === "number" && bit >= 0);
          var off2 = bit / 26 | 0;
          var wbit = bit % 26;
          this._expand(off2 + 1);
          if (val) {
            this.words[off2] = this.words[off2] | 1 << wbit;
          } else {
            this.words[off2] = this.words[off2] & ~(1 << wbit);
          }
          return this._strip();
        };
        BN4.prototype.iadd = function iadd(num) {
          var r;
          if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
          } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r = this.isub(num);
            num.negative = 1;
            return r._normSign();
          }
          var a, b2;
          if (this.length > num.length) {
            a = this;
            b2 = num;
          } else {
            a = num;
            b2 = this;
          }
          var carry = 0;
          for (var i = 0; i < b2.length; i++) {
            r = (a.words[i] | 0) + (b2.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          this.length = a.length;
          if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
          } else if (a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          return this;
        };
        BN4.prototype.add = function add2(num) {
          var res;
          if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
          } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
          }
          if (this.length > num.length)
            return this.clone().iadd(num);
          return num.clone().iadd(this);
        };
        BN4.prototype.isub = function isub(num) {
          if (num.negative !== 0) {
            num.negative = 0;
            var r = this.iadd(num);
            num.negative = 1;
            return r._normSign();
          } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
          }
          var cmp = this.cmp(num);
          if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
          }
          var a, b2;
          if (cmp > 0) {
            a = this;
            b2 = num;
          } else {
            a = num;
            b2 = this;
          }
          var carry = 0;
          for (var i = 0; i < b2.length; i++) {
            r = (a.words[i] | 0) - (b2.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          if (carry === 0 && i < a.length && a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = Math.max(this.length, i);
          if (a !== this) {
            this.negative = 1;
          }
          return this._strip();
        };
        BN4.prototype.sub = function sub(num) {
          return this.clone().isub(num);
        };
        function smallMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          var len = self2.length + num.length | 0;
          out.length = len;
          len = len - 1 | 0;
          var a = self2.words[0] | 0;
          var b2 = num.words[0] | 0;
          var r = a * b2;
          var lo = r & 67108863;
          var carry = r / 67108864 | 0;
          out.words[0] = lo;
          for (var k2 = 1; k2 < len; k2++) {
            var ncarry = carry >>> 26;
            var rword = carry & 67108863;
            var maxJ = Math.min(k2, num.length - 1);
            for (var j2 = Math.max(0, k2 - self2.length + 1); j2 <= maxJ; j2++) {
              var i = k2 - j2 | 0;
              a = self2.words[i] | 0;
              b2 = num.words[j2] | 0;
              r = a * b2 + rword;
              ncarry += r / 67108864 | 0;
              rword = r & 67108863;
            }
            out.words[k2] = rword | 0;
            carry = ncarry | 0;
          }
          if (carry !== 0) {
            out.words[k2] = carry | 0;
          } else {
            out.length--;
          }
          return out._strip();
        }
        var comb10MulTo = function comb10MulTo2(self2, num, out) {
          var a = self2.words;
          var b2 = num.words;
          var o = out.words;
          var c2 = 0;
          var lo;
          var mid;
          var hi;
          var a0 = a[0] | 0;
          var al0 = a0 & 8191;
          var ah0 = a0 >>> 13;
          var a1 = a[1] | 0;
          var al1 = a1 & 8191;
          var ah1 = a1 >>> 13;
          var a2 = a[2] | 0;
          var al2 = a2 & 8191;
          var ah2 = a2 >>> 13;
          var a3 = a[3] | 0;
          var al3 = a3 & 8191;
          var ah3 = a3 >>> 13;
          var a4 = a[4] | 0;
          var al4 = a4 & 8191;
          var ah4 = a4 >>> 13;
          var a5 = a[5] | 0;
          var al5 = a5 & 8191;
          var ah5 = a5 >>> 13;
          var a6 = a[6] | 0;
          var al6 = a6 & 8191;
          var ah6 = a6 >>> 13;
          var a7 = a[7] | 0;
          var al7 = a7 & 8191;
          var ah7 = a7 >>> 13;
          var a8 = a[8] | 0;
          var al8 = a8 & 8191;
          var ah8 = a8 >>> 13;
          var a9 = a[9] | 0;
          var al9 = a9 & 8191;
          var ah9 = a9 >>> 13;
          var b0 = b2[0] | 0;
          var bl0 = b0 & 8191;
          var bh0 = b0 >>> 13;
          var b1 = b2[1] | 0;
          var bl1 = b1 & 8191;
          var bh1 = b1 >>> 13;
          var b22 = b2[2] | 0;
          var bl2 = b22 & 8191;
          var bh2 = b22 >>> 13;
          var b3 = b2[3] | 0;
          var bl3 = b3 & 8191;
          var bh3 = b3 >>> 13;
          var b4 = b2[4] | 0;
          var bl4 = b4 & 8191;
          var bh4 = b4 >>> 13;
          var b5 = b2[5] | 0;
          var bl5 = b5 & 8191;
          var bh5 = b5 >>> 13;
          var b6 = b2[6] | 0;
          var bl6 = b6 & 8191;
          var bh6 = b6 >>> 13;
          var b7 = b2[7] | 0;
          var bl7 = b7 & 8191;
          var bh7 = b7 >>> 13;
          var b8 = b2[8] | 0;
          var bl8 = b8 & 8191;
          var bh8 = b8 >>> 13;
          var b9 = b2[9] | 0;
          var bl9 = b9 & 8191;
          var bh9 = b9 >>> 13;
          out.negative = self2.negative ^ num.negative;
          out.length = 19;
          lo = Math.imul(al0, bl0);
          mid = Math.imul(al0, bh0);
          mid = mid + Math.imul(ah0, bl0) | 0;
          hi = Math.imul(ah0, bh0);
          var w0 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
          w0 &= 67108863;
          lo = Math.imul(al1, bl0);
          mid = Math.imul(al1, bh0);
          mid = mid + Math.imul(ah1, bl0) | 0;
          hi = Math.imul(ah1, bh0);
          lo = lo + Math.imul(al0, bl1) | 0;
          mid = mid + Math.imul(al0, bh1) | 0;
          mid = mid + Math.imul(ah0, bl1) | 0;
          hi = hi + Math.imul(ah0, bh1) | 0;
          var w1 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
          w1 &= 67108863;
          lo = Math.imul(al2, bl0);
          mid = Math.imul(al2, bh0);
          mid = mid + Math.imul(ah2, bl0) | 0;
          hi = Math.imul(ah2, bh0);
          lo = lo + Math.imul(al1, bl1) | 0;
          mid = mid + Math.imul(al1, bh1) | 0;
          mid = mid + Math.imul(ah1, bl1) | 0;
          hi = hi + Math.imul(ah1, bh1) | 0;
          lo = lo + Math.imul(al0, bl2) | 0;
          mid = mid + Math.imul(al0, bh2) | 0;
          mid = mid + Math.imul(ah0, bl2) | 0;
          hi = hi + Math.imul(ah0, bh2) | 0;
          var w2 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
          w2 &= 67108863;
          lo = Math.imul(al3, bl0);
          mid = Math.imul(al3, bh0);
          mid = mid + Math.imul(ah3, bl0) | 0;
          hi = Math.imul(ah3, bh0);
          lo = lo + Math.imul(al2, bl1) | 0;
          mid = mid + Math.imul(al2, bh1) | 0;
          mid = mid + Math.imul(ah2, bl1) | 0;
          hi = hi + Math.imul(ah2, bh1) | 0;
          lo = lo + Math.imul(al1, bl2) | 0;
          mid = mid + Math.imul(al1, bh2) | 0;
          mid = mid + Math.imul(ah1, bl2) | 0;
          hi = hi + Math.imul(ah1, bh2) | 0;
          lo = lo + Math.imul(al0, bl3) | 0;
          mid = mid + Math.imul(al0, bh3) | 0;
          mid = mid + Math.imul(ah0, bl3) | 0;
          hi = hi + Math.imul(ah0, bh3) | 0;
          var w3 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
          w3 &= 67108863;
          lo = Math.imul(al4, bl0);
          mid = Math.imul(al4, bh0);
          mid = mid + Math.imul(ah4, bl0) | 0;
          hi = Math.imul(ah4, bh0);
          lo = lo + Math.imul(al3, bl1) | 0;
          mid = mid + Math.imul(al3, bh1) | 0;
          mid = mid + Math.imul(ah3, bl1) | 0;
          hi = hi + Math.imul(ah3, bh1) | 0;
          lo = lo + Math.imul(al2, bl2) | 0;
          mid = mid + Math.imul(al2, bh2) | 0;
          mid = mid + Math.imul(ah2, bl2) | 0;
          hi = hi + Math.imul(ah2, bh2) | 0;
          lo = lo + Math.imul(al1, bl3) | 0;
          mid = mid + Math.imul(al1, bh3) | 0;
          mid = mid + Math.imul(ah1, bl3) | 0;
          hi = hi + Math.imul(ah1, bh3) | 0;
          lo = lo + Math.imul(al0, bl4) | 0;
          mid = mid + Math.imul(al0, bh4) | 0;
          mid = mid + Math.imul(ah0, bl4) | 0;
          hi = hi + Math.imul(ah0, bh4) | 0;
          var w4 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
          w4 &= 67108863;
          lo = Math.imul(al5, bl0);
          mid = Math.imul(al5, bh0);
          mid = mid + Math.imul(ah5, bl0) | 0;
          hi = Math.imul(ah5, bh0);
          lo = lo + Math.imul(al4, bl1) | 0;
          mid = mid + Math.imul(al4, bh1) | 0;
          mid = mid + Math.imul(ah4, bl1) | 0;
          hi = hi + Math.imul(ah4, bh1) | 0;
          lo = lo + Math.imul(al3, bl2) | 0;
          mid = mid + Math.imul(al3, bh2) | 0;
          mid = mid + Math.imul(ah3, bl2) | 0;
          hi = hi + Math.imul(ah3, bh2) | 0;
          lo = lo + Math.imul(al2, bl3) | 0;
          mid = mid + Math.imul(al2, bh3) | 0;
          mid = mid + Math.imul(ah2, bl3) | 0;
          hi = hi + Math.imul(ah2, bh3) | 0;
          lo = lo + Math.imul(al1, bl4) | 0;
          mid = mid + Math.imul(al1, bh4) | 0;
          mid = mid + Math.imul(ah1, bl4) | 0;
          hi = hi + Math.imul(ah1, bh4) | 0;
          lo = lo + Math.imul(al0, bl5) | 0;
          mid = mid + Math.imul(al0, bh5) | 0;
          mid = mid + Math.imul(ah0, bl5) | 0;
          hi = hi + Math.imul(ah0, bh5) | 0;
          var w5 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
          w5 &= 67108863;
          lo = Math.imul(al6, bl0);
          mid = Math.imul(al6, bh0);
          mid = mid + Math.imul(ah6, bl0) | 0;
          hi = Math.imul(ah6, bh0);
          lo = lo + Math.imul(al5, bl1) | 0;
          mid = mid + Math.imul(al5, bh1) | 0;
          mid = mid + Math.imul(ah5, bl1) | 0;
          hi = hi + Math.imul(ah5, bh1) | 0;
          lo = lo + Math.imul(al4, bl2) | 0;
          mid = mid + Math.imul(al4, bh2) | 0;
          mid = mid + Math.imul(ah4, bl2) | 0;
          hi = hi + Math.imul(ah4, bh2) | 0;
          lo = lo + Math.imul(al3, bl3) | 0;
          mid = mid + Math.imul(al3, bh3) | 0;
          mid = mid + Math.imul(ah3, bl3) | 0;
          hi = hi + Math.imul(ah3, bh3) | 0;
          lo = lo + Math.imul(al2, bl4) | 0;
          mid = mid + Math.imul(al2, bh4) | 0;
          mid = mid + Math.imul(ah2, bl4) | 0;
          hi = hi + Math.imul(ah2, bh4) | 0;
          lo = lo + Math.imul(al1, bl5) | 0;
          mid = mid + Math.imul(al1, bh5) | 0;
          mid = mid + Math.imul(ah1, bl5) | 0;
          hi = hi + Math.imul(ah1, bh5) | 0;
          lo = lo + Math.imul(al0, bl6) | 0;
          mid = mid + Math.imul(al0, bh6) | 0;
          mid = mid + Math.imul(ah0, bl6) | 0;
          hi = hi + Math.imul(ah0, bh6) | 0;
          var w6 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
          w6 &= 67108863;
          lo = Math.imul(al7, bl0);
          mid = Math.imul(al7, bh0);
          mid = mid + Math.imul(ah7, bl0) | 0;
          hi = Math.imul(ah7, bh0);
          lo = lo + Math.imul(al6, bl1) | 0;
          mid = mid + Math.imul(al6, bh1) | 0;
          mid = mid + Math.imul(ah6, bl1) | 0;
          hi = hi + Math.imul(ah6, bh1) | 0;
          lo = lo + Math.imul(al5, bl2) | 0;
          mid = mid + Math.imul(al5, bh2) | 0;
          mid = mid + Math.imul(ah5, bl2) | 0;
          hi = hi + Math.imul(ah5, bh2) | 0;
          lo = lo + Math.imul(al4, bl3) | 0;
          mid = mid + Math.imul(al4, bh3) | 0;
          mid = mid + Math.imul(ah4, bl3) | 0;
          hi = hi + Math.imul(ah4, bh3) | 0;
          lo = lo + Math.imul(al3, bl4) | 0;
          mid = mid + Math.imul(al3, bh4) | 0;
          mid = mid + Math.imul(ah3, bl4) | 0;
          hi = hi + Math.imul(ah3, bh4) | 0;
          lo = lo + Math.imul(al2, bl5) | 0;
          mid = mid + Math.imul(al2, bh5) | 0;
          mid = mid + Math.imul(ah2, bl5) | 0;
          hi = hi + Math.imul(ah2, bh5) | 0;
          lo = lo + Math.imul(al1, bl6) | 0;
          mid = mid + Math.imul(al1, bh6) | 0;
          mid = mid + Math.imul(ah1, bl6) | 0;
          hi = hi + Math.imul(ah1, bh6) | 0;
          lo = lo + Math.imul(al0, bl7) | 0;
          mid = mid + Math.imul(al0, bh7) | 0;
          mid = mid + Math.imul(ah0, bl7) | 0;
          hi = hi + Math.imul(ah0, bh7) | 0;
          var w7 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
          w7 &= 67108863;
          lo = Math.imul(al8, bl0);
          mid = Math.imul(al8, bh0);
          mid = mid + Math.imul(ah8, bl0) | 0;
          hi = Math.imul(ah8, bh0);
          lo = lo + Math.imul(al7, bl1) | 0;
          mid = mid + Math.imul(al7, bh1) | 0;
          mid = mid + Math.imul(ah7, bl1) | 0;
          hi = hi + Math.imul(ah7, bh1) | 0;
          lo = lo + Math.imul(al6, bl2) | 0;
          mid = mid + Math.imul(al6, bh2) | 0;
          mid = mid + Math.imul(ah6, bl2) | 0;
          hi = hi + Math.imul(ah6, bh2) | 0;
          lo = lo + Math.imul(al5, bl3) | 0;
          mid = mid + Math.imul(al5, bh3) | 0;
          mid = mid + Math.imul(ah5, bl3) | 0;
          hi = hi + Math.imul(ah5, bh3) | 0;
          lo = lo + Math.imul(al4, bl4) | 0;
          mid = mid + Math.imul(al4, bh4) | 0;
          mid = mid + Math.imul(ah4, bl4) | 0;
          hi = hi + Math.imul(ah4, bh4) | 0;
          lo = lo + Math.imul(al3, bl5) | 0;
          mid = mid + Math.imul(al3, bh5) | 0;
          mid = mid + Math.imul(ah3, bl5) | 0;
          hi = hi + Math.imul(ah3, bh5) | 0;
          lo = lo + Math.imul(al2, bl6) | 0;
          mid = mid + Math.imul(al2, bh6) | 0;
          mid = mid + Math.imul(ah2, bl6) | 0;
          hi = hi + Math.imul(ah2, bh6) | 0;
          lo = lo + Math.imul(al1, bl7) | 0;
          mid = mid + Math.imul(al1, bh7) | 0;
          mid = mid + Math.imul(ah1, bl7) | 0;
          hi = hi + Math.imul(ah1, bh7) | 0;
          lo = lo + Math.imul(al0, bl8) | 0;
          mid = mid + Math.imul(al0, bh8) | 0;
          mid = mid + Math.imul(ah0, bl8) | 0;
          hi = hi + Math.imul(ah0, bh8) | 0;
          var w8 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
          w8 &= 67108863;
          lo = Math.imul(al9, bl0);
          mid = Math.imul(al9, bh0);
          mid = mid + Math.imul(ah9, bl0) | 0;
          hi = Math.imul(ah9, bh0);
          lo = lo + Math.imul(al8, bl1) | 0;
          mid = mid + Math.imul(al8, bh1) | 0;
          mid = mid + Math.imul(ah8, bl1) | 0;
          hi = hi + Math.imul(ah8, bh1) | 0;
          lo = lo + Math.imul(al7, bl2) | 0;
          mid = mid + Math.imul(al7, bh2) | 0;
          mid = mid + Math.imul(ah7, bl2) | 0;
          hi = hi + Math.imul(ah7, bh2) | 0;
          lo = lo + Math.imul(al6, bl3) | 0;
          mid = mid + Math.imul(al6, bh3) | 0;
          mid = mid + Math.imul(ah6, bl3) | 0;
          hi = hi + Math.imul(ah6, bh3) | 0;
          lo = lo + Math.imul(al5, bl4) | 0;
          mid = mid + Math.imul(al5, bh4) | 0;
          mid = mid + Math.imul(ah5, bl4) | 0;
          hi = hi + Math.imul(ah5, bh4) | 0;
          lo = lo + Math.imul(al4, bl5) | 0;
          mid = mid + Math.imul(al4, bh5) | 0;
          mid = mid + Math.imul(ah4, bl5) | 0;
          hi = hi + Math.imul(ah4, bh5) | 0;
          lo = lo + Math.imul(al3, bl6) | 0;
          mid = mid + Math.imul(al3, bh6) | 0;
          mid = mid + Math.imul(ah3, bl6) | 0;
          hi = hi + Math.imul(ah3, bh6) | 0;
          lo = lo + Math.imul(al2, bl7) | 0;
          mid = mid + Math.imul(al2, bh7) | 0;
          mid = mid + Math.imul(ah2, bl7) | 0;
          hi = hi + Math.imul(ah2, bh7) | 0;
          lo = lo + Math.imul(al1, bl8) | 0;
          mid = mid + Math.imul(al1, bh8) | 0;
          mid = mid + Math.imul(ah1, bl8) | 0;
          hi = hi + Math.imul(ah1, bh8) | 0;
          lo = lo + Math.imul(al0, bl9) | 0;
          mid = mid + Math.imul(al0, bh9) | 0;
          mid = mid + Math.imul(ah0, bl9) | 0;
          hi = hi + Math.imul(ah0, bh9) | 0;
          var w9 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
          w9 &= 67108863;
          lo = Math.imul(al9, bl1);
          mid = Math.imul(al9, bh1);
          mid = mid + Math.imul(ah9, bl1) | 0;
          hi = Math.imul(ah9, bh1);
          lo = lo + Math.imul(al8, bl2) | 0;
          mid = mid + Math.imul(al8, bh2) | 0;
          mid = mid + Math.imul(ah8, bl2) | 0;
          hi = hi + Math.imul(ah8, bh2) | 0;
          lo = lo + Math.imul(al7, bl3) | 0;
          mid = mid + Math.imul(al7, bh3) | 0;
          mid = mid + Math.imul(ah7, bl3) | 0;
          hi = hi + Math.imul(ah7, bh3) | 0;
          lo = lo + Math.imul(al6, bl4) | 0;
          mid = mid + Math.imul(al6, bh4) | 0;
          mid = mid + Math.imul(ah6, bl4) | 0;
          hi = hi + Math.imul(ah6, bh4) | 0;
          lo = lo + Math.imul(al5, bl5) | 0;
          mid = mid + Math.imul(al5, bh5) | 0;
          mid = mid + Math.imul(ah5, bl5) | 0;
          hi = hi + Math.imul(ah5, bh5) | 0;
          lo = lo + Math.imul(al4, bl6) | 0;
          mid = mid + Math.imul(al4, bh6) | 0;
          mid = mid + Math.imul(ah4, bl6) | 0;
          hi = hi + Math.imul(ah4, bh6) | 0;
          lo = lo + Math.imul(al3, bl7) | 0;
          mid = mid + Math.imul(al3, bh7) | 0;
          mid = mid + Math.imul(ah3, bl7) | 0;
          hi = hi + Math.imul(ah3, bh7) | 0;
          lo = lo + Math.imul(al2, bl8) | 0;
          mid = mid + Math.imul(al2, bh8) | 0;
          mid = mid + Math.imul(ah2, bl8) | 0;
          hi = hi + Math.imul(ah2, bh8) | 0;
          lo = lo + Math.imul(al1, bl9) | 0;
          mid = mid + Math.imul(al1, bh9) | 0;
          mid = mid + Math.imul(ah1, bl9) | 0;
          hi = hi + Math.imul(ah1, bh9) | 0;
          var w10 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
          w10 &= 67108863;
          lo = Math.imul(al9, bl2);
          mid = Math.imul(al9, bh2);
          mid = mid + Math.imul(ah9, bl2) | 0;
          hi = Math.imul(ah9, bh2);
          lo = lo + Math.imul(al8, bl3) | 0;
          mid = mid + Math.imul(al8, bh3) | 0;
          mid = mid + Math.imul(ah8, bl3) | 0;
          hi = hi + Math.imul(ah8, bh3) | 0;
          lo = lo + Math.imul(al7, bl4) | 0;
          mid = mid + Math.imul(al7, bh4) | 0;
          mid = mid + Math.imul(ah7, bl4) | 0;
          hi = hi + Math.imul(ah7, bh4) | 0;
          lo = lo + Math.imul(al6, bl5) | 0;
          mid = mid + Math.imul(al6, bh5) | 0;
          mid = mid + Math.imul(ah6, bl5) | 0;
          hi = hi + Math.imul(ah6, bh5) | 0;
          lo = lo + Math.imul(al5, bl6) | 0;
          mid = mid + Math.imul(al5, bh6) | 0;
          mid = mid + Math.imul(ah5, bl6) | 0;
          hi = hi + Math.imul(ah5, bh6) | 0;
          lo = lo + Math.imul(al4, bl7) | 0;
          mid = mid + Math.imul(al4, bh7) | 0;
          mid = mid + Math.imul(ah4, bl7) | 0;
          hi = hi + Math.imul(ah4, bh7) | 0;
          lo = lo + Math.imul(al3, bl8) | 0;
          mid = mid + Math.imul(al3, bh8) | 0;
          mid = mid + Math.imul(ah3, bl8) | 0;
          hi = hi + Math.imul(ah3, bh8) | 0;
          lo = lo + Math.imul(al2, bl9) | 0;
          mid = mid + Math.imul(al2, bh9) | 0;
          mid = mid + Math.imul(ah2, bl9) | 0;
          hi = hi + Math.imul(ah2, bh9) | 0;
          var w11 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
          w11 &= 67108863;
          lo = Math.imul(al9, bl3);
          mid = Math.imul(al9, bh3);
          mid = mid + Math.imul(ah9, bl3) | 0;
          hi = Math.imul(ah9, bh3);
          lo = lo + Math.imul(al8, bl4) | 0;
          mid = mid + Math.imul(al8, bh4) | 0;
          mid = mid + Math.imul(ah8, bl4) | 0;
          hi = hi + Math.imul(ah8, bh4) | 0;
          lo = lo + Math.imul(al7, bl5) | 0;
          mid = mid + Math.imul(al7, bh5) | 0;
          mid = mid + Math.imul(ah7, bl5) | 0;
          hi = hi + Math.imul(ah7, bh5) | 0;
          lo = lo + Math.imul(al6, bl6) | 0;
          mid = mid + Math.imul(al6, bh6) | 0;
          mid = mid + Math.imul(ah6, bl6) | 0;
          hi = hi + Math.imul(ah6, bh6) | 0;
          lo = lo + Math.imul(al5, bl7) | 0;
          mid = mid + Math.imul(al5, bh7) | 0;
          mid = mid + Math.imul(ah5, bl7) | 0;
          hi = hi + Math.imul(ah5, bh7) | 0;
          lo = lo + Math.imul(al4, bl8) | 0;
          mid = mid + Math.imul(al4, bh8) | 0;
          mid = mid + Math.imul(ah4, bl8) | 0;
          hi = hi + Math.imul(ah4, bh8) | 0;
          lo = lo + Math.imul(al3, bl9) | 0;
          mid = mid + Math.imul(al3, bh9) | 0;
          mid = mid + Math.imul(ah3, bl9) | 0;
          hi = hi + Math.imul(ah3, bh9) | 0;
          var w12 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
          w12 &= 67108863;
          lo = Math.imul(al9, bl4);
          mid = Math.imul(al9, bh4);
          mid = mid + Math.imul(ah9, bl4) | 0;
          hi = Math.imul(ah9, bh4);
          lo = lo + Math.imul(al8, bl5) | 0;
          mid = mid + Math.imul(al8, bh5) | 0;
          mid = mid + Math.imul(ah8, bl5) | 0;
          hi = hi + Math.imul(ah8, bh5) | 0;
          lo = lo + Math.imul(al7, bl6) | 0;
          mid = mid + Math.imul(al7, bh6) | 0;
          mid = mid + Math.imul(ah7, bl6) | 0;
          hi = hi + Math.imul(ah7, bh6) | 0;
          lo = lo + Math.imul(al6, bl7) | 0;
          mid = mid + Math.imul(al6, bh7) | 0;
          mid = mid + Math.imul(ah6, bl7) | 0;
          hi = hi + Math.imul(ah6, bh7) | 0;
          lo = lo + Math.imul(al5, bl8) | 0;
          mid = mid + Math.imul(al5, bh8) | 0;
          mid = mid + Math.imul(ah5, bl8) | 0;
          hi = hi + Math.imul(ah5, bh8) | 0;
          lo = lo + Math.imul(al4, bl9) | 0;
          mid = mid + Math.imul(al4, bh9) | 0;
          mid = mid + Math.imul(ah4, bl9) | 0;
          hi = hi + Math.imul(ah4, bh9) | 0;
          var w13 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
          w13 &= 67108863;
          lo = Math.imul(al9, bl5);
          mid = Math.imul(al9, bh5);
          mid = mid + Math.imul(ah9, bl5) | 0;
          hi = Math.imul(ah9, bh5);
          lo = lo + Math.imul(al8, bl6) | 0;
          mid = mid + Math.imul(al8, bh6) | 0;
          mid = mid + Math.imul(ah8, bl6) | 0;
          hi = hi + Math.imul(ah8, bh6) | 0;
          lo = lo + Math.imul(al7, bl7) | 0;
          mid = mid + Math.imul(al7, bh7) | 0;
          mid = mid + Math.imul(ah7, bl7) | 0;
          hi = hi + Math.imul(ah7, bh7) | 0;
          lo = lo + Math.imul(al6, bl8) | 0;
          mid = mid + Math.imul(al6, bh8) | 0;
          mid = mid + Math.imul(ah6, bl8) | 0;
          hi = hi + Math.imul(ah6, bh8) | 0;
          lo = lo + Math.imul(al5, bl9) | 0;
          mid = mid + Math.imul(al5, bh9) | 0;
          mid = mid + Math.imul(ah5, bl9) | 0;
          hi = hi + Math.imul(ah5, bh9) | 0;
          var w14 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
          w14 &= 67108863;
          lo = Math.imul(al9, bl6);
          mid = Math.imul(al9, bh6);
          mid = mid + Math.imul(ah9, bl6) | 0;
          hi = Math.imul(ah9, bh6);
          lo = lo + Math.imul(al8, bl7) | 0;
          mid = mid + Math.imul(al8, bh7) | 0;
          mid = mid + Math.imul(ah8, bl7) | 0;
          hi = hi + Math.imul(ah8, bh7) | 0;
          lo = lo + Math.imul(al7, bl8) | 0;
          mid = mid + Math.imul(al7, bh8) | 0;
          mid = mid + Math.imul(ah7, bl8) | 0;
          hi = hi + Math.imul(ah7, bh8) | 0;
          lo = lo + Math.imul(al6, bl9) | 0;
          mid = mid + Math.imul(al6, bh9) | 0;
          mid = mid + Math.imul(ah6, bl9) | 0;
          hi = hi + Math.imul(ah6, bh9) | 0;
          var w15 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
          w15 &= 67108863;
          lo = Math.imul(al9, bl7);
          mid = Math.imul(al9, bh7);
          mid = mid + Math.imul(ah9, bl7) | 0;
          hi = Math.imul(ah9, bh7);
          lo = lo + Math.imul(al8, bl8) | 0;
          mid = mid + Math.imul(al8, bh8) | 0;
          mid = mid + Math.imul(ah8, bl8) | 0;
          hi = hi + Math.imul(ah8, bh8) | 0;
          lo = lo + Math.imul(al7, bl9) | 0;
          mid = mid + Math.imul(al7, bh9) | 0;
          mid = mid + Math.imul(ah7, bl9) | 0;
          hi = hi + Math.imul(ah7, bh9) | 0;
          var w16 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
          w16 &= 67108863;
          lo = Math.imul(al9, bl8);
          mid = Math.imul(al9, bh8);
          mid = mid + Math.imul(ah9, bl8) | 0;
          hi = Math.imul(ah9, bh8);
          lo = lo + Math.imul(al8, bl9) | 0;
          mid = mid + Math.imul(al8, bh9) | 0;
          mid = mid + Math.imul(ah8, bl9) | 0;
          hi = hi + Math.imul(ah8, bh9) | 0;
          var w17 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
          w17 &= 67108863;
          lo = Math.imul(al9, bl9);
          mid = Math.imul(al9, bh9);
          mid = mid + Math.imul(ah9, bl9) | 0;
          hi = Math.imul(ah9, bh9);
          var w18 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
          w18 &= 67108863;
          o[0] = w0;
          o[1] = w1;
          o[2] = w2;
          o[3] = w3;
          o[4] = w4;
          o[5] = w5;
          o[6] = w6;
          o[7] = w7;
          o[8] = w8;
          o[9] = w9;
          o[10] = w10;
          o[11] = w11;
          o[12] = w12;
          o[13] = w13;
          o[14] = w14;
          o[15] = w15;
          o[16] = w16;
          o[17] = w17;
          o[18] = w18;
          if (c2 !== 0) {
            o[19] = c2;
            out.length++;
          }
          return out;
        };
        if (!Math.imul) {
          comb10MulTo = smallMulTo;
        }
        function bigMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          out.length = self2.length + num.length;
          var carry = 0;
          var hncarry = 0;
          for (var k2 = 0; k2 < out.length - 1; k2++) {
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 67108863;
            var maxJ = Math.min(k2, num.length - 1);
            for (var j2 = Math.max(0, k2 - self2.length + 1); j2 <= maxJ; j2++) {
              var i = k2 - j2;
              var a = self2.words[i] | 0;
              var b2 = num.words[j2] | 0;
              var r = a * b2;
              var lo = r & 67108863;
              ncarry = ncarry + (r / 67108864 | 0) | 0;
              lo = lo + rword | 0;
              rword = lo & 67108863;
              ncarry = ncarry + (lo >>> 26) | 0;
              hncarry += ncarry >>> 26;
              ncarry &= 67108863;
            }
            out.words[k2] = rword;
            carry = ncarry;
            ncarry = hncarry;
          }
          if (carry !== 0) {
            out.words[k2] = carry;
          } else {
            out.length--;
          }
          return out._strip();
        }
        function jumboMulTo(self2, num, out) {
          return bigMulTo(self2, num, out);
        }
        BN4.prototype.mulTo = function mulTo(num, out) {
          var res;
          var len = this.length + num.length;
          if (this.length === 10 && num.length === 10) {
            res = comb10MulTo(this, num, out);
          } else if (len < 63) {
            res = smallMulTo(this, num, out);
          } else if (len < 1024) {
            res = bigMulTo(this, num, out);
          } else {
            res = jumboMulTo(this, num, out);
          }
          return res;
        };
        function FFTM(x2, y2) {
          this.x = x2;
          this.y = y2;
        }
        FFTM.prototype.makeRBT = function makeRBT(N2) {
          var t2 = new Array(N2);
          var l2 = BN4.prototype._countBits(N2) - 1;
          for (var i = 0; i < N2; i++) {
            t2[i] = this.revBin(i, l2, N2);
          }
          return t2;
        };
        FFTM.prototype.revBin = function revBin(x2, l2, N2) {
          if (x2 === 0 || x2 === N2 - 1)
            return x2;
          var rb = 0;
          for (var i = 0; i < l2; i++) {
            rb |= (x2 & 1) << l2 - i - 1;
            x2 >>= 1;
          }
          return rb;
        };
        FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N2) {
          for (var i = 0; i < N2; i++) {
            rtws[i] = rws[rbt[i]];
            itws[i] = iws[rbt[i]];
          }
        };
        FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N2, rbt) {
          this.permute(rbt, rws, iws, rtws, itws, N2);
          for (var s = 1; s < N2; s <<= 1) {
            var l2 = s << 1;
            var rtwdf = Math.cos(2 * Math.PI / l2);
            var itwdf = Math.sin(2 * Math.PI / l2);
            for (var p2 = 0; p2 < N2; p2 += l2) {
              var rtwdf_ = rtwdf;
              var itwdf_ = itwdf;
              for (var j2 = 0; j2 < s; j2++) {
                var re2 = rtws[p2 + j2];
                var ie2 = itws[p2 + j2];
                var ro = rtws[p2 + j2 + s];
                var io = itws[p2 + j2 + s];
                var rx = rtwdf_ * ro - itwdf_ * io;
                io = rtwdf_ * io + itwdf_ * ro;
                ro = rx;
                rtws[p2 + j2] = re2 + ro;
                itws[p2 + j2] = ie2 + io;
                rtws[p2 + j2 + s] = re2 - ro;
                itws[p2 + j2 + s] = ie2 - io;
                if (j2 !== l2) {
                  rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                  itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                  rtwdf_ = rx;
                }
              }
            }
          }
        };
        FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
          var N2 = Math.max(m, n) | 1;
          var odd = N2 & 1;
          var i = 0;
          for (N2 = N2 / 2 | 0; N2; N2 = N2 >>> 1) {
            i++;
          }
          return 1 << i + 1 + odd;
        };
        FFTM.prototype.conjugate = function conjugate(rws, iws, N2) {
          if (N2 <= 1)
            return;
          for (var i = 0; i < N2 / 2; i++) {
            var t2 = rws[i];
            rws[i] = rws[N2 - i - 1];
            rws[N2 - i - 1] = t2;
            t2 = iws[i];
            iws[i] = -iws[N2 - i - 1];
            iws[N2 - i - 1] = -t2;
          }
        };
        FFTM.prototype.normalize13b = function normalize13b(ws, N2) {
          var carry = 0;
          for (var i = 0; i < N2 / 2; i++) {
            var w2 = Math.round(ws[2 * i + 1] / N2) * 8192 + Math.round(ws[2 * i] / N2) + carry;
            ws[i] = w2 & 67108863;
            if (w2 < 67108864) {
              carry = 0;
            } else {
              carry = w2 / 67108864 | 0;
            }
          }
          return ws;
        };
        FFTM.prototype.convert13b = function convert13b(ws, len, rws, N2) {
          var carry = 0;
          for (var i = 0; i < len; i++) {
            carry = carry + (ws[i] | 0);
            rws[2 * i] = carry & 8191;
            carry = carry >>> 13;
            rws[2 * i + 1] = carry & 8191;
            carry = carry >>> 13;
          }
          for (i = 2 * len; i < N2; ++i) {
            rws[i] = 0;
          }
          assert7(carry === 0);
          assert7((carry & ~8191) === 0);
        };
        FFTM.prototype.stub = function stub(N2) {
          var ph = new Array(N2);
          for (var i = 0; i < N2; i++) {
            ph[i] = 0;
          }
          return ph;
        };
        FFTM.prototype.mulp = function mulp(x2, y2, out) {
          var N2 = 2 * this.guessLen13b(x2.length, y2.length);
          var rbt = this.makeRBT(N2);
          var _2 = this.stub(N2);
          var rws = new Array(N2);
          var rwst = new Array(N2);
          var iwst = new Array(N2);
          var nrws = new Array(N2);
          var nrwst = new Array(N2);
          var niwst = new Array(N2);
          var rmws = out.words;
          rmws.length = N2;
          this.convert13b(x2.words, x2.length, rws, N2);
          this.convert13b(y2.words, y2.length, nrws, N2);
          this.transform(rws, _2, rwst, iwst, N2, rbt);
          this.transform(nrws, _2, nrwst, niwst, N2, rbt);
          for (var i = 0; i < N2; i++) {
            var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
            iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
            rwst[i] = rx;
          }
          this.conjugate(rwst, iwst, N2);
          this.transform(rwst, iwst, rmws, _2, N2, rbt);
          this.conjugate(rmws, _2, N2);
          this.normalize13b(rmws, N2);
          out.negative = x2.negative ^ y2.negative;
          out.length = x2.length + y2.length;
          return out._strip();
        };
        BN4.prototype.mul = function mul(num) {
          var out = new BN4(null);
          out.words = new Array(this.length + num.length);
          return this.mulTo(num, out);
        };
        BN4.prototype.mulf = function mulf(num) {
          var out = new BN4(null);
          out.words = new Array(this.length + num.length);
          return jumboMulTo(this, num, out);
        };
        BN4.prototype.imul = function imul(num) {
          return this.clone().mulTo(num, this);
        };
        BN4.prototype.imuln = function imuln(num) {
          var isNegNum = num < 0;
          if (isNegNum)
            num = -num;
          assert7(typeof num === "number");
          assert7(num < 67108864);
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w2 = (this.words[i] | 0) * num;
            var lo = (w2 & 67108863) + (carry & 67108863);
            carry >>= 26;
            carry += w2 / 67108864 | 0;
            carry += lo >>> 26;
            this.words[i] = lo & 67108863;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          return isNegNum ? this.ineg() : this;
        };
        BN4.prototype.muln = function muln(num) {
          return this.clone().imuln(num);
        };
        BN4.prototype.sqr = function sqr() {
          return this.mul(this);
        };
        BN4.prototype.isqr = function isqr() {
          return this.imul(this.clone());
        };
        BN4.prototype.pow = function pow3(num) {
          var w2 = toBitArray(num);
          if (w2.length === 0)
            return new BN4(1);
          var res = this;
          for (var i = 0; i < w2.length; i++, res = res.sqr()) {
            if (w2[i] !== 0)
              break;
          }
          if (++i < w2.length) {
            for (var q2 = res.sqr(); i < w2.length; i++, q2 = q2.sqr()) {
              if (w2[i] === 0)
                continue;
              res = res.mul(q2);
            }
          }
          return res;
        };
        BN4.prototype.iushln = function iushln(bits) {
          assert7(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          var carryMask = 67108863 >>> 26 - r << 26 - r;
          var i;
          if (r !== 0) {
            var carry = 0;
            for (i = 0; i < this.length; i++) {
              var newCarry = this.words[i] & carryMask;
              var c2 = (this.words[i] | 0) - newCarry << r;
              this.words[i] = c2 | carry;
              carry = newCarry >>> 26 - r;
            }
            if (carry) {
              this.words[i] = carry;
              this.length++;
            }
          }
          if (s !== 0) {
            for (i = this.length - 1; i >= 0; i--) {
              this.words[i + s] = this.words[i];
            }
            for (i = 0; i < s; i++) {
              this.words[i] = 0;
            }
            this.length += s;
          }
          return this._strip();
        };
        BN4.prototype.ishln = function ishln(bits) {
          assert7(this.negative === 0);
          return this.iushln(bits);
        };
        BN4.prototype.iushrn = function iushrn(bits, hint, extended) {
          assert7(typeof bits === "number" && bits >= 0);
          var h2;
          if (hint) {
            h2 = (hint - hint % 26) / 26;
          } else {
            h2 = 0;
          }
          var r = bits % 26;
          var s = Math.min((bits - r) / 26, this.length);
          var mask4 = 67108863 ^ 67108863 >>> r << r;
          var maskedWords = extended;
          h2 -= s;
          h2 = Math.max(0, h2);
          if (maskedWords) {
            for (var i = 0; i < s; i++) {
              maskedWords.words[i] = this.words[i];
            }
            maskedWords.length = s;
          }
          if (s === 0) {
          } else if (this.length > s) {
            this.length -= s;
            for (i = 0; i < this.length; i++) {
              this.words[i] = this.words[i + s];
            }
          } else {
            this.words[0] = 0;
            this.length = 1;
          }
          var carry = 0;
          for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h2); i--) {
            var word = this.words[i] | 0;
            this.words[i] = carry << 26 - r | word >>> r;
            carry = word & mask4;
          }
          if (maskedWords && carry !== 0) {
            maskedWords.words[maskedWords.length++] = carry;
          }
          if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
          }
          return this._strip();
        };
        BN4.prototype.ishrn = function ishrn(bits, hint, extended) {
          assert7(this.negative === 0);
          return this.iushrn(bits, hint, extended);
        };
        BN4.prototype.shln = function shln(bits) {
          return this.clone().ishln(bits);
        };
        BN4.prototype.ushln = function ushln(bits) {
          return this.clone().iushln(bits);
        };
        BN4.prototype.shrn = function shrn(bits) {
          return this.clone().ishrn(bits);
        };
        BN4.prototype.ushrn = function ushrn(bits) {
          return this.clone().iushrn(bits);
        };
        BN4.prototype.testn = function testn(bit) {
          assert7(typeof bit === "number" && bit >= 0);
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q2 = 1 << r;
          if (this.length <= s)
            return false;
          var w2 = this.words[s];
          return !!(w2 & q2);
        };
        BN4.prototype.imaskn = function imaskn(bits) {
          assert7(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          assert7(this.negative === 0, "imaskn works only with positive numbers");
          if (this.length <= s) {
            return this;
          }
          if (r !== 0) {
            s++;
          }
          this.length = Math.min(s, this.length);
          if (r !== 0) {
            var mask4 = 67108863 ^ 67108863 >>> r << r;
            this.words[this.length - 1] &= mask4;
          }
          return this._strip();
        };
        BN4.prototype.maskn = function maskn(bits) {
          return this.clone().imaskn(bits);
        };
        BN4.prototype.iaddn = function iaddn(num) {
          assert7(typeof num === "number");
          assert7(num < 67108864);
          if (num < 0)
            return this.isubn(-num);
          if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) <= num) {
              this.words[0] = num - (this.words[0] | 0);
              this.negative = 0;
              return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
          }
          return this._iaddn(num);
        };
        BN4.prototype._iaddn = function _iaddn(num) {
          this.words[0] += num;
          for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
            this.words[i] -= 67108864;
            if (i === this.length - 1) {
              this.words[i + 1] = 1;
            } else {
              this.words[i + 1]++;
            }
          }
          this.length = Math.max(this.length, i + 1);
          return this;
        };
        BN4.prototype.isubn = function isubn(num) {
          assert7(typeof num === "number");
          assert7(num < 67108864);
          if (num < 0)
            return this.iaddn(-num);
          if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
          }
          this.words[0] -= num;
          if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
          } else {
            for (var i = 0; i < this.length && this.words[i] < 0; i++) {
              this.words[i] += 67108864;
              this.words[i + 1] -= 1;
            }
          }
          return this._strip();
        };
        BN4.prototype.addn = function addn(num) {
          return this.clone().iaddn(num);
        };
        BN4.prototype.subn = function subn(num) {
          return this.clone().isubn(num);
        };
        BN4.prototype.iabs = function iabs() {
          this.negative = 0;
          return this;
        };
        BN4.prototype.abs = function abs() {
          return this.clone().iabs();
        };
        BN4.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
          var len = num.length + shift;
          var i;
          this._expand(len);
          var w2;
          var carry = 0;
          for (i = 0; i < num.length; i++) {
            w2 = (this.words[i + shift] | 0) + carry;
            var right = (num.words[i] | 0) * mul;
            w2 -= right & 67108863;
            carry = (w2 >> 26) - (right / 67108864 | 0);
            this.words[i + shift] = w2 & 67108863;
          }
          for (; i < this.length - shift; i++) {
            w2 = (this.words[i + shift] | 0) + carry;
            carry = w2 >> 26;
            this.words[i + shift] = w2 & 67108863;
          }
          if (carry === 0)
            return this._strip();
          assert7(carry === -1);
          carry = 0;
          for (i = 0; i < this.length; i++) {
            w2 = -(this.words[i] | 0) + carry;
            carry = w2 >> 26;
            this.words[i] = w2 & 67108863;
          }
          this.negative = 1;
          return this._strip();
        };
        BN4.prototype._wordDiv = function _wordDiv(num, mode) {
          var shift = this.length - num.length;
          var a = this.clone();
          var b2 = num;
          var bhi = b2.words[b2.length - 1] | 0;
          var bhiBits = this._countBits(bhi);
          shift = 26 - bhiBits;
          if (shift !== 0) {
            b2 = b2.ushln(shift);
            a.iushln(shift);
            bhi = b2.words[b2.length - 1] | 0;
          }
          var m = a.length - b2.length;
          var q2;
          if (mode !== "mod") {
            q2 = new BN4(null);
            q2.length = m + 1;
            q2.words = new Array(q2.length);
            for (var i = 0; i < q2.length; i++) {
              q2.words[i] = 0;
            }
          }
          var diff = a.clone()._ishlnsubmul(b2, 1, m);
          if (diff.negative === 0) {
            a = diff;
            if (q2) {
              q2.words[m] = 1;
            }
          }
          for (var j2 = m - 1; j2 >= 0; j2--) {
            var qj = (a.words[b2.length + j2] | 0) * 67108864 + (a.words[b2.length + j2 - 1] | 0);
            qj = Math.min(qj / bhi | 0, 67108863);
            a._ishlnsubmul(b2, qj, j2);
            while (a.negative !== 0) {
              qj--;
              a.negative = 0;
              a._ishlnsubmul(b2, 1, j2);
              if (!a.isZero()) {
                a.negative ^= 1;
              }
            }
            if (q2) {
              q2.words[j2] = qj;
            }
          }
          if (q2) {
            q2._strip();
          }
          a._strip();
          if (mode !== "div" && shift !== 0) {
            a.iushrn(shift);
          }
          return {
            div: q2 || null,
            mod: a
          };
        };
        BN4.prototype.divmod = function divmod(num, mode, positive) {
          assert7(!num.isZero());
          if (this.isZero()) {
            return {
              div: new BN4(0),
              mod: new BN4(0)
            };
          }
          var div, mod2, res;
          if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            if (mode !== "div") {
              mod2 = res.mod.neg();
              if (positive && mod2.negative !== 0) {
                mod2.iadd(num);
              }
            }
            return {
              div,
              mod: mod2
            };
          }
          if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            return {
              div,
              mod: res.mod
            };
          }
          if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
              mod2 = res.mod.neg();
              if (positive && mod2.negative !== 0) {
                mod2.isub(num);
              }
            }
            return {
              div: res.div,
              mod: mod2
            };
          }
          if (num.length > this.length || this.cmp(num) < 0) {
            return {
              div: new BN4(0),
              mod: this
            };
          }
          if (num.length === 1) {
            if (mode === "div") {
              return {
                div: this.divn(num.words[0]),
                mod: null
              };
            }
            if (mode === "mod") {
              return {
                div: null,
                mod: new BN4(this.modrn(num.words[0]))
              };
            }
            return {
              div: this.divn(num.words[0]),
              mod: new BN4(this.modrn(num.words[0]))
            };
          }
          return this._wordDiv(num, mode);
        };
        BN4.prototype.div = function div(num) {
          return this.divmod(num, "div", false).div;
        };
        BN4.prototype.mod = function mod2(num) {
          return this.divmod(num, "mod", false).mod;
        };
        BN4.prototype.umod = function umod(num) {
          return this.divmod(num, "mod", true).mod;
        };
        BN4.prototype.divRound = function divRound(num) {
          var dm = this.divmod(num);
          if (dm.mod.isZero())
            return dm.div;
          var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
          var half = num.ushrn(1);
          var r2 = num.andln(1);
          var cmp = mod2.cmp(half);
          if (cmp < 0 || r2 === 1 && cmp === 0)
            return dm.div;
          return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
        };
        BN4.prototype.modrn = function modrn(num) {
          var isNegNum = num < 0;
          if (isNegNum)
            num = -num;
          assert7(num <= 67108863);
          var p2 = (1 << 26) % num;
          var acc = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            acc = (p2 * acc + (this.words[i] | 0)) % num;
          }
          return isNegNum ? -acc : acc;
        };
        BN4.prototype.modn = function modn(num) {
          return this.modrn(num);
        };
        BN4.prototype.idivn = function idivn(num) {
          var isNegNum = num < 0;
          if (isNegNum)
            num = -num;
          assert7(num <= 67108863);
          var carry = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var w2 = (this.words[i] | 0) + carry * 67108864;
            this.words[i] = w2 / num | 0;
            carry = w2 % num;
          }
          this._strip();
          return isNegNum ? this.ineg() : this;
        };
        BN4.prototype.divn = function divn(num) {
          return this.clone().idivn(num);
        };
        BN4.prototype.egcd = function egcd(p2) {
          assert7(p2.negative === 0);
          assert7(!p2.isZero());
          var x2 = this;
          var y2 = p2.clone();
          if (x2.negative !== 0) {
            x2 = x2.umod(p2);
          } else {
            x2 = x2.clone();
          }
          var A2 = new BN4(1);
          var B2 = new BN4(0);
          var C2 = new BN4(0);
          var D2 = new BN4(1);
          var g2 = 0;
          while (x2.isEven() && y2.isEven()) {
            x2.iushrn(1);
            y2.iushrn(1);
            ++g2;
          }
          var yp = y2.clone();
          var xp = x2.clone();
          while (!x2.isZero()) {
            for (var i = 0, im = 1; (x2.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
              ;
            if (i > 0) {
              x2.iushrn(i);
              while (i-- > 0) {
                if (A2.isOdd() || B2.isOdd()) {
                  A2.iadd(yp);
                  B2.isub(xp);
                }
                A2.iushrn(1);
                B2.iushrn(1);
              }
            }
            for (var j2 = 0, jm = 1; (y2.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1)
              ;
            if (j2 > 0) {
              y2.iushrn(j2);
              while (j2-- > 0) {
                if (C2.isOdd() || D2.isOdd()) {
                  C2.iadd(yp);
                  D2.isub(xp);
                }
                C2.iushrn(1);
                D2.iushrn(1);
              }
            }
            if (x2.cmp(y2) >= 0) {
              x2.isub(y2);
              A2.isub(C2);
              B2.isub(D2);
            } else {
              y2.isub(x2);
              C2.isub(A2);
              D2.isub(B2);
            }
          }
          return {
            a: C2,
            b: D2,
            gcd: y2.iushln(g2)
          };
        };
        BN4.prototype._invmp = function _invmp(p2) {
          assert7(p2.negative === 0);
          assert7(!p2.isZero());
          var a = this;
          var b2 = p2.clone();
          if (a.negative !== 0) {
            a = a.umod(p2);
          } else {
            a = a.clone();
          }
          var x1 = new BN4(1);
          var x2 = new BN4(0);
          var delta = b2.clone();
          while (a.cmpn(1) > 0 && b2.cmpn(1) > 0) {
            for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
              ;
            if (i > 0) {
              a.iushrn(i);
              while (i-- > 0) {
                if (x1.isOdd()) {
                  x1.iadd(delta);
                }
                x1.iushrn(1);
              }
            }
            for (var j2 = 0, jm = 1; (b2.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1)
              ;
            if (j2 > 0) {
              b2.iushrn(j2);
              while (j2-- > 0) {
                if (x2.isOdd()) {
                  x2.iadd(delta);
                }
                x2.iushrn(1);
              }
            }
            if (a.cmp(b2) >= 0) {
              a.isub(b2);
              x1.isub(x2);
            } else {
              b2.isub(a);
              x2.isub(x1);
            }
          }
          var res;
          if (a.cmpn(1) === 0) {
            res = x1;
          } else {
            res = x2;
          }
          if (res.cmpn(0) < 0) {
            res.iadd(p2);
          }
          return res;
        };
        BN4.prototype.gcd = function gcd(num) {
          if (this.isZero())
            return num.abs();
          if (num.isZero())
            return this.abs();
          var a = this.clone();
          var b2 = num.clone();
          a.negative = 0;
          b2.negative = 0;
          for (var shift = 0; a.isEven() && b2.isEven(); shift++) {
            a.iushrn(1);
            b2.iushrn(1);
          }
          do {
            while (a.isEven()) {
              a.iushrn(1);
            }
            while (b2.isEven()) {
              b2.iushrn(1);
            }
            var r = a.cmp(b2);
            if (r < 0) {
              var t2 = a;
              a = b2;
              b2 = t2;
            } else if (r === 0 || b2.cmpn(1) === 0) {
              break;
            }
            a.isub(b2);
          } while (true);
          return b2.iushln(shift);
        };
        BN4.prototype.invm = function invm(num) {
          return this.egcd(num).a.umod(num);
        };
        BN4.prototype.isEven = function isEven() {
          return (this.words[0] & 1) === 0;
        };
        BN4.prototype.isOdd = function isOdd() {
          return (this.words[0] & 1) === 1;
        };
        BN4.prototype.andln = function andln(num) {
          return this.words[0] & num;
        };
        BN4.prototype.bincn = function bincn(bit) {
          assert7(typeof bit === "number");
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q2 = 1 << r;
          if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q2;
            return this;
          }
          var carry = q2;
          for (var i = s; carry !== 0 && i < this.length; i++) {
            var w2 = this.words[i] | 0;
            w2 += carry;
            carry = w2 >>> 26;
            w2 &= 67108863;
            this.words[i] = w2;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          return this;
        };
        BN4.prototype.isZero = function isZero() {
          return this.length === 1 && this.words[0] === 0;
        };
        BN4.prototype.cmpn = function cmpn(num) {
          var negative = num < 0;
          if (this.negative !== 0 && !negative)
            return -1;
          if (this.negative === 0 && negative)
            return 1;
          this._strip();
          var res;
          if (this.length > 1) {
            res = 1;
          } else {
            if (negative) {
              num = -num;
            }
            assert7(num <= 67108863, "Number is too big");
            var w2 = this.words[0] | 0;
            res = w2 === num ? 0 : w2 < num ? -1 : 1;
          }
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN4.prototype.cmp = function cmp(num) {
          if (this.negative !== 0 && num.negative === 0)
            return -1;
          if (this.negative === 0 && num.negative !== 0)
            return 1;
          var res = this.ucmp(num);
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN4.prototype.ucmp = function ucmp(num) {
          if (this.length > num.length)
            return 1;
          if (this.length < num.length)
            return -1;
          var res = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var a = this.words[i] | 0;
            var b2 = num.words[i] | 0;
            if (a === b2)
              continue;
            if (a < b2) {
              res = -1;
            } else if (a > b2) {
              res = 1;
            }
            break;
          }
          return res;
        };
        BN4.prototype.gtn = function gtn(num) {
          return this.cmpn(num) === 1;
        };
        BN4.prototype.gt = function gt2(num) {
          return this.cmp(num) === 1;
        };
        BN4.prototype.gten = function gten(num) {
          return this.cmpn(num) >= 0;
        };
        BN4.prototype.gte = function gte(num) {
          return this.cmp(num) >= 0;
        };
        BN4.prototype.ltn = function ltn(num) {
          return this.cmpn(num) === -1;
        };
        BN4.prototype.lt = function lt2(num) {
          return this.cmp(num) === -1;
        };
        BN4.prototype.lten = function lten(num) {
          return this.cmpn(num) <= 0;
        };
        BN4.prototype.lte = function lte(num) {
          return this.cmp(num) <= 0;
        };
        BN4.prototype.eqn = function eqn(num) {
          return this.cmpn(num) === 0;
        };
        BN4.prototype.eq = function eq(num) {
          return this.cmp(num) === 0;
        };
        BN4.red = function red2(num) {
          return new Red(num);
        };
        BN4.prototype.toRed = function toRed(ctx) {
          assert7(!this.red, "Already a number in reduction context");
          assert7(this.negative === 0, "red works only with positives");
          return ctx.convertTo(this)._forceRed(ctx);
        };
        BN4.prototype.fromRed = function fromRed() {
          assert7(this.red, "fromRed works only with numbers in reduction context");
          return this.red.convertFrom(this);
        };
        BN4.prototype._forceRed = function _forceRed(ctx) {
          this.red = ctx;
          return this;
        };
        BN4.prototype.forceRed = function forceRed(ctx) {
          assert7(!this.red, "Already a number in reduction context");
          return this._forceRed(ctx);
        };
        BN4.prototype.redAdd = function redAdd(num) {
          assert7(this.red, "redAdd works only with red numbers");
          return this.red.add(this, num);
        };
        BN4.prototype.redIAdd = function redIAdd(num) {
          assert7(this.red, "redIAdd works only with red numbers");
          return this.red.iadd(this, num);
        };
        BN4.prototype.redSub = function redSub(num) {
          assert7(this.red, "redSub works only with red numbers");
          return this.red.sub(this, num);
        };
        BN4.prototype.redISub = function redISub(num) {
          assert7(this.red, "redISub works only with red numbers");
          return this.red.isub(this, num);
        };
        BN4.prototype.redShl = function redShl(num) {
          assert7(this.red, "redShl works only with red numbers");
          return this.red.shl(this, num);
        };
        BN4.prototype.redMul = function redMul(num) {
          assert7(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.mul(this, num);
        };
        BN4.prototype.redIMul = function redIMul(num) {
          assert7(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.imul(this, num);
        };
        BN4.prototype.redSqr = function redSqr() {
          assert7(this.red, "redSqr works only with red numbers");
          this.red._verify1(this);
          return this.red.sqr(this);
        };
        BN4.prototype.redISqr = function redISqr() {
          assert7(this.red, "redISqr works only with red numbers");
          this.red._verify1(this);
          return this.red.isqr(this);
        };
        BN4.prototype.redSqrt = function redSqrt() {
          assert7(this.red, "redSqrt works only with red numbers");
          this.red._verify1(this);
          return this.red.sqrt(this);
        };
        BN4.prototype.redInvm = function redInvm() {
          assert7(this.red, "redInvm works only with red numbers");
          this.red._verify1(this);
          return this.red.invm(this);
        };
        BN4.prototype.redNeg = function redNeg() {
          assert7(this.red, "redNeg works only with red numbers");
          this.red._verify1(this);
          return this.red.neg(this);
        };
        BN4.prototype.redPow = function redPow(num) {
          assert7(this.red && !num.red, "redPow(normalNum)");
          this.red._verify1(this);
          return this.red.pow(this, num);
        };
        var primes = {
          k256: null,
          p224: null,
          p192: null,
          p25519: null
        };
        function MPrime(name2, p2) {
          this.name = name2;
          this.p = new BN4(p2, 16);
          this.n = this.p.bitLength();
          this.k = new BN4(1).iushln(this.n).isub(this.p);
          this.tmp = this._tmp();
        }
        MPrime.prototype._tmp = function _tmp() {
          var tmp = new BN4(null);
          tmp.words = new Array(Math.ceil(this.n / 13));
          return tmp;
        };
        MPrime.prototype.ireduce = function ireduce(num) {
          var r = num;
          var rlen;
          do {
            this.split(r, this.tmp);
            r = this.imulK(r);
            r = r.iadd(this.tmp);
            rlen = r.bitLength();
          } while (rlen > this.n);
          var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
          if (cmp === 0) {
            r.words[0] = 0;
            r.length = 1;
          } else if (cmp > 0) {
            r.isub(this.p);
          } else {
            if (r.strip !== void 0) {
              r.strip();
            } else {
              r._strip();
            }
          }
          return r;
        };
        MPrime.prototype.split = function split2(input, out) {
          input.iushrn(this.n, 0, out);
        };
        MPrime.prototype.imulK = function imulK(num) {
          return num.imul(this.k);
        };
        function K256() {
          MPrime.call(
            this,
            "k256",
            "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
          );
        }
        inherits2(K256, MPrime);
        K256.prototype.split = function split2(input, output2) {
          var mask4 = 4194303;
          var outLen = Math.min(input.length, 9);
          for (var i = 0; i < outLen; i++) {
            output2.words[i] = input.words[i];
          }
          output2.length = outLen;
          if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
          }
          var prev = input.words[9];
          output2.words[output2.length++] = prev & mask4;
          for (i = 10; i < input.length; i++) {
            var next = input.words[i] | 0;
            input.words[i - 10] = (next & mask4) << 4 | prev >>> 22;
            prev = next;
          }
          prev >>>= 22;
          input.words[i - 10] = prev;
          if (prev === 0 && input.length > 10) {
            input.length -= 10;
          } else {
            input.length -= 9;
          }
        };
        K256.prototype.imulK = function imulK(num) {
          num.words[num.length] = 0;
          num.words[num.length + 1] = 0;
          num.length += 2;
          var lo = 0;
          for (var i = 0; i < num.length; i++) {
            var w2 = num.words[i] | 0;
            lo += w2 * 977;
            num.words[i] = lo & 67108863;
            lo = w2 * 64 + (lo / 67108864 | 0);
          }
          if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) {
              num.length--;
            }
          }
          return num;
        };
        function P224() {
          MPrime.call(
            this,
            "p224",
            "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
          );
        }
        inherits2(P224, MPrime);
        function P192() {
          MPrime.call(
            this,
            "p192",
            "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
          );
        }
        inherits2(P192, MPrime);
        function P25519() {
          MPrime.call(
            this,
            "25519",
            "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
          );
        }
        inherits2(P25519, MPrime);
        P25519.prototype.imulK = function imulK(num) {
          var carry = 0;
          for (var i = 0; i < num.length; i++) {
            var hi = (num.words[i] | 0) * 19 + carry;
            var lo = hi & 67108863;
            hi >>>= 26;
            num.words[i] = lo;
            carry = hi;
          }
          if (carry !== 0) {
            num.words[num.length++] = carry;
          }
          return num;
        };
        BN4._prime = function prime(name2) {
          if (primes[name2])
            return primes[name2];
          var prime2;
          if (name2 === "k256") {
            prime2 = new K256();
          } else if (name2 === "p224") {
            prime2 = new P224();
          } else if (name2 === "p192") {
            prime2 = new P192();
          } else if (name2 === "p25519") {
            prime2 = new P25519();
          } else {
            throw new Error("Unknown prime " + name2);
          }
          primes[name2] = prime2;
          return prime2;
        };
        function Red(m) {
          if (typeof m === "string") {
            var prime = BN4._prime(m);
            this.m = prime.p;
            this.prime = prime;
          } else {
            assert7(m.gtn(1), "modulus must be greater than 1");
            this.m = m;
            this.prime = null;
          }
        }
        Red.prototype._verify1 = function _verify1(a) {
          assert7(a.negative === 0, "red works only with positives");
          assert7(a.red, "red works only with red numbers");
        };
        Red.prototype._verify2 = function _verify2(a, b2) {
          assert7((a.negative | b2.negative) === 0, "red works only with positives");
          assert7(
            a.red && a.red === b2.red,
            "red works only with red numbers"
          );
        };
        Red.prototype.imod = function imod(a) {
          if (this.prime)
            return this.prime.ireduce(a)._forceRed(this);
          move(a, a.umod(this.m)._forceRed(this));
          return a;
        };
        Red.prototype.neg = function neg(a) {
          if (a.isZero()) {
            return a.clone();
          }
          return this.m.sub(a)._forceRed(this);
        };
        Red.prototype.add = function add2(a, b2) {
          this._verify2(a, b2);
          var res = a.add(b2);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.iadd = function iadd(a, b2) {
          this._verify2(a, b2);
          var res = a.iadd(b2);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res;
        };
        Red.prototype.sub = function sub(a, b2) {
          this._verify2(a, b2);
          var res = a.sub(b2);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.isub = function isub(a, b2) {
          this._verify2(a, b2);
          var res = a.isub(b2);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res;
        };
        Red.prototype.shl = function shl(a, num) {
          this._verify1(a);
          return this.imod(a.ushln(num));
        };
        Red.prototype.imul = function imul(a, b2) {
          this._verify2(a, b2);
          return this.imod(a.imul(b2));
        };
        Red.prototype.mul = function mul(a, b2) {
          this._verify2(a, b2);
          return this.imod(a.mul(b2));
        };
        Red.prototype.isqr = function isqr(a) {
          return this.imul(a, a.clone());
        };
        Red.prototype.sqr = function sqr(a) {
          return this.mul(a, a);
        };
        Red.prototype.sqrt = function sqrt(a) {
          if (a.isZero())
            return a.clone();
          var mod3 = this.m.andln(3);
          assert7(mod3 % 2 === 1);
          if (mod3 === 3) {
            var pow3 = this.m.add(new BN4(1)).iushrn(2);
            return this.pow(a, pow3);
          }
          var q2 = this.m.subn(1);
          var s = 0;
          while (!q2.isZero() && q2.andln(1) === 0) {
            s++;
            q2.iushrn(1);
          }
          assert7(!q2.isZero());
          var one = new BN4(1).toRed(this);
          var nOne = one.redNeg();
          var lpow = this.m.subn(1).iushrn(1);
          var z2 = this.m.bitLength();
          z2 = new BN4(2 * z2 * z2).toRed(this);
          while (this.pow(z2, lpow).cmp(nOne) !== 0) {
            z2.redIAdd(nOne);
          }
          var c2 = this.pow(z2, q2);
          var r = this.pow(a, q2.addn(1).iushrn(1));
          var t2 = this.pow(a, q2);
          var m = s;
          while (t2.cmp(one) !== 0) {
            var tmp = t2;
            for (var i = 0; tmp.cmp(one) !== 0; i++) {
              tmp = tmp.redSqr();
            }
            assert7(i < m);
            var b2 = this.pow(c2, new BN4(1).iushln(m - i - 1));
            r = r.redMul(b2);
            c2 = b2.redSqr();
            t2 = t2.redMul(c2);
            m = i;
          }
          return r;
        };
        Red.prototype.invm = function invm(a) {
          var inv = a._invmp(this.m);
          if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
          } else {
            return this.imod(inv);
          }
        };
        Red.prototype.pow = function pow3(a, num) {
          if (num.isZero())
            return new BN4(1).toRed(this);
          if (num.cmpn(1) === 0)
            return a.clone();
          var windowSize = 4;
          var wnd = new Array(1 << windowSize);
          wnd[0] = new BN4(1).toRed(this);
          wnd[1] = a;
          for (var i = 2; i < wnd.length; i++) {
            wnd[i] = this.mul(wnd[i - 1], a);
          }
          var res = wnd[0];
          var current = 0;
          var currentLen = 0;
          var start = num.bitLength() % 26;
          if (start === 0) {
            start = 26;
          }
          for (i = num.length - 1; i >= 0; i--) {
            var word = num.words[i];
            for (var j2 = start - 1; j2 >= 0; j2--) {
              var bit = word >> j2 & 1;
              if (res !== wnd[0]) {
                res = this.sqr(res);
              }
              if (bit === 0 && current === 0) {
                currentLen = 0;
                continue;
              }
              current <<= 1;
              current |= bit;
              currentLen++;
              if (currentLen !== windowSize && (i !== 0 || j2 !== 0))
                continue;
              res = this.mul(res, wnd[current]);
              currentLen = 0;
              current = 0;
            }
            start = 26;
          }
          return res;
        };
        Red.prototype.convertTo = function convertTo(num) {
          var r = num.umod(this.m);
          return r === num ? r.clone() : r;
        };
        Red.prototype.convertFrom = function convertFrom(num) {
          var res = num.clone();
          res.red = null;
          return res;
        };
        BN4.mont = function mont(num) {
          return new Mont(num);
        };
        function Mont(m) {
          Red.call(this, m);
          this.shift = this.m.bitLength();
          if (this.shift % 26 !== 0) {
            this.shift += 26 - this.shift % 26;
          }
          this.r = new BN4(1).iushln(this.shift);
          this.r2 = this.imod(this.r.sqr());
          this.rinv = this.r._invmp(this.m);
          this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
          this.minv = this.minv.umod(this.r);
          this.minv = this.r.sub(this.minv);
        }
        inherits2(Mont, Red);
        Mont.prototype.convertTo = function convertTo(num) {
          return this.imod(num.ushln(this.shift));
        };
        Mont.prototype.convertFrom = function convertFrom(num) {
          var r = this.imod(num.mul(this.rinv));
          r.red = null;
          return r;
        };
        Mont.prototype.imul = function imul(a, b2) {
          if (a.isZero() || b2.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
          }
          var t2 = a.imul(b2);
          var c2 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u2 = t2.isub(c2).iushrn(this.shift);
          var res = u2;
          if (u2.cmp(this.m) >= 0) {
            res = u2.isub(this.m);
          } else if (u2.cmpn(0) < 0) {
            res = u2.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.mul = function mul(a, b2) {
          if (a.isZero() || b2.isZero())
            return new BN4(0)._forceRed(this);
          var t2 = a.mul(b2);
          var c2 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u2 = t2.isub(c2).iushrn(this.shift);
          var res = u2;
          if (u2.cmp(this.m) >= 0) {
            res = u2.isub(this.m);
          } else if (u2.cmpn(0) < 0) {
            res = u2.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.invm = function invm(a) {
          var res = this.imod(a._invmp(this.m).mul(this.r2));
          return res._forceRed(this);
        };
      })(typeof module2 === "undefined" || module2, exports2);
    }
  });

  // node_modules/safe-buffer/index.js
  var require_safe_buffer = __commonJS({
    "node_modules/safe-buffer/index.js"(exports2, module2) {
      init_virtual_process_polyfill();
      init_buffer();
      var buffer2 = require_buffer();
      var Buffer3 = buffer2.Buffer;
      function copyProps(src, dst) {
        for (var key in src) {
          dst[key] = src[key];
        }
      }
      if (Buffer3.from && Buffer3.alloc && Buffer3.allocUnsafe && Buffer3.allocUnsafeSlow) {
        module2.exports = buffer2;
      } else {
        copyProps(buffer2, exports2);
        exports2.Buffer = SafeBuffer;
      }
      function SafeBuffer(arg, encodingOrOffset, length) {
        return Buffer3(arg, encodingOrOffset, length);
      }
      SafeBuffer.prototype = Object.create(Buffer3.prototype);
      copyProps(Buffer3, SafeBuffer);
      SafeBuffer.from = function(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          throw new TypeError("Argument must not be a number");
        }
        return Buffer3(arg, encodingOrOffset, length);
      };
      SafeBuffer.alloc = function(size, fill2, encoding) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        var buf = Buffer3(size);
        if (fill2 !== void 0) {
          if (typeof encoding === "string") {
            buf.fill(fill2, encoding);
          } else {
            buf.fill(fill2);
          }
        } else {
          buf.fill(0);
        }
        return buf;
      };
      SafeBuffer.allocUnsafe = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return Buffer3(size);
      };
      SafeBuffer.allocUnsafeSlow = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return buffer2.SlowBuffer(size);
      };
    }
  });

  // node_modules/base-x/src/index.js
  var require_src = __commonJS({
    "node_modules/base-x/src/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var _Buffer = require_safe_buffer().Buffer;
      function base(ALPHABET) {
        if (ALPHABET.length >= 255) {
          throw new TypeError("Alphabet too long");
        }
        var BASE_MAP = new Uint8Array(256);
        for (var j2 = 0; j2 < BASE_MAP.length; j2++) {
          BASE_MAP[j2] = 255;
        }
        for (var i = 0; i < ALPHABET.length; i++) {
          var x2 = ALPHABET.charAt(i);
          var xc = x2.charCodeAt(0);
          if (BASE_MAP[xc] !== 255) {
            throw new TypeError(x2 + " is ambiguous");
          }
          BASE_MAP[xc] = i;
        }
        var BASE = ALPHABET.length;
        var LEADER = ALPHABET.charAt(0);
        var FACTOR = Math.log(BASE) / Math.log(256);
        var iFACTOR = Math.log(256) / Math.log(BASE);
        function encode(source) {
          if (Array.isArray(source) || source instanceof Uint8Array) {
            source = _Buffer.from(source);
          }
          if (!_Buffer.isBuffer(source)) {
            throw new TypeError("Expected Buffer");
          }
          if (source.length === 0) {
            return "";
          }
          var zeroes = 0;
          var length = 0;
          var pbegin = 0;
          var pend = source.length;
          while (pbegin !== pend && source[pbegin] === 0) {
            pbegin++;
            zeroes++;
          }
          var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
          var b58 = new Uint8Array(size);
          while (pbegin !== pend) {
            var carry = source[pbegin];
            var i2 = 0;
            for (var it1 = size - 1; (carry !== 0 || i2 < length) && it1 !== -1; it1--, i2++) {
              carry += 256 * b58[it1] >>> 0;
              b58[it1] = carry % BASE >>> 0;
              carry = carry / BASE >>> 0;
            }
            if (carry !== 0) {
              throw new Error("Non-zero carry");
            }
            length = i2;
            pbegin++;
          }
          var it2 = size - length;
          while (it2 !== size && b58[it2] === 0) {
            it2++;
          }
          var str3 = LEADER.repeat(zeroes);
          for (; it2 < size; ++it2) {
            str3 += ALPHABET.charAt(b58[it2]);
          }
          return str3;
        }
        function decodeUnsafe(source) {
          if (typeof source !== "string") {
            throw new TypeError("Expected String");
          }
          if (source.length === 0) {
            return _Buffer.alloc(0);
          }
          var psz = 0;
          var zeroes = 0;
          var length = 0;
          while (source[psz] === LEADER) {
            zeroes++;
            psz++;
          }
          var size = (source.length - psz) * FACTOR + 1 >>> 0;
          var b256 = new Uint8Array(size);
          while (source[psz]) {
            var carry = BASE_MAP[source.charCodeAt(psz)];
            if (carry === 255) {
              return;
            }
            var i2 = 0;
            for (var it3 = size - 1; (carry !== 0 || i2 < length) && it3 !== -1; it3--, i2++) {
              carry += BASE * b256[it3] >>> 0;
              b256[it3] = carry % 256 >>> 0;
              carry = carry / 256 >>> 0;
            }
            if (carry !== 0) {
              throw new Error("Non-zero carry");
            }
            length = i2;
            psz++;
          }
          var it4 = size - length;
          while (it4 !== size && b256[it4] === 0) {
            it4++;
          }
          var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
          vch.fill(0, 0, zeroes);
          var j3 = zeroes;
          while (it4 !== size) {
            vch[j3++] = b256[it4++];
          }
          return vch;
        }
        function decode2(string4) {
          var buffer2 = decodeUnsafe(string4);
          if (buffer2) {
            return buffer2;
          }
          throw new Error("Non-base" + BASE + " character");
        }
        return {
          encode,
          decodeUnsafe,
          decode: decode2
        };
      }
      module2.exports = base;
    }
  });

  // node_modules/bs58/index.js
  var require_bs58 = __commonJS({
    "node_modules/bs58/index.js"(exports2, module2) {
      init_virtual_process_polyfill();
      init_buffer();
      var basex = require_src();
      var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
      module2.exports = basex(ALPHABET);
    }
  });

  // node_modules/@noble/hashes/esm/sha256.js
  var Chi, Maj, SHA256_K, IV, SHA256_W, SHA256, SHA224, sha256, sha224;
  var init_sha256 = __esm({
    "node_modules/@noble/hashes/esm/sha256.js"() {
      init_virtual_process_polyfill();
      init_buffer();
      init_sha2();
      init_utils();
      Chi = (a, b2, c2) => a & b2 ^ ~a & c2;
      Maj = (a, b2, c2) => a & b2 ^ a & c2 ^ b2 & c2;
      SHA256_K = new Uint32Array([
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ]);
      IV = new Uint32Array([
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ]);
      SHA256_W = new Uint32Array(64);
      SHA256 = class extends SHA2 {
        constructor() {
          super(64, 32, 8, false);
          this.A = IV[0] | 0;
          this.B = IV[1] | 0;
          this.C = IV[2] | 0;
          this.D = IV[3] | 0;
          this.E = IV[4] | 0;
          this.F = IV[5] | 0;
          this.G = IV[6] | 0;
          this.H = IV[7] | 0;
        }
        get() {
          const { A: A2, B: B2, C: C2, D: D2, E: E2, F: F2, G: G2, H: H2 } = this;
          return [A2, B2, C2, D2, E2, F2, G2, H2];
        }
        set(A2, B2, C2, D2, E2, F2, G2, H2) {
          this.A = A2 | 0;
          this.B = B2 | 0;
          this.C = C2 | 0;
          this.D = D2 | 0;
          this.E = E2 | 0;
          this.F = F2 | 0;
          this.G = G2 | 0;
          this.H = H2 | 0;
        }
        process(view, offset3) {
          for (let i = 0; i < 16; i++, offset3 += 4)
            SHA256_W[i] = view.getUint32(offset3, false);
          for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
            const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
            SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
          }
          let { A: A2, B: B2, C: C2, D: D2, E: E2, F: F2, G: G2, H: H2 } = this;
          for (let i = 0; i < 64; i++) {
            const sigma1 = rotr(E2, 6) ^ rotr(E2, 11) ^ rotr(E2, 25);
            const T1 = H2 + sigma1 + Chi(E2, F2, G2) + SHA256_K[i] + SHA256_W[i] | 0;
            const sigma0 = rotr(A2, 2) ^ rotr(A2, 13) ^ rotr(A2, 22);
            const T2 = sigma0 + Maj(A2, B2, C2) | 0;
            H2 = G2;
            G2 = F2;
            F2 = E2;
            E2 = D2 + T1 | 0;
            D2 = C2;
            C2 = B2;
            B2 = A2;
            A2 = T1 + T2 | 0;
          }
          A2 = A2 + this.A | 0;
          B2 = B2 + this.B | 0;
          C2 = C2 + this.C | 0;
          D2 = D2 + this.D | 0;
          E2 = E2 + this.E | 0;
          F2 = F2 + this.F | 0;
          G2 = G2 + this.G | 0;
          H2 = H2 + this.H | 0;
          this.set(A2, B2, C2, D2, E2, F2, G2, H2);
        }
        roundClean() {
          SHA256_W.fill(0);
        }
        destroy() {
          this.set(0, 0, 0, 0, 0, 0, 0, 0);
          this.buffer.fill(0);
        }
      };
      SHA224 = class extends SHA256 {
        constructor() {
          super();
          this.A = 3238371032 | 0;
          this.B = 914150663 | 0;
          this.C = 812702999 | 0;
          this.D = 4144912697 | 0;
          this.E = 4290775857 | 0;
          this.F = 1750603025 | 0;
          this.G = 1694076839 | 0;
          this.H = 3204075428 | 0;
          this.outputLen = 28;
        }
      };
      sha256 = wrapConstructor(() => new SHA256());
      sha224 = wrapConstructor(() => new SHA224());
    }
  });

  // node_modules/text-encoding-utf-8/lib/encoding.lib.js
  var require_encoding_lib = __commonJS({
    "node_modules/text-encoding-utf-8/lib/encoding.lib.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      function inRange(a, min, max) {
        return min <= a && a <= max;
      }
      function ToDictionary(o) {
        if (o === void 0)
          return {};
        if (o === Object(o))
          return o;
        throw TypeError("Could not convert argument to dictionary");
      }
      function stringToCodePoints(string4) {
        var s = String(string4);
        var n = s.length;
        var i = 0;
        var u2 = [];
        while (i < n) {
          var c2 = s.charCodeAt(i);
          if (c2 < 55296 || c2 > 57343) {
            u2.push(c2);
          } else if (56320 <= c2 && c2 <= 57343) {
            u2.push(65533);
          } else if (55296 <= c2 && c2 <= 56319) {
            if (i === n - 1) {
              u2.push(65533);
            } else {
              var d2 = string4.charCodeAt(i + 1);
              if (56320 <= d2 && d2 <= 57343) {
                var a = c2 & 1023;
                var b2 = d2 & 1023;
                u2.push(65536 + (a << 10) + b2);
                i += 1;
              } else {
                u2.push(65533);
              }
            }
          }
          i += 1;
        }
        return u2;
      }
      function codePointsToString(code_points) {
        var s = "";
        for (var i = 0; i < code_points.length; ++i) {
          var cp = code_points[i];
          if (cp <= 65535) {
            s += String.fromCharCode(cp);
          } else {
            cp -= 65536;
            s += String.fromCharCode(
              (cp >> 10) + 55296,
              (cp & 1023) + 56320
            );
          }
        }
        return s;
      }
      var end_of_stream = -1;
      function Stream(tokens) {
        this.tokens = [].slice.call(tokens);
      }
      Stream.prototype = {
        endOfStream: function() {
          return !this.tokens.length;
        },
        read: function() {
          if (!this.tokens.length)
            return end_of_stream;
          return this.tokens.shift();
        },
        prepend: function(token) {
          if (Array.isArray(token)) {
            var tokens = token;
            while (tokens.length)
              this.tokens.unshift(tokens.pop());
          } else {
            this.tokens.unshift(token);
          }
        },
        push: function(token) {
          if (Array.isArray(token)) {
            var tokens = token;
            while (tokens.length)
              this.tokens.push(tokens.shift());
          } else {
            this.tokens.push(token);
          }
        }
      };
      var finished = -1;
      function decoderError(fatal, opt_code_point) {
        if (fatal)
          throw TypeError("Decoder error");
        return opt_code_point || 65533;
      }
      var DEFAULT_ENCODING = "utf-8";
      function TextDecoder2(encoding, options) {
        if (!(this instanceof TextDecoder2)) {
          return new TextDecoder2(encoding, options);
        }
        encoding = encoding !== void 0 ? String(encoding).toLowerCase() : DEFAULT_ENCODING;
        if (encoding !== DEFAULT_ENCODING) {
          throw new Error("Encoding not supported. Only utf-8 is supported");
        }
        options = ToDictionary(options);
        this._streaming = false;
        this._BOMseen = false;
        this._decoder = null;
        this._fatal = Boolean(options["fatal"]);
        this._ignoreBOM = Boolean(options["ignoreBOM"]);
        Object.defineProperty(this, "encoding", { value: "utf-8" });
        Object.defineProperty(this, "fatal", { value: this._fatal });
        Object.defineProperty(this, "ignoreBOM", { value: this._ignoreBOM });
      }
      TextDecoder2.prototype = {
        decode: function decode2(input, options) {
          var bytes2;
          if (typeof input === "object" && input instanceof ArrayBuffer) {
            bytes2 = new Uint8Array(input);
          } else if (typeof input === "object" && "buffer" in input && input.buffer instanceof ArrayBuffer) {
            bytes2 = new Uint8Array(
              input.buffer,
              input.byteOffset,
              input.byteLength
            );
          } else {
            bytes2 = new Uint8Array(0);
          }
          options = ToDictionary(options);
          if (!this._streaming) {
            this._decoder = new UTF8Decoder({ fatal: this._fatal });
            this._BOMseen = false;
          }
          this._streaming = Boolean(options["stream"]);
          var input_stream = new Stream(bytes2);
          var code_points = [];
          var result;
          while (!input_stream.endOfStream()) {
            result = this._decoder.handler(input_stream, input_stream.read());
            if (result === finished)
              break;
            if (result === null)
              continue;
            if (Array.isArray(result))
              code_points.push.apply(code_points, result);
            else
              code_points.push(result);
          }
          if (!this._streaming) {
            do {
              result = this._decoder.handler(input_stream, input_stream.read());
              if (result === finished)
                break;
              if (result === null)
                continue;
              if (Array.isArray(result))
                code_points.push.apply(code_points, result);
              else
                code_points.push(result);
            } while (!input_stream.endOfStream());
            this._decoder = null;
          }
          if (code_points.length) {
            if (["utf-8"].indexOf(this.encoding) !== -1 && !this._ignoreBOM && !this._BOMseen) {
              if (code_points[0] === 65279) {
                this._BOMseen = true;
                code_points.shift();
              } else {
                this._BOMseen = true;
              }
            }
          }
          return codePointsToString(code_points);
        }
      };
      function TextEncoder2(encoding, options) {
        if (!(this instanceof TextEncoder2))
          return new TextEncoder2(encoding, options);
        encoding = encoding !== void 0 ? String(encoding).toLowerCase() : DEFAULT_ENCODING;
        if (encoding !== DEFAULT_ENCODING) {
          throw new Error("Encoding not supported. Only utf-8 is supported");
        }
        options = ToDictionary(options);
        this._streaming = false;
        this._encoder = null;
        this._options = { fatal: Boolean(options["fatal"]) };
        Object.defineProperty(this, "encoding", { value: "utf-8" });
      }
      TextEncoder2.prototype = {
        encode: function encode(opt_string, options) {
          opt_string = opt_string ? String(opt_string) : "";
          options = ToDictionary(options);
          if (!this._streaming)
            this._encoder = new UTF8Encoder(this._options);
          this._streaming = Boolean(options["stream"]);
          var bytes2 = [];
          var input_stream = new Stream(stringToCodePoints(opt_string));
          var result;
          while (!input_stream.endOfStream()) {
            result = this._encoder.handler(input_stream, input_stream.read());
            if (result === finished)
              break;
            if (Array.isArray(result))
              bytes2.push.apply(bytes2, result);
            else
              bytes2.push(result);
          }
          if (!this._streaming) {
            while (true) {
              result = this._encoder.handler(input_stream, input_stream.read());
              if (result === finished)
                break;
              if (Array.isArray(result))
                bytes2.push.apply(bytes2, result);
              else
                bytes2.push(result);
            }
            this._encoder = null;
          }
          return new Uint8Array(bytes2);
        }
      };
      function UTF8Decoder(options) {
        var fatal = options.fatal;
        var utf8_code_point = 0, utf8_bytes_seen = 0, utf8_bytes_needed = 0, utf8_lower_boundary = 128, utf8_upper_boundary = 191;
        this.handler = function(stream, bite) {
          if (bite === end_of_stream && utf8_bytes_needed !== 0) {
            utf8_bytes_needed = 0;
            return decoderError(fatal);
          }
          if (bite === end_of_stream)
            return finished;
          if (utf8_bytes_needed === 0) {
            if (inRange(bite, 0, 127)) {
              return bite;
            }
            if (inRange(bite, 194, 223)) {
              utf8_bytes_needed = 1;
              utf8_code_point = bite - 192;
            } else if (inRange(bite, 224, 239)) {
              if (bite === 224)
                utf8_lower_boundary = 160;
              if (bite === 237)
                utf8_upper_boundary = 159;
              utf8_bytes_needed = 2;
              utf8_code_point = bite - 224;
            } else if (inRange(bite, 240, 244)) {
              if (bite === 240)
                utf8_lower_boundary = 144;
              if (bite === 244)
                utf8_upper_boundary = 143;
              utf8_bytes_needed = 3;
              utf8_code_point = bite - 240;
            } else {
              return decoderError(fatal);
            }
            utf8_code_point = utf8_code_point << 6 * utf8_bytes_needed;
            return null;
          }
          if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {
            utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
            utf8_lower_boundary = 128;
            utf8_upper_boundary = 191;
            stream.prepend(bite);
            return decoderError(fatal);
          }
          utf8_lower_boundary = 128;
          utf8_upper_boundary = 191;
          utf8_bytes_seen += 1;
          utf8_code_point += bite - 128 << 6 * (utf8_bytes_needed - utf8_bytes_seen);
          if (utf8_bytes_seen !== utf8_bytes_needed)
            return null;
          var code_point = utf8_code_point;
          utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
          return code_point;
        };
      }
      function UTF8Encoder(options) {
        var fatal = options.fatal;
        this.handler = function(stream, code_point) {
          if (code_point === end_of_stream)
            return finished;
          if (inRange(code_point, 0, 127))
            return code_point;
          var count, offset3;
          if (inRange(code_point, 128, 2047)) {
            count = 1;
            offset3 = 192;
          } else if (inRange(code_point, 2048, 65535)) {
            count = 2;
            offset3 = 224;
          } else if (inRange(code_point, 65536, 1114111)) {
            count = 3;
            offset3 = 240;
          }
          var bytes2 = [(code_point >> 6 * count) + offset3];
          while (count > 0) {
            var temp = code_point >> 6 * (count - 1);
            bytes2.push(128 | temp & 63);
            count -= 1;
          }
          return bytes2;
        };
      }
      exports2.TextEncoder = TextEncoder2;
      exports2.TextDecoder = TextDecoder2;
    }
  });

  // node_modules/borsh/lib/index.js
  var require_lib = __commonJS({
    "node_modules/borsh/lib/index.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        Object.defineProperty(o, k22, { enumerable: true, get: function() {
          return m[k2];
        } });
      } : function(o, m, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o[k22] = m[k2];
      });
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v2) {
        Object.defineProperty(o, "default", { enumerable: true, value: v2 });
      } : function(o, v2) {
        o["default"] = v2;
      });
      var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
        var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d2 = decorators[i])
              r = (c2 < 3 ? d2(r) : c2 > 3 ? d2(target, key, r) : d2(target, key)) || r;
        return c2 > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __importStar = exports2 && exports2.__importStar || function(mod2) {
        if (mod2 && mod2.__esModule)
          return mod2;
        var result = {};
        if (mod2 != null) {
          for (var k2 in mod2)
            if (k2 !== "default" && Object.hasOwnProperty.call(mod2, k2))
              __createBinding(result, mod2, k2);
        }
        __setModuleDefault(result, mod2);
        return result;
      };
      var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.deserializeUnchecked = exports2.deserialize = exports2.serialize = exports2.BinaryReader = exports2.BinaryWriter = exports2.BorshError = exports2.baseDecode = exports2.baseEncode = void 0;
      var bn_js_1 = __importDefault(require_bn());
      var bs58_1 = __importDefault(require_bs58());
      var encoding = __importStar(require_encoding_lib());
      var ResolvedTextDecoder = typeof TextDecoder !== "function" ? encoding.TextDecoder : TextDecoder;
      var textDecoder = new ResolvedTextDecoder("utf-8", { fatal: true });
      function baseEncode(value) {
        if (typeof value === "string") {
          value = Buffer.from(value, "utf8");
        }
        return bs58_1.default.encode(Buffer.from(value));
      }
      exports2.baseEncode = baseEncode;
      function baseDecode(value) {
        return Buffer.from(bs58_1.default.decode(value));
      }
      exports2.baseDecode = baseDecode;
      var INITIAL_LENGTH = 1024;
      var BorshError = class extends Error {
        constructor(message) {
          super(message);
          this.fieldPath = [];
          this.originalMessage = message;
        }
        addToFieldPath(fieldName) {
          this.fieldPath.splice(0, 0, fieldName);
          this.message = this.originalMessage + ": " + this.fieldPath.join(".");
        }
      };
      exports2.BorshError = BorshError;
      var BinaryWriter = class {
        constructor() {
          this.buf = Buffer.alloc(INITIAL_LENGTH);
          this.length = 0;
        }
        maybeResize() {
          if (this.buf.length < 16 + this.length) {
            this.buf = Buffer.concat([this.buf, Buffer.alloc(INITIAL_LENGTH)]);
          }
        }
        writeU8(value) {
          this.maybeResize();
          this.buf.writeUInt8(value, this.length);
          this.length += 1;
        }
        writeU16(value) {
          this.maybeResize();
          this.buf.writeUInt16LE(value, this.length);
          this.length += 2;
        }
        writeU32(value) {
          this.maybeResize();
          this.buf.writeUInt32LE(value, this.length);
          this.length += 4;
        }
        writeU64(value) {
          this.maybeResize();
          this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 8)));
        }
        writeU128(value) {
          this.maybeResize();
          this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 16)));
        }
        writeU256(value) {
          this.maybeResize();
          this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 32)));
        }
        writeU512(value) {
          this.maybeResize();
          this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 64)));
        }
        writeBuffer(buffer2) {
          this.buf = Buffer.concat([
            Buffer.from(this.buf.subarray(0, this.length)),
            buffer2,
            Buffer.alloc(INITIAL_LENGTH)
          ]);
          this.length += buffer2.length;
        }
        writeString(str3) {
          this.maybeResize();
          const b2 = Buffer.from(str3, "utf8");
          this.writeU32(b2.length);
          this.writeBuffer(b2);
        }
        writeFixedArray(array6) {
          this.writeBuffer(Buffer.from(array6));
        }
        writeArray(array6, fn2) {
          this.maybeResize();
          this.writeU32(array6.length);
          for (const elem of array6) {
            this.maybeResize();
            fn2(elem);
          }
        }
        toArray() {
          return this.buf.subarray(0, this.length);
        }
      };
      exports2.BinaryWriter = BinaryWriter;
      function handlingRangeError(target, propertyKey, propertyDescriptor) {
        const originalMethod = propertyDescriptor.value;
        propertyDescriptor.value = function(...args) {
          try {
            return originalMethod.apply(this, args);
          } catch (e) {
            if (e instanceof RangeError) {
              const code2 = e.code;
              if (["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(code2) >= 0) {
                throw new BorshError("Reached the end of buffer when deserializing");
              }
            }
            throw e;
          }
        };
      }
      var BinaryReader = class {
        constructor(buf) {
          this.buf = buf;
          this.offset = 0;
        }
        readU8() {
          const value = this.buf.readUInt8(this.offset);
          this.offset += 1;
          return value;
        }
        readU16() {
          const value = this.buf.readUInt16LE(this.offset);
          this.offset += 2;
          return value;
        }
        readU32() {
          const value = this.buf.readUInt32LE(this.offset);
          this.offset += 4;
          return value;
        }
        readU64() {
          const buf = this.readBuffer(8);
          return new bn_js_1.default(buf, "le");
        }
        readU128() {
          const buf = this.readBuffer(16);
          return new bn_js_1.default(buf, "le");
        }
        readU256() {
          const buf = this.readBuffer(32);
          return new bn_js_1.default(buf, "le");
        }
        readU512() {
          const buf = this.readBuffer(64);
          return new bn_js_1.default(buf, "le");
        }
        readBuffer(len) {
          if (this.offset + len > this.buf.length) {
            throw new BorshError(`Expected buffer length ${len} isn't within bounds`);
          }
          const result = this.buf.slice(this.offset, this.offset + len);
          this.offset += len;
          return result;
        }
        readString() {
          const len = this.readU32();
          const buf = this.readBuffer(len);
          try {
            return textDecoder.decode(buf);
          } catch (e) {
            throw new BorshError(`Error decoding UTF-8 string: ${e}`);
          }
        }
        readFixedArray(len) {
          return new Uint8Array(this.readBuffer(len));
        }
        readArray(fn2) {
          const len = this.readU32();
          const result = Array();
          for (let i = 0; i < len; ++i) {
            result.push(fn2());
          }
          return result;
        }
      };
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readU8", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readU16", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readU32", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readU64", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readU128", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readU256", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readU512", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readString", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readFixedArray", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readArray", null);
      exports2.BinaryReader = BinaryReader;
      function capitalizeFirstLetter(string4) {
        return string4.charAt(0).toUpperCase() + string4.slice(1);
      }
      function serializeField(schema, fieldName, value, fieldType, writer) {
        try {
          if (typeof fieldType === "string") {
            writer[`write${capitalizeFirstLetter(fieldType)}`](value);
          } else if (fieldType instanceof Array) {
            if (typeof fieldType[0] === "number") {
              if (value.length !== fieldType[0]) {
                throw new BorshError(`Expecting byte array of length ${fieldType[0]}, but got ${value.length} bytes`);
              }
              writer.writeFixedArray(value);
            } else if (fieldType.length === 2 && typeof fieldType[1] === "number") {
              if (value.length !== fieldType[1]) {
                throw new BorshError(`Expecting byte array of length ${fieldType[1]}, but got ${value.length} bytes`);
              }
              for (let i = 0; i < fieldType[1]; i++) {
                serializeField(schema, null, value[i], fieldType[0], writer);
              }
            } else {
              writer.writeArray(value, (item) => {
                serializeField(schema, fieldName, item, fieldType[0], writer);
              });
            }
          } else if (fieldType.kind !== void 0) {
            switch (fieldType.kind) {
              case "option": {
                if (value === null || value === void 0) {
                  writer.writeU8(0);
                } else {
                  writer.writeU8(1);
                  serializeField(schema, fieldName, value, fieldType.type, writer);
                }
                break;
              }
              case "map": {
                writer.writeU32(value.size);
                value.forEach((val, key) => {
                  serializeField(schema, fieldName, key, fieldType.key, writer);
                  serializeField(schema, fieldName, val, fieldType.value, writer);
                });
                break;
              }
              default:
                throw new BorshError(`FieldType ${fieldType} unrecognized`);
            }
          } else {
            serializeStruct(schema, value, writer);
          }
        } catch (error2) {
          if (error2 instanceof BorshError) {
            error2.addToFieldPath(fieldName);
          }
          throw error2;
        }
      }
      function serializeStruct(schema, obj, writer) {
        if (typeof obj.borshSerialize === "function") {
          obj.borshSerialize(writer);
          return;
        }
        const structSchema = schema.get(obj.constructor);
        if (!structSchema) {
          throw new BorshError(`Class ${obj.constructor.name} is missing in schema`);
        }
        if (structSchema.kind === "struct") {
          structSchema.fields.map(([fieldName, fieldType]) => {
            serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
          });
        } else if (structSchema.kind === "enum") {
          const name2 = obj[structSchema.field];
          for (let idx = 0; idx < structSchema.values.length; ++idx) {
            const [fieldName, fieldType] = structSchema.values[idx];
            if (fieldName === name2) {
              writer.writeU8(idx);
              serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
              break;
            }
          }
        } else {
          throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${obj.constructor.name}`);
        }
      }
      function serialize2(schema, obj, Writer = BinaryWriter) {
        const writer = new Writer();
        serializeStruct(schema, obj, writer);
        return writer.toArray();
      }
      exports2.serialize = serialize2;
      function deserializeField(schema, fieldName, fieldType, reader) {
        try {
          if (typeof fieldType === "string") {
            return reader[`read${capitalizeFirstLetter(fieldType)}`]();
          }
          if (fieldType instanceof Array) {
            if (typeof fieldType[0] === "number") {
              return reader.readFixedArray(fieldType[0]);
            } else if (typeof fieldType[1] === "number") {
              const arr = [];
              for (let i = 0; i < fieldType[1]; i++) {
                arr.push(deserializeField(schema, null, fieldType[0], reader));
              }
              return arr;
            } else {
              return reader.readArray(() => deserializeField(schema, fieldName, fieldType[0], reader));
            }
          }
          if (fieldType.kind === "option") {
            const option3 = reader.readU8();
            if (option3) {
              return deserializeField(schema, fieldName, fieldType.type, reader);
            }
            return void 0;
          }
          if (fieldType.kind === "map") {
            let map = /* @__PURE__ */ new Map();
            const length = reader.readU32();
            for (let i = 0; i < length; i++) {
              const key = deserializeField(schema, fieldName, fieldType.key, reader);
              const val = deserializeField(schema, fieldName, fieldType.value, reader);
              map.set(key, val);
            }
            return map;
          }
          return deserializeStruct(schema, fieldType, reader);
        } catch (error2) {
          if (error2 instanceof BorshError) {
            error2.addToFieldPath(fieldName);
          }
          throw error2;
        }
      }
      function deserializeStruct(schema, classType, reader) {
        if (typeof classType.borshDeserialize === "function") {
          return classType.borshDeserialize(reader);
        }
        const structSchema = schema.get(classType);
        if (!structSchema) {
          throw new BorshError(`Class ${classType.name} is missing in schema`);
        }
        if (structSchema.kind === "struct") {
          const result = {};
          for (const [fieldName, fieldType] of schema.get(classType).fields) {
            result[fieldName] = deserializeField(schema, fieldName, fieldType, reader);
          }
          return new classType(result);
        }
        if (structSchema.kind === "enum") {
          const idx = reader.readU8();
          if (idx >= structSchema.values.length) {
            throw new BorshError(`Enum index: ${idx} is out of range`);
          }
          const [fieldName, fieldType] = structSchema.values[idx];
          const fieldValue = deserializeField(schema, fieldName, fieldType, reader);
          return new classType({ [fieldName]: fieldValue });
        }
        throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${classType.constructor.name}`);
      }
      function deserialize2(schema, classType, buffer2, Reader = BinaryReader) {
        const reader = new Reader(buffer2);
        const result = deserializeStruct(schema, classType, reader);
        if (reader.offset < buffer2.length) {
          throw new BorshError(`Unexpected ${buffer2.length - reader.offset} bytes after deserialized data`);
        }
        return result;
      }
      exports2.deserialize = deserialize2;
      function deserializeUnchecked2(schema, classType, buffer2, Reader = BinaryReader) {
        const reader = new Reader(buffer2);
        return deserializeStruct(schema, classType, reader);
      }
      exports2.deserializeUnchecked = deserializeUnchecked2;
    }
  });

  // node_modules/@solana/buffer-layout/lib/Layout.js
  var require_Layout = __commonJS({
    "node_modules/@solana/buffer-layout/lib/Layout.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.s16 = exports2.s8 = exports2.nu64be = exports2.u48be = exports2.u40be = exports2.u32be = exports2.u24be = exports2.u16be = exports2.nu64 = exports2.u48 = exports2.u40 = exports2.u32 = exports2.u24 = exports2.u16 = exports2.u8 = exports2.offset = exports2.greedy = exports2.Constant = exports2.UTF8 = exports2.CString = exports2.Blob = exports2.Boolean = exports2.BitField = exports2.BitStructure = exports2.VariantLayout = exports2.Union = exports2.UnionLayoutDiscriminator = exports2.UnionDiscriminator = exports2.Structure = exports2.Sequence = exports2.DoubleBE = exports2.Double = exports2.FloatBE = exports2.Float = exports2.NearInt64BE = exports2.NearInt64 = exports2.NearUInt64BE = exports2.NearUInt64 = exports2.IntBE = exports2.Int = exports2.UIntBE = exports2.UInt = exports2.OffsetLayout = exports2.GreedyCount = exports2.ExternalLayout = exports2.bindConstructorLayout = exports2.nameWithProperty = exports2.Layout = exports2.uint8ArrayToBuffer = exports2.checkUint8Array = void 0;
      exports2.constant = exports2.utf8 = exports2.cstr = exports2.blob = exports2.unionLayoutDiscriminator = exports2.union = exports2.seq = exports2.bits = exports2.struct = exports2.f64be = exports2.f64 = exports2.f32be = exports2.f32 = exports2.ns64be = exports2.s48be = exports2.s40be = exports2.s32be = exports2.s24be = exports2.s16be = exports2.ns64 = exports2.s48 = exports2.s40 = exports2.s32 = exports2.s24 = void 0;
      var buffer_1 = require_buffer();
      function checkUint8Array(b2) {
        if (!(b2 instanceof Uint8Array)) {
          throw new TypeError("b must be a Uint8Array");
        }
      }
      exports2.checkUint8Array = checkUint8Array;
      function uint8ArrayToBuffer(b2) {
        checkUint8Array(b2);
        return buffer_1.Buffer.from(b2.buffer, b2.byteOffset, b2.length);
      }
      exports2.uint8ArrayToBuffer = uint8ArrayToBuffer;
      var Layout3 = class {
        constructor(span, property) {
          if (!Number.isInteger(span)) {
            throw new TypeError("span must be an integer");
          }
          this.span = span;
          this.property = property;
        }
        makeDestinationObject() {
          return {};
        }
        getSpan(b2, offset3) {
          if (0 > this.span) {
            throw new RangeError("indeterminate span");
          }
          return this.span;
        }
        replicate(property) {
          const rv = Object.create(this.constructor.prototype);
          Object.assign(rv, this);
          rv.property = property;
          return rv;
        }
        fromArray(values) {
          return void 0;
        }
      };
      exports2.Layout = Layout3;
      function nameWithProperty3(name2, lo) {
        if (lo.property) {
          return name2 + "[" + lo.property + "]";
        }
        return name2;
      }
      exports2.nameWithProperty = nameWithProperty3;
      function bindConstructorLayout2(Class, layout) {
        if ("function" !== typeof Class) {
          throw new TypeError("Class must be constructor");
        }
        if (Object.prototype.hasOwnProperty.call(Class, "layout_")) {
          throw new Error("Class is already bound to a layout");
        }
        if (!(layout && layout instanceof Layout3)) {
          throw new TypeError("layout must be a Layout");
        }
        if (Object.prototype.hasOwnProperty.call(layout, "boundConstructor_")) {
          throw new Error("layout is already bound to a constructor");
        }
        Class.layout_ = layout;
        layout.boundConstructor_ = Class;
        layout.makeDestinationObject = () => new Class();
        Object.defineProperty(Class.prototype, "encode", {
          value(b2, offset3) {
            return layout.encode(this, b2, offset3);
          },
          writable: true
        });
        Object.defineProperty(Class, "decode", {
          value(b2, offset3) {
            return layout.decode(b2, offset3);
          },
          writable: true
        });
      }
      exports2.bindConstructorLayout = bindConstructorLayout2;
      var ExternalLayout3 = class extends Layout3 {
        isCount() {
          throw new Error("ExternalLayout is abstract");
        }
      };
      exports2.ExternalLayout = ExternalLayout3;
      var GreedyCount2 = class extends ExternalLayout3 {
        constructor(elementSpan = 1, property) {
          if (!Number.isInteger(elementSpan) || 0 >= elementSpan) {
            throw new TypeError("elementSpan must be a (positive) integer");
          }
          super(-1, property);
          this.elementSpan = elementSpan;
        }
        isCount() {
          return true;
        }
        decode(b2, offset3 = 0) {
          checkUint8Array(b2);
          const rem = b2.length - offset3;
          return Math.floor(rem / this.elementSpan);
        }
        encode(src, b2, offset3) {
          return 0;
        }
      };
      exports2.GreedyCount = GreedyCount2;
      var OffsetLayout3 = class extends ExternalLayout3 {
        constructor(layout, offset3 = 0, property) {
          if (!(layout instanceof Layout3)) {
            throw new TypeError("layout must be a Layout");
          }
          if (!Number.isInteger(offset3)) {
            throw new TypeError("offset must be integer or undefined");
          }
          super(layout.span, property || layout.property);
          this.layout = layout;
          this.offset = offset3;
        }
        isCount() {
          return this.layout instanceof UInt3 || this.layout instanceof UIntBE3;
        }
        decode(b2, offset3 = 0) {
          return this.layout.decode(b2, offset3 + this.offset);
        }
        encode(src, b2, offset3 = 0) {
          return this.layout.encode(src, b2, offset3 + this.offset);
        }
      };
      exports2.OffsetLayout = OffsetLayout3;
      var UInt3 = class extends Layout3 {
        constructor(span, property) {
          super(span, property);
          if (6 < this.span) {
            throw new RangeError("span must not exceed 6 bytes");
          }
        }
        decode(b2, offset3 = 0) {
          return uint8ArrayToBuffer(b2).readUIntLE(offset3, this.span);
        }
        encode(src, b2, offset3 = 0) {
          uint8ArrayToBuffer(b2).writeUIntLE(src, offset3, this.span);
          return this.span;
        }
      };
      exports2.UInt = UInt3;
      var UIntBE3 = class extends Layout3 {
        constructor(span, property) {
          super(span, property);
          if (6 < this.span) {
            throw new RangeError("span must not exceed 6 bytes");
          }
        }
        decode(b2, offset3 = 0) {
          return uint8ArrayToBuffer(b2).readUIntBE(offset3, this.span);
        }
        encode(src, b2, offset3 = 0) {
          uint8ArrayToBuffer(b2).writeUIntBE(src, offset3, this.span);
          return this.span;
        }
      };
      exports2.UIntBE = UIntBE3;
      var Int2 = class extends Layout3 {
        constructor(span, property) {
          super(span, property);
          if (6 < this.span) {
            throw new RangeError("span must not exceed 6 bytes");
          }
        }
        decode(b2, offset3 = 0) {
          return uint8ArrayToBuffer(b2).readIntLE(offset3, this.span);
        }
        encode(src, b2, offset3 = 0) {
          uint8ArrayToBuffer(b2).writeIntLE(src, offset3, this.span);
          return this.span;
        }
      };
      exports2.Int = Int2;
      var IntBE2 = class extends Layout3 {
        constructor(span, property) {
          super(span, property);
          if (6 < this.span) {
            throw new RangeError("span must not exceed 6 bytes");
          }
        }
        decode(b2, offset3 = 0) {
          return uint8ArrayToBuffer(b2).readIntBE(offset3, this.span);
        }
        encode(src, b2, offset3 = 0) {
          uint8ArrayToBuffer(b2).writeIntBE(src, offset3, this.span);
          return this.span;
        }
      };
      exports2.IntBE = IntBE2;
      var V2E323 = Math.pow(2, 32);
      function divmodInt643(src) {
        const hi32 = Math.floor(src / V2E323);
        const lo32 = src - hi32 * V2E323;
        return { hi32, lo32 };
      }
      function roundedInt643(hi32, lo32) {
        return hi32 * V2E323 + lo32;
      }
      var NearUInt643 = class extends Layout3 {
        constructor(property) {
          super(8, property);
        }
        decode(b2, offset3 = 0) {
          const buffer2 = uint8ArrayToBuffer(b2);
          const lo32 = buffer2.readUInt32LE(offset3);
          const hi32 = buffer2.readUInt32LE(offset3 + 4);
          return roundedInt643(hi32, lo32);
        }
        encode(src, b2, offset3 = 0) {
          const split2 = divmodInt643(src);
          const buffer2 = uint8ArrayToBuffer(b2);
          buffer2.writeUInt32LE(split2.lo32, offset3);
          buffer2.writeUInt32LE(split2.hi32, offset3 + 4);
          return 8;
        }
      };
      exports2.NearUInt64 = NearUInt643;
      var NearUInt64BE2 = class extends Layout3 {
        constructor(property) {
          super(8, property);
        }
        decode(b2, offset3 = 0) {
          const buffer2 = uint8ArrayToBuffer(b2);
          const hi32 = buffer2.readUInt32BE(offset3);
          const lo32 = buffer2.readUInt32BE(offset3 + 4);
          return roundedInt643(hi32, lo32);
        }
        encode(src, b2, offset3 = 0) {
          const split2 = divmodInt643(src);
          const buffer2 = uint8ArrayToBuffer(b2);
          buffer2.writeUInt32BE(split2.hi32, offset3);
          buffer2.writeUInt32BE(split2.lo32, offset3 + 4);
          return 8;
        }
      };
      exports2.NearUInt64BE = NearUInt64BE2;
      var NearInt643 = class extends Layout3 {
        constructor(property) {
          super(8, property);
        }
        decode(b2, offset3 = 0) {
          const buffer2 = uint8ArrayToBuffer(b2);
          const lo32 = buffer2.readUInt32LE(offset3);
          const hi32 = buffer2.readInt32LE(offset3 + 4);
          return roundedInt643(hi32, lo32);
        }
        encode(src, b2, offset3 = 0) {
          const split2 = divmodInt643(src);
          const buffer2 = uint8ArrayToBuffer(b2);
          buffer2.writeUInt32LE(split2.lo32, offset3);
          buffer2.writeInt32LE(split2.hi32, offset3 + 4);
          return 8;
        }
      };
      exports2.NearInt64 = NearInt643;
      var NearInt64BE2 = class extends Layout3 {
        constructor(property) {
          super(8, property);
        }
        decode(b2, offset3 = 0) {
          const buffer2 = uint8ArrayToBuffer(b2);
          const hi32 = buffer2.readInt32BE(offset3);
          const lo32 = buffer2.readUInt32BE(offset3 + 4);
          return roundedInt643(hi32, lo32);
        }
        encode(src, b2, offset3 = 0) {
          const split2 = divmodInt643(src);
          const buffer2 = uint8ArrayToBuffer(b2);
          buffer2.writeInt32BE(split2.hi32, offset3);
          buffer2.writeUInt32BE(split2.lo32, offset3 + 4);
          return 8;
        }
      };
      exports2.NearInt64BE = NearInt64BE2;
      var Float2 = class extends Layout3 {
        constructor(property) {
          super(4, property);
        }
        decode(b2, offset3 = 0) {
          return uint8ArrayToBuffer(b2).readFloatLE(offset3);
        }
        encode(src, b2, offset3 = 0) {
          uint8ArrayToBuffer(b2).writeFloatLE(src, offset3);
          return 4;
        }
      };
      exports2.Float = Float2;
      var FloatBE2 = class extends Layout3 {
        constructor(property) {
          super(4, property);
        }
        decode(b2, offset3 = 0) {
          return uint8ArrayToBuffer(b2).readFloatBE(offset3);
        }
        encode(src, b2, offset3 = 0) {
          uint8ArrayToBuffer(b2).writeFloatBE(src, offset3);
          return 4;
        }
      };
      exports2.FloatBE = FloatBE2;
      var Double2 = class extends Layout3 {
        constructor(property) {
          super(8, property);
        }
        decode(b2, offset3 = 0) {
          return uint8ArrayToBuffer(b2).readDoubleLE(offset3);
        }
        encode(src, b2, offset3 = 0) {
          uint8ArrayToBuffer(b2).writeDoubleLE(src, offset3);
          return 8;
        }
      };
      exports2.Double = Double2;
      var DoubleBE2 = class extends Layout3 {
        constructor(property) {
          super(8, property);
        }
        decode(b2, offset3 = 0) {
          return uint8ArrayToBuffer(b2).readDoubleBE(offset3);
        }
        encode(src, b2, offset3 = 0) {
          uint8ArrayToBuffer(b2).writeDoubleBE(src, offset3);
          return 8;
        }
      };
      exports2.DoubleBE = DoubleBE2;
      var Sequence2 = class extends Layout3 {
        constructor(elementLayout, count, property) {
          if (!(elementLayout instanceof Layout3)) {
            throw new TypeError("elementLayout must be a Layout");
          }
          if (!(count instanceof ExternalLayout3 && count.isCount() || Number.isInteger(count) && 0 <= count)) {
            throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
          }
          let span = -1;
          if (!(count instanceof ExternalLayout3) && 0 < elementLayout.span) {
            span = count * elementLayout.span;
          }
          super(span, property);
          this.elementLayout = elementLayout;
          this.count = count;
        }
        getSpan(b2, offset3 = 0) {
          if (0 <= this.span) {
            return this.span;
          }
          let span = 0;
          let count = this.count;
          if (count instanceof ExternalLayout3) {
            count = count.decode(b2, offset3);
          }
          if (0 < this.elementLayout.span) {
            span = count * this.elementLayout.span;
          } else {
            let idx = 0;
            while (idx < count) {
              span += this.elementLayout.getSpan(b2, offset3 + span);
              ++idx;
            }
          }
          return span;
        }
        decode(b2, offset3 = 0) {
          const rv = [];
          let i = 0;
          let count = this.count;
          if (count instanceof ExternalLayout3) {
            count = count.decode(b2, offset3);
          }
          while (i < count) {
            rv.push(this.elementLayout.decode(b2, offset3));
            offset3 += this.elementLayout.getSpan(b2, offset3);
            i += 1;
          }
          return rv;
        }
        encode(src, b2, offset3 = 0) {
          const elo = this.elementLayout;
          const span = src.reduce((span2, v2) => {
            return span2 + elo.encode(v2, b2, offset3 + span2);
          }, 0);
          if (this.count instanceof ExternalLayout3) {
            this.count.encode(src.length, b2, offset3);
          }
          return span;
        }
      };
      exports2.Sequence = Sequence2;
      var Structure3 = class extends Layout3 {
        constructor(fields, property, decodePrefixes) {
          if (!(Array.isArray(fields) && fields.reduce((acc, v2) => acc && v2 instanceof Layout3, true))) {
            throw new TypeError("fields must be array of Layout instances");
          }
          if ("boolean" === typeof property && void 0 === decodePrefixes) {
            decodePrefixes = property;
            property = void 0;
          }
          for (const fd of fields) {
            if (0 > fd.span && void 0 === fd.property) {
              throw new Error("fields cannot contain unnamed variable-length layout");
            }
          }
          let span = -1;
          try {
            span = fields.reduce((span2, fd) => span2 + fd.getSpan(), 0);
          } catch (e) {
          }
          super(span, property);
          this.fields = fields;
          this.decodePrefixes = !!decodePrefixes;
        }
        getSpan(b2, offset3 = 0) {
          if (0 <= this.span) {
            return this.span;
          }
          let span = 0;
          try {
            span = this.fields.reduce((span2, fd) => {
              const fsp = fd.getSpan(b2, offset3);
              offset3 += fsp;
              return span2 + fsp;
            }, 0);
          } catch (e) {
            throw new RangeError("indeterminate span");
          }
          return span;
        }
        decode(b2, offset3 = 0) {
          checkUint8Array(b2);
          const dest = this.makeDestinationObject();
          for (const fd of this.fields) {
            if (void 0 !== fd.property) {
              dest[fd.property] = fd.decode(b2, offset3);
            }
            offset3 += fd.getSpan(b2, offset3);
            if (this.decodePrefixes && b2.length === offset3) {
              break;
            }
          }
          return dest;
        }
        encode(src, b2, offset3 = 0) {
          const firstOffset = offset3;
          let lastOffset = 0;
          let lastWrote = 0;
          for (const fd of this.fields) {
            let span = fd.span;
            lastWrote = 0 < span ? span : 0;
            if (void 0 !== fd.property) {
              const fv = src[fd.property];
              if (void 0 !== fv) {
                lastWrote = fd.encode(fv, b2, offset3);
                if (0 > span) {
                  span = fd.getSpan(b2, offset3);
                }
              }
            }
            lastOffset = offset3;
            offset3 += span;
          }
          return lastOffset + lastWrote - firstOffset;
        }
        fromArray(values) {
          const dest = this.makeDestinationObject();
          for (const fd of this.fields) {
            if (void 0 !== fd.property && 0 < values.length) {
              dest[fd.property] = values.shift();
            }
          }
          return dest;
        }
        layoutFor(property) {
          if ("string" !== typeof property) {
            throw new TypeError("property must be string");
          }
          for (const fd of this.fields) {
            if (fd.property === property) {
              return fd;
            }
          }
          return void 0;
        }
        offsetOf(property) {
          if ("string" !== typeof property) {
            throw new TypeError("property must be string");
          }
          let offset3 = 0;
          for (const fd of this.fields) {
            if (fd.property === property) {
              return offset3;
            }
            if (0 > fd.span) {
              offset3 = -1;
            } else if (0 <= offset3) {
              offset3 += fd.span;
            }
          }
          return void 0;
        }
      };
      exports2.Structure = Structure3;
      var UnionDiscriminator3 = class {
        constructor(property) {
          this.property = property;
        }
        decode(b2, offset3) {
          throw new Error("UnionDiscriminator is abstract");
        }
        encode(src, b2, offset3) {
          throw new Error("UnionDiscriminator is abstract");
        }
      };
      exports2.UnionDiscriminator = UnionDiscriminator3;
      var UnionLayoutDiscriminator3 = class extends UnionDiscriminator3 {
        constructor(layout, property) {
          if (!(layout instanceof ExternalLayout3 && layout.isCount())) {
            throw new TypeError("layout must be an unsigned integer ExternalLayout");
          }
          super(property || layout.property || "variant");
          this.layout = layout;
        }
        decode(b2, offset3) {
          return this.layout.decode(b2, offset3);
        }
        encode(src, b2, offset3) {
          return this.layout.encode(src, b2, offset3);
        }
      };
      exports2.UnionLayoutDiscriminator = UnionLayoutDiscriminator3;
      var Union3 = class extends Layout3 {
        constructor(discr, defaultLayout, property) {
          let discriminator;
          if (discr instanceof UInt3 || discr instanceof UIntBE3) {
            discriminator = new UnionLayoutDiscriminator3(new OffsetLayout3(discr));
          } else if (discr instanceof ExternalLayout3 && discr.isCount()) {
            discriminator = new UnionLayoutDiscriminator3(discr);
          } else if (!(discr instanceof UnionDiscriminator3)) {
            throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
          } else {
            discriminator = discr;
          }
          if (void 0 === defaultLayout) {
            defaultLayout = null;
          }
          if (!(null === defaultLayout || defaultLayout instanceof Layout3)) {
            throw new TypeError("defaultLayout must be null or a Layout");
          }
          if (null !== defaultLayout) {
            if (0 > defaultLayout.span) {
              throw new Error("defaultLayout must have constant span");
            }
            if (void 0 === defaultLayout.property) {
              defaultLayout = defaultLayout.replicate("content");
            }
          }
          let span = -1;
          if (defaultLayout) {
            span = defaultLayout.span;
            if (0 <= span && (discr instanceof UInt3 || discr instanceof UIntBE3)) {
              span += discriminator.layout.span;
            }
          }
          super(span, property);
          this.discriminator = discriminator;
          this.usesPrefixDiscriminator = discr instanceof UInt3 || discr instanceof UIntBE3;
          this.defaultLayout = defaultLayout;
          this.registry = {};
          let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);
          this.getSourceVariant = function(src) {
            return boundGetSourceVariant(src);
          };
          this.configGetSourceVariant = function(gsv) {
            boundGetSourceVariant = gsv.bind(this);
          };
        }
        getSpan(b2, offset3 = 0) {
          if (0 <= this.span) {
            return this.span;
          }
          const vlo = this.getVariant(b2, offset3);
          if (!vlo) {
            throw new Error("unable to determine span for unrecognized variant");
          }
          return vlo.getSpan(b2, offset3);
        }
        defaultGetSourceVariant(src) {
          if (Object.prototype.hasOwnProperty.call(src, this.discriminator.property)) {
            if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(src, this.defaultLayout.property)) {
              return void 0;
            }
            const vlo = this.registry[src[this.discriminator.property]];
            if (vlo && (!vlo.layout || vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property))) {
              return vlo;
            }
          } else {
            for (const tag in this.registry) {
              const vlo = this.registry[tag];
              if (vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property)) {
                return vlo;
              }
            }
          }
          throw new Error("unable to infer src variant");
        }
        decode(b2, offset3 = 0) {
          let dest;
          const dlo = this.discriminator;
          const discr = dlo.decode(b2, offset3);
          const clo = this.registry[discr];
          if (void 0 === clo) {
            const defaultLayout = this.defaultLayout;
            let contentOffset = 0;
            if (this.usesPrefixDiscriminator) {
              contentOffset = dlo.layout.span;
            }
            dest = this.makeDestinationObject();
            dest[dlo.property] = discr;
            dest[defaultLayout.property] = defaultLayout.decode(b2, offset3 + contentOffset);
          } else {
            dest = clo.decode(b2, offset3);
          }
          return dest;
        }
        encode(src, b2, offset3 = 0) {
          const vlo = this.getSourceVariant(src);
          if (void 0 === vlo) {
            const dlo = this.discriminator;
            const clo = this.defaultLayout;
            let contentOffset = 0;
            if (this.usesPrefixDiscriminator) {
              contentOffset = dlo.layout.span;
            }
            dlo.encode(src[dlo.property], b2, offset3);
            return contentOffset + clo.encode(src[clo.property], b2, offset3 + contentOffset);
          }
          return vlo.encode(src, b2, offset3);
        }
        addVariant(variant, layout, property) {
          const rv = new VariantLayout3(this, variant, layout, property);
          this.registry[variant] = rv;
          return rv;
        }
        getVariant(vb, offset3 = 0) {
          let variant;
          if (vb instanceof Uint8Array) {
            variant = this.discriminator.decode(vb, offset3);
          } else {
            variant = vb;
          }
          return this.registry[variant];
        }
      };
      exports2.Union = Union3;
      var VariantLayout3 = class extends Layout3 {
        constructor(union4, variant, layout, property) {
          if (!(union4 instanceof Union3)) {
            throw new TypeError("union must be a Union");
          }
          if (!Number.isInteger(variant) || 0 > variant) {
            throw new TypeError("variant must be a (non-negative) integer");
          }
          if ("string" === typeof layout && void 0 === property) {
            property = layout;
            layout = null;
          }
          if (layout) {
            if (!(layout instanceof Layout3)) {
              throw new TypeError("layout must be a Layout");
            }
            if (null !== union4.defaultLayout && 0 <= layout.span && layout.span > union4.defaultLayout.span) {
              throw new Error("variant span exceeds span of containing union");
            }
            if ("string" !== typeof property) {
              throw new TypeError("variant must have a String property");
            }
          }
          let span = union4.span;
          if (0 > union4.span) {
            span = layout ? layout.span : 0;
            if (0 <= span && union4.usesPrefixDiscriminator) {
              span += union4.discriminator.layout.span;
            }
          }
          super(span, property);
          this.union = union4;
          this.variant = variant;
          this.layout = layout || null;
        }
        getSpan(b2, offset3 = 0) {
          if (0 <= this.span) {
            return this.span;
          }
          let contentOffset = 0;
          if (this.union.usesPrefixDiscriminator) {
            contentOffset = this.union.discriminator.layout.span;
          }
          let span = 0;
          if (this.layout) {
            span = this.layout.getSpan(b2, offset3 + contentOffset);
          }
          return contentOffset + span;
        }
        decode(b2, offset3 = 0) {
          const dest = this.makeDestinationObject();
          if (this !== this.union.getVariant(b2, offset3)) {
            throw new Error("variant mismatch");
          }
          let contentOffset = 0;
          if (this.union.usesPrefixDiscriminator) {
            contentOffset = this.union.discriminator.layout.span;
          }
          if (this.layout) {
            dest[this.property] = this.layout.decode(b2, offset3 + contentOffset);
          } else if (this.property) {
            dest[this.property] = true;
          } else if (this.union.usesPrefixDiscriminator) {
            dest[this.union.discriminator.property] = this.variant;
          }
          return dest;
        }
        encode(src, b2, offset3 = 0) {
          let contentOffset = 0;
          if (this.union.usesPrefixDiscriminator) {
            contentOffset = this.union.discriminator.layout.span;
          }
          if (this.layout && !Object.prototype.hasOwnProperty.call(src, this.property)) {
            throw new TypeError("variant lacks property " + this.property);
          }
          this.union.discriminator.encode(this.variant, b2, offset3);
          let span = contentOffset;
          if (this.layout) {
            this.layout.encode(src[this.property], b2, offset3 + contentOffset);
            span += this.layout.getSpan(b2, offset3 + contentOffset);
            if (0 <= this.union.span && span > this.union.span) {
              throw new Error("encoded variant overruns containing union");
            }
          }
          return span;
        }
        fromArray(values) {
          if (this.layout) {
            return this.layout.fromArray(values);
          }
          return void 0;
        }
      };
      exports2.VariantLayout = VariantLayout3;
      function fixBitwiseResult2(v2) {
        if (0 > v2) {
          v2 += 4294967296;
        }
        return v2;
      }
      var BitStructure2 = class extends Layout3 {
        constructor(word, msb, property) {
          if (!(word instanceof UInt3 || word instanceof UIntBE3)) {
            throw new TypeError("word must be a UInt or UIntBE layout");
          }
          if ("string" === typeof msb && void 0 === property) {
            property = msb;
            msb = false;
          }
          if (4 < word.span) {
            throw new RangeError("word cannot exceed 32 bits");
          }
          super(word.span, property);
          this.word = word;
          this.msb = !!msb;
          this.fields = [];
          let value = 0;
          this._packedSetValue = function(v2) {
            value = fixBitwiseResult2(v2);
            return this;
          };
          this._packedGetValue = function() {
            return value;
          };
        }
        decode(b2, offset3 = 0) {
          const dest = this.makeDestinationObject();
          const value = this.word.decode(b2, offset3);
          this._packedSetValue(value);
          for (const fd of this.fields) {
            if (void 0 !== fd.property) {
              dest[fd.property] = fd.decode(b2);
            }
          }
          return dest;
        }
        encode(src, b2, offset3 = 0) {
          const value = this.word.decode(b2, offset3);
          this._packedSetValue(value);
          for (const fd of this.fields) {
            if (void 0 !== fd.property) {
              const fv = src[fd.property];
              if (void 0 !== fv) {
                fd.encode(fv);
              }
            }
          }
          return this.word.encode(this._packedGetValue(), b2, offset3);
        }
        addField(bits, property) {
          const bf = new BitField2(this, bits, property);
          this.fields.push(bf);
          return bf;
        }
        addBoolean(property) {
          const bf = new Boolean3(this, property);
          this.fields.push(bf);
          return bf;
        }
        fieldFor(property) {
          if ("string" !== typeof property) {
            throw new TypeError("property must be string");
          }
          for (const fd of this.fields) {
            if (fd.property === property) {
              return fd;
            }
          }
          return void 0;
        }
      };
      exports2.BitStructure = BitStructure2;
      var BitField2 = class {
        constructor(container, bits, property) {
          if (!(container instanceof BitStructure2)) {
            throw new TypeError("container must be a BitStructure");
          }
          if (!Number.isInteger(bits) || 0 >= bits) {
            throw new TypeError("bits must be positive integer");
          }
          const totalBits = 8 * container.span;
          const usedBits = container.fields.reduce((sum, fd) => sum + fd.bits, 0);
          if (bits + usedBits > totalBits) {
            throw new Error("bits too long for span remainder (" + (totalBits - usedBits) + " of " + totalBits + " remain)");
          }
          this.container = container;
          this.bits = bits;
          this.valueMask = (1 << bits) - 1;
          if (32 === bits) {
            this.valueMask = 4294967295;
          }
          this.start = usedBits;
          if (this.container.msb) {
            this.start = totalBits - usedBits - bits;
          }
          this.wordMask = fixBitwiseResult2(this.valueMask << this.start);
          this.property = property;
        }
        decode(b2, offset3) {
          const word = this.container._packedGetValue();
          const wordValue = fixBitwiseResult2(word & this.wordMask);
          const value = wordValue >>> this.start;
          return value;
        }
        encode(value) {
          if ("number" !== typeof value || !Number.isInteger(value) || value !== fixBitwiseResult2(value & this.valueMask)) {
            throw new TypeError(nameWithProperty3("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
          }
          const word = this.container._packedGetValue();
          const wordValue = fixBitwiseResult2(value << this.start);
          this.container._packedSetValue(fixBitwiseResult2(word & ~this.wordMask) | wordValue);
        }
      };
      exports2.BitField = BitField2;
      var Boolean3 = class extends BitField2 {
        constructor(container, property) {
          super(container, 1, property);
        }
        decode(b2, offset3) {
          return !!super.decode(b2, offset3);
        }
        encode(value) {
          if ("boolean" === typeof value) {
            value = +value;
          }
          super.encode(value);
        }
      };
      exports2.Boolean = Boolean3;
      var Blob3 = class extends Layout3 {
        constructor(length, property) {
          if (!(length instanceof ExternalLayout3 && length.isCount() || Number.isInteger(length) && 0 <= length)) {
            throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
          }
          let span = -1;
          if (!(length instanceof ExternalLayout3)) {
            span = length;
          }
          super(span, property);
          this.length = length;
        }
        getSpan(b2, offset3) {
          let span = this.span;
          if (0 > span) {
            span = this.length.decode(b2, offset3);
          }
          return span;
        }
        decode(b2, offset3 = 0) {
          let span = this.span;
          if (0 > span) {
            span = this.length.decode(b2, offset3);
          }
          return uint8ArrayToBuffer(b2).slice(offset3, offset3 + span);
        }
        encode(src, b2, offset3) {
          let span = this.length;
          if (this.length instanceof ExternalLayout3) {
            span = src.length;
          }
          if (!(src instanceof Uint8Array && span === src.length)) {
            throw new TypeError(nameWithProperty3("Blob.encode", this) + " requires (length " + span + ") Uint8Array as src");
          }
          if (offset3 + span > b2.length) {
            throw new RangeError("encoding overruns Uint8Array");
          }
          const srcBuffer = uint8ArrayToBuffer(src);
          uint8ArrayToBuffer(b2).write(srcBuffer.toString("hex"), offset3, span, "hex");
          if (this.length instanceof ExternalLayout3) {
            this.length.encode(span, b2, offset3);
          }
          return span;
        }
      };
      exports2.Blob = Blob3;
      var CString2 = class extends Layout3 {
        constructor(property) {
          super(-1, property);
        }
        getSpan(b2, offset3 = 0) {
          checkUint8Array(b2);
          let idx = offset3;
          while (idx < b2.length && 0 !== b2[idx]) {
            idx += 1;
          }
          return 1 + idx - offset3;
        }
        decode(b2, offset3 = 0) {
          const span = this.getSpan(b2, offset3);
          return uint8ArrayToBuffer(b2).slice(offset3, offset3 + span - 1).toString("utf-8");
        }
        encode(src, b2, offset3 = 0) {
          if ("string" !== typeof src) {
            src = String(src);
          }
          const srcb = buffer_1.Buffer.from(src, "utf8");
          const span = srcb.length;
          if (offset3 + span > b2.length) {
            throw new RangeError("encoding overruns Buffer");
          }
          const buffer2 = uint8ArrayToBuffer(b2);
          srcb.copy(buffer2, offset3);
          buffer2[offset3 + span] = 0;
          return span + 1;
        }
      };
      exports2.CString = CString2;
      var UTF82 = class extends Layout3 {
        constructor(maxSpan, property) {
          if ("string" === typeof maxSpan && void 0 === property) {
            property = maxSpan;
            maxSpan = void 0;
          }
          if (void 0 === maxSpan) {
            maxSpan = -1;
          } else if (!Number.isInteger(maxSpan)) {
            throw new TypeError("maxSpan must be an integer");
          }
          super(-1, property);
          this.maxSpan = maxSpan;
        }
        getSpan(b2, offset3 = 0) {
          checkUint8Array(b2);
          return b2.length - offset3;
        }
        decode(b2, offset3 = 0) {
          const span = this.getSpan(b2, offset3);
          if (0 <= this.maxSpan && this.maxSpan < span) {
            throw new RangeError("text length exceeds maxSpan");
          }
          return uint8ArrayToBuffer(b2).slice(offset3, offset3 + span).toString("utf-8");
        }
        encode(src, b2, offset3 = 0) {
          if ("string" !== typeof src) {
            src = String(src);
          }
          const srcb = buffer_1.Buffer.from(src, "utf8");
          const span = srcb.length;
          if (0 <= this.maxSpan && this.maxSpan < span) {
            throw new RangeError("text length exceeds maxSpan");
          }
          if (offset3 + span > b2.length) {
            throw new RangeError("encoding overruns Buffer");
          }
          srcb.copy(uint8ArrayToBuffer(b2), offset3);
          return span;
        }
      };
      exports2.UTF8 = UTF82;
      var Constant2 = class extends Layout3 {
        constructor(value, property) {
          super(0, property);
          this.value = value;
        }
        decode(b2, offset3) {
          return this.value;
        }
        encode(src, b2, offset3) {
          return 0;
        }
      };
      exports2.Constant = Constant2;
      exports2.greedy = (elementSpan, property) => new GreedyCount2(elementSpan, property);
      exports2.offset = (layout, offset3, property) => new OffsetLayout3(layout, offset3, property);
      exports2.u8 = (property) => new UInt3(1, property);
      exports2.u16 = (property) => new UInt3(2, property);
      exports2.u24 = (property) => new UInt3(3, property);
      exports2.u32 = (property) => new UInt3(4, property);
      exports2.u40 = (property) => new UInt3(5, property);
      exports2.u48 = (property) => new UInt3(6, property);
      exports2.nu64 = (property) => new NearUInt643(property);
      exports2.u16be = (property) => new UIntBE3(2, property);
      exports2.u24be = (property) => new UIntBE3(3, property);
      exports2.u32be = (property) => new UIntBE3(4, property);
      exports2.u40be = (property) => new UIntBE3(5, property);
      exports2.u48be = (property) => new UIntBE3(6, property);
      exports2.nu64be = (property) => new NearUInt64BE2(property);
      exports2.s8 = (property) => new Int2(1, property);
      exports2.s16 = (property) => new Int2(2, property);
      exports2.s24 = (property) => new Int2(3, property);
      exports2.s32 = (property) => new Int2(4, property);
      exports2.s40 = (property) => new Int2(5, property);
      exports2.s48 = (property) => new Int2(6, property);
      exports2.ns64 = (property) => new NearInt643(property);
      exports2.s16be = (property) => new IntBE2(2, property);
      exports2.s24be = (property) => new IntBE2(3, property);
      exports2.s32be = (property) => new IntBE2(4, property);
      exports2.s40be = (property) => new IntBE2(5, property);
      exports2.s48be = (property) => new IntBE2(6, property);
      exports2.ns64be = (property) => new NearInt64BE2(property);
      exports2.f32 = (property) => new Float2(property);
      exports2.f32be = (property) => new FloatBE2(property);
      exports2.f64 = (property) => new Double2(property);
      exports2.f64be = (property) => new DoubleBE2(property);
      exports2.struct = (fields, property, decodePrefixes) => new Structure3(fields, property, decodePrefixes);
      exports2.bits = (word, msb, property) => new BitStructure2(word, msb, property);
      exports2.seq = (elementLayout, count, property) => new Sequence2(elementLayout, count, property);
      exports2.union = (discr, defaultLayout, property) => new Union3(discr, defaultLayout, property);
      exports2.unionLayoutDiscriminator = (layout, property) => new UnionLayoutDiscriminator3(layout, property);
      exports2.blob = (length, property) => new Blob3(length, property);
      exports2.cstr = (property) => new CString2(property);
      exports2.utf8 = (maxSpan, property) => new UTF82(maxSpan, property);
      exports2.constant = (value, property) => new Constant2(value, property);
    }
  });

  // node_modules/bigint-buffer/dist/browser.js
  var require_browser = __commonJS({
    "node_modules/bigint-buffer/dist/browser.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      var converter;
      function toBigIntLE2(buf) {
        {
          const reversed = Buffer.from(buf);
          reversed.reverse();
          const hex = reversed.toString("hex");
          if (hex.length === 0) {
            return BigInt(0);
          }
          return BigInt(`0x${hex}`);
        }
        return converter.toBigInt(buf, false);
      }
      exports2.toBigIntLE = toBigIntLE2;
      function toBigIntBE(buf) {
        {
          const hex = buf.toString("hex");
          if (hex.length === 0) {
            return BigInt(0);
          }
          return BigInt(`0x${hex}`);
        }
        return converter.toBigInt(buf, true);
      }
      exports2.toBigIntBE = toBigIntBE;
      function toBufferLE2(num, width) {
        {
          const hex = num.toString(16);
          const buffer2 = Buffer.from(hex.padStart(width * 2, "0").slice(0, width * 2), "hex");
          buffer2.reverse();
          return buffer2;
        }
        return converter.fromBigInt(num, Buffer.allocUnsafe(width), false);
      }
      exports2.toBufferLE = toBufferLE2;
      function toBufferBE(num, width) {
        {
          const hex = num.toString(16);
          return Buffer.from(hex.padStart(width * 2, "0").slice(0, width * 2), "hex");
        }
        return converter.fromBigInt(num, Buffer.allocUnsafe(width), true);
      }
      exports2.toBufferBE = toBufferBE;
    }
  });

  // node_modules/@solana/web3.js/node_modules/superstruct/lib/index.es.js
  function isIterable2(x2) {
    return isObject2(x2) && typeof x2[Symbol.iterator] === "function";
  }
  function isObject2(x2) {
    return typeof x2 === "object" && x2 != null;
  }
  function print2(value) {
    return typeof value === "string" ? JSON.stringify(value) : "" + value;
  }
  function shiftIterator2(input) {
    const {
      done,
      value
    } = input.next();
    return done ? void 0 : value;
  }
  function toFailure2(result, context, struct6, value) {
    if (result === true) {
      return;
    } else if (result === false) {
      result = {};
    } else if (typeof result === "string") {
      result = {
        message: result
      };
    }
    const {
      path,
      branch
    } = context;
    const {
      type: type5
    } = struct6;
    const {
      refinement,
      message = "Expected a value of type `" + type5 + "`" + (refinement ? " with refinement `" + refinement + "`" : "") + ", but received: `" + print2(value) + "`"
    } = result;
    return {
      value,
      type: type5,
      refinement,
      key: path[path.length - 1],
      path,
      branch,
      ...result,
      message
    };
  }
  function* toFailures2(result, context, struct6, value) {
    if (!isIterable2(result)) {
      result = [result];
    }
    for (const r of result) {
      const failure = toFailure2(r, context, struct6, value);
      if (failure) {
        yield failure;
      }
    }
  }
  function* run2(value, struct6, options = {}) {
    const {
      path = [],
      branch = [value],
      coerce: coerce3 = false,
      mask: mask4 = false
    } = options;
    const ctx = {
      path,
      branch
    };
    if (coerce3) {
      value = struct6.coercer(value, ctx);
      if (mask4 && struct6.type !== "type" && isObject2(struct6.schema) && isObject2(value) && !Array.isArray(value)) {
        for (const key in value) {
          if (struct6.schema[key] === void 0) {
            delete value[key];
          }
        }
      }
    }
    let valid = true;
    for (const failure of struct6.validator(value, ctx)) {
      valid = false;
      yield [failure, void 0];
    }
    for (let [k2, v2, s] of struct6.entries(value, ctx)) {
      const ts = run2(v2, s, {
        path: k2 === void 0 ? path : [...path, k2],
        branch: k2 === void 0 ? branch : [...branch, v2],
        coerce: coerce3,
        mask: mask4
      });
      for (const t2 of ts) {
        if (t2[0]) {
          valid = false;
          yield [t2[0], void 0];
        } else if (coerce3) {
          v2 = t2[1];
          if (k2 === void 0) {
            value = v2;
          } else if (value instanceof Map) {
            value.set(k2, v2);
          } else if (value instanceof Set) {
            value.add(v2);
          } else if (isObject2(value)) {
            value[k2] = v2;
          }
        }
      }
    }
    if (valid) {
      for (const failure of struct6.refiner(value, ctx)) {
        valid = false;
        yield [failure, void 0];
      }
    }
    if (valid) {
      yield [void 0, value];
    }
  }
  function assert3(value, struct6) {
    const result = validate3(value, struct6);
    if (result[0]) {
      throw result[0];
    }
  }
  function create3(value, struct6) {
    const result = validate3(value, struct6, {
      coerce: true
    });
    if (result[0]) {
      throw result[0];
    } else {
      return result[1];
    }
  }
  function mask2(value, struct6) {
    const result = validate3(value, struct6, {
      coerce: true,
      mask: true
    });
    if (result[0]) {
      throw result[0];
    } else {
      return result[1];
    }
  }
  function is2(value, struct6) {
    const result = validate3(value, struct6);
    return !result[0];
  }
  function validate3(value, struct6, options = {}) {
    const tuples = run2(value, struct6, options);
    const tuple4 = shiftIterator2(tuples);
    if (tuple4[0]) {
      const error2 = new StructError2(tuple4[0], function* () {
        for (const t2 of tuples) {
          if (t2[0]) {
            yield t2[0];
          }
        }
      });
      return [error2, void 0];
    } else {
      const v2 = tuple4[1];
      return [void 0, v2];
    }
  }
  function define3(name2, validator) {
    return new Struct2({
      type: name2,
      schema: null,
      validator
    });
  }
  function any() {
    return define3("any", () => true);
  }
  function array2(Element) {
    return new Struct2({
      type: "array",
      schema: Element,
      *entries(value) {
        if (Element && Array.isArray(value)) {
          for (const [i, v2] of value.entries()) {
            yield [i, v2, Element];
          }
        }
      },
      coercer(value) {
        return Array.isArray(value) ? value.slice() : value;
      },
      validator(value) {
        return Array.isArray(value) || "Expected an array value, but received: " + print2(value);
      }
    });
  }
  function boolean2() {
    return define3("boolean", (value) => {
      return typeof value === "boolean";
    });
  }
  function instance(Class) {
    return define3("instance", (value) => {
      return value instanceof Class || "Expected a `" + Class.name + "` instance, but received: " + print2(value);
    });
  }
  function literal2(constant) {
    const description = print2(constant);
    const t2 = typeof constant;
    return new Struct2({
      type: "literal",
      schema: t2 === "string" || t2 === "number" || t2 === "boolean" ? constant : null,
      validator(value) {
        return value === constant || "Expected the literal `" + description + "`, but received: " + print2(value);
      }
    });
  }
  function never2() {
    return define3("never", () => false);
  }
  function nullable4(struct6) {
    return new Struct2({
      ...struct6,
      validator: (value, ctx) => value === null || struct6.validator(value, ctx),
      refiner: (value, ctx) => value === null || struct6.refiner(value, ctx)
    });
  }
  function number3() {
    return define3("number", (value) => {
      return typeof value === "number" && !isNaN(value) || "Expected a number, but received: " + print2(value);
    });
  }
  function optional2(struct6) {
    return new Struct2({
      ...struct6,
      validator: (value, ctx) => value === void 0 || struct6.validator(value, ctx),
      refiner: (value, ctx) => value === void 0 || struct6.refiner(value, ctx)
    });
  }
  function record2(Key, Value) {
    return new Struct2({
      type: "record",
      schema: null,
      *entries(value) {
        if (isObject2(value)) {
          for (const k2 in value) {
            const v2 = value[k2];
            yield [k2, k2, Key];
            yield [k2, v2, Value];
          }
        }
      },
      validator(value) {
        return isObject2(value) || "Expected an object, but received: " + print2(value);
      }
    });
  }
  function string2() {
    return define3("string", (value) => {
      return typeof value === "string" || "Expected a string, but received: " + print2(value);
    });
  }
  function tuple3(Elements) {
    const Never = never2();
    return new Struct2({
      type: "tuple",
      schema: null,
      *entries(value) {
        if (Array.isArray(value)) {
          const length = Math.max(Elements.length, value.length);
          for (let i = 0; i < length; i++) {
            yield [i, value[i], Elements[i] || Never];
          }
        }
      },
      validator(value) {
        return Array.isArray(value) || "Expected an array, but received: " + print2(value);
      }
    });
  }
  function type3(schema) {
    const keys = Object.keys(schema);
    return new Struct2({
      type: "type",
      schema,
      *entries(value) {
        if (isObject2(value)) {
          for (const k2 of keys) {
            yield [k2, value[k2], schema[k2]];
          }
        }
      },
      validator(value) {
        return isObject2(value) || "Expected an object, but received: " + print2(value);
      }
    });
  }
  function union2(Structs) {
    const description = Structs.map((s) => s.type).join(" | ");
    return new Struct2({
      type: "union",
      schema: null,
      validator(value, ctx) {
        const failures = [];
        for (const S2 of Structs) {
          const [...tuples] = run2(value, S2, ctx);
          const [first] = tuples;
          if (!first[0]) {
            return [];
          } else {
            for (const [failure] of tuples) {
              if (failure) {
                failures.push(failure);
              }
            }
          }
        }
        return ["Expected the value to satisfy a union of `" + description + "`, but received: " + print2(value), ...failures];
      }
    });
  }
  function unknown2() {
    return define3("unknown", () => true);
  }
  function coerce(struct6, condition, coercer) {
    return new Struct2({
      ...struct6,
      coercer: (value, ctx) => {
        return is2(value, condition) ? struct6.coercer(coercer(value, ctx), ctx) : struct6.coercer(value, ctx);
      }
    });
  }
  var StructError2, Struct2;
  var init_index_es = __esm({
    "node_modules/@solana/web3.js/node_modules/superstruct/lib/index.es.js"() {
      init_virtual_process_polyfill();
      init_buffer();
      StructError2 = class extends TypeError {
        constructor(failure, failures) {
          let cached;
          const {
            message,
            ...rest
          } = failure;
          const {
            path
          } = failure;
          const msg = path.length === 0 ? message : "At path: " + path.join(".") + " -- " + message;
          super(msg);
          Object.assign(this, rest);
          this.name = this.constructor.name;
          this.failures = () => {
            var _cached;
            return (_cached = cached) != null ? _cached : cached = [failure, ...failures()];
          };
        }
      };
      Struct2 = class {
        constructor(props) {
          const {
            type: type5,
            schema,
            validator,
            refiner,
            coercer = (value) => value,
            entries = function* () {
            }
          } = props;
          this.type = type5;
          this.schema = schema;
          this.entries = entries;
          this.coercer = coercer;
          if (validator) {
            this.validator = (value, context) => {
              const result = validator(value, context);
              return toFailures2(result, context, this, value);
            };
          } else {
            this.validator = () => [];
          }
          if (refiner) {
            this.refiner = (value, context) => {
              const result = refiner(value, context);
              return toFailures2(result, context, this, value);
            };
          } else {
            this.refiner = () => [];
          }
        }
        assert(value) {
          return assert3(value, this);
        }
        create(value) {
          return create3(value, this);
        }
        is(value) {
          return is2(value, this);
        }
        mask(value) {
          return mask2(value, this);
        }
        validate(value, options = {}) {
          return validate3(value, this, options);
        }
      };
    }
  });

  // node_modules/jayson/lib/generateRequest.js
  var require_generateRequest = __commonJS({
    "node_modules/jayson/lib/generateRequest.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var uuid = (init_esm_browser(), __toCommonJS(esm_browser_exports)).v4;
      var generateRequest = function(method2, params, id, options) {
        if (typeof method2 !== "string") {
          throw new TypeError(method2 + " must be a string");
        }
        options = options || {};
        const version4 = typeof options.version === "number" ? options.version : 2;
        if (version4 !== 1 && version4 !== 2) {
          throw new TypeError(version4 + " must be 1 or 2");
        }
        const request = {
          method: method2
        };
        if (version4 === 2) {
          request.jsonrpc = "2.0";
        }
        if (params) {
          if (typeof params !== "object" && !Array.isArray(params)) {
            throw new TypeError(params + " must be an object, array or omitted");
          }
          request.params = params;
        }
        if (typeof id === "undefined") {
          const generator = typeof options.generator === "function" ? options.generator : function() {
            return uuid();
          };
          request.id = generator(request, options);
        } else if (version4 === 2 && id === null) {
          if (options.notificationIdNull) {
            request.id = null;
          }
        } else {
          request.id = id;
        }
        return request;
      };
      module2.exports = generateRequest;
    }
  });

  // node_modules/jayson/lib/client/browser/index.js
  var require_browser2 = __commonJS({
    "node_modules/jayson/lib/client/browser/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var uuid = (init_esm_browser(), __toCommonJS(esm_browser_exports)).v4;
      var generateRequest = require_generateRequest();
      var ClientBrowser = function(callServer, options) {
        if (!(this instanceof ClientBrowser)) {
          return new ClientBrowser(callServer, options);
        }
        if (!options) {
          options = {};
        }
        this.options = {
          reviver: typeof options.reviver !== "undefined" ? options.reviver : null,
          replacer: typeof options.replacer !== "undefined" ? options.replacer : null,
          generator: typeof options.generator !== "undefined" ? options.generator : function() {
            return uuid();
          },
          version: typeof options.version !== "undefined" ? options.version : 2,
          notificationIdNull: typeof options.notificationIdNull === "boolean" ? options.notificationIdNull : false
        };
        this.callServer = callServer;
      };
      module2.exports = ClientBrowser;
      ClientBrowser.prototype.request = function(method2, params, id, callback) {
        const self2 = this;
        let request = null;
        const isBatch = Array.isArray(method2) && typeof params === "function";
        if (this.options.version === 1 && isBatch) {
          throw new TypeError("JSON-RPC 1.0 does not support batching");
        }
        const isRaw = !isBatch && method2 && typeof method2 === "object" && typeof params === "function";
        if (isBatch || isRaw) {
          callback = params;
          request = method2;
        } else {
          if (typeof id === "function") {
            callback = id;
            id = void 0;
          }
          const hasCallback = typeof callback === "function";
          try {
            request = generateRequest(method2, params, id, {
              generator: this.options.generator,
              version: this.options.version,
              notificationIdNull: this.options.notificationIdNull
            });
          } catch (err2) {
            if (hasCallback) {
              return callback(err2);
            }
            throw err2;
          }
          if (!hasCallback) {
            return request;
          }
        }
        let message;
        try {
          message = JSON.stringify(request, this.options.replacer);
        } catch (err2) {
          return callback(err2);
        }
        this.callServer(message, function(err2, response) {
          self2._parseResponse(err2, response, callback);
        });
        return request;
      };
      ClientBrowser.prototype._parseResponse = function(err2, responseText, callback) {
        if (err2) {
          callback(err2);
          return;
        }
        if (!responseText) {
          return callback();
        }
        let response;
        try {
          response = JSON.parse(responseText, this.options.reviver);
        } catch (err3) {
          return callback(err3);
        }
        if (callback.length === 3) {
          if (Array.isArray(response)) {
            const isError2 = function(res) {
              return typeof res.error !== "undefined";
            };
            const isNotError = function(res) {
              return !isError2(res);
            };
            return callback(null, response.filter(isError2), response.filter(isNotError));
          } else {
            return callback(null, response.error, response.result);
          }
        }
        callback(null, response);
      };
    }
  });

  // node_modules/@babel/runtime/helpers/interopRequireDefault.js
  var require_interopRequireDefault = __commonJS({
    "node_modules/@babel/runtime/helpers/interopRequireDefault.js"(exports2, module2) {
      init_virtual_process_polyfill();
      init_buffer();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }
      module2.exports = _interopRequireDefault, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/typeof.js
  var require_typeof = __commonJS({
    "node_modules/@babel/runtime/helpers/typeof.js"(exports2, module2) {
      init_virtual_process_polyfill();
      init_buffer();
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        return module2.exports = _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
          return typeof obj2;
        } : function(obj2) {
          return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports, _typeof2(obj);
      }
      module2.exports = _typeof2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/regeneratorRuntime.js
  var require_regeneratorRuntime = __commonJS({
    "node_modules/@babel/runtime/helpers/regeneratorRuntime.js"(exports2, module2) {
      init_virtual_process_polyfill();
      init_buffer();
      var _typeof2 = require_typeof()["default"];
      function _regeneratorRuntime() {
        "use strict";
        module2.exports = _regeneratorRuntime = function _regeneratorRuntime2() {
          return exports3;
        }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
        var exports3 = {}, Op = Object.prototype, hasOwn2 = Op.hasOwnProperty, defineProperty = Object.defineProperty || function(obj, key, desc) {
          obj[key] = desc.value;
        }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
        function define5(obj, key, value) {
          return Object.defineProperty(obj, key, {
            value,
            enumerable: true,
            configurable: true,
            writable: true
          }), obj[key];
        }
        try {
          define5({}, "");
        } catch (err2) {
          define5 = function define6(obj, key, value) {
            return obj[key] = value;
          };
        }
        function wrap(innerFn, outerFn, self2, tryLocsList) {
          var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []);
          return defineProperty(generator, "_invoke", {
            value: makeInvokeMethod(innerFn, self2, context)
          }), generator;
        }
        function tryCatch(fn2, obj, arg) {
          try {
            return {
              type: "normal",
              arg: fn2.call(obj, arg)
            };
          } catch (err2) {
            return {
              type: "throw",
              arg: err2
            };
          }
        }
        exports3.wrap = wrap;
        var ContinueSentinel = {};
        function Generator() {
        }
        function GeneratorFunction() {
        }
        function GeneratorFunctionPrototype() {
        }
        var IteratorPrototype = {};
        define5(IteratorPrototype, iteratorSymbol, function() {
          return this;
        });
        var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
        NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn2.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
        var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
        function defineIteratorMethods(prototype) {
          ["next", "throw", "return"].forEach(function(method2) {
            define5(prototype, method2, function(arg) {
              return this._invoke(method2, arg);
            });
          });
        }
        function AsyncIterator(generator, PromiseImpl) {
          function invoke(method2, arg, resolve, reject) {
            var record3 = tryCatch(generator[method2], generator, arg);
            if ("throw" !== record3.type) {
              var result = record3.arg, value = result.value;
              return value && "object" == _typeof2(value) && hasOwn2.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
                invoke("next", value2, resolve, reject);
              }, function(err2) {
                invoke("throw", err2, resolve, reject);
              }) : PromiseImpl.resolve(value).then(function(unwrapped) {
                result.value = unwrapped, resolve(result);
              }, function(error2) {
                return invoke("throw", error2, resolve, reject);
              });
            }
            reject(record3.arg);
          }
          var previousPromise;
          defineProperty(this, "_invoke", {
            value: function value(method2, arg) {
              function callInvokeWithMethodAndArg() {
                return new PromiseImpl(function(resolve, reject) {
                  invoke(method2, arg, resolve, reject);
                });
              }
              return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
            }
          });
        }
        function makeInvokeMethod(innerFn, self2, context) {
          var state = "suspendedStart";
          return function(method2, arg) {
            if ("executing" === state)
              throw new Error("Generator is already running");
            if ("completed" === state) {
              if ("throw" === method2)
                throw arg;
              return doneResult();
            }
            for (context.method = method2, context.arg = arg; ; ) {
              var delegate = context.delegate;
              if (delegate) {
                var delegateResult = maybeInvokeDelegate(delegate, context);
                if (delegateResult) {
                  if (delegateResult === ContinueSentinel)
                    continue;
                  return delegateResult;
                }
              }
              if ("next" === context.method)
                context.sent = context._sent = context.arg;
              else if ("throw" === context.method) {
                if ("suspendedStart" === state)
                  throw state = "completed", context.arg;
                context.dispatchException(context.arg);
              } else
                "return" === context.method && context.abrupt("return", context.arg);
              state = "executing";
              var record3 = tryCatch(innerFn, self2, context);
              if ("normal" === record3.type) {
                if (state = context.done ? "completed" : "suspendedYield", record3.arg === ContinueSentinel)
                  continue;
                return {
                  value: record3.arg,
                  done: context.done
                };
              }
              "throw" === record3.type && (state = "completed", context.method = "throw", context.arg = record3.arg);
            }
          };
        }
        function maybeInvokeDelegate(delegate, context) {
          var methodName = context.method, method2 = delegate.iterator[methodName];
          if (void 0 === method2)
            return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
          var record3 = tryCatch(method2, delegate.iterator, context.arg);
          if ("throw" === record3.type)
            return context.method = "throw", context.arg = record3.arg, context.delegate = null, ContinueSentinel;
          var info = record3.arg;
          return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
        }
        function pushTryEntry(locs) {
          var entry = {
            tryLoc: locs[0]
          };
          1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
        }
        function resetTryEntry(entry) {
          var record3 = entry.completion || {};
          record3.type = "normal", delete record3.arg, entry.completion = record3;
        }
        function Context(tryLocsList) {
          this.tryEntries = [{
            tryLoc: "root"
          }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
        }
        function values(iterable) {
          if (iterable) {
            var iteratorMethod = iterable[iteratorSymbol];
            if (iteratorMethod)
              return iteratorMethod.call(iterable);
            if ("function" == typeof iterable.next)
              return iterable;
            if (!isNaN(iterable.length)) {
              var i = -1, next = function next2() {
                for (; ++i < iterable.length; )
                  if (hasOwn2.call(iterable, i))
                    return next2.value = iterable[i], next2.done = false, next2;
                return next2.value = void 0, next2.done = true, next2;
              };
              return next.next = next;
            }
          }
          return {
            next: doneResult
          };
        }
        function doneResult() {
          return {
            value: void 0,
            done: true
          };
        }
        return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
          value: GeneratorFunctionPrototype,
          configurable: true
        }), defineProperty(GeneratorFunctionPrototype, "constructor", {
          value: GeneratorFunction,
          configurable: true
        }), GeneratorFunction.displayName = define5(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports3.isGeneratorFunction = function(genFun) {
          var ctor = "function" == typeof genFun && genFun.constructor;
          return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
        }, exports3.mark = function(genFun) {
          return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define5(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
        }, exports3.awrap = function(arg) {
          return {
            __await: arg
          };
        }, defineIteratorMethods(AsyncIterator.prototype), define5(AsyncIterator.prototype, asyncIteratorSymbol, function() {
          return this;
        }), exports3.AsyncIterator = AsyncIterator, exports3.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
          void 0 === PromiseImpl && (PromiseImpl = Promise);
          var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
          return exports3.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
            return result.done ? result.value : iter.next();
          });
        }, defineIteratorMethods(Gp), define5(Gp, toStringTagSymbol, "Generator"), define5(Gp, iteratorSymbol, function() {
          return this;
        }), define5(Gp, "toString", function() {
          return "[object Generator]";
        }), exports3.keys = function(val) {
          var object3 = Object(val), keys = [];
          for (var key in object3)
            keys.push(key);
          return keys.reverse(), function next() {
            for (; keys.length; ) {
              var key2 = keys.pop();
              if (key2 in object3)
                return next.value = key2, next.done = false, next;
            }
            return next.done = true, next;
          };
        }, exports3.values = values, Context.prototype = {
          constructor: Context,
          reset: function reset(skipTempReset) {
            if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
              for (var name2 in this)
                "t" === name2.charAt(0) && hasOwn2.call(this, name2) && !isNaN(+name2.slice(1)) && (this[name2] = void 0);
          },
          stop: function stop() {
            this.done = true;
            var rootRecord = this.tryEntries[0].completion;
            if ("throw" === rootRecord.type)
              throw rootRecord.arg;
            return this.rval;
          },
          dispatchException: function dispatchException(exception) {
            if (this.done)
              throw exception;
            var context = this;
            function handle(loc, caught) {
              return record3.type = "throw", record3.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
            }
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i], record3 = entry.completion;
              if ("root" === entry.tryLoc)
                return handle("end");
              if (entry.tryLoc <= this.prev) {
                var hasCatch = hasOwn2.call(entry, "catchLoc"), hasFinally = hasOwn2.call(entry, "finallyLoc");
                if (hasCatch && hasFinally) {
                  if (this.prev < entry.catchLoc)
                    return handle(entry.catchLoc, true);
                  if (this.prev < entry.finallyLoc)
                    return handle(entry.finallyLoc);
                } else if (hasCatch) {
                  if (this.prev < entry.catchLoc)
                    return handle(entry.catchLoc, true);
                } else {
                  if (!hasFinally)
                    throw new Error("try statement without catch or finally");
                  if (this.prev < entry.finallyLoc)
                    return handle(entry.finallyLoc);
                }
              }
            }
          },
          abrupt: function abrupt(type5, arg) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];
              if (entry.tryLoc <= this.prev && hasOwn2.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
                var finallyEntry = entry;
                break;
              }
            }
            finallyEntry && ("break" === type5 || "continue" === type5) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
            var record3 = finallyEntry ? finallyEntry.completion : {};
            return record3.type = type5, record3.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record3);
          },
          complete: function complete(record3, afterLoc) {
            if ("throw" === record3.type)
              throw record3.arg;
            return "break" === record3.type || "continue" === record3.type ? this.next = record3.arg : "return" === record3.type ? (this.rval = this.arg = record3.arg, this.method = "return", this.next = "end") : "normal" === record3.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
          },
          finish: function finish(finallyLoc) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];
              if (entry.finallyLoc === finallyLoc)
                return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
            }
          },
          "catch": function _catch(tryLoc) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];
              if (entry.tryLoc === tryLoc) {
                var record3 = entry.completion;
                if ("throw" === record3.type) {
                  var thrown = record3.arg;
                  resetTryEntry(entry);
                }
                return thrown;
              }
            }
            throw new Error("illegal catch attempt");
          },
          delegateYield: function delegateYield(iterable, resultName, nextLoc) {
            return this.delegate = {
              iterator: values(iterable),
              resultName,
              nextLoc
            }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
          }
        }, exports3;
      }
      module2.exports = _regeneratorRuntime, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/@babel/runtime/regenerator/index.js
  var require_regenerator = __commonJS({
    "node_modules/@babel/runtime/regenerator/index.js"(exports2, module2) {
      init_virtual_process_polyfill();
      init_buffer();
      var runtime = require_regeneratorRuntime()();
      module2.exports = runtime;
      try {
        regeneratorRuntime = runtime;
      } catch (accidentalStrictMode) {
        if (typeof globalThis === "object") {
          globalThis.regeneratorRuntime = runtime;
        } else {
          Function("r", "regeneratorRuntime = r")(runtime);
        }
      }
    }
  });

  // node_modules/@babel/runtime/helpers/asyncToGenerator.js
  var require_asyncToGenerator = __commonJS({
    "node_modules/@babel/runtime/helpers/asyncToGenerator.js"(exports2, module2) {
      init_virtual_process_polyfill();
      init_buffer();
      function asyncGeneratorStep(gen2, resolve, reject, _next, _throw, key, arg) {
        try {
          var info = gen2[key](arg);
          var value = info.value;
        } catch (error2) {
          reject(error2);
          return;
        }
        if (info.done) {
          resolve(value);
        } else {
          Promise.resolve(value).then(_next, _throw);
        }
      }
      function _asyncToGenerator(fn2) {
        return function() {
          var self2 = this, args = arguments;
          return new Promise(function(resolve, reject) {
            var gen2 = fn2.apply(self2, args);
            function _next(value) {
              asyncGeneratorStep(gen2, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err2) {
              asyncGeneratorStep(gen2, resolve, reject, _next, _throw, "throw", err2);
            }
            _next(void 0);
          });
        };
      }
      module2.exports = _asyncToGenerator, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/classCallCheck.js
  var require_classCallCheck = __commonJS({
    "node_modules/@babel/runtime/helpers/classCallCheck.js"(exports2, module2) {
      init_virtual_process_polyfill();
      init_buffer();
      function _classCallCheck(instance2, Constructor) {
        if (!(instance2 instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      module2.exports = _classCallCheck, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/toPrimitive.js
  var require_toPrimitive = __commonJS({
    "node_modules/@babel/runtime/helpers/toPrimitive.js"(exports2, module2) {
      init_virtual_process_polyfill();
      init_buffer();
      var _typeof2 = require_typeof()["default"];
      function _toPrimitive2(input, hint) {
        if (_typeof2(input) !== "object" || input === null)
          return input;
        var prim = input[Symbol.toPrimitive];
        if (prim !== void 0) {
          var res = prim.call(input, hint || "default");
          if (_typeof2(res) !== "object")
            return res;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return (hint === "string" ? String : Number)(input);
      }
      module2.exports = _toPrimitive2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/toPropertyKey.js
  var require_toPropertyKey = __commonJS({
    "node_modules/@babel/runtime/helpers/toPropertyKey.js"(exports2, module2) {
      init_virtual_process_polyfill();
      init_buffer();
      var _typeof2 = require_typeof()["default"];
      var toPrimitive = require_toPrimitive();
      function _toPropertyKey2(arg) {
        var key = toPrimitive(arg, "string");
        return _typeof2(key) === "symbol" ? key : String(key);
      }
      module2.exports = _toPropertyKey2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/createClass.js
  var require_createClass = __commonJS({
    "node_modules/@babel/runtime/helpers/createClass.js"(exports2, module2) {
      init_virtual_process_polyfill();
      init_buffer();
      var toPropertyKey = require_toPropertyKey();
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", {
          writable: false
        });
        return Constructor;
      }
      module2.exports = _createClass, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/setPrototypeOf.js
  var require_setPrototypeOf = __commonJS({
    "node_modules/@babel/runtime/helpers/setPrototypeOf.js"(exports2, module2) {
      init_virtual_process_polyfill();
      init_buffer();
      function _setPrototypeOf(o, p2) {
        module2.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
          o2.__proto__ = p3;
          return o2;
        }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
        return _setPrototypeOf(o, p2);
      }
      module2.exports = _setPrototypeOf, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/inherits.js
  var require_inherits = __commonJS({
    "node_modules/@babel/runtime/helpers/inherits.js"(exports2, module2) {
      init_virtual_process_polyfill();
      init_buffer();
      var setPrototypeOf = require_setPrototypeOf();
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true
          }
        });
        Object.defineProperty(subClass, "prototype", {
          writable: false
        });
        if (superClass)
          setPrototypeOf(subClass, superClass);
      }
      module2.exports = _inherits, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/assertThisInitialized.js
  var require_assertThisInitialized = __commonJS({
    "node_modules/@babel/runtime/helpers/assertThisInitialized.js"(exports2, module2) {
      init_virtual_process_polyfill();
      init_buffer();
      function _assertThisInitialized(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      module2.exports = _assertThisInitialized, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/possibleConstructorReturn.js
  var require_possibleConstructorReturn = __commonJS({
    "node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"(exports2, module2) {
      init_virtual_process_polyfill();
      init_buffer();
      var _typeof2 = require_typeof()["default"];
      var assertThisInitialized = require_assertThisInitialized();
      function _possibleConstructorReturn(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        } else if (call !== void 0) {
          throw new TypeError("Derived constructors may only return object or undefined");
        }
        return assertThisInitialized(self2);
      }
      module2.exports = _possibleConstructorReturn, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/getPrototypeOf.js
  var require_getPrototypeOf = __commonJS({
    "node_modules/@babel/runtime/helpers/getPrototypeOf.js"(exports2, module2) {
      init_virtual_process_polyfill();
      init_buffer();
      function _getPrototypeOf(o) {
        module2.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
        return _getPrototypeOf(o);
      }
      module2.exports = _getPrototypeOf, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    }
  });

  // node_modules/rpc-websockets/dist/lib/client.js
  var require_client = __commonJS({
    "node_modules/rpc-websockets/dist/lib/client.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2["default"] = void 0;
      var _regenerator = _interopRequireDefault(require_regenerator());
      var _asyncToGenerator2 = _interopRequireDefault(require_asyncToGenerator());
      var _typeof2 = _interopRequireDefault(require_typeof());
      var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
      var _createClass2 = _interopRequireDefault(require_createClass());
      var _inherits2 = _interopRequireDefault(require_inherits());
      var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
      var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
      var _eventemitter = require_eventemitter3();
      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();
        return function _createSuperInternal() {
          var Super = (0, _getPrototypeOf2["default"])(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return (0, _possibleConstructorReturn2["default"])(this, result);
        };
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      var __rest = function(s, e) {
        var t2 = {};
        for (var p2 in s) {
          if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)
            t2[p2] = s[p2];
        }
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
            if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
              t2[p2[i]] = s[p2[i]];
          }
        return t2;
      };
      var CommonClient = /* @__PURE__ */ function(_EventEmitter) {
        (0, _inherits2["default"])(CommonClient2, _EventEmitter);
        var _super = _createSuper(CommonClient2);
        function CommonClient2(webSocketFactory) {
          var _this;
          var address = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "ws://localhost:8080";
          var _a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          var generate_request_id = arguments.length > 3 ? arguments[3] : void 0;
          (0, _classCallCheck2["default"])(this, CommonClient2);
          var _a$autoconnect = _a.autoconnect, autoconnect = _a$autoconnect === void 0 ? true : _a$autoconnect, _a$reconnect = _a.reconnect, reconnect = _a$reconnect === void 0 ? true : _a$reconnect, _a$reconnect_interval = _a.reconnect_interval, reconnect_interval = _a$reconnect_interval === void 0 ? 1e3 : _a$reconnect_interval, _a$max_reconnects = _a.max_reconnects, max_reconnects = _a$max_reconnects === void 0 ? 5 : _a$max_reconnects, rest_options = __rest(_a, ["autoconnect", "reconnect", "reconnect_interval", "max_reconnects"]);
          _this = _super.call(this);
          _this.webSocketFactory = webSocketFactory;
          _this.queue = {};
          _this.rpc_id = 0;
          _this.address = address;
          _this.autoconnect = autoconnect;
          _this.ready = false;
          _this.reconnect = reconnect;
          _this.reconnect_timer_id = void 0;
          _this.reconnect_interval = reconnect_interval;
          _this.max_reconnects = max_reconnects;
          _this.rest_options = rest_options;
          _this.current_reconnects = 0;
          _this.generate_request_id = generate_request_id || function() {
            return ++_this.rpc_id;
          };
          if (_this.autoconnect)
            _this._connect(_this.address, Object.assign({
              autoconnect: _this.autoconnect,
              reconnect: _this.reconnect,
              reconnect_interval: _this.reconnect_interval,
              max_reconnects: _this.max_reconnects
            }, _this.rest_options));
          return _this;
        }
        (0, _createClass2["default"])(CommonClient2, [{
          key: "connect",
          value: function connect2() {
            if (this.socket)
              return;
            this._connect(this.address, Object.assign({
              autoconnect: this.autoconnect,
              reconnect: this.reconnect,
              reconnect_interval: this.reconnect_interval,
              max_reconnects: this.max_reconnects
            }, this.rest_options));
          }
        }, {
          key: "call",
          value: function call(method2, params, timeout, ws_opts) {
            var _this2 = this;
            if (!ws_opts && "object" === (0, _typeof2["default"])(timeout)) {
              ws_opts = timeout;
              timeout = null;
            }
            return new Promise(function(resolve, reject) {
              if (!_this2.ready)
                return reject(new Error("socket not ready"));
              var rpc_id = _this2.generate_request_id(method2, params);
              var message = {
                jsonrpc: "2.0",
                method: method2,
                params: params || null,
                id: rpc_id
              };
              _this2.socket.send(JSON.stringify(message), ws_opts, function(error2) {
                if (error2)
                  return reject(error2);
                _this2.queue[rpc_id] = {
                  promise: [resolve, reject]
                };
                if (timeout) {
                  _this2.queue[rpc_id].timeout = setTimeout(function() {
                    delete _this2.queue[rpc_id];
                    reject(new Error("reply timeout"));
                  }, timeout);
                }
              });
            });
          }
        }, {
          key: "login",
          value: function() {
            var _login = (0, _asyncToGenerator2["default"])(/* @__PURE__ */ _regenerator["default"].mark(function _callee(params) {
              var resp;
              return _regenerator["default"].wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      _context.next = 2;
                      return this.call("rpc.login", params);
                    case 2:
                      resp = _context.sent;
                      if (resp) {
                        _context.next = 5;
                        break;
                      }
                      throw new Error("authentication failed");
                    case 5:
                      return _context.abrupt("return", resp);
                    case 6:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, this);
            }));
            function login(_x) {
              return _login.apply(this, arguments);
            }
            return login;
          }()
        }, {
          key: "listMethods",
          value: function() {
            var _listMethods = (0, _asyncToGenerator2["default"])(/* @__PURE__ */ _regenerator["default"].mark(function _callee2() {
              return _regenerator["default"].wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      _context2.next = 2;
                      return this.call("__listMethods");
                    case 2:
                      return _context2.abrupt("return", _context2.sent);
                    case 3:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2, this);
            }));
            function listMethods() {
              return _listMethods.apply(this, arguments);
            }
            return listMethods;
          }()
        }, {
          key: "notify",
          value: function notify(method2, params) {
            var _this3 = this;
            return new Promise(function(resolve, reject) {
              if (!_this3.ready)
                return reject(new Error("socket not ready"));
              var message = {
                jsonrpc: "2.0",
                method: method2,
                params: params || null
              };
              _this3.socket.send(JSON.stringify(message), function(error2) {
                if (error2)
                  return reject(error2);
                resolve();
              });
            });
          }
        }, {
          key: "subscribe",
          value: function() {
            var _subscribe = (0, _asyncToGenerator2["default"])(/* @__PURE__ */ _regenerator["default"].mark(function _callee3(event) {
              var result;
              return _regenerator["default"].wrap(function _callee3$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      if (typeof event === "string")
                        event = [event];
                      _context3.next = 3;
                      return this.call("rpc.on", event);
                    case 3:
                      result = _context3.sent;
                      if (!(typeof event === "string" && result[event] !== "ok")) {
                        _context3.next = 6;
                        break;
                      }
                      throw new Error("Failed subscribing to an event '" + event + "' with: " + result[event]);
                    case 6:
                      return _context3.abrupt("return", result);
                    case 7:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, _callee3, this);
            }));
            function subscribe(_x2) {
              return _subscribe.apply(this, arguments);
            }
            return subscribe;
          }()
        }, {
          key: "unsubscribe",
          value: function() {
            var _unsubscribe = (0, _asyncToGenerator2["default"])(/* @__PURE__ */ _regenerator["default"].mark(function _callee4(event) {
              var result;
              return _regenerator["default"].wrap(function _callee4$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:
                      if (typeof event === "string")
                        event = [event];
                      _context4.next = 3;
                      return this.call("rpc.off", event);
                    case 3:
                      result = _context4.sent;
                      if (!(typeof event === "string" && result[event] !== "ok")) {
                        _context4.next = 6;
                        break;
                      }
                      throw new Error("Failed unsubscribing from an event with: " + result);
                    case 6:
                      return _context4.abrupt("return", result);
                    case 7:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, _callee4, this);
            }));
            function unsubscribe(_x3) {
              return _unsubscribe.apply(this, arguments);
            }
            return unsubscribe;
          }()
        }, {
          key: "close",
          value: function close(code2, data) {
            this.socket.close(code2 || 1e3, data);
          }
        }, {
          key: "_connect",
          value: function _connect(address, options) {
            var _this4 = this;
            clearTimeout(this.reconnect_timer_id);
            this.socket = this.webSocketFactory(address, options);
            this.socket.addEventListener("open", function() {
              _this4.ready = true;
              _this4.emit("open");
              _this4.current_reconnects = 0;
            });
            this.socket.addEventListener("message", function(_ref) {
              var message = _ref.data;
              if (message instanceof ArrayBuffer)
                message = Buffer.from(message).toString();
              try {
                message = JSON.parse(message);
              } catch (error2) {
                return;
              }
              if (message.notification && _this4.listeners(message.notification).length) {
                if (!Object.keys(message.params).length)
                  return _this4.emit(message.notification);
                var args = [message.notification];
                if (message.params.constructor === Object)
                  args.push(message.params);
                else
                  for (var i = 0; i < message.params.length; i++) {
                    args.push(message.params[i]);
                  }
                return Promise.resolve().then(function() {
                  _this4.emit.apply(_this4, args);
                });
              }
              if (!_this4.queue[message.id]) {
                if (message.method && message.params) {
                  return Promise.resolve().then(function() {
                    _this4.emit(message.method, message.params);
                  });
                }
                return;
              }
              if ("error" in message === "result" in message)
                _this4.queue[message.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.'));
              if (_this4.queue[message.id].timeout)
                clearTimeout(_this4.queue[message.id].timeout);
              if (message.error)
                _this4.queue[message.id].promise[1](message.error);
              else
                _this4.queue[message.id].promise[0](message.result);
              delete _this4.queue[message.id];
            });
            this.socket.addEventListener("error", function(error2) {
              return _this4.emit("error", error2);
            });
            this.socket.addEventListener("close", function(_ref2) {
              var code2 = _ref2.code, reason = _ref2.reason;
              if (_this4.ready)
                setTimeout(function() {
                  return _this4.emit("close", code2, reason);
                }, 0);
              _this4.ready = false;
              _this4.socket = void 0;
              if (code2 === 1e3)
                return;
              _this4.current_reconnects++;
              if (_this4.reconnect && (_this4.max_reconnects > _this4.current_reconnects || _this4.max_reconnects === 0))
                _this4.reconnect_timer_id = setTimeout(function() {
                  return _this4._connect(address, options);
                }, _this4.reconnect_interval);
            });
          }
        }]);
        return CommonClient2;
      }(_eventemitter.EventEmitter);
      exports2["default"] = CommonClient;
    }
  });

  // node_modules/rpc-websockets/dist/lib/client/websocket.browser.js
  var require_websocket_browser = __commonJS({
    "node_modules/rpc-websockets/dist/lib/client/websocket.browser.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2["default"] = _default;
      var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
      var _createClass2 = _interopRequireDefault(require_createClass());
      var _inherits2 = _interopRequireDefault(require_inherits());
      var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
      var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
      var _eventemitter = require_eventemitter3();
      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();
        return function _createSuperInternal() {
          var Super = (0, _getPrototypeOf2["default"])(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return (0, _possibleConstructorReturn2["default"])(this, result);
        };
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      var WebSocketBrowserImpl = /* @__PURE__ */ function(_EventEmitter) {
        (0, _inherits2["default"])(WebSocketBrowserImpl2, _EventEmitter);
        var _super = _createSuper(WebSocketBrowserImpl2);
        function WebSocketBrowserImpl2(address, options, protocols) {
          var _this;
          (0, _classCallCheck2["default"])(this, WebSocketBrowserImpl2);
          _this = _super.call(this);
          _this.socket = new window.WebSocket(address, protocols);
          _this.socket.onopen = function() {
            return _this.emit("open");
          };
          _this.socket.onmessage = function(event) {
            return _this.emit("message", event.data);
          };
          _this.socket.onerror = function(error2) {
            return _this.emit("error", error2);
          };
          _this.socket.onclose = function(event) {
            _this.emit("close", event.code, event.reason);
          };
          return _this;
        }
        (0, _createClass2["default"])(WebSocketBrowserImpl2, [{
          key: "send",
          value: function send(data, optionsOrCallback, callback) {
            var cb = callback || optionsOrCallback;
            try {
              this.socket.send(data);
              cb();
            } catch (error2) {
              cb(error2);
            }
          }
        }, {
          key: "close",
          value: function close(code2, reason) {
            this.socket.close(code2, reason);
          }
        }, {
          key: "addEventListener",
          value: function addEventListener(type5, listener, options) {
            this.socket.addEventListener(type5, listener, options);
          }
        }]);
        return WebSocketBrowserImpl2;
      }(_eventemitter.EventEmitter);
      function _default(address, options) {
        return new WebSocketBrowserImpl(address, options);
      }
    }
  });

  // node_modules/@noble/hashes/esm/sha3.js
  function keccakP(s, rounds = 24) {
    const B2 = new Uint32Array(5 * 2);
    for (let round = 24 - rounds; round < 24; round++) {
      for (let x2 = 0; x2 < 10; x2++)
        B2[x2] = s[x2] ^ s[x2 + 10] ^ s[x2 + 20] ^ s[x2 + 30] ^ s[x2 + 40];
      for (let x2 = 0; x2 < 10; x2 += 2) {
        const idx1 = (x2 + 8) % 10;
        const idx0 = (x2 + 2) % 10;
        const B0 = B2[idx0];
        const B1 = B2[idx0 + 1];
        const Th = rotlH(B0, B1, 1) ^ B2[idx1];
        const Tl = rotlL(B0, B1, 1) ^ B2[idx1 + 1];
        for (let y2 = 0; y2 < 50; y2 += 10) {
          s[x2 + y2] ^= Th;
          s[x2 + y2 + 1] ^= Tl;
        }
      }
      let curH = s[2];
      let curL = s[3];
      for (let t2 = 0; t2 < 24; t2++) {
        const shift = SHA3_ROTL[t2];
        const Th = rotlH(curH, curL, shift);
        const Tl = rotlL(curH, curL, shift);
        const PI = SHA3_PI[t2];
        curH = s[PI];
        curL = s[PI + 1];
        s[PI] = Th;
        s[PI + 1] = Tl;
      }
      for (let y2 = 0; y2 < 50; y2 += 10) {
        for (let x2 = 0; x2 < 10; x2++)
          B2[x2] = s[y2 + x2];
        for (let x2 = 0; x2 < 10; x2++)
          s[y2 + x2] ^= ~B2[(x2 + 2) % 10] & B2[(x2 + 4) % 10];
      }
      s[0] ^= SHA3_IOTA_H[round];
      s[1] ^= SHA3_IOTA_L[round];
    }
    B2.fill(0);
  }
  var SHA3_PI, SHA3_ROTL, _SHA3_IOTA, _0n7, _1n7, _2n5, _7n, _256n, _0x71n, SHA3_IOTA_H, SHA3_IOTA_L, rotlH, rotlL, Keccak, gen, sha3_224, sha3_256, sha3_384, sha3_512, keccak_224, keccak_256, keccak_384, keccak_512, genShake, shake128, shake256;
  var init_sha3 = __esm({
    "node_modules/@noble/hashes/esm/sha3.js"() {
      init_virtual_process_polyfill();
      init_buffer();
      init_assert();
      init_u64();
      init_utils();
      [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
      _0n7 = BigInt(0);
      _1n7 = BigInt(1);
      _2n5 = BigInt(2);
      _7n = BigInt(7);
      _256n = BigInt(256);
      _0x71n = BigInt(113);
      for (let round = 0, R2 = _1n7, x2 = 1, y2 = 0; round < 24; round++) {
        [x2, y2] = [y2, (2 * x2 + 3 * y2) % 5];
        SHA3_PI.push(2 * (5 * y2 + x2));
        SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
        let t2 = _0n7;
        for (let j2 = 0; j2 < 7; j2++) {
          R2 = (R2 << _1n7 ^ (R2 >> _7n) * _0x71n) % _256n;
          if (R2 & _2n5)
            t2 ^= _1n7 << (_1n7 << BigInt(j2)) - _1n7;
        }
        _SHA3_IOTA.push(t2);
      }
      [SHA3_IOTA_H, SHA3_IOTA_L] = u64_default.split(_SHA3_IOTA, true);
      rotlH = (h2, l2, s) => s > 32 ? u64_default.rotlBH(h2, l2, s) : u64_default.rotlSH(h2, l2, s);
      rotlL = (h2, l2, s) => s > 32 ? u64_default.rotlBL(h2, l2, s) : u64_default.rotlSL(h2, l2, s);
      Keccak = class extends Hash {
        constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
          super();
          this.blockLen = blockLen;
          this.suffix = suffix;
          this.outputLen = outputLen;
          this.enableXOF = enableXOF;
          this.rounds = rounds;
          this.pos = 0;
          this.posOut = 0;
          this.finished = false;
          this.destroyed = false;
          assert_default.number(outputLen);
          if (0 >= this.blockLen || this.blockLen >= 200)
            throw new Error("Sha3 supports only keccak-f1600 function");
          this.state = new Uint8Array(200);
          this.state32 = u32(this.state);
        }
        keccak() {
          keccakP(this.state32, this.rounds);
          this.posOut = 0;
          this.pos = 0;
        }
        update(data) {
          assert_default.exists(this);
          const { blockLen, state } = this;
          data = toBytes(data);
          const len = data.length;
          for (let pos = 0; pos < len; ) {
            const take = Math.min(blockLen - this.pos, len - pos);
            for (let i = 0; i < take; i++)
              state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen)
              this.keccak();
          }
          return this;
        }
        finish() {
          if (this.finished)
            return;
          this.finished = true;
          const { state, suffix, pos, blockLen } = this;
          state[pos] ^= suffix;
          if ((suffix & 128) !== 0 && pos === blockLen - 1)
            this.keccak();
          state[blockLen - 1] ^= 128;
          this.keccak();
        }
        writeInto(out) {
          assert_default.exists(this, false);
          assert_default.bytes(out);
          this.finish();
          const bufferOut = this.state;
          const { blockLen } = this;
          for (let pos = 0, len = out.length; pos < len; ) {
            if (this.posOut >= blockLen)
              this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
          }
          return out;
        }
        xofInto(out) {
          if (!this.enableXOF)
            throw new Error("XOF is not possible for this instance");
          return this.writeInto(out);
        }
        xof(bytes2) {
          assert_default.number(bytes2);
          return this.xofInto(new Uint8Array(bytes2));
        }
        digestInto(out) {
          assert_default.output(out, this);
          if (this.finished)
            throw new Error("digest() was already called");
          this.writeInto(out);
          this.destroy();
          return out;
        }
        digest() {
          return this.digestInto(new Uint8Array(this.outputLen));
        }
        destroy() {
          this.destroyed = true;
          this.state.fill(0);
        }
        _cloneInto(to) {
          const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
          to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
          to.state32.set(this.state32);
          to.pos = this.pos;
          to.posOut = this.posOut;
          to.finished = this.finished;
          to.rounds = rounds;
          to.suffix = suffix;
          to.outputLen = outputLen;
          to.enableXOF = enableXOF;
          to.destroyed = this.destroyed;
          return to;
        }
      };
      gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
      sha3_224 = gen(6, 144, 224 / 8);
      sha3_256 = gen(6, 136, 256 / 8);
      sha3_384 = gen(6, 104, 384 / 8);
      sha3_512 = gen(6, 72, 512 / 8);
      keccak_224 = gen(1, 144, 224 / 8);
      keccak_256 = gen(1, 136, 256 / 8);
      keccak_384 = gen(1, 104, 384 / 8);
      keccak_512 = gen(1, 72, 512 / 8);
      genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
      shake128 = genShake(31, 168, 128 / 8);
      shake256 = genShake(31, 136, 256 / 8);
    }
  });

  // node_modules/@noble/curves/esm/abstract/weierstrass.js
  function validatePointOpts(curve) {
    const opts = validateBasic(curve);
    validateObject(opts, {
      a: "field",
      b: "field"
    }, {
      allowedPrivateKeyLengths: "array",
      wrapPrivateKey: "boolean",
      isTorsionFree: "function",
      clearCofactor: "function",
      allowInfinityPoint: "boolean",
      fromBytes: "function",
      toBytes: "function"
    });
    const { endo, Fp: Fp3, a } = opts;
    if (endo) {
      if (!Fp3.eql(a, Fp3.ZERO)) {
        throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
      }
      if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
        throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
      }
    }
    return Object.freeze({ ...opts });
  }
  function weierstrassPoints(opts) {
    const CURVE = validatePointOpts(opts);
    const { Fp: Fp3 } = CURVE;
    const toBytes2 = CURVE.toBytes || ((c2, point, isCompressed) => {
      const a = point.toAffine();
      return concatBytes2(Uint8Array.from([4]), Fp3.toBytes(a.x), Fp3.toBytes(a.y));
    });
    const fromBytes = CURVE.fromBytes || ((bytes2) => {
      const tail = bytes2.subarray(1);
      const x2 = Fp3.fromBytes(tail.subarray(0, Fp3.BYTES));
      const y2 = Fp3.fromBytes(tail.subarray(Fp3.BYTES, 2 * Fp3.BYTES));
      return { x: x2, y: y2 };
    });
    function weierstrassEquation(x2) {
      const { a, b: b2 } = CURVE;
      const x22 = Fp3.sqr(x2);
      const x3 = Fp3.mul(x22, x2);
      return Fp3.add(Fp3.add(x3, Fp3.mul(x2, a)), b2);
    }
    if (!Fp3.eql(Fp3.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
      throw new Error("bad generator point: equation left != right");
    function isWithinCurveOrder(num) {
      return typeof num === "bigint" && _0n8 < num && num < CURVE.n;
    }
    function assertGE(num) {
      if (!isWithinCurveOrder(num))
        throw new Error("Expected valid bigint: 0 < bigint < curve.n");
    }
    function normPrivateKeyToScalar(key) {
      const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
      if (lengths && typeof key !== "bigint") {
        if (key instanceof Uint8Array)
          key = bytesToHex(key);
        if (typeof key !== "string" || !lengths.includes(key.length))
          throw new Error("Invalid key");
        key = key.padStart(nByteLength * 2, "0");
      }
      let num;
      try {
        num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
      } catch (error2) {
        throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
      }
      if (wrapPrivateKey)
        num = mod(num, n);
      assertGE(num);
      return num;
    }
    const pointPrecomputes = /* @__PURE__ */ new Map();
    function assertPrjPoint(other) {
      if (!(other instanceof Point2))
        throw new Error("ProjectivePoint expected");
    }
    class Point2 {
      constructor(px, py, pz) {
        this.px = px;
        this.py = py;
        this.pz = pz;
        if (px == null || !Fp3.isValid(px))
          throw new Error("x required");
        if (py == null || !Fp3.isValid(py))
          throw new Error("y required");
        if (pz == null || !Fp3.isValid(pz))
          throw new Error("z required");
      }
      static fromAffine(p2) {
        const { x: x2, y: y2 } = p2 || {};
        if (!p2 || !Fp3.isValid(x2) || !Fp3.isValid(y2))
          throw new Error("invalid affine point");
        if (p2 instanceof Point2)
          throw new Error("projective point not allowed");
        const is0 = (i) => Fp3.eql(i, Fp3.ZERO);
        if (is0(x2) && is0(y2))
          return Point2.ZERO;
        return new Point2(x2, y2, Fp3.ONE);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      static normalizeZ(points) {
        const toInv = Fp3.invertBatch(points.map((p2) => p2.pz));
        return points.map((p2, i) => p2.toAffine(toInv[i])).map(Point2.fromAffine);
      }
      static fromHex(hex) {
        const P2 = Point2.fromAffine(fromBytes(ensureBytes("pointHex", hex)));
        P2.assertValidity();
        return P2;
      }
      static fromPrivateKey(privateKey) {
        return Point2.BASE.multiply(normPrivateKeyToScalar(privateKey));
      }
      _setWindowSize(windowSize) {
        this._WINDOW_SIZE = windowSize;
        pointPrecomputes.delete(this);
      }
      assertValidity() {
        if (this.is0()) {
          if (CURVE.allowInfinityPoint)
            return;
          throw new Error("bad point: ZERO");
        }
        const { x: x2, y: y2 } = this.toAffine();
        if (!Fp3.isValid(x2) || !Fp3.isValid(y2))
          throw new Error("bad point: x or y not FE");
        const left = Fp3.sqr(y2);
        const right = weierstrassEquation(x2);
        if (!Fp3.eql(left, right))
          throw new Error("bad point: equation left != right");
        if (!this.isTorsionFree())
          throw new Error("bad point: not in prime-order subgroup");
      }
      hasEvenY() {
        const { y: y2 } = this.toAffine();
        if (Fp3.isOdd)
          return !Fp3.isOdd(y2);
        throw new Error("Field doesn't support isOdd");
      }
      equals(other) {
        assertPrjPoint(other);
        const { px: X1, py: Y1, pz: Z1 } = this;
        const { px: X2, py: Y2, pz: Z2 } = other;
        const U1 = Fp3.eql(Fp3.mul(X1, Z2), Fp3.mul(X2, Z1));
        const U2 = Fp3.eql(Fp3.mul(Y1, Z2), Fp3.mul(Y2, Z1));
        return U1 && U2;
      }
      negate() {
        return new Point2(this.px, Fp3.neg(this.py), this.pz);
      }
      double() {
        const { a, b: b2 } = CURVE;
        const b3 = Fp3.mul(b2, _3n2);
        const { px: X1, py: Y1, pz: Z1 } = this;
        let X3 = Fp3.ZERO, Y3 = Fp3.ZERO, Z3 = Fp3.ZERO;
        let t0 = Fp3.mul(X1, X1);
        let t1 = Fp3.mul(Y1, Y1);
        let t2 = Fp3.mul(Z1, Z1);
        let t3 = Fp3.mul(X1, Y1);
        t3 = Fp3.add(t3, t3);
        Z3 = Fp3.mul(X1, Z1);
        Z3 = Fp3.add(Z3, Z3);
        X3 = Fp3.mul(a, Z3);
        Y3 = Fp3.mul(b3, t2);
        Y3 = Fp3.add(X3, Y3);
        X3 = Fp3.sub(t1, Y3);
        Y3 = Fp3.add(t1, Y3);
        Y3 = Fp3.mul(X3, Y3);
        X3 = Fp3.mul(t3, X3);
        Z3 = Fp3.mul(b3, Z3);
        t2 = Fp3.mul(a, t2);
        t3 = Fp3.sub(t0, t2);
        t3 = Fp3.mul(a, t3);
        t3 = Fp3.add(t3, Z3);
        Z3 = Fp3.add(t0, t0);
        t0 = Fp3.add(Z3, t0);
        t0 = Fp3.add(t0, t2);
        t0 = Fp3.mul(t0, t3);
        Y3 = Fp3.add(Y3, t0);
        t2 = Fp3.mul(Y1, Z1);
        t2 = Fp3.add(t2, t2);
        t0 = Fp3.mul(t2, t3);
        X3 = Fp3.sub(X3, t0);
        Z3 = Fp3.mul(t2, t1);
        Z3 = Fp3.add(Z3, Z3);
        Z3 = Fp3.add(Z3, Z3);
        return new Point2(X3, Y3, Z3);
      }
      add(other) {
        assertPrjPoint(other);
        const { px: X1, py: Y1, pz: Z1 } = this;
        const { px: X2, py: Y2, pz: Z2 } = other;
        let X3 = Fp3.ZERO, Y3 = Fp3.ZERO, Z3 = Fp3.ZERO;
        const a = CURVE.a;
        const b3 = Fp3.mul(CURVE.b, _3n2);
        let t0 = Fp3.mul(X1, X2);
        let t1 = Fp3.mul(Y1, Y2);
        let t2 = Fp3.mul(Z1, Z2);
        let t3 = Fp3.add(X1, Y1);
        let t4 = Fp3.add(X2, Y2);
        t3 = Fp3.mul(t3, t4);
        t4 = Fp3.add(t0, t1);
        t3 = Fp3.sub(t3, t4);
        t4 = Fp3.add(X1, Z1);
        let t5 = Fp3.add(X2, Z2);
        t4 = Fp3.mul(t4, t5);
        t5 = Fp3.add(t0, t2);
        t4 = Fp3.sub(t4, t5);
        t5 = Fp3.add(Y1, Z1);
        X3 = Fp3.add(Y2, Z2);
        t5 = Fp3.mul(t5, X3);
        X3 = Fp3.add(t1, t2);
        t5 = Fp3.sub(t5, X3);
        Z3 = Fp3.mul(a, t4);
        X3 = Fp3.mul(b3, t2);
        Z3 = Fp3.add(X3, Z3);
        X3 = Fp3.sub(t1, Z3);
        Z3 = Fp3.add(t1, Z3);
        Y3 = Fp3.mul(X3, Z3);
        t1 = Fp3.add(t0, t0);
        t1 = Fp3.add(t1, t0);
        t2 = Fp3.mul(a, t2);
        t4 = Fp3.mul(b3, t4);
        t1 = Fp3.add(t1, t2);
        t2 = Fp3.sub(t0, t2);
        t2 = Fp3.mul(a, t2);
        t4 = Fp3.add(t4, t2);
        t0 = Fp3.mul(t1, t4);
        Y3 = Fp3.add(Y3, t0);
        t0 = Fp3.mul(t5, t4);
        X3 = Fp3.mul(t3, X3);
        X3 = Fp3.sub(X3, t0);
        t0 = Fp3.mul(t3, t1);
        Z3 = Fp3.mul(t5, Z3);
        Z3 = Fp3.add(Z3, t0);
        return new Point2(X3, Y3, Z3);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      is0() {
        return this.equals(Point2.ZERO);
      }
      wNAF(n) {
        return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {
          const toInv = Fp3.invertBatch(comp.map((p2) => p2.pz));
          return comp.map((p2, i) => p2.toAffine(toInv[i])).map(Point2.fromAffine);
        });
      }
      multiplyUnsafe(n) {
        const I2 = Point2.ZERO;
        if (n === _0n8)
          return I2;
        assertGE(n);
        if (n === _1n8)
          return this;
        const { endo } = CURVE;
        if (!endo)
          return wnaf.unsafeLadder(this, n);
        let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
        let k1p = I2;
        let k2p = I2;
        let d2 = this;
        while (k1 > _0n8 || k2 > _0n8) {
          if (k1 & _1n8)
            k1p = k1p.add(d2);
          if (k2 & _1n8)
            k2p = k2p.add(d2);
          d2 = d2.double();
          k1 >>= _1n8;
          k2 >>= _1n8;
        }
        if (k1neg)
          k1p = k1p.negate();
        if (k2neg)
          k2p = k2p.negate();
        k2p = new Point2(Fp3.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        return k1p.add(k2p);
      }
      multiply(scalar) {
        assertGE(scalar);
        let n = scalar;
        let point, fake;
        const { endo } = CURVE;
        if (endo) {
          const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
          let { p: k1p, f: f1p } = this.wNAF(k1);
          let { p: k2p, f: f2p } = this.wNAF(k2);
          k1p = wnaf.constTimeNegate(k1neg, k1p);
          k2p = wnaf.constTimeNegate(k2neg, k2p);
          k2p = new Point2(Fp3.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
          point = k1p.add(k2p);
          fake = f1p.add(f2p);
        } else {
          const { p: p2, f: f3 } = this.wNAF(n);
          point = p2;
          fake = f3;
        }
        return Point2.normalizeZ([point, fake])[0];
      }
      multiplyAndAddUnsafe(Q2, a, b2) {
        const G2 = Point2.BASE;
        const mul = (P2, a2) => a2 === _0n8 || a2 === _1n8 || !P2.equals(G2) ? P2.multiplyUnsafe(a2) : P2.multiply(a2);
        const sum = mul(this, a).add(mul(Q2, b2));
        return sum.is0() ? void 0 : sum;
      }
      toAffine(iz) {
        const { px: x2, py: y2, pz: z2 } = this;
        const is0 = this.is0();
        if (iz == null)
          iz = is0 ? Fp3.ONE : Fp3.inv(z2);
        const ax = Fp3.mul(x2, iz);
        const ay = Fp3.mul(y2, iz);
        const zz = Fp3.mul(z2, iz);
        if (is0)
          return { x: Fp3.ZERO, y: Fp3.ZERO };
        if (!Fp3.eql(zz, Fp3.ONE))
          throw new Error("invZ was invalid");
        return { x: ax, y: ay };
      }
      isTorsionFree() {
        const { h: cofactor, isTorsionFree } = CURVE;
        if (cofactor === _1n8)
          return true;
        if (isTorsionFree)
          return isTorsionFree(Point2, this);
        throw new Error("isTorsionFree() has not been declared for the elliptic curve");
      }
      clearCofactor() {
        const { h: cofactor, clearCofactor } = CURVE;
        if (cofactor === _1n8)
          return this;
        if (clearCofactor)
          return clearCofactor(Point2, this);
        return this.multiplyUnsafe(CURVE.h);
      }
      toRawBytes(isCompressed = true) {
        this.assertValidity();
        return toBytes2(Point2, this, isCompressed);
      }
      toHex(isCompressed = true) {
        return bytesToHex(this.toRawBytes(isCompressed));
      }
    }
    Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, Fp3.ONE);
    Point2.ZERO = new Point2(Fp3.ZERO, Fp3.ONE, Fp3.ZERO);
    const _bits = CURVE.nBitLength;
    const wnaf = wNAF(Point2, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
    return {
      CURVE,
      ProjectivePoint: Point2,
      normPrivateKeyToScalar,
      weierstrassEquation,
      isWithinCurveOrder
    };
  }
  function validateOpts2(curve) {
    const opts = validateBasic(curve);
    validateObject(opts, {
      hash: "hash",
      hmac: "function",
      randomBytes: "function"
    }, {
      bits2int: "function",
      bits2int_modN: "function",
      lowS: "boolean"
    });
    return Object.freeze({ lowS: true, ...opts });
  }
  function weierstrass(curveDef) {
    const CURVE = validateOpts2(curveDef);
    const { Fp: Fp3, n: CURVE_ORDER } = CURVE;
    const compressedLen = Fp3.BYTES + 1;
    const uncompressedLen = 2 * Fp3.BYTES + 1;
    function isValidFieldElement(num) {
      return _0n8 < num && num < Fp3.ORDER;
    }
    function modN(a) {
      return mod(a, CURVE_ORDER);
    }
    function invN(a) {
      return invert(a, CURVE_ORDER);
    }
    const { ProjectivePoint: Point2, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
      ...CURVE,
      toBytes(c2, point, isCompressed) {
        const a = point.toAffine();
        const x2 = Fp3.toBytes(a.x);
        const cat = concatBytes2;
        if (isCompressed) {
          return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x2);
        } else {
          return cat(Uint8Array.from([4]), x2, Fp3.toBytes(a.y));
        }
      },
      fromBytes(bytes2) {
        const len = bytes2.length;
        const head = bytes2[0];
        const tail = bytes2.subarray(1);
        if (len === compressedLen && (head === 2 || head === 3)) {
          const x2 = bytesToNumberBE(tail);
          if (!isValidFieldElement(x2))
            throw new Error("Point is not on curve");
          const y2 = weierstrassEquation(x2);
          let y3 = Fp3.sqrt(y2);
          const isYOdd = (y3 & _1n8) === _1n8;
          const isHeadOdd = (head & 1) === 1;
          if (isHeadOdd !== isYOdd)
            y3 = Fp3.neg(y3);
          return { x: x2, y: y3 };
        } else if (len === uncompressedLen && head === 4) {
          const x2 = Fp3.fromBytes(tail.subarray(0, Fp3.BYTES));
          const y2 = Fp3.fromBytes(tail.subarray(Fp3.BYTES, 2 * Fp3.BYTES));
          return { x: x2, y: y2 };
        } else {
          throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
        }
      }
    });
    const numToNByteStr = (num) => bytesToHex(numberToBytesBE(num, CURVE.nByteLength));
    function isBiggerThanHalfOrder(number5) {
      const HALF = CURVE_ORDER >> _1n8;
      return number5 > HALF;
    }
    function normalizeS(s) {
      return isBiggerThanHalfOrder(s) ? modN(-s) : s;
    }
    const slcNum = (b2, from2, to) => bytesToNumberBE(b2.slice(from2, to));
    class Signature {
      constructor(r, s, recovery) {
        this.r = r;
        this.s = s;
        this.recovery = recovery;
        this.assertValidity();
      }
      static fromCompact(hex) {
        const l2 = CURVE.nByteLength;
        hex = ensureBytes("compactSignature", hex, l2 * 2);
        return new Signature(slcNum(hex, 0, l2), slcNum(hex, l2, 2 * l2));
      }
      static fromDER(hex) {
        const { r, s } = DER.toSig(ensureBytes("DER", hex));
        return new Signature(r, s);
      }
      assertValidity() {
        if (!isWithinCurveOrder(this.r))
          throw new Error("r must be 0 < r < CURVE.n");
        if (!isWithinCurveOrder(this.s))
          throw new Error("s must be 0 < s < CURVE.n");
      }
      addRecoveryBit(recovery) {
        return new Signature(this.r, this.s, recovery);
      }
      recoverPublicKey(msgHash) {
        const { r, s, recovery: rec } = this;
        const h2 = bits2int_modN(ensureBytes("msgHash", msgHash));
        if (rec == null || ![0, 1, 2, 3].includes(rec))
          throw new Error("recovery id invalid");
        const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
        if (radj >= Fp3.ORDER)
          throw new Error("recovery id 2 or 3 invalid");
        const prefix = (rec & 1) === 0 ? "02" : "03";
        const R2 = Point2.fromHex(prefix + numToNByteStr(radj));
        const ir = invN(radj);
        const u1 = modN(-h2 * ir);
        const u2 = modN(s * ir);
        const Q2 = Point2.BASE.multiplyAndAddUnsafe(R2, u1, u2);
        if (!Q2)
          throw new Error("point at infinify");
        Q2.assertValidity();
        return Q2;
      }
      hasHighS() {
        return isBiggerThanHalfOrder(this.s);
      }
      normalizeS() {
        return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
      }
      toDERRawBytes() {
        return hexToBytes(this.toDERHex());
      }
      toDERHex() {
        return DER.hexFromSig({ r: this.r, s: this.s });
      }
      toCompactRawBytes() {
        return hexToBytes(this.toCompactHex());
      }
      toCompactHex() {
        return numToNByteStr(this.r) + numToNByteStr(this.s);
      }
    }
    const utils = {
      isValidPrivateKey(privateKey) {
        try {
          normPrivateKeyToScalar(privateKey);
          return true;
        } catch (error2) {
          return false;
        }
      },
      normPrivateKeyToScalar,
      randomPrivateKey: () => {
        const rand = CURVE.randomBytes(Fp3.BYTES + 8);
        const num = hashToPrivateScalar(rand, CURVE_ORDER);
        return numberToBytesBE(num, CURVE.nByteLength);
      },
      precompute(windowSize = 8, point = Point2.BASE) {
        point._setWindowSize(windowSize);
        point.multiply(BigInt(3));
        return point;
      }
    };
    function getPublicKey2(privateKey, isCompressed = true) {
      return Point2.fromPrivateKey(privateKey).toRawBytes(isCompressed);
    }
    function isProbPub(item) {
      const arr = item instanceof Uint8Array;
      const str3 = typeof item === "string";
      const len = (arr || str3) && item.length;
      if (arr)
        return len === compressedLen || len === uncompressedLen;
      if (str3)
        return len === 2 * compressedLen || len === 2 * uncompressedLen;
      if (item instanceof Point2)
        return true;
      return false;
    }
    function getSharedSecret(privateA, publicB, isCompressed = true) {
      if (isProbPub(privateA))
        throw new Error("first arg must be private key");
      if (!isProbPub(publicB))
        throw new Error("second arg must be public key");
      const b2 = Point2.fromHex(publicB);
      return b2.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
    }
    const bits2int = CURVE.bits2int || function(bytes2) {
      const num = bytesToNumberBE(bytes2);
      const delta = bytes2.length * 8 - CURVE.nBitLength;
      return delta > 0 ? num >> BigInt(delta) : num;
    };
    const bits2int_modN = CURVE.bits2int_modN || function(bytes2) {
      return modN(bits2int(bytes2));
    };
    const ORDER_MASK = bitMask(CURVE.nBitLength);
    function int2octets(num) {
      if (typeof num !== "bigint")
        throw new Error("bigint expected");
      if (!(_0n8 <= num && num < ORDER_MASK))
        throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
      return numberToBytesBE(num, CURVE.nByteLength);
    }
    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
      if (["recovered", "canonical"].some((k2) => k2 in opts))
        throw new Error("sign() legacy options not supported");
      const { hash: hash2, randomBytes: randomBytes2 } = CURVE;
      let { lowS, prehash, extraEntropy: ent } = opts;
      if (lowS == null)
        lowS = true;
      msgHash = ensureBytes("msgHash", msgHash);
      if (prehash)
        msgHash = ensureBytes("prehashed msgHash", hash2(msgHash));
      const h1int = bits2int_modN(msgHash);
      const d2 = normPrivateKeyToScalar(privateKey);
      const seedArgs = [int2octets(d2), int2octets(h1int)];
      if (ent != null) {
        const e = ent === true ? randomBytes2(Fp3.BYTES) : ent;
        seedArgs.push(ensureBytes("extraEntropy", e, Fp3.BYTES));
      }
      const seed2 = concatBytes2(...seedArgs);
      const m = h1int;
      function k2sig(kBytes) {
        const k2 = bits2int(kBytes);
        if (!isWithinCurveOrder(k2))
          return;
        const ik = invN(k2);
        const q2 = Point2.BASE.multiply(k2).toAffine();
        const r = modN(q2.x);
        if (r === _0n8)
          return;
        const s = modN(ik * modN(m + r * d2));
        if (s === _0n8)
          return;
        let recovery = (q2.x === r ? 0 : 2) | Number(q2.y & _1n8);
        let normS = s;
        if (lowS && isBiggerThanHalfOrder(s)) {
          normS = normalizeS(s);
          recovery ^= 1;
        }
        return new Signature(r, normS, recovery);
      }
      return { seed: seed2, k2sig };
    }
    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
    function sign2(msgHash, privKey, opts = defaultSigOpts) {
      const { seed: seed2, k2sig } = prepSig(msgHash, privKey, opts);
      const C2 = CURVE;
      const drbg = createHmacDrbg(C2.hash.outputLen, C2.nByteLength, C2.hmac);
      return drbg(seed2, k2sig);
    }
    Point2.BASE._setWindowSize(8);
    function verify2(signature2, msgHash, publicKey6, opts = defaultVerOpts) {
      const sg = signature2;
      msgHash = ensureBytes("msgHash", msgHash);
      publicKey6 = ensureBytes("publicKey", publicKey6);
      if ("strict" in opts)
        throw new Error("options.strict was renamed to lowS");
      const { lowS, prehash } = opts;
      let _sig = void 0;
      let P2;
      try {
        if (typeof sg === "string" || sg instanceof Uint8Array) {
          try {
            _sig = Signature.fromDER(sg);
          } catch (derError) {
            if (!(derError instanceof DER.Err))
              throw derError;
            _sig = Signature.fromCompact(sg);
          }
        } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
          const { r: r2, s: s2 } = sg;
          _sig = new Signature(r2, s2);
        } else {
          throw new Error("PARSE");
        }
        P2 = Point2.fromHex(publicKey6);
      } catch (error2) {
        if (error2.message === "PARSE")
          throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
        return false;
      }
      if (lowS && _sig.hasHighS())
        return false;
      if (prehash)
        msgHash = CURVE.hash(msgHash);
      const { r, s } = _sig;
      const h2 = bits2int_modN(msgHash);
      const is4 = invN(s);
      const u1 = modN(h2 * is4);
      const u2 = modN(r * is4);
      const R2 = Point2.BASE.multiplyAndAddUnsafe(P2, u1, u2)?.toAffine();
      if (!R2)
        return false;
      const v2 = modN(R2.x);
      return v2 === r;
    }
    return {
      CURVE,
      getPublicKey: getPublicKey2,
      getSharedSecret,
      sign: sign2,
      verify: verify2,
      ProjectivePoint: Point2,
      Signature,
      utils
    };
  }
  var b2n, h2b, DER, _0n8, _1n8, _2n6, _3n2, _4n2;
  var init_weierstrass = __esm({
    "node_modules/@noble/curves/esm/abstract/weierstrass.js"() {
      init_virtual_process_polyfill();
      init_buffer();
      init_modular();
      init_utils2();
      init_utils2();
      init_curve();
      ({ bytesToNumberBE: b2n, hexToBytes: h2b } = utils_exports);
      DER = {
        Err: class DERErr extends Error {
          constructor(m = "") {
            super(m);
          }
        },
        _parseInt(data) {
          const { Err: E2 } = DER;
          if (data.length < 2 || data[0] !== 2)
            throw new E2("Invalid signature integer tag");
          const len = data[1];
          const res = data.subarray(2, len + 2);
          if (!len || res.length !== len)
            throw new E2("Invalid signature integer: wrong length");
          if (res[0] & 128)
            throw new E2("Invalid signature integer: negative");
          if (res[0] === 0 && !(res[1] & 128))
            throw new E2("Invalid signature integer: unnecessary leading zero");
          return { d: b2n(res), l: data.subarray(len + 2) };
        },
        toSig(hex) {
          const { Err: E2 } = DER;
          const data = typeof hex === "string" ? h2b(hex) : hex;
          if (!(data instanceof Uint8Array))
            throw new Error("ui8a expected");
          let l2 = data.length;
          if (l2 < 2 || data[0] != 48)
            throw new E2("Invalid signature tag");
          if (data[1] !== l2 - 2)
            throw new E2("Invalid signature: incorrect length");
          const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));
          const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);
          if (rBytesLeft.length)
            throw new E2("Invalid signature: left bytes after parsing");
          return { r, s };
        },
        hexFromSig(sig) {
          const slice2 = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
          const h2 = (num) => {
            const hex = num.toString(16);
            return hex.length & 1 ? `0${hex}` : hex;
          };
          const s = slice2(h2(sig.s));
          const r = slice2(h2(sig.r));
          const shl = s.length / 2;
          const rhl = r.length / 2;
          const sl = h2(shl);
          const rl = h2(rhl);
          return `30${h2(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
        }
      };
      _0n8 = BigInt(0);
      _1n8 = BigInt(1);
      _2n6 = BigInt(2);
      _3n2 = BigInt(3);
      _4n2 = BigInt(4);
    }
  });

  // node_modules/@noble/hashes/esm/hmac.js
  var HMAC, hmac;
  var init_hmac = __esm({
    "node_modules/@noble/hashes/esm/hmac.js"() {
      init_virtual_process_polyfill();
      init_buffer();
      init_assert();
      init_utils();
      HMAC = class extends Hash {
        constructor(hash2, _key) {
          super();
          this.finished = false;
          this.destroyed = false;
          assert_default.hash(hash2);
          const key = toBytes(_key);
          this.iHash = hash2.create();
          if (typeof this.iHash.update !== "function")
            throw new Error("Expected instance of class which extends utils.Hash");
          this.blockLen = this.iHash.blockLen;
          this.outputLen = this.iHash.outputLen;
          const blockLen = this.blockLen;
          const pad = new Uint8Array(blockLen);
          pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
          for (let i = 0; i < pad.length; i++)
            pad[i] ^= 54;
          this.iHash.update(pad);
          this.oHash = hash2.create();
          for (let i = 0; i < pad.length; i++)
            pad[i] ^= 54 ^ 92;
          this.oHash.update(pad);
          pad.fill(0);
        }
        update(buf) {
          assert_default.exists(this);
          this.iHash.update(buf);
          return this;
        }
        digestInto(out) {
          assert_default.exists(this);
          assert_default.bytes(out, this.outputLen);
          this.finished = true;
          this.iHash.digestInto(out);
          this.oHash.update(out);
          this.oHash.digestInto(out);
          this.destroy();
        }
        digest() {
          const out = new Uint8Array(this.oHash.outputLen);
          this.digestInto(out);
          return out;
        }
        _cloneInto(to) {
          to || (to = Object.create(Object.getPrototypeOf(this), {}));
          const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
          to = to;
          to.finished = finished;
          to.destroyed = destroyed;
          to.blockLen = blockLen;
          to.outputLen = outputLen;
          to.oHash = oHash._cloneInto(to.oHash);
          to.iHash = iHash._cloneInto(to.iHash);
          return to;
        }
        destroy() {
          this.destroyed = true;
          this.oHash.destroy();
          this.iHash.destroy();
        }
      };
      hmac = (hash2, key, message) => new HMAC(hash2, key).update(message).digest();
      hmac.create = (hash2, key) => new HMAC(hash2, key);
    }
  });

  // node_modules/@noble/curves/esm/_shortw_utils.js
  function getHash(hash2) {
    return {
      hash: hash2,
      hmac: (key, ...msgs) => hmac(hash2, key, concatBytes(...msgs)),
      randomBytes
    };
  }
  function createCurve(curveDef, defHash) {
    const create5 = (hash2) => weierstrass({ ...curveDef, ...getHash(hash2) });
    return Object.freeze({ ...create5(defHash), create: create5 });
  }
  var init_shortw_utils = __esm({
    "node_modules/@noble/curves/esm/_shortw_utils.js"() {
      init_virtual_process_polyfill();
      init_buffer();
      init_hmac();
      init_utils();
      init_weierstrass();
    }
  });

  // node_modules/@noble/curves/esm/secp256k1.js
  function sqrtMod(y2) {
    const P2 = secp256k1P;
    const _3n3 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
    const b2 = y2 * y2 * y2 % P2;
    const b3 = b2 * b2 * y2 % P2;
    const b6 = pow2(b3, _3n3, P2) * b3 % P2;
    const b9 = pow2(b6, _3n3, P2) * b3 % P2;
    const b11 = pow2(b9, _2n7, P2) * b2 % P2;
    const b22 = pow2(b11, _11n, P2) * b11 % P2;
    const b44 = pow2(b22, _22n, P2) * b22 % P2;
    const b88 = pow2(b44, _44n, P2) * b44 % P2;
    const b176 = pow2(b88, _88n, P2) * b88 % P2;
    const b220 = pow2(b176, _44n, P2) * b44 % P2;
    const b223 = pow2(b220, _3n3, P2) * b3 % P2;
    const t1 = pow2(b223, _23n, P2) * b22 % P2;
    const t2 = pow2(t1, _6n, P2) * b2 % P2;
    const root2 = pow2(t2, _2n7, P2);
    if (!Fp2.eql(Fp2.sqr(root2), y2))
      throw new Error("Cannot find square root");
    return root2;
  }
  var secp256k1P, secp256k1N, _1n9, _2n7, divNearest, Fp2, secp256k1, _0n9, Point;
  var init_secp256k1 = __esm({
    "node_modules/@noble/curves/esm/secp256k1.js"() {
      init_virtual_process_polyfill();
      init_buffer();
      init_sha256();
      init_utils();
      init_modular();
      init_weierstrass();
      init_utils2();
      init_hash_to_curve();
      init_shortw_utils();
      secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
      secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
      _1n9 = BigInt(1);
      _2n7 = BigInt(2);
      divNearest = (a, b2) => (a + b2 / _2n7) / b2;
      Fp2 = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
      secp256k1 = createCurve({
        a: BigInt(0),
        b: BigInt(7),
        Fp: Fp2,
        n: secp256k1N,
        Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
        Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
        h: BigInt(1),
        lowS: true,
        endo: {
          beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
          splitScalar: (k2) => {
            const n = secp256k1N;
            const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
            const b1 = -_1n9 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
            const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
            const b2 = a1;
            const POW_2_128 = BigInt("0x100000000000000000000000000000000");
            const c1 = divNearest(b2 * k2, n);
            const c2 = divNearest(-b1 * k2, n);
            let k1 = mod(k2 - c1 * a1 - c2 * a2, n);
            let k22 = mod(-c1 * b1 - c2 * b2, n);
            const k1neg = k1 > POW_2_128;
            const k2neg = k22 > POW_2_128;
            if (k1neg)
              k1 = n - k1;
            if (k2neg)
              k22 = n - k22;
            if (k1 > POW_2_128 || k22 > POW_2_128) {
              throw new Error("splitScalar: Endomorphism failed, k=" + k2);
            }
            return { k1neg, k1, k2neg, k2: k22 };
          }
        }
      }, sha256);
      _0n9 = BigInt(0);
      Point = secp256k1.ProjectivePoint;
    }
  });

  // node_modules/@solana/web3.js/lib/index.browser.esm.js
  var index_browser_esm_exports = {};
  __export(index_browser_esm_exports, {
    Account: () => Account,
    AddressLookupTableAccount: () => AddressLookupTableAccount,
    AddressLookupTableInstruction: () => AddressLookupTableInstruction,
    AddressLookupTableProgram: () => AddressLookupTableProgram,
    Authorized: () => Authorized,
    BLOCKHASH_CACHE_TIMEOUT_MS: () => BLOCKHASH_CACHE_TIMEOUT_MS,
    BPF_LOADER_DEPRECATED_PROGRAM_ID: () => BPF_LOADER_DEPRECATED_PROGRAM_ID,
    BPF_LOADER_PROGRAM_ID: () => BPF_LOADER_PROGRAM_ID,
    BpfLoader: () => BpfLoader,
    COMPUTE_BUDGET_INSTRUCTION_LAYOUTS: () => COMPUTE_BUDGET_INSTRUCTION_LAYOUTS,
    ComputeBudgetInstruction: () => ComputeBudgetInstruction,
    ComputeBudgetProgram: () => ComputeBudgetProgram,
    Connection: () => Connection,
    Ed25519Program: () => Ed25519Program,
    Enum: () => Enum,
    EpochSchedule: () => EpochSchedule,
    FeeCalculatorLayout: () => FeeCalculatorLayout,
    Keypair: () => Keypair,
    LAMPORTS_PER_SOL: () => LAMPORTS_PER_SOL,
    LOOKUP_TABLE_INSTRUCTION_LAYOUTS: () => LOOKUP_TABLE_INSTRUCTION_LAYOUTS,
    Loader: () => Loader,
    Lockup: () => Lockup,
    MAX_SEED_LENGTH: () => MAX_SEED_LENGTH,
    Message: () => Message,
    MessageAccountKeys: () => MessageAccountKeys,
    MessageV0: () => MessageV0,
    NONCE_ACCOUNT_LENGTH: () => NONCE_ACCOUNT_LENGTH,
    NonceAccount: () => NonceAccount,
    PACKET_DATA_SIZE: () => PACKET_DATA_SIZE,
    PUBLIC_KEY_LENGTH: () => PUBLIC_KEY_LENGTH,
    PublicKey: () => PublicKey,
    SIGNATURE_LENGTH_IN_BYTES: () => SIGNATURE_LENGTH_IN_BYTES,
    SOLANA_SCHEMA: () => SOLANA_SCHEMA,
    STAKE_CONFIG_ID: () => STAKE_CONFIG_ID,
    STAKE_INSTRUCTION_LAYOUTS: () => STAKE_INSTRUCTION_LAYOUTS,
    SYSTEM_INSTRUCTION_LAYOUTS: () => SYSTEM_INSTRUCTION_LAYOUTS,
    SYSVAR_CLOCK_PUBKEY: () => SYSVAR_CLOCK_PUBKEY,
    SYSVAR_EPOCH_SCHEDULE_PUBKEY: () => SYSVAR_EPOCH_SCHEDULE_PUBKEY,
    SYSVAR_INSTRUCTIONS_PUBKEY: () => SYSVAR_INSTRUCTIONS_PUBKEY,
    SYSVAR_RECENT_BLOCKHASHES_PUBKEY: () => SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
    SYSVAR_RENT_PUBKEY: () => SYSVAR_RENT_PUBKEY,
    SYSVAR_REWARDS_PUBKEY: () => SYSVAR_REWARDS_PUBKEY,
    SYSVAR_SLOT_HASHES_PUBKEY: () => SYSVAR_SLOT_HASHES_PUBKEY,
    SYSVAR_SLOT_HISTORY_PUBKEY: () => SYSVAR_SLOT_HISTORY_PUBKEY,
    SYSVAR_STAKE_HISTORY_PUBKEY: () => SYSVAR_STAKE_HISTORY_PUBKEY,
    Secp256k1Program: () => Secp256k1Program,
    SendTransactionError: () => SendTransactionError,
    SolanaJSONRPCError: () => SolanaJSONRPCError,
    SolanaJSONRPCErrorCode: () => SolanaJSONRPCErrorCode,
    StakeAuthorizationLayout: () => StakeAuthorizationLayout,
    StakeInstruction: () => StakeInstruction,
    StakeProgram: () => StakeProgram,
    Struct: () => Struct3,
    SystemInstruction: () => SystemInstruction,
    SystemProgram: () => SystemProgram,
    Transaction: () => Transaction,
    TransactionExpiredBlockheightExceededError: () => TransactionExpiredBlockheightExceededError,
    TransactionExpiredNonceInvalidError: () => TransactionExpiredNonceInvalidError,
    TransactionExpiredTimeoutError: () => TransactionExpiredTimeoutError,
    TransactionInstruction: () => TransactionInstruction,
    TransactionMessage: () => TransactionMessage,
    TransactionStatus: () => TransactionStatus,
    VALIDATOR_INFO_KEY: () => VALIDATOR_INFO_KEY,
    VERSION_PREFIX_MASK: () => VERSION_PREFIX_MASK,
    VOTE_PROGRAM_ID: () => VOTE_PROGRAM_ID,
    ValidatorInfo: () => ValidatorInfo,
    VersionedMessage: () => VersionedMessage,
    VersionedTransaction: () => VersionedTransaction,
    VoteAccount: () => VoteAccount,
    VoteAuthorizationLayout: () => VoteAuthorizationLayout,
    VoteInit: () => VoteInit,
    VoteInstruction: () => VoteInstruction,
    VoteProgram: () => VoteProgram,
    clusterApiUrl: () => clusterApiUrl,
    sendAndConfirmRawTransaction: () => sendAndConfirmRawTransaction,
    sendAndConfirmTransaction: () => sendAndConfirmTransaction
  });
  function isOnCurve(publicKey6) {
    try {
      ed25519.ExtendedPoint.fromHex(publicKey6);
      return true;
    } catch {
      return false;
    }
  }
  function isPublicKeyData(value) {
    return value._bn !== void 0;
  }
  function getAlloc(type5, fields) {
    const getItemAlloc = (item) => {
      if (item.span >= 0) {
        return item.span;
      } else if (typeof item.alloc === "function") {
        return item.alloc(fields[item.property]);
      } else if ("count" in item && "elementLayout" in item) {
        const field = fields[item.property];
        if (Array.isArray(field)) {
          return field.length * getItemAlloc(item.elementLayout);
        }
      } else if ("fields" in item) {
        return getAlloc({
          layout: item
        }, fields[item.property]);
      }
      return 0;
    };
    let alloc2 = 0;
    type5.layout.fields.forEach((item) => {
      alloc2 += getItemAlloc(item);
    });
    return alloc2;
  }
  function decodeLength(bytes2) {
    let len = 0;
    let size = 0;
    for (; ; ) {
      let elem = bytes2.shift();
      len |= (elem & 127) << size * 7;
      size += 1;
      if ((elem & 128) === 0) {
        break;
      }
    }
    return len;
  }
  function encodeLength(bytes2, len) {
    let rem_len = len;
    for (; ; ) {
      let elem = rem_len & 127;
      rem_len >>= 7;
      if (rem_len == 0) {
        bytes2.push(elem);
        break;
      } else {
        elem |= 128;
        bytes2.push(elem);
      }
    }
  }
  function assert4(condition, message) {
    if (!condition) {
      throw new Error(message || "Assertion failed");
    }
  }
  async function sendAndConfirmTransaction(connection, transaction, signers, options) {
    const sendOptions = options && {
      skipPreflight: options.skipPreflight,
      preflightCommitment: options.preflightCommitment || options.commitment,
      maxRetries: options.maxRetries,
      minContextSlot: options.minContextSlot
    };
    const signature2 = await connection.sendTransaction(transaction, signers, sendOptions);
    let status;
    if (transaction.recentBlockhash != null && transaction.lastValidBlockHeight != null) {
      status = (await connection.confirmTransaction({
        abortSignal: options?.abortSignal,
        signature: signature2,
        blockhash: transaction.recentBlockhash,
        lastValidBlockHeight: transaction.lastValidBlockHeight
      }, options && options.commitment)).value;
    } else if (transaction.minNonceContextSlot != null && transaction.nonceInfo != null) {
      const {
        nonceInstruction
      } = transaction.nonceInfo;
      const nonceAccountPubkey = nonceInstruction.keys[0].pubkey;
      status = (await connection.confirmTransaction({
        abortSignal: options?.abortSignal,
        minContextSlot: transaction.minNonceContextSlot,
        nonceAccountPubkey,
        nonceValue: transaction.nonceInfo.nonce,
        signature: signature2
      }, options && options.commitment)).value;
    } else {
      if (options?.abortSignal != null) {
        console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable.");
      }
      status = (await connection.confirmTransaction(signature2, options && options.commitment)).value;
    }
    if (status.err) {
      throw new Error(`Transaction ${signature2} failed (${JSON.stringify(status)})`);
    }
    return signature2;
  }
  function sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  function encodeData(type5, fields) {
    const allocLength = type5.layout.span >= 0 ? type5.layout.span : getAlloc(type5, fields);
    const data = import_buffer86.Buffer.alloc(allocLength);
    const layoutFields = Object.assign({
      instruction: type5.index
    }, fields);
    type5.layout.encode(layoutFields, data);
    return data;
  }
  function decodeData$1(type5, buffer2) {
    let data;
    try {
      data = type5.layout.decode(buffer2);
    } catch (err2) {
      throw new Error("invalid instruction; " + err2);
    }
    if (data.instruction !== type5.index) {
      throw new Error(`invalid instruction; instruction index mismatch ${data.instruction} != ${type5.index}`);
    }
    return data;
  }
  function getDefaultExportFromCjs(x2) {
    return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
  }
  function stringify2(val, isArrayProp) {
    var i, max, str3, keys, key, propVal, toStr;
    if (val === true) {
      return "true";
    }
    if (val === false) {
      return "false";
    }
    switch (typeof val) {
      case "object":
        if (val === null) {
          return null;
        } else if (val.toJSON && typeof val.toJSON === "function") {
          return stringify2(val.toJSON(), isArrayProp);
        } else {
          toStr = objToString.call(val);
          if (toStr === "[object Array]") {
            str3 = "[";
            max = val.length - 1;
            for (i = 0; i < max; i++) {
              str3 += stringify2(val[i], true) + ",";
            }
            if (max > -1) {
              str3 += stringify2(val[i], true);
            }
            return str3 + "]";
          } else if (toStr === "[object Object]") {
            keys = objKeys(val).sort();
            max = keys.length;
            str3 = "";
            i = 0;
            while (i < max) {
              key = keys[i];
              propVal = stringify2(val[key], false);
              if (propVal !== void 0) {
                if (str3) {
                  str3 += ",";
                }
                str3 += JSON.stringify(key) + ":" + propVal;
              }
              i++;
            }
            return "{" + str3 + "}";
          } else {
            return JSON.stringify(val);
          }
        }
      case "function":
      case "undefined":
        return isArrayProp ? null : void 0;
      case "string":
        return JSON.stringify(val);
      default:
        return isFinite(val) ? val : null;
    }
  }
  function trailingZeros(n) {
    let trailingZeros2 = 0;
    while (n > 1) {
      n /= 2;
      trailingZeros2++;
    }
    return trailingZeros2;
  }
  function nextPowerOfTwo(n) {
    if (n === 0)
      return 1;
    n--;
    n |= n >> 1;
    n |= n >> 2;
    n |= n >> 4;
    n |= n >> 8;
    n |= n >> 16;
    n |= n >> 32;
    return n + 1;
  }
  function decodeData(type5, data) {
    let decoded;
    try {
      decoded = type5.layout.decode(data);
    } catch (err2) {
      throw new Error("invalid instruction; " + err2);
    }
    if (decoded.typeIndex !== type5.index) {
      throw new Error(`invalid account data; account type mismatch ${decoded.typeIndex} != ${type5.index}`);
    }
    return decoded;
  }
  function makeWebsocketUrl(endpoint2) {
    const matches = endpoint2.match(URL_RE);
    if (matches == null) {
      throw TypeError(`Failed to validate endpoint URL \`${endpoint2}\``);
    }
    const [
      _2,
      hostish,
      portWithColon,
      rest
    ] = matches;
    const protocol = endpoint2.startsWith("https:") ? "wss:" : "ws:";
    const startPort = portWithColon == null ? null : parseInt(portWithColon.slice(1), 10);
    const websocketPort = startPort == null ? "" : `:${startPort + 1}`;
    return `${protocol}//${hostish}${websocketPort}${rest}`;
  }
  function assertEndpointUrl(putativeUrl) {
    if (/^https?:/.test(putativeUrl) === false) {
      throw new TypeError("Endpoint URL must start with `http:` or `https:`.");
    }
    return putativeUrl;
  }
  function extractCommitmentFromConfig(commitmentOrConfig) {
    let commitment;
    let config2;
    if (typeof commitmentOrConfig === "string") {
      commitment = commitmentOrConfig;
    } else if (commitmentOrConfig) {
      const {
        commitment: specifiedCommitment,
        ...specifiedConfig
      } = commitmentOrConfig;
      commitment = specifiedCommitment;
      config2 = specifiedConfig;
    }
    return {
      commitment,
      config: config2
    };
  }
  function createRpcResult(result) {
    return union2([type3({
      jsonrpc: literal2("2.0"),
      id: string2(),
      result
    }), type3({
      jsonrpc: literal2("2.0"),
      id: string2(),
      error: type3({
        code: unknown2(),
        message: string2(),
        data: optional2(any())
      })
    })]);
  }
  function jsonRpcResult(schema) {
    return coerce(createRpcResult(schema), UnknownRpcResult, (value) => {
      if ("error" in value) {
        return value;
      } else {
        return {
          ...value,
          result: create3(value.result, schema)
        };
      }
    });
  }
  function jsonRpcResultAndContext(value) {
    return jsonRpcResult(type3({
      context: type3({
        slot: number3()
      }),
      value
    }));
  }
  function notificationResultAndContext(value) {
    return type3({
      context: type3({
        slot: number3()
      }),
      value
    });
  }
  function versionedMessageFromResponse(version4, response) {
    if (version4 === 0) {
      return new MessageV0({
        header: response.header,
        staticAccountKeys: response.accountKeys.map((accountKey) => new PublicKey(accountKey)),
        recentBlockhash: response.recentBlockhash,
        compiledInstructions: response.instructions.map((ix) => ({
          programIdIndex: ix.programIdIndex,
          accountKeyIndexes: ix.accounts,
          data: import_bs58.default.decode(ix.data)
        })),
        addressTableLookups: response.addressTableLookups
      });
    } else {
      return new Message(response);
    }
  }
  function createRpcClient(url2, httpHeaders, customFetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent) {
    const fetch3 = customFetch ? customFetch : fetchImpl;
    let agent;
    {
      if (httpAgent != null) {
        console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");
      }
    }
    let fetchWithMiddleware;
    if (fetchMiddleware) {
      fetchWithMiddleware = async (info, init2) => {
        const modifiedFetchArgs = await new Promise((resolve, reject) => {
          try {
            fetchMiddleware(info, init2, (modifiedInfo, modifiedInit) => resolve([modifiedInfo, modifiedInit]));
          } catch (error2) {
            reject(error2);
          }
        });
        return await fetch3(...modifiedFetchArgs);
      };
    }
    const clientBrowser = new import_browser.default(async (request, callback) => {
      const options = {
        method: "POST",
        body: request,
        agent,
        headers: Object.assign({
          "Content-Type": "application/json"
        }, httpHeaders || {}, COMMON_HTTP_HEADERS)
      };
      try {
        let too_many_requests_retries = 5;
        let res;
        let waitTime = 500;
        for (; ; ) {
          if (fetchWithMiddleware) {
            res = await fetchWithMiddleware(url2, options);
          } else {
            res = await fetch3(url2, options);
          }
          if (res.status !== 429) {
            break;
          }
          if (disableRetryOnRateLimit === true) {
            break;
          }
          too_many_requests_retries -= 1;
          if (too_many_requests_retries === 0) {
            break;
          }
          console.log(`Server responded with ${res.status} ${res.statusText}.  Retrying after ${waitTime}ms delay...`);
          await sleep(waitTime);
          waitTime *= 2;
        }
        const text = await res.text();
        if (res.ok) {
          callback(null, text);
        } else {
          callback(new Error(`${res.status} ${res.statusText}: ${text}`));
        }
      } catch (err2) {
        if (err2 instanceof Error)
          callback(err2);
      }
    }, {});
    return clientBrowser;
  }
  function createRpcRequest(client) {
    return (method2, args) => {
      return new Promise((resolve, reject) => {
        client.request(method2, args, (err2, response) => {
          if (err2) {
            reject(err2);
            return;
          }
          resolve(response);
        });
      });
    };
  }
  function createRpcBatchRequest(client) {
    return (requests) => {
      return new Promise((resolve, reject) => {
        if (requests.length === 0)
          resolve([]);
        const batch = requests.map((params) => {
          return client.request(params.methodName, params.args);
        });
        client.request(batch, (err2, response) => {
          if (err2) {
            reject(err2);
            return;
          }
          resolve(response);
        });
      });
    };
  }
  function parseAuthorizedVoter({
    authorizedVoter,
    epoch
  }) {
    return {
      epoch,
      authorizedVoter: new PublicKey(authorizedVoter)
    };
  }
  function parsePriorVoters({
    authorizedPubkey,
    epochOfLastAuthorizedSwitch,
    targetEpoch
  }) {
    return {
      authorizedPubkey: new PublicKey(authorizedPubkey),
      epochOfLastAuthorizedSwitch,
      targetEpoch
    };
  }
  function getPriorVoters({
    buf,
    idx,
    isEmpty
  }) {
    if (isEmpty) {
      return [];
    }
    return [...buf.slice(idx + 1).map(parsePriorVoters), ...buf.slice(0, idx).map(parsePriorVoters)];
  }
  function clusterApiUrl(cluster, tls) {
    const key = tls === false ? "http" : "https";
    if (!cluster) {
      return endpoint[key]["devnet"];
    }
    const url2 = endpoint[key][cluster];
    if (!url2) {
      throw new Error(`Unknown ${key} cluster: ${cluster}`);
    }
    return url2;
  }
  async function sendAndConfirmRawTransaction(connection, rawTransaction, confirmationStrategyOrConfirmOptions, maybeConfirmOptions) {
    let confirmationStrategy;
    let options;
    if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, "lastValidBlockHeight")) {
      confirmationStrategy = confirmationStrategyOrConfirmOptions;
      options = maybeConfirmOptions;
    } else if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, "nonceValue")) {
      confirmationStrategy = confirmationStrategyOrConfirmOptions;
      options = maybeConfirmOptions;
    } else {
      options = confirmationStrategyOrConfirmOptions;
    }
    const sendOptions = options && {
      skipPreflight: options.skipPreflight,
      preflightCommitment: options.preflightCommitment || options.commitment,
      minContextSlot: options.minContextSlot
    };
    const signature2 = await connection.sendRawTransaction(rawTransaction, sendOptions);
    const commitment = options && options.commitment;
    const confirmationPromise = confirmationStrategy ? connection.confirmTransaction(confirmationStrategy, commitment) : connection.confirmTransaction(signature2, commitment);
    const status = (await confirmationPromise).value;
    if (status.err) {
      throw new Error(`Raw transaction ${signature2} failed (${JSON.stringify(status)})`);
    }
    return signature2;
  }
  var import_buffer86, import_bn, import_bs58, import_borsh, BufferLayout, import_buffer_layout, import_bigint_buffer, import_browser, import_client, import_websocket, generatePrivateKey, generateKeypair, getPublicKey, sign, verify, toBuffer, Struct3, Enum, SOLANA_SCHEMA, _Symbol$toStringTag, MAX_SEED_LENGTH, PUBLIC_KEY_LENGTH, uniquePublicKeyCounter, PublicKey, Account, BPF_LOADER_DEPRECATED_PROGRAM_ID, PACKET_DATA_SIZE, VERSION_PREFIX_MASK, SIGNATURE_LENGTH_IN_BYTES, TransactionExpiredBlockheightExceededError, TransactionExpiredTimeoutError, TransactionExpiredNonceInvalidError, MessageAccountKeys, publicKey, signature, rustString, authorized, lockup, voteInit, voteAuthorizeWithSeedArgs, CompiledKeys, Message, MessageV0, VersionedMessage, TransactionStatus, DEFAULT_SIGNATURE, TransactionInstruction, Transaction, TransactionMessage, VersionedTransaction, NUM_TICKS_PER_SECOND, DEFAULT_TICKS_PER_SLOT, NUM_SLOTS_PER_SECOND, MS_PER_SLOT, SYSVAR_CLOCK_PUBKEY, SYSVAR_EPOCH_SCHEDULE_PUBKEY, SYSVAR_INSTRUCTIONS_PUBKEY, SYSVAR_RECENT_BLOCKHASHES_PUBKEY, SYSVAR_RENT_PUBKEY, SYSVAR_REWARDS_PUBKEY, SYSVAR_SLOT_HASHES_PUBKEY, SYSVAR_SLOT_HISTORY_PUBKEY, SYSVAR_STAKE_HISTORY_PUBKEY, FeeCalculatorLayout, NonceAccountLayout, NONCE_ACCOUNT_LENGTH, NonceAccount, encodeDecode, bigInt, u642, SystemInstruction, SYSTEM_INSTRUCTION_LAYOUTS, SystemProgram, CHUNK_SIZE, Loader, BPF_LOADER_PROGRAM_ID, BpfLoader, objToString, objKeys, fastStableStringify, fastStableStringify$1, MINIMUM_SLOT_PER_EPOCH, EpochSchedule, SendTransactionError, SolanaJSONRPCErrorCode, SolanaJSONRPCError, fetchImpl, RpcWebSocketClient, LOOKUP_TABLE_META_SIZE, AddressLookupTableAccount, LookupTableMetaLayout, URL_RE, PublicKeyFromString, RawAccountDataResult, BufferFromRawAccountData, BLOCKHASH_CACHE_TIMEOUT_MS, UnknownRpcResult, GetInflationGovernorResult, GetInflationRewardResult, GetRecentPrioritizationFeesResult, GetInflationRateResult, GetEpochInfoResult, GetEpochScheduleResult, GetLeaderScheduleResult, TransactionErrorResult, SignatureStatusResult, SignatureReceivedResult, VersionResult, SimulatedTransactionResponseStruct, BlockProductionResponseStruct, GetInflationGovernorRpcResult, GetInflationRateRpcResult, GetRecentPrioritizationFeesRpcResult, GetEpochInfoRpcResult, GetEpochScheduleRpcResult, GetLeaderScheduleRpcResult, SlotRpcResult, GetSupplyRpcResult, TokenAmountResult, GetTokenLargestAccountsResult, GetTokenAccountsByOwner, ParsedAccountDataResult, GetParsedTokenAccountsByOwner, GetLargestAccountsRpcResult, AccountInfoResult, KeyedAccountInfoResult, ParsedOrRawAccountData, ParsedAccountInfoResult, KeyedParsedAccountInfoResult, StakeActivationResult, GetConfirmedSignaturesForAddress2RpcResult, GetSignaturesForAddressRpcResult, AccountNotificationResult, ProgramAccountInfoResult, ProgramAccountNotificationResult, SlotInfoResult, SlotNotificationResult, SlotUpdateResult, SlotUpdateNotificationResult, SignatureNotificationResult, RootNotificationResult, ContactInfoResult, VoteAccountInfoResult, GetVoteAccounts, ConfirmationStatus, SignatureStatusResponse, GetSignatureStatusesRpcResult, GetMinimumBalanceForRentExemptionRpcResult, AddressTableLookupStruct, ConfirmedTransactionResult, AnnotatedAccountKey, ConfirmedTransactionAccountsModeResult, ParsedInstructionResult, RawInstructionResult, InstructionResult, UnknownInstructionResult, ParsedOrRawInstruction, ParsedConfirmedTransactionResult, TokenBalanceResult, LoadedAddressesResult, ConfirmedTransactionMetaResult, ParsedConfirmedTransactionMetaResult, TransactionVersionStruct, RewardsResult, GetBlockRpcResult, GetNoneModeBlockRpcResult, GetAccountsModeBlockRpcResult, GetParsedBlockRpcResult, GetParsedAccountsModeBlockRpcResult, GetParsedNoneModeBlockRpcResult, GetConfirmedBlockRpcResult, GetBlockSignaturesRpcResult, GetTransactionRpcResult, GetParsedTransactionRpcResult, GetRecentBlockhashAndContextRpcResult, GetLatestBlockhashRpcResult, IsBlockhashValidRpcResult, PerfSampleResult, GetRecentPerformanceSamplesRpcResult, GetFeeCalculatorRpcResult, RequestAirdropRpcResult, SendTransactionRpcResult, LogsResult, LogsNotificationResult, COMMON_HTTP_HEADERS, Connection, Keypair, LOOKUP_TABLE_INSTRUCTION_LAYOUTS, AddressLookupTableInstruction, AddressLookupTableProgram, ComputeBudgetInstruction, COMPUTE_BUDGET_INSTRUCTION_LAYOUTS, ComputeBudgetProgram, PRIVATE_KEY_BYTES$1, PUBLIC_KEY_BYTES$1, SIGNATURE_BYTES, ED25519_INSTRUCTION_LAYOUT, Ed25519Program, ecdsaSign, publicKeyCreate, PRIVATE_KEY_BYTES, ETHEREUM_ADDRESS_BYTES, PUBLIC_KEY_BYTES, SIGNATURE_OFFSETS_SERIALIZED_SIZE, SECP256K1_INSTRUCTION_LAYOUT, Secp256k1Program, STAKE_CONFIG_ID, Authorized, Lockup, StakeInstruction, STAKE_INSTRUCTION_LAYOUTS, StakeAuthorizationLayout, StakeProgram, VoteInit, VoteInstruction, VOTE_INSTRUCTION_LAYOUTS, VoteAuthorizationLayout, VoteProgram, VALIDATOR_INFO_KEY, InfoString, ValidatorInfo, VOTE_PROGRAM_ID, VoteAccountLayout, VoteAccount, endpoint, LAMPORTS_PER_SOL;
  var init_index_browser_esm = __esm({
    "node_modules/@solana/web3.js/lib/index.browser.esm.js"() {
      init_virtual_process_polyfill();
      init_buffer();
      import_buffer86 = __toESM(require_buffer());
      init_ed25519();
      import_bn = __toESM(require_bn());
      import_bs58 = __toESM(require_bs58());
      init_sha256();
      import_borsh = __toESM(require_lib());
      BufferLayout = __toESM(require_Layout());
      import_buffer_layout = __toESM(require_Layout());
      import_bigint_buffer = __toESM(require_browser());
      init_index_es();
      import_browser = __toESM(require_browser2());
      import_client = __toESM(require_client());
      import_websocket = __toESM(require_websocket_browser());
      init_sha3();
      init_secp256k1();
      generatePrivateKey = ed25519.utils.randomPrivateKey;
      generateKeypair = () => {
        const privateScalar = ed25519.utils.randomPrivateKey();
        const publicKey6 = getPublicKey(privateScalar);
        const secretKey = new Uint8Array(64);
        secretKey.set(privateScalar);
        secretKey.set(publicKey6, 32);
        return {
          publicKey: publicKey6,
          secretKey
        };
      };
      getPublicKey = ed25519.getPublicKey;
      sign = (message, secretKey) => ed25519.sign(message, secretKey.slice(0, 32));
      verify = ed25519.verify;
      toBuffer = (arr) => {
        if (import_buffer86.Buffer.isBuffer(arr)) {
          return arr;
        } else if (arr instanceof Uint8Array) {
          return import_buffer86.Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);
        } else {
          return import_buffer86.Buffer.from(arr);
        }
      };
      Struct3 = class {
        constructor(properties) {
          Object.assign(this, properties);
        }
        encode() {
          return import_buffer86.Buffer.from((0, import_borsh.serialize)(SOLANA_SCHEMA, this));
        }
        static decode(data) {
          return (0, import_borsh.deserialize)(SOLANA_SCHEMA, this, data);
        }
        static decodeUnchecked(data) {
          return (0, import_borsh.deserializeUnchecked)(SOLANA_SCHEMA, this, data);
        }
      };
      Enum = class extends Struct3 {
        constructor(properties) {
          super(properties);
          this.enum = "";
          if (Object.keys(properties).length !== 1) {
            throw new Error("Enum can only take single value");
          }
          Object.keys(properties).map((key) => {
            this.enum = key;
          });
        }
      };
      SOLANA_SCHEMA = /* @__PURE__ */ new Map();
      MAX_SEED_LENGTH = 32;
      PUBLIC_KEY_LENGTH = 32;
      uniquePublicKeyCounter = 1;
      _Symbol$toStringTag = Symbol.toStringTag;
      PublicKey = class extends Struct3 {
        constructor(value) {
          super({});
          this._bn = void 0;
          if (isPublicKeyData(value)) {
            this._bn = value._bn;
          } else {
            if (typeof value === "string") {
              const decoded = import_bs58.default.decode(value);
              if (decoded.length != PUBLIC_KEY_LENGTH) {
                throw new Error(`Invalid public key input`);
              }
              this._bn = new import_bn.default(decoded);
            } else {
              this._bn = new import_bn.default(value);
            }
            if (this._bn.byteLength() > PUBLIC_KEY_LENGTH) {
              throw new Error(`Invalid public key input`);
            }
          }
        }
        static unique() {
          const key = new PublicKey(uniquePublicKeyCounter);
          uniquePublicKeyCounter += 1;
          return new PublicKey(key.toBuffer());
        }
        equals(publicKey6) {
          return this._bn.eq(publicKey6._bn);
        }
        toBase58() {
          return import_bs58.default.encode(this.toBytes());
        }
        toJSON() {
          return this.toBase58();
        }
        toBytes() {
          const buf = this.toBuffer();
          return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
        }
        toBuffer() {
          const b2 = this._bn.toArrayLike(import_buffer86.Buffer);
          if (b2.length === PUBLIC_KEY_LENGTH) {
            return b2;
          }
          const zeroPad = import_buffer86.Buffer.alloc(32);
          b2.copy(zeroPad, 32 - b2.length);
          return zeroPad;
        }
        get [_Symbol$toStringTag]() {
          return `PublicKey(${this.toString()})`;
        }
        toString() {
          return this.toBase58();
        }
        static async createWithSeed(fromPublicKey, seed2, programId) {
          const buffer2 = import_buffer86.Buffer.concat([fromPublicKey.toBuffer(), import_buffer86.Buffer.from(seed2), programId.toBuffer()]);
          const publicKeyBytes = sha256(buffer2);
          return new PublicKey(publicKeyBytes);
        }
        static createProgramAddressSync(seeds, programId) {
          let buffer2 = import_buffer86.Buffer.alloc(0);
          seeds.forEach(function(seed2) {
            if (seed2.length > MAX_SEED_LENGTH) {
              throw new TypeError(`Max seed length exceeded`);
            }
            buffer2 = import_buffer86.Buffer.concat([buffer2, toBuffer(seed2)]);
          });
          buffer2 = import_buffer86.Buffer.concat([buffer2, programId.toBuffer(), import_buffer86.Buffer.from("ProgramDerivedAddress")]);
          const publicKeyBytes = sha256(buffer2);
          if (isOnCurve(publicKeyBytes)) {
            throw new Error(`Invalid seeds, address must fall off the curve`);
          }
          return new PublicKey(publicKeyBytes);
        }
        static async createProgramAddress(seeds, programId) {
          return this.createProgramAddressSync(seeds, programId);
        }
        static findProgramAddressSync(seeds, programId) {
          let nonce = 255;
          let address;
          while (nonce != 0) {
            try {
              const seedsWithNonce = seeds.concat(import_buffer86.Buffer.from([nonce]));
              address = this.createProgramAddressSync(seedsWithNonce, programId);
            } catch (err2) {
              if (err2 instanceof TypeError) {
                throw err2;
              }
              nonce--;
              continue;
            }
            return [address, nonce];
          }
          throw new Error(`Unable to find a viable program address nonce`);
        }
        static async findProgramAddress(seeds, programId) {
          return this.findProgramAddressSync(seeds, programId);
        }
        static isOnCurve(pubkeyData) {
          const pubkey = new PublicKey(pubkeyData);
          return isOnCurve(pubkey.toBytes());
        }
      };
      PublicKey.default = new PublicKey("11111111111111111111111111111111");
      SOLANA_SCHEMA.set(PublicKey, {
        kind: "struct",
        fields: [["_bn", "u256"]]
      });
      Account = class {
        constructor(secretKey) {
          this._publicKey = void 0;
          this._secretKey = void 0;
          if (secretKey) {
            const secretKeyBuffer = toBuffer(secretKey);
            if (secretKey.length !== 64) {
              throw new Error("bad secret key size");
            }
            this._publicKey = secretKeyBuffer.slice(32, 64);
            this._secretKey = secretKeyBuffer.slice(0, 32);
          } else {
            this._secretKey = toBuffer(generatePrivateKey());
            this._publicKey = toBuffer(getPublicKey(this._secretKey));
          }
        }
        get publicKey() {
          return new PublicKey(this._publicKey);
        }
        get secretKey() {
          return import_buffer86.Buffer.concat([this._secretKey, this._publicKey], 64);
        }
      };
      BPF_LOADER_DEPRECATED_PROGRAM_ID = new PublicKey("BPFLoader1111111111111111111111111111111111");
      PACKET_DATA_SIZE = 1280 - 40 - 8;
      VERSION_PREFIX_MASK = 127;
      SIGNATURE_LENGTH_IN_BYTES = 64;
      TransactionExpiredBlockheightExceededError = class extends Error {
        constructor(signature2) {
          super(`Signature ${signature2} has expired: block height exceeded.`);
          this.signature = void 0;
          this.signature = signature2;
        }
      };
      Object.defineProperty(TransactionExpiredBlockheightExceededError.prototype, "name", {
        value: "TransactionExpiredBlockheightExceededError"
      });
      TransactionExpiredTimeoutError = class extends Error {
        constructor(signature2, timeoutSeconds) {
          super(`Transaction was not confirmed in ${timeoutSeconds.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${signature2} using the Solana Explorer or CLI tools.`);
          this.signature = void 0;
          this.signature = signature2;
        }
      };
      Object.defineProperty(TransactionExpiredTimeoutError.prototype, "name", {
        value: "TransactionExpiredTimeoutError"
      });
      TransactionExpiredNonceInvalidError = class extends Error {
        constructor(signature2) {
          super(`Signature ${signature2} has expired: the nonce is no longer valid.`);
          this.signature = void 0;
          this.signature = signature2;
        }
      };
      Object.defineProperty(TransactionExpiredNonceInvalidError.prototype, "name", {
        value: "TransactionExpiredNonceInvalidError"
      });
      MessageAccountKeys = class {
        constructor(staticAccountKeys, accountKeysFromLookups) {
          this.staticAccountKeys = void 0;
          this.accountKeysFromLookups = void 0;
          this.staticAccountKeys = staticAccountKeys;
          this.accountKeysFromLookups = accountKeysFromLookups;
        }
        keySegments() {
          const keySegments = [this.staticAccountKeys];
          if (this.accountKeysFromLookups) {
            keySegments.push(this.accountKeysFromLookups.writable);
            keySegments.push(this.accountKeysFromLookups.readonly);
          }
          return keySegments;
        }
        get(index) {
          for (const keySegment of this.keySegments()) {
            if (index < keySegment.length) {
              return keySegment[index];
            } else {
              index -= keySegment.length;
            }
          }
          return;
        }
        get length() {
          return this.keySegments().flat().length;
        }
        compileInstructions(instructions2) {
          const U8_MAX = 255;
          if (this.length > U8_MAX + 1) {
            throw new Error("Account index overflow encountered during compilation");
          }
          const keyIndexMap = /* @__PURE__ */ new Map();
          this.keySegments().flat().forEach((key, index) => {
            keyIndexMap.set(key.toBase58(), index);
          });
          const findKeyIndex = (key) => {
            const keyIndex = keyIndexMap.get(key.toBase58());
            if (keyIndex === void 0)
              throw new Error("Encountered an unknown instruction account key during compilation");
            return keyIndex;
          };
          return instructions2.map((instruction) => {
            return {
              programIdIndex: findKeyIndex(instruction.programId),
              accountKeyIndexes: instruction.keys.map((meta) => findKeyIndex(meta.pubkey)),
              data: instruction.data
            };
          });
        }
      };
      publicKey = (property = "publicKey") => {
        return BufferLayout.blob(32, property);
      };
      signature = (property = "signature") => {
        return BufferLayout.blob(64, property);
      };
      rustString = (property = "string") => {
        const rsl = BufferLayout.struct([BufferLayout.u32("length"), BufferLayout.u32("lengthPadding"), BufferLayout.blob(BufferLayout.offset(BufferLayout.u32(), -8), "chars")], property);
        const _decode = rsl.decode.bind(rsl);
        const _encode = rsl.encode.bind(rsl);
        const rslShim = rsl;
        rslShim.decode = (b2, offset3) => {
          const data = _decode(b2, offset3);
          return data["chars"].toString();
        };
        rslShim.encode = (str3, b2, offset3) => {
          const data = {
            chars: import_buffer86.Buffer.from(str3, "utf8")
          };
          return _encode(data, b2, offset3);
        };
        rslShim.alloc = (str3) => {
          return BufferLayout.u32().span + BufferLayout.u32().span + import_buffer86.Buffer.from(str3, "utf8").length;
        };
        return rslShim;
      };
      authorized = (property = "authorized") => {
        return BufferLayout.struct([publicKey("staker"), publicKey("withdrawer")], property);
      };
      lockup = (property = "lockup") => {
        return BufferLayout.struct([BufferLayout.ns64("unixTimestamp"), BufferLayout.ns64("epoch"), publicKey("custodian")], property);
      };
      voteInit = (property = "voteInit") => {
        return BufferLayout.struct([publicKey("nodePubkey"), publicKey("authorizedVoter"), publicKey("authorizedWithdrawer"), BufferLayout.u8("commission")], property);
      };
      voteAuthorizeWithSeedArgs = (property = "voteAuthorizeWithSeedArgs") => {
        return BufferLayout.struct([BufferLayout.u32("voteAuthorizationType"), publicKey("currentAuthorityDerivedKeyOwnerPubkey"), rustString("currentAuthorityDerivedKeySeed"), publicKey("newAuthorized")], property);
      };
      CompiledKeys = class {
        constructor(payer, keyMetaMap) {
          this.payer = void 0;
          this.keyMetaMap = void 0;
          this.payer = payer;
          this.keyMetaMap = keyMetaMap;
        }
        static compile(instructions2, payer) {
          const keyMetaMap = /* @__PURE__ */ new Map();
          const getOrInsertDefault = (pubkey) => {
            const address = pubkey.toBase58();
            let keyMeta = keyMetaMap.get(address);
            if (keyMeta === void 0) {
              keyMeta = {
                isSigner: false,
                isWritable: false,
                isInvoked: false
              };
              keyMetaMap.set(address, keyMeta);
            }
            return keyMeta;
          };
          const payerKeyMeta = getOrInsertDefault(payer);
          payerKeyMeta.isSigner = true;
          payerKeyMeta.isWritable = true;
          for (const ix of instructions2) {
            getOrInsertDefault(ix.programId).isInvoked = true;
            for (const accountMeta of ix.keys) {
              const keyMeta = getOrInsertDefault(accountMeta.pubkey);
              keyMeta.isSigner ||= accountMeta.isSigner;
              keyMeta.isWritable ||= accountMeta.isWritable;
            }
          }
          return new CompiledKeys(payer, keyMetaMap);
        }
        getMessageComponents() {
          const mapEntries = [...this.keyMetaMap.entries()];
          assert4(mapEntries.length <= 256, "Max static account keys length exceeded");
          const writableSigners = mapEntries.filter(([, meta]) => meta.isSigner && meta.isWritable);
          const readonlySigners = mapEntries.filter(([, meta]) => meta.isSigner && !meta.isWritable);
          const writableNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && meta.isWritable);
          const readonlyNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && !meta.isWritable);
          const header = {
            numRequiredSignatures: writableSigners.length + readonlySigners.length,
            numReadonlySignedAccounts: readonlySigners.length,
            numReadonlyUnsignedAccounts: readonlyNonSigners.length
          };
          {
            assert4(writableSigners.length > 0, "Expected at least one writable signer key");
            const [payerAddress] = writableSigners[0];
            assert4(payerAddress === this.payer.toBase58(), "Expected first writable signer key to be the fee payer");
          }
          const staticAccountKeys = [...writableSigners.map(([address]) => new PublicKey(address)), ...readonlySigners.map(([address]) => new PublicKey(address)), ...writableNonSigners.map(([address]) => new PublicKey(address)), ...readonlyNonSigners.map(([address]) => new PublicKey(address))];
          return [header, staticAccountKeys];
        }
        extractTableLookup(lookupTable) {
          const [writableIndexes, drainedWritableKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta) => !keyMeta.isSigner && !keyMeta.isInvoked && keyMeta.isWritable);
          const [readonlyIndexes, drainedReadonlyKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta) => !keyMeta.isSigner && !keyMeta.isInvoked && !keyMeta.isWritable);
          if (writableIndexes.length === 0 && readonlyIndexes.length === 0) {
            return;
          }
          return [{
            accountKey: lookupTable.key,
            writableIndexes,
            readonlyIndexes
          }, {
            writable: drainedWritableKeys,
            readonly: drainedReadonlyKeys
          }];
        }
        drainKeysFoundInLookupTable(lookupTableEntries, keyMetaFilter) {
          const lookupTableIndexes = new Array();
          const drainedKeys = new Array();
          for (const [address, keyMeta] of this.keyMetaMap.entries()) {
            if (keyMetaFilter(keyMeta)) {
              const key = new PublicKey(address);
              const lookupTableIndex = lookupTableEntries.findIndex((entry) => entry.equals(key));
              if (lookupTableIndex >= 0) {
                assert4(lookupTableIndex < 256, "Max lookup table index exceeded");
                lookupTableIndexes.push(lookupTableIndex);
                drainedKeys.push(key);
                this.keyMetaMap.delete(address);
              }
            }
          }
          return [lookupTableIndexes, drainedKeys];
        }
      };
      Message = class {
        constructor(args) {
          this.header = void 0;
          this.accountKeys = void 0;
          this.recentBlockhash = void 0;
          this.instructions = void 0;
          this.indexToProgramIds = /* @__PURE__ */ new Map();
          this.header = args.header;
          this.accountKeys = args.accountKeys.map((account) => new PublicKey(account));
          this.recentBlockhash = args.recentBlockhash;
          this.instructions = args.instructions;
          this.instructions.forEach((ix) => this.indexToProgramIds.set(ix.programIdIndex, this.accountKeys[ix.programIdIndex]));
        }
        get version() {
          return "legacy";
        }
        get staticAccountKeys() {
          return this.accountKeys;
        }
        get compiledInstructions() {
          return this.instructions.map((ix) => ({
            programIdIndex: ix.programIdIndex,
            accountKeyIndexes: ix.accounts,
            data: import_bs58.default.decode(ix.data)
          }));
        }
        get addressTableLookups() {
          return [];
        }
        getAccountKeys() {
          return new MessageAccountKeys(this.staticAccountKeys);
        }
        static compile(args) {
          const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);
          const [header, staticAccountKeys] = compiledKeys.getMessageComponents();
          const accountKeys = new MessageAccountKeys(staticAccountKeys);
          const instructions2 = accountKeys.compileInstructions(args.instructions).map((ix) => ({
            programIdIndex: ix.programIdIndex,
            accounts: ix.accountKeyIndexes,
            data: import_bs58.default.encode(ix.data)
          }));
          return new Message({
            header,
            accountKeys: staticAccountKeys,
            recentBlockhash: args.recentBlockhash,
            instructions: instructions2
          });
        }
        isAccountSigner(index) {
          return index < this.header.numRequiredSignatures;
        }
        isAccountWritable(index) {
          const numSignedAccounts = this.header.numRequiredSignatures;
          if (index >= this.header.numRequiredSignatures) {
            const unsignedAccountIndex = index - numSignedAccounts;
            const numUnsignedAccounts = this.accountKeys.length - numSignedAccounts;
            const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
            return unsignedAccountIndex < numWritableUnsignedAccounts;
          } else {
            const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
            return index < numWritableSignedAccounts;
          }
        }
        isProgramId(index) {
          return this.indexToProgramIds.has(index);
        }
        programIds() {
          return [...this.indexToProgramIds.values()];
        }
        nonProgramIds() {
          return this.accountKeys.filter((_2, index) => !this.isProgramId(index));
        }
        serialize() {
          const numKeys = this.accountKeys.length;
          let keyCount = [];
          encodeLength(keyCount, numKeys);
          const instructions2 = this.instructions.map((instruction) => {
            const {
              accounts,
              programIdIndex
            } = instruction;
            const data = Array.from(import_bs58.default.decode(instruction.data));
            let keyIndicesCount = [];
            encodeLength(keyIndicesCount, accounts.length);
            let dataCount = [];
            encodeLength(dataCount, data.length);
            return {
              programIdIndex,
              keyIndicesCount: import_buffer86.Buffer.from(keyIndicesCount),
              keyIndices: accounts,
              dataLength: import_buffer86.Buffer.from(dataCount),
              data
            };
          });
          let instructionCount = [];
          encodeLength(instructionCount, instructions2.length);
          let instructionBuffer = import_buffer86.Buffer.alloc(PACKET_DATA_SIZE);
          import_buffer86.Buffer.from(instructionCount).copy(instructionBuffer);
          let instructionBufferLength = instructionCount.length;
          instructions2.forEach((instruction) => {
            const instructionLayout = BufferLayout.struct([BufferLayout.u8("programIdIndex"), BufferLayout.blob(instruction.keyIndicesCount.length, "keyIndicesCount"), BufferLayout.seq(BufferLayout.u8("keyIndex"), instruction.keyIndices.length, "keyIndices"), BufferLayout.blob(instruction.dataLength.length, "dataLength"), BufferLayout.seq(BufferLayout.u8("userdatum"), instruction.data.length, "data")]);
            const length2 = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);
            instructionBufferLength += length2;
          });
          instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);
          const signDataLayout = BufferLayout.struct([BufferLayout.blob(1, "numRequiredSignatures"), BufferLayout.blob(1, "numReadonlySignedAccounts"), BufferLayout.blob(1, "numReadonlyUnsignedAccounts"), BufferLayout.blob(keyCount.length, "keyCount"), BufferLayout.seq(publicKey("key"), numKeys, "keys"), publicKey("recentBlockhash")]);
          const transaction = {
            numRequiredSignatures: import_buffer86.Buffer.from([this.header.numRequiredSignatures]),
            numReadonlySignedAccounts: import_buffer86.Buffer.from([this.header.numReadonlySignedAccounts]),
            numReadonlyUnsignedAccounts: import_buffer86.Buffer.from([this.header.numReadonlyUnsignedAccounts]),
            keyCount: import_buffer86.Buffer.from(keyCount),
            keys: this.accountKeys.map((key) => toBuffer(key.toBytes())),
            recentBlockhash: import_bs58.default.decode(this.recentBlockhash)
          };
          let signData = import_buffer86.Buffer.alloc(2048);
          const length = signDataLayout.encode(transaction, signData);
          instructionBuffer.copy(signData, length);
          return signData.slice(0, length + instructionBuffer.length);
        }
        static from(buffer2) {
          let byteArray = [...buffer2];
          const numRequiredSignatures = byteArray.shift();
          if (numRequiredSignatures !== (numRequiredSignatures & VERSION_PREFIX_MASK)) {
            throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");
          }
          const numReadonlySignedAccounts = byteArray.shift();
          const numReadonlyUnsignedAccounts = byteArray.shift();
          const accountCount = decodeLength(byteArray);
          let accountKeys = [];
          for (let i = 0; i < accountCount; i++) {
            const account = byteArray.slice(0, PUBLIC_KEY_LENGTH);
            byteArray = byteArray.slice(PUBLIC_KEY_LENGTH);
            accountKeys.push(new PublicKey(import_buffer86.Buffer.from(account)));
          }
          const recentBlockhash = byteArray.slice(0, PUBLIC_KEY_LENGTH);
          byteArray = byteArray.slice(PUBLIC_KEY_LENGTH);
          const instructionCount = decodeLength(byteArray);
          let instructions2 = [];
          for (let i = 0; i < instructionCount; i++) {
            const programIdIndex = byteArray.shift();
            const accountCount2 = decodeLength(byteArray);
            const accounts = byteArray.slice(0, accountCount2);
            byteArray = byteArray.slice(accountCount2);
            const dataLength = decodeLength(byteArray);
            const dataSlice = byteArray.slice(0, dataLength);
            const data = import_bs58.default.encode(import_buffer86.Buffer.from(dataSlice));
            byteArray = byteArray.slice(dataLength);
            instructions2.push({
              programIdIndex,
              accounts,
              data
            });
          }
          const messageArgs = {
            header: {
              numRequiredSignatures,
              numReadonlySignedAccounts,
              numReadonlyUnsignedAccounts
            },
            recentBlockhash: import_bs58.default.encode(import_buffer86.Buffer.from(recentBlockhash)),
            accountKeys,
            instructions: instructions2
          };
          return new Message(messageArgs);
        }
      };
      MessageV0 = class {
        constructor(args) {
          this.header = void 0;
          this.staticAccountKeys = void 0;
          this.recentBlockhash = void 0;
          this.compiledInstructions = void 0;
          this.addressTableLookups = void 0;
          this.header = args.header;
          this.staticAccountKeys = args.staticAccountKeys;
          this.recentBlockhash = args.recentBlockhash;
          this.compiledInstructions = args.compiledInstructions;
          this.addressTableLookups = args.addressTableLookups;
        }
        get version() {
          return 0;
        }
        get numAccountKeysFromLookups() {
          let count = 0;
          for (const lookup3 of this.addressTableLookups) {
            count += lookup3.readonlyIndexes.length + lookup3.writableIndexes.length;
          }
          return count;
        }
        getAccountKeys(args) {
          let accountKeysFromLookups;
          if (args && "accountKeysFromLookups" in args && args.accountKeysFromLookups) {
            if (this.numAccountKeysFromLookups != args.accountKeysFromLookups.writable.length + args.accountKeysFromLookups.readonly.length) {
              throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");
            }
            accountKeysFromLookups = args.accountKeysFromLookups;
          } else if (args && "addressLookupTableAccounts" in args && args.addressLookupTableAccounts) {
            accountKeysFromLookups = this.resolveAddressTableLookups(args.addressLookupTableAccounts);
          } else if (this.addressTableLookups.length > 0) {
            throw new Error("Failed to get account keys because address table lookups were not resolved");
          }
          return new MessageAccountKeys(this.staticAccountKeys, accountKeysFromLookups);
        }
        isAccountSigner(index) {
          return index < this.header.numRequiredSignatures;
        }
        isAccountWritable(index) {
          const numSignedAccounts = this.header.numRequiredSignatures;
          const numStaticAccountKeys = this.staticAccountKeys.length;
          if (index >= numStaticAccountKeys) {
            const lookupAccountKeysIndex = index - numStaticAccountKeys;
            const numWritableLookupAccountKeys = this.addressTableLookups.reduce((count, lookup3) => count + lookup3.writableIndexes.length, 0);
            return lookupAccountKeysIndex < numWritableLookupAccountKeys;
          } else if (index >= this.header.numRequiredSignatures) {
            const unsignedAccountIndex = index - numSignedAccounts;
            const numUnsignedAccounts = numStaticAccountKeys - numSignedAccounts;
            const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
            return unsignedAccountIndex < numWritableUnsignedAccounts;
          } else {
            const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
            return index < numWritableSignedAccounts;
          }
        }
        resolveAddressTableLookups(addressLookupTableAccounts) {
          const accountKeysFromLookups = {
            writable: [],
            readonly: []
          };
          for (const tableLookup of this.addressTableLookups) {
            const tableAccount = addressLookupTableAccounts.find((account) => account.key.equals(tableLookup.accountKey));
            if (!tableAccount) {
              throw new Error(`Failed to find address lookup table account for table key ${tableLookup.accountKey.toBase58()}`);
            }
            for (const index of tableLookup.writableIndexes) {
              if (index < tableAccount.state.addresses.length) {
                accountKeysFromLookups.writable.push(tableAccount.state.addresses[index]);
              } else {
                throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);
              }
            }
            for (const index of tableLookup.readonlyIndexes) {
              if (index < tableAccount.state.addresses.length) {
                accountKeysFromLookups.readonly.push(tableAccount.state.addresses[index]);
              } else {
                throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);
              }
            }
          }
          return accountKeysFromLookups;
        }
        static compile(args) {
          const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);
          const addressTableLookups = new Array();
          const accountKeysFromLookups = {
            writable: new Array(),
            readonly: new Array()
          };
          const lookupTableAccounts = args.addressLookupTableAccounts || [];
          for (const lookupTable of lookupTableAccounts) {
            const extractResult = compiledKeys.extractTableLookup(lookupTable);
            if (extractResult !== void 0) {
              const [addressTableLookup, {
                writable,
                readonly
              }] = extractResult;
              addressTableLookups.push(addressTableLookup);
              accountKeysFromLookups.writable.push(...writable);
              accountKeysFromLookups.readonly.push(...readonly);
            }
          }
          const [header, staticAccountKeys] = compiledKeys.getMessageComponents();
          const accountKeys = new MessageAccountKeys(staticAccountKeys, accountKeysFromLookups);
          const compiledInstructions = accountKeys.compileInstructions(args.instructions);
          return new MessageV0({
            header,
            staticAccountKeys,
            recentBlockhash: args.recentBlockhash,
            compiledInstructions,
            addressTableLookups
          });
        }
        serialize() {
          const encodedStaticAccountKeysLength = Array();
          encodeLength(encodedStaticAccountKeysLength, this.staticAccountKeys.length);
          const serializedInstructions = this.serializeInstructions();
          const encodedInstructionsLength = Array();
          encodeLength(encodedInstructionsLength, this.compiledInstructions.length);
          const serializedAddressTableLookups = this.serializeAddressTableLookups();
          const encodedAddressTableLookupsLength = Array();
          encodeLength(encodedAddressTableLookupsLength, this.addressTableLookups.length);
          const messageLayout = BufferLayout.struct([BufferLayout.u8("prefix"), BufferLayout.struct([BufferLayout.u8("numRequiredSignatures"), BufferLayout.u8("numReadonlySignedAccounts"), BufferLayout.u8("numReadonlyUnsignedAccounts")], "header"), BufferLayout.blob(encodedStaticAccountKeysLength.length, "staticAccountKeysLength"), BufferLayout.seq(publicKey(), this.staticAccountKeys.length, "staticAccountKeys"), publicKey("recentBlockhash"), BufferLayout.blob(encodedInstructionsLength.length, "instructionsLength"), BufferLayout.blob(serializedInstructions.length, "serializedInstructions"), BufferLayout.blob(encodedAddressTableLookupsLength.length, "addressTableLookupsLength"), BufferLayout.blob(serializedAddressTableLookups.length, "serializedAddressTableLookups")]);
          const serializedMessage = new Uint8Array(PACKET_DATA_SIZE);
          const MESSAGE_VERSION_0_PREFIX = 1 << 7;
          const serializedMessageLength = messageLayout.encode({
            prefix: MESSAGE_VERSION_0_PREFIX,
            header: this.header,
            staticAccountKeysLength: new Uint8Array(encodedStaticAccountKeysLength),
            staticAccountKeys: this.staticAccountKeys.map((key) => key.toBytes()),
            recentBlockhash: import_bs58.default.decode(this.recentBlockhash),
            instructionsLength: new Uint8Array(encodedInstructionsLength),
            serializedInstructions,
            addressTableLookupsLength: new Uint8Array(encodedAddressTableLookupsLength),
            serializedAddressTableLookups
          }, serializedMessage);
          return serializedMessage.slice(0, serializedMessageLength);
        }
        serializeInstructions() {
          let serializedLength = 0;
          const serializedInstructions = new Uint8Array(PACKET_DATA_SIZE);
          for (const instruction of this.compiledInstructions) {
            const encodedAccountKeyIndexesLength = Array();
            encodeLength(encodedAccountKeyIndexesLength, instruction.accountKeyIndexes.length);
            const encodedDataLength = Array();
            encodeLength(encodedDataLength, instruction.data.length);
            const instructionLayout = BufferLayout.struct([BufferLayout.u8("programIdIndex"), BufferLayout.blob(encodedAccountKeyIndexesLength.length, "encodedAccountKeyIndexesLength"), BufferLayout.seq(BufferLayout.u8(), instruction.accountKeyIndexes.length, "accountKeyIndexes"), BufferLayout.blob(encodedDataLength.length, "encodedDataLength"), BufferLayout.blob(instruction.data.length, "data")]);
            serializedLength += instructionLayout.encode({
              programIdIndex: instruction.programIdIndex,
              encodedAccountKeyIndexesLength: new Uint8Array(encodedAccountKeyIndexesLength),
              accountKeyIndexes: instruction.accountKeyIndexes,
              encodedDataLength: new Uint8Array(encodedDataLength),
              data: instruction.data
            }, serializedInstructions, serializedLength);
          }
          return serializedInstructions.slice(0, serializedLength);
        }
        serializeAddressTableLookups() {
          let serializedLength = 0;
          const serializedAddressTableLookups = new Uint8Array(PACKET_DATA_SIZE);
          for (const lookup3 of this.addressTableLookups) {
            const encodedWritableIndexesLength = Array();
            encodeLength(encodedWritableIndexesLength, lookup3.writableIndexes.length);
            const encodedReadonlyIndexesLength = Array();
            encodeLength(encodedReadonlyIndexesLength, lookup3.readonlyIndexes.length);
            const addressTableLookupLayout = BufferLayout.struct([publicKey("accountKey"), BufferLayout.blob(encodedWritableIndexesLength.length, "encodedWritableIndexesLength"), BufferLayout.seq(BufferLayout.u8(), lookup3.writableIndexes.length, "writableIndexes"), BufferLayout.blob(encodedReadonlyIndexesLength.length, "encodedReadonlyIndexesLength"), BufferLayout.seq(BufferLayout.u8(), lookup3.readonlyIndexes.length, "readonlyIndexes")]);
            serializedLength += addressTableLookupLayout.encode({
              accountKey: lookup3.accountKey.toBytes(),
              encodedWritableIndexesLength: new Uint8Array(encodedWritableIndexesLength),
              writableIndexes: lookup3.writableIndexes,
              encodedReadonlyIndexesLength: new Uint8Array(encodedReadonlyIndexesLength),
              readonlyIndexes: lookup3.readonlyIndexes
            }, serializedAddressTableLookups, serializedLength);
          }
          return serializedAddressTableLookups.slice(0, serializedLength);
        }
        static deserialize(serializedMessage) {
          let byteArray = [...serializedMessage];
          const prefix = byteArray.shift();
          const maskedPrefix = prefix & VERSION_PREFIX_MASK;
          assert4(prefix !== maskedPrefix, `Expected versioned message but received legacy message`);
          const version4 = maskedPrefix;
          assert4(version4 === 0, `Expected versioned message with version 0 but found version ${version4}`);
          const header = {
            numRequiredSignatures: byteArray.shift(),
            numReadonlySignedAccounts: byteArray.shift(),
            numReadonlyUnsignedAccounts: byteArray.shift()
          };
          const staticAccountKeys = [];
          const staticAccountKeysLength = decodeLength(byteArray);
          for (let i = 0; i < staticAccountKeysLength; i++) {
            staticAccountKeys.push(new PublicKey(byteArray.splice(0, PUBLIC_KEY_LENGTH)));
          }
          const recentBlockhash = import_bs58.default.encode(byteArray.splice(0, PUBLIC_KEY_LENGTH));
          const instructionCount = decodeLength(byteArray);
          const compiledInstructions = [];
          for (let i = 0; i < instructionCount; i++) {
            const programIdIndex = byteArray.shift();
            const accountKeyIndexesLength = decodeLength(byteArray);
            const accountKeyIndexes = byteArray.splice(0, accountKeyIndexesLength);
            const dataLength = decodeLength(byteArray);
            const data = new Uint8Array(byteArray.splice(0, dataLength));
            compiledInstructions.push({
              programIdIndex,
              accountKeyIndexes,
              data
            });
          }
          const addressTableLookupsCount = decodeLength(byteArray);
          const addressTableLookups = [];
          for (let i = 0; i < addressTableLookupsCount; i++) {
            const accountKey = new PublicKey(byteArray.splice(0, PUBLIC_KEY_LENGTH));
            const writableIndexesLength = decodeLength(byteArray);
            const writableIndexes = byteArray.splice(0, writableIndexesLength);
            const readonlyIndexesLength = decodeLength(byteArray);
            const readonlyIndexes = byteArray.splice(0, readonlyIndexesLength);
            addressTableLookups.push({
              accountKey,
              writableIndexes,
              readonlyIndexes
            });
          }
          return new MessageV0({
            header,
            staticAccountKeys,
            recentBlockhash,
            compiledInstructions,
            addressTableLookups
          });
        }
      };
      VersionedMessage = {
        deserializeMessageVersion(serializedMessage) {
          const prefix = serializedMessage[0];
          const maskedPrefix = prefix & VERSION_PREFIX_MASK;
          if (maskedPrefix === prefix) {
            return "legacy";
          }
          return maskedPrefix;
        },
        deserialize: (serializedMessage) => {
          const version4 = VersionedMessage.deserializeMessageVersion(serializedMessage);
          if (version4 === "legacy") {
            return Message.from(serializedMessage);
          }
          if (version4 === 0) {
            return MessageV0.deserialize(serializedMessage);
          } else {
            throw new Error(`Transaction message version ${version4} deserialization is not supported`);
          }
        }
      };
      TransactionStatus = /* @__PURE__ */ function(TransactionStatus2) {
        TransactionStatus2[TransactionStatus2["BLOCKHEIGHT_EXCEEDED"] = 0] = "BLOCKHEIGHT_EXCEEDED";
        TransactionStatus2[TransactionStatus2["PROCESSED"] = 1] = "PROCESSED";
        TransactionStatus2[TransactionStatus2["TIMED_OUT"] = 2] = "TIMED_OUT";
        TransactionStatus2[TransactionStatus2["NONCE_INVALID"] = 3] = "NONCE_INVALID";
        return TransactionStatus2;
      }({});
      DEFAULT_SIGNATURE = import_buffer86.Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);
      TransactionInstruction = class {
        constructor(opts) {
          this.keys = void 0;
          this.programId = void 0;
          this.data = import_buffer86.Buffer.alloc(0);
          this.programId = opts.programId;
          this.keys = opts.keys;
          if (opts.data) {
            this.data = opts.data;
          }
        }
        toJSON() {
          return {
            keys: this.keys.map(({
              pubkey,
              isSigner,
              isWritable
            }) => ({
              pubkey: pubkey.toJSON(),
              isSigner,
              isWritable
            })),
            programId: this.programId.toJSON(),
            data: [...this.data]
          };
        }
      };
      Transaction = class {
        get signature() {
          if (this.signatures.length > 0) {
            return this.signatures[0].signature;
          }
          return null;
        }
        constructor(opts) {
          this.signatures = [];
          this.feePayer = void 0;
          this.instructions = [];
          this.recentBlockhash = void 0;
          this.lastValidBlockHeight = void 0;
          this.nonceInfo = void 0;
          this.minNonceContextSlot = void 0;
          this._message = void 0;
          this._json = void 0;
          if (!opts) {
            return;
          }
          if (opts.feePayer) {
            this.feePayer = opts.feePayer;
          }
          if (opts.signatures) {
            this.signatures = opts.signatures;
          }
          if (Object.prototype.hasOwnProperty.call(opts, "nonceInfo")) {
            const {
              minContextSlot,
              nonceInfo
            } = opts;
            this.minNonceContextSlot = minContextSlot;
            this.nonceInfo = nonceInfo;
          } else if (Object.prototype.hasOwnProperty.call(opts, "lastValidBlockHeight")) {
            const {
              blockhash,
              lastValidBlockHeight
            } = opts;
            this.recentBlockhash = blockhash;
            this.lastValidBlockHeight = lastValidBlockHeight;
          } else {
            const {
              recentBlockhash,
              nonceInfo
            } = opts;
            if (nonceInfo) {
              this.nonceInfo = nonceInfo;
            }
            this.recentBlockhash = recentBlockhash;
          }
        }
        toJSON() {
          return {
            recentBlockhash: this.recentBlockhash || null,
            feePayer: this.feePayer ? this.feePayer.toJSON() : null,
            nonceInfo: this.nonceInfo ? {
              nonce: this.nonceInfo.nonce,
              nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
            } : null,
            instructions: this.instructions.map((instruction) => instruction.toJSON()),
            signers: this.signatures.map(({
              publicKey: publicKey6
            }) => {
              return publicKey6.toJSON();
            })
          };
        }
        add(...items) {
          if (items.length === 0) {
            throw new Error("No instructions");
          }
          items.forEach((item) => {
            if ("instructions" in item) {
              this.instructions = this.instructions.concat(item.instructions);
            } else if ("data" in item && "programId" in item && "keys" in item) {
              this.instructions.push(item);
            } else {
              this.instructions.push(new TransactionInstruction(item));
            }
          });
          return this;
        }
        compileMessage() {
          if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) {
            return this._message;
          }
          let recentBlockhash;
          let instructions2;
          if (this.nonceInfo) {
            recentBlockhash = this.nonceInfo.nonce;
            if (this.instructions[0] != this.nonceInfo.nonceInstruction) {
              instructions2 = [this.nonceInfo.nonceInstruction, ...this.instructions];
            } else {
              instructions2 = this.instructions;
            }
          } else {
            recentBlockhash = this.recentBlockhash;
            instructions2 = this.instructions;
          }
          if (!recentBlockhash) {
            throw new Error("Transaction recentBlockhash required");
          }
          if (instructions2.length < 1) {
            console.warn("No instructions provided");
          }
          let feePayer;
          if (this.feePayer) {
            feePayer = this.feePayer;
          } else if (this.signatures.length > 0 && this.signatures[0].publicKey) {
            feePayer = this.signatures[0].publicKey;
          } else {
            throw new Error("Transaction fee payer required");
          }
          for (let i = 0; i < instructions2.length; i++) {
            if (instructions2[i].programId === void 0) {
              throw new Error(`Transaction instruction index ${i} has undefined program id`);
            }
          }
          const programIds = [];
          const accountMetas = [];
          instructions2.forEach((instruction) => {
            instruction.keys.forEach((accountMeta) => {
              accountMetas.push({
                ...accountMeta
              });
            });
            const programId = instruction.programId.toString();
            if (!programIds.includes(programId)) {
              programIds.push(programId);
            }
          });
          programIds.forEach((programId) => {
            accountMetas.push({
              pubkey: new PublicKey(programId),
              isSigner: false,
              isWritable: false
            });
          });
          const uniqueMetas = [];
          accountMetas.forEach((accountMeta) => {
            const pubkeyString = accountMeta.pubkey.toString();
            const uniqueIndex = uniqueMetas.findIndex((x2) => {
              return x2.pubkey.toString() === pubkeyString;
            });
            if (uniqueIndex > -1) {
              uniqueMetas[uniqueIndex].isWritable = uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;
              uniqueMetas[uniqueIndex].isSigner = uniqueMetas[uniqueIndex].isSigner || accountMeta.isSigner;
            } else {
              uniqueMetas.push(accountMeta);
            }
          });
          uniqueMetas.sort(function(x2, y2) {
            if (x2.isSigner !== y2.isSigner) {
              return x2.isSigner ? -1 : 1;
            }
            if (x2.isWritable !== y2.isWritable) {
              return x2.isWritable ? -1 : 1;
            }
            const options = {
              localeMatcher: "best fit",
              usage: "sort",
              sensitivity: "variant",
              ignorePunctuation: false,
              numeric: false,
              caseFirst: "lower"
            };
            return x2.pubkey.toBase58().localeCompare(y2.pubkey.toBase58(), "en", options);
          });
          const feePayerIndex = uniqueMetas.findIndex((x2) => {
            return x2.pubkey.equals(feePayer);
          });
          if (feePayerIndex > -1) {
            const [payerMeta] = uniqueMetas.splice(feePayerIndex, 1);
            payerMeta.isSigner = true;
            payerMeta.isWritable = true;
            uniqueMetas.unshift(payerMeta);
          } else {
            uniqueMetas.unshift({
              pubkey: feePayer,
              isSigner: true,
              isWritable: true
            });
          }
          for (const signature2 of this.signatures) {
            const uniqueIndex = uniqueMetas.findIndex((x2) => {
              return x2.pubkey.equals(signature2.publicKey);
            });
            if (uniqueIndex > -1) {
              if (!uniqueMetas[uniqueIndex].isSigner) {
                uniqueMetas[uniqueIndex].isSigner = true;
                console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release.");
              }
            } else {
              throw new Error(`unknown signer: ${signature2.publicKey.toString()}`);
            }
          }
          let numRequiredSignatures = 0;
          let numReadonlySignedAccounts = 0;
          let numReadonlyUnsignedAccounts = 0;
          const signedKeys = [];
          const unsignedKeys = [];
          uniqueMetas.forEach(({
            pubkey,
            isSigner,
            isWritable
          }) => {
            if (isSigner) {
              signedKeys.push(pubkey.toString());
              numRequiredSignatures += 1;
              if (!isWritable) {
                numReadonlySignedAccounts += 1;
              }
            } else {
              unsignedKeys.push(pubkey.toString());
              if (!isWritable) {
                numReadonlyUnsignedAccounts += 1;
              }
            }
          });
          const accountKeys = signedKeys.concat(unsignedKeys);
          const compiledInstructions = instructions2.map((instruction) => {
            const {
              data,
              programId
            } = instruction;
            return {
              programIdIndex: accountKeys.indexOf(programId.toString()),
              accounts: instruction.keys.map((meta) => accountKeys.indexOf(meta.pubkey.toString())),
              data: import_bs58.default.encode(data)
            };
          });
          compiledInstructions.forEach((instruction) => {
            assert4(instruction.programIdIndex >= 0);
            instruction.accounts.forEach((keyIndex) => assert4(keyIndex >= 0));
          });
          return new Message({
            header: {
              numRequiredSignatures,
              numReadonlySignedAccounts,
              numReadonlyUnsignedAccounts
            },
            accountKeys,
            recentBlockhash,
            instructions: compiledInstructions
          });
        }
        _compile() {
          const message = this.compileMessage();
          const signedKeys = message.accountKeys.slice(0, message.header.numRequiredSignatures);
          if (this.signatures.length === signedKeys.length) {
            const valid = this.signatures.every((pair, index) => {
              return signedKeys[index].equals(pair.publicKey);
            });
            if (valid)
              return message;
          }
          this.signatures = signedKeys.map((publicKey6) => ({
            signature: null,
            publicKey: publicKey6
          }));
          return message;
        }
        serializeMessage() {
          return this._compile().serialize();
        }
        async getEstimatedFee(connection) {
          return (await connection.getFeeForMessage(this.compileMessage())).value;
        }
        setSigners(...signers) {
          if (signers.length === 0) {
            throw new Error("No signers");
          }
          const seen = /* @__PURE__ */ new Set();
          this.signatures = signers.filter((publicKey6) => {
            const key = publicKey6.toString();
            if (seen.has(key)) {
              return false;
            } else {
              seen.add(key);
              return true;
            }
          }).map((publicKey6) => ({
            signature: null,
            publicKey: publicKey6
          }));
        }
        sign(...signers) {
          if (signers.length === 0) {
            throw new Error("No signers");
          }
          const seen = /* @__PURE__ */ new Set();
          const uniqueSigners = [];
          for (const signer of signers) {
            const key = signer.publicKey.toString();
            if (seen.has(key)) {
              continue;
            } else {
              seen.add(key);
              uniqueSigners.push(signer);
            }
          }
          this.signatures = uniqueSigners.map((signer) => ({
            signature: null,
            publicKey: signer.publicKey
          }));
          const message = this._compile();
          this._partialSign(message, ...uniqueSigners);
        }
        partialSign(...signers) {
          if (signers.length === 0) {
            throw new Error("No signers");
          }
          const seen = /* @__PURE__ */ new Set();
          const uniqueSigners = [];
          for (const signer of signers) {
            const key = signer.publicKey.toString();
            if (seen.has(key)) {
              continue;
            } else {
              seen.add(key);
              uniqueSigners.push(signer);
            }
          }
          const message = this._compile();
          this._partialSign(message, ...uniqueSigners);
        }
        _partialSign(message, ...signers) {
          const signData = message.serialize();
          signers.forEach((signer) => {
            const signature2 = sign(signData, signer.secretKey);
            this._addSignature(signer.publicKey, toBuffer(signature2));
          });
        }
        addSignature(pubkey, signature2) {
          this._compile();
          this._addSignature(pubkey, signature2);
        }
        _addSignature(pubkey, signature2) {
          assert4(signature2.length === 64);
          const index = this.signatures.findIndex((sigpair) => pubkey.equals(sigpair.publicKey));
          if (index < 0) {
            throw new Error(`unknown signer: ${pubkey.toString()}`);
          }
          this.signatures[index].signature = import_buffer86.Buffer.from(signature2);
        }
        verifySignatures(requireAllSignatures) {
          return this._verifySignatures(this.serializeMessage(), requireAllSignatures === void 0 ? true : requireAllSignatures);
        }
        _verifySignatures(signData, requireAllSignatures) {
          for (const {
            signature: signature2,
            publicKey: publicKey6
          } of this.signatures) {
            if (signature2 === null) {
              if (requireAllSignatures) {
                return false;
              }
            } else {
              if (!verify(signature2, signData, publicKey6.toBytes())) {
                return false;
              }
            }
          }
          return true;
        }
        serialize(config2) {
          const {
            requireAllSignatures,
            verifySignatures
          } = Object.assign({
            requireAllSignatures: true,
            verifySignatures: true
          }, config2);
          const signData = this.serializeMessage();
          if (verifySignatures && !this._verifySignatures(signData, requireAllSignatures)) {
            throw new Error("Signature verification failed");
          }
          return this._serialize(signData);
        }
        _serialize(signData) {
          const {
            signatures
          } = this;
          const signatureCount = [];
          encodeLength(signatureCount, signatures.length);
          const transactionLength = signatureCount.length + signatures.length * 64 + signData.length;
          const wireTransaction = import_buffer86.Buffer.alloc(transactionLength);
          assert4(signatures.length < 256);
          import_buffer86.Buffer.from(signatureCount).copy(wireTransaction, 0);
          signatures.forEach(({
            signature: signature2
          }, index) => {
            if (signature2 !== null) {
              assert4(signature2.length === 64, `signature has invalid length`);
              import_buffer86.Buffer.from(signature2).copy(wireTransaction, signatureCount.length + index * 64);
            }
          });
          signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);
          assert4(wireTransaction.length <= PACKET_DATA_SIZE, `Transaction too large: ${wireTransaction.length} > ${PACKET_DATA_SIZE}`);
          return wireTransaction;
        }
        get keys() {
          assert4(this.instructions.length === 1);
          return this.instructions[0].keys.map((keyObj) => keyObj.pubkey);
        }
        get programId() {
          assert4(this.instructions.length === 1);
          return this.instructions[0].programId;
        }
        get data() {
          assert4(this.instructions.length === 1);
          return this.instructions[0].data;
        }
        static from(buffer2) {
          let byteArray = [...buffer2];
          const signatureCount = decodeLength(byteArray);
          let signatures = [];
          for (let i = 0; i < signatureCount; i++) {
            const signature2 = byteArray.slice(0, SIGNATURE_LENGTH_IN_BYTES);
            byteArray = byteArray.slice(SIGNATURE_LENGTH_IN_BYTES);
            signatures.push(import_bs58.default.encode(import_buffer86.Buffer.from(signature2)));
          }
          return Transaction.populate(Message.from(byteArray), signatures);
        }
        static populate(message, signatures = []) {
          const transaction = new Transaction();
          transaction.recentBlockhash = message.recentBlockhash;
          if (message.header.numRequiredSignatures > 0) {
            transaction.feePayer = message.accountKeys[0];
          }
          signatures.forEach((signature2, index) => {
            const sigPubkeyPair = {
              signature: signature2 == import_bs58.default.encode(DEFAULT_SIGNATURE) ? null : import_bs58.default.decode(signature2),
              publicKey: message.accountKeys[index]
            };
            transaction.signatures.push(sigPubkeyPair);
          });
          message.instructions.forEach((instruction) => {
            const keys = instruction.accounts.map((account) => {
              const pubkey = message.accountKeys[account];
              return {
                pubkey,
                isSigner: transaction.signatures.some((keyObj) => keyObj.publicKey.toString() === pubkey.toString()) || message.isAccountSigner(account),
                isWritable: message.isAccountWritable(account)
              };
            });
            transaction.instructions.push(new TransactionInstruction({
              keys,
              programId: message.accountKeys[instruction.programIdIndex],
              data: import_bs58.default.decode(instruction.data)
            }));
          });
          transaction._message = message;
          transaction._json = transaction.toJSON();
          return transaction;
        }
      };
      TransactionMessage = class {
        constructor(args) {
          this.payerKey = void 0;
          this.instructions = void 0;
          this.recentBlockhash = void 0;
          this.payerKey = args.payerKey;
          this.instructions = args.instructions;
          this.recentBlockhash = args.recentBlockhash;
        }
        static decompile(message, args) {
          const {
            header,
            compiledInstructions,
            recentBlockhash
          } = message;
          const {
            numRequiredSignatures,
            numReadonlySignedAccounts,
            numReadonlyUnsignedAccounts
          } = header;
          const numWritableSignedAccounts = numRequiredSignatures - numReadonlySignedAccounts;
          assert4(numWritableSignedAccounts > 0, "Message header is invalid");
          const numWritableUnsignedAccounts = message.staticAccountKeys.length - numRequiredSignatures - numReadonlyUnsignedAccounts;
          assert4(numWritableUnsignedAccounts >= 0, "Message header is invalid");
          const accountKeys = message.getAccountKeys(args);
          const payerKey = accountKeys.get(0);
          if (payerKey === void 0) {
            throw new Error("Failed to decompile message because no account keys were found");
          }
          const instructions2 = [];
          for (const compiledIx of compiledInstructions) {
            const keys = [];
            for (const keyIndex of compiledIx.accountKeyIndexes) {
              const pubkey = accountKeys.get(keyIndex);
              if (pubkey === void 0) {
                throw new Error(`Failed to find key for account key index ${keyIndex}`);
              }
              const isSigner = keyIndex < numRequiredSignatures;
              let isWritable;
              if (isSigner) {
                isWritable = keyIndex < numWritableSignedAccounts;
              } else if (keyIndex < accountKeys.staticAccountKeys.length) {
                isWritable = keyIndex - numRequiredSignatures < numWritableUnsignedAccounts;
              } else {
                isWritable = keyIndex - accountKeys.staticAccountKeys.length < accountKeys.accountKeysFromLookups.writable.length;
              }
              keys.push({
                pubkey,
                isSigner: keyIndex < header.numRequiredSignatures,
                isWritable
              });
            }
            const programId = accountKeys.get(compiledIx.programIdIndex);
            if (programId === void 0) {
              throw new Error(`Failed to find program id for program id index ${compiledIx.programIdIndex}`);
            }
            instructions2.push(new TransactionInstruction({
              programId,
              data: toBuffer(compiledIx.data),
              keys
            }));
          }
          return new TransactionMessage({
            payerKey,
            instructions: instructions2,
            recentBlockhash
          });
        }
        compileToLegacyMessage() {
          return Message.compile({
            payerKey: this.payerKey,
            recentBlockhash: this.recentBlockhash,
            instructions: this.instructions
          });
        }
        compileToV0Message(addressLookupTableAccounts) {
          return MessageV0.compile({
            payerKey: this.payerKey,
            recentBlockhash: this.recentBlockhash,
            instructions: this.instructions,
            addressLookupTableAccounts
          });
        }
      };
      VersionedTransaction = class {
        get version() {
          return this.message.version;
        }
        constructor(message, signatures) {
          this.signatures = void 0;
          this.message = void 0;
          if (signatures !== void 0) {
            assert4(signatures.length === message.header.numRequiredSignatures, "Expected signatures length to be equal to the number of required signatures");
            this.signatures = signatures;
          } else {
            const defaultSignatures = [];
            for (let i = 0; i < message.header.numRequiredSignatures; i++) {
              defaultSignatures.push(new Uint8Array(SIGNATURE_LENGTH_IN_BYTES));
            }
            this.signatures = defaultSignatures;
          }
          this.message = message;
        }
        serialize() {
          const serializedMessage = this.message.serialize();
          const encodedSignaturesLength = Array();
          encodeLength(encodedSignaturesLength, this.signatures.length);
          const transactionLayout = BufferLayout.struct([BufferLayout.blob(encodedSignaturesLength.length, "encodedSignaturesLength"), BufferLayout.seq(signature(), this.signatures.length, "signatures"), BufferLayout.blob(serializedMessage.length, "serializedMessage")]);
          const serializedTransaction = new Uint8Array(2048);
          const serializedTransactionLength = transactionLayout.encode({
            encodedSignaturesLength: new Uint8Array(encodedSignaturesLength),
            signatures: this.signatures,
            serializedMessage
          }, serializedTransaction);
          return serializedTransaction.slice(0, serializedTransactionLength);
        }
        static deserialize(serializedTransaction) {
          let byteArray = [...serializedTransaction];
          const signatures = [];
          const signaturesLength = decodeLength(byteArray);
          for (let i = 0; i < signaturesLength; i++) {
            signatures.push(new Uint8Array(byteArray.splice(0, SIGNATURE_LENGTH_IN_BYTES)));
          }
          const message = VersionedMessage.deserialize(new Uint8Array(byteArray));
          return new VersionedTransaction(message, signatures);
        }
        sign(signers) {
          const messageData = this.message.serialize();
          const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
          for (const signer of signers) {
            const signerIndex = signerPubkeys.findIndex((pubkey) => pubkey.equals(signer.publicKey));
            assert4(signerIndex >= 0, `Cannot sign with non signer key ${signer.publicKey.toBase58()}`);
            this.signatures[signerIndex] = sign(messageData, signer.secretKey);
          }
        }
        addSignature(publicKey6, signature2) {
          assert4(signature2.byteLength === 64, "Signature must be 64 bytes long");
          const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
          const signerIndex = signerPubkeys.findIndex((pubkey) => pubkey.equals(publicKey6));
          assert4(signerIndex >= 0, `Can not add signature; \`${publicKey6.toBase58()}\` is not required to sign this transaction`);
          this.signatures[signerIndex] = signature2;
        }
      };
      NUM_TICKS_PER_SECOND = 160;
      DEFAULT_TICKS_PER_SLOT = 64;
      NUM_SLOTS_PER_SECOND = NUM_TICKS_PER_SECOND / DEFAULT_TICKS_PER_SLOT;
      MS_PER_SLOT = 1e3 / NUM_SLOTS_PER_SECOND;
      SYSVAR_CLOCK_PUBKEY = new PublicKey("SysvarC1ock11111111111111111111111111111111");
      SYSVAR_EPOCH_SCHEDULE_PUBKEY = new PublicKey("SysvarEpochSchedu1e111111111111111111111111");
      SYSVAR_INSTRUCTIONS_PUBKEY = new PublicKey("Sysvar1nstructions1111111111111111111111111");
      SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey("SysvarRecentB1ockHashes11111111111111111111");
      SYSVAR_RENT_PUBKEY = new PublicKey("SysvarRent111111111111111111111111111111111");
      SYSVAR_REWARDS_PUBKEY = new PublicKey("SysvarRewards111111111111111111111111111111");
      SYSVAR_SLOT_HASHES_PUBKEY = new PublicKey("SysvarS1otHashes111111111111111111111111111");
      SYSVAR_SLOT_HISTORY_PUBKEY = new PublicKey("SysvarS1otHistory11111111111111111111111111");
      SYSVAR_STAKE_HISTORY_PUBKEY = new PublicKey("SysvarStakeHistory1111111111111111111111111");
      FeeCalculatorLayout = BufferLayout.nu64("lamportsPerSignature");
      NonceAccountLayout = BufferLayout.struct([BufferLayout.u32("version"), BufferLayout.u32("state"), publicKey("authorizedPubkey"), publicKey("nonce"), BufferLayout.struct([FeeCalculatorLayout], "feeCalculator")]);
      NONCE_ACCOUNT_LENGTH = NonceAccountLayout.span;
      NonceAccount = class {
        constructor(args) {
          this.authorizedPubkey = void 0;
          this.nonce = void 0;
          this.feeCalculator = void 0;
          this.authorizedPubkey = args.authorizedPubkey;
          this.nonce = args.nonce;
          this.feeCalculator = args.feeCalculator;
        }
        static fromAccountData(buffer2) {
          const nonceAccount = NonceAccountLayout.decode(toBuffer(buffer2), 0);
          return new NonceAccount({
            authorizedPubkey: new PublicKey(nonceAccount.authorizedPubkey),
            nonce: new PublicKey(nonceAccount.nonce).toString(),
            feeCalculator: nonceAccount.feeCalculator
          });
        }
      };
      encodeDecode = (layout) => {
        const decode2 = layout.decode.bind(layout);
        const encode = layout.encode.bind(layout);
        return {
          decode: decode2,
          encode
        };
      };
      bigInt = (length) => (property) => {
        const layout = (0, import_buffer_layout.blob)(length, property);
        const {
          encode,
          decode: decode2
        } = encodeDecode(layout);
        const bigIntLayout = layout;
        bigIntLayout.decode = (buffer2, offset3) => {
          const src = decode2(buffer2, offset3);
          return (0, import_bigint_buffer.toBigIntLE)(import_buffer86.Buffer.from(src));
        };
        bigIntLayout.encode = (bigInt2, buffer2, offset3) => {
          const src = (0, import_bigint_buffer.toBufferLE)(bigInt2, length);
          return encode(src, buffer2, offset3);
        };
        return bigIntLayout;
      };
      u642 = bigInt(8);
      SystemInstruction = class {
        constructor() {
        }
        static decodeInstructionType(instruction) {
          this.checkProgramId(instruction.programId);
          const instructionTypeLayout = BufferLayout.u32("instruction");
          const typeIndex = instructionTypeLayout.decode(instruction.data);
          let type5;
          for (const [ixType, layout] of Object.entries(SYSTEM_INSTRUCTION_LAYOUTS)) {
            if (layout.index == typeIndex) {
              type5 = ixType;
              break;
            }
          }
          if (!type5) {
            throw new Error("Instruction type incorrect; not a SystemInstruction");
          }
          return type5;
        }
        static decodeCreateAccount(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 2);
          const {
            lamports,
            space,
            programId
          } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Create, instruction.data);
          return {
            fromPubkey: instruction.keys[0].pubkey,
            newAccountPubkey: instruction.keys[1].pubkey,
            lamports,
            space,
            programId: new PublicKey(programId)
          };
        }
        static decodeTransfer(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 2);
          const {
            lamports
          } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Transfer, instruction.data);
          return {
            fromPubkey: instruction.keys[0].pubkey,
            toPubkey: instruction.keys[1].pubkey,
            lamports
          };
        }
        static decodeTransferWithSeed(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 3);
          const {
            lamports,
            seed: seed2,
            programId
          } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed, instruction.data);
          return {
            fromPubkey: instruction.keys[0].pubkey,
            basePubkey: instruction.keys[1].pubkey,
            toPubkey: instruction.keys[2].pubkey,
            lamports,
            seed: seed2,
            programId: new PublicKey(programId)
          };
        }
        static decodeAllocate(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 1);
          const {
            space
          } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Allocate, instruction.data);
          return {
            accountPubkey: instruction.keys[0].pubkey,
            space
          };
        }
        static decodeAllocateWithSeed(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 1);
          const {
            base,
            seed: seed2,
            space,
            programId
          } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed, instruction.data);
          return {
            accountPubkey: instruction.keys[0].pubkey,
            basePubkey: new PublicKey(base),
            seed: seed2,
            space,
            programId: new PublicKey(programId)
          };
        }
        static decodeAssign(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 1);
          const {
            programId
          } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Assign, instruction.data);
          return {
            accountPubkey: instruction.keys[0].pubkey,
            programId: new PublicKey(programId)
          };
        }
        static decodeAssignWithSeed(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 1);
          const {
            base,
            seed: seed2,
            programId
          } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed, instruction.data);
          return {
            accountPubkey: instruction.keys[0].pubkey,
            basePubkey: new PublicKey(base),
            seed: seed2,
            programId: new PublicKey(programId)
          };
        }
        static decodeCreateWithSeed(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 2);
          const {
            base,
            seed: seed2,
            lamports,
            space,
            programId
          } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed, instruction.data);
          return {
            fromPubkey: instruction.keys[0].pubkey,
            newAccountPubkey: instruction.keys[1].pubkey,
            basePubkey: new PublicKey(base),
            seed: seed2,
            lamports,
            space,
            programId: new PublicKey(programId)
          };
        }
        static decodeNonceInitialize(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 3);
          const {
            authorized: authorized2
          } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount, instruction.data);
          return {
            noncePubkey: instruction.keys[0].pubkey,
            authorizedPubkey: new PublicKey(authorized2)
          };
        }
        static decodeNonceAdvance(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 3);
          decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount, instruction.data);
          return {
            noncePubkey: instruction.keys[0].pubkey,
            authorizedPubkey: instruction.keys[2].pubkey
          };
        }
        static decodeNonceWithdraw(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 5);
          const {
            lamports
          } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount, instruction.data);
          return {
            noncePubkey: instruction.keys[0].pubkey,
            toPubkey: instruction.keys[1].pubkey,
            authorizedPubkey: instruction.keys[4].pubkey,
            lamports
          };
        }
        static decodeNonceAuthorize(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 2);
          const {
            authorized: authorized2
          } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount, instruction.data);
          return {
            noncePubkey: instruction.keys[0].pubkey,
            authorizedPubkey: instruction.keys[1].pubkey,
            newAuthorizedPubkey: new PublicKey(authorized2)
          };
        }
        static checkProgramId(programId) {
          if (!programId.equals(SystemProgram.programId)) {
            throw new Error("invalid instruction; programId is not SystemProgram");
          }
        }
        static checkKeyLength(keys, expectedLength) {
          if (keys.length < expectedLength) {
            throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
          }
        }
      };
      SYSTEM_INSTRUCTION_LAYOUTS = Object.freeze({
        Create: {
          index: 0,
          layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports"), BufferLayout.ns64("space"), publicKey("programId")])
        },
        Assign: {
          index: 1,
          layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("programId")])
        },
        Transfer: {
          index: 2,
          layout: BufferLayout.struct([BufferLayout.u32("instruction"), u642("lamports")])
        },
        CreateWithSeed: {
          index: 3,
          layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("base"), rustString("seed"), BufferLayout.ns64("lamports"), BufferLayout.ns64("space"), publicKey("programId")])
        },
        AdvanceNonceAccount: {
          index: 4,
          layout: BufferLayout.struct([BufferLayout.u32("instruction")])
        },
        WithdrawNonceAccount: {
          index: 5,
          layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports")])
        },
        InitializeNonceAccount: {
          index: 6,
          layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("authorized")])
        },
        AuthorizeNonceAccount: {
          index: 7,
          layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("authorized")])
        },
        Allocate: {
          index: 8,
          layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("space")])
        },
        AllocateWithSeed: {
          index: 9,
          layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("base"), rustString("seed"), BufferLayout.ns64("space"), publicKey("programId")])
        },
        AssignWithSeed: {
          index: 10,
          layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("base"), rustString("seed"), publicKey("programId")])
        },
        TransferWithSeed: {
          index: 11,
          layout: BufferLayout.struct([BufferLayout.u32("instruction"), u642("lamports"), rustString("seed"), publicKey("programId")])
        },
        UpgradeNonceAccount: {
          index: 12,
          layout: BufferLayout.struct([BufferLayout.u32("instruction")])
        }
      });
      SystemProgram = class {
        constructor() {
        }
        static createAccount(params) {
          const type5 = SYSTEM_INSTRUCTION_LAYOUTS.Create;
          const data = encodeData(type5, {
            lamports: params.lamports,
            space: params.space,
            programId: toBuffer(params.programId.toBuffer())
          });
          return new TransactionInstruction({
            keys: [{
              pubkey: params.fromPubkey,
              isSigner: true,
              isWritable: true
            }, {
              pubkey: params.newAccountPubkey,
              isSigner: true,
              isWritable: true
            }],
            programId: this.programId,
            data
          });
        }
        static transfer(params) {
          let data;
          let keys;
          if ("basePubkey" in params) {
            const type5 = SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed;
            data = encodeData(type5, {
              lamports: BigInt(params.lamports),
              seed: params.seed,
              programId: toBuffer(params.programId.toBuffer())
            });
            keys = [{
              pubkey: params.fromPubkey,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: params.basePubkey,
              isSigner: true,
              isWritable: false
            }, {
              pubkey: params.toPubkey,
              isSigner: false,
              isWritable: true
            }];
          } else {
            const type5 = SYSTEM_INSTRUCTION_LAYOUTS.Transfer;
            data = encodeData(type5, {
              lamports: BigInt(params.lamports)
            });
            keys = [{
              pubkey: params.fromPubkey,
              isSigner: true,
              isWritable: true
            }, {
              pubkey: params.toPubkey,
              isSigner: false,
              isWritable: true
            }];
          }
          return new TransactionInstruction({
            keys,
            programId: this.programId,
            data
          });
        }
        static assign(params) {
          let data;
          let keys;
          if ("basePubkey" in params) {
            const type5 = SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed;
            data = encodeData(type5, {
              base: toBuffer(params.basePubkey.toBuffer()),
              seed: params.seed,
              programId: toBuffer(params.programId.toBuffer())
            });
            keys = [{
              pubkey: params.accountPubkey,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: params.basePubkey,
              isSigner: true,
              isWritable: false
            }];
          } else {
            const type5 = SYSTEM_INSTRUCTION_LAYOUTS.Assign;
            data = encodeData(type5, {
              programId: toBuffer(params.programId.toBuffer())
            });
            keys = [{
              pubkey: params.accountPubkey,
              isSigner: true,
              isWritable: true
            }];
          }
          return new TransactionInstruction({
            keys,
            programId: this.programId,
            data
          });
        }
        static createAccountWithSeed(params) {
          const type5 = SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed;
          const data = encodeData(type5, {
            base: toBuffer(params.basePubkey.toBuffer()),
            seed: params.seed,
            lamports: params.lamports,
            space: params.space,
            programId: toBuffer(params.programId.toBuffer())
          });
          let keys = [{
            pubkey: params.fromPubkey,
            isSigner: true,
            isWritable: true
          }, {
            pubkey: params.newAccountPubkey,
            isSigner: false,
            isWritable: true
          }];
          if (params.basePubkey != params.fromPubkey) {
            keys.push({
              pubkey: params.basePubkey,
              isSigner: true,
              isWritable: false
            });
          }
          return new TransactionInstruction({
            keys,
            programId: this.programId,
            data
          });
        }
        static createNonceAccount(params) {
          const transaction = new Transaction();
          if ("basePubkey" in params && "seed" in params) {
            transaction.add(SystemProgram.createAccountWithSeed({
              fromPubkey: params.fromPubkey,
              newAccountPubkey: params.noncePubkey,
              basePubkey: params.basePubkey,
              seed: params.seed,
              lamports: params.lamports,
              space: NONCE_ACCOUNT_LENGTH,
              programId: this.programId
            }));
          } else {
            transaction.add(SystemProgram.createAccount({
              fromPubkey: params.fromPubkey,
              newAccountPubkey: params.noncePubkey,
              lamports: params.lamports,
              space: NONCE_ACCOUNT_LENGTH,
              programId: this.programId
            }));
          }
          const initParams = {
            noncePubkey: params.noncePubkey,
            authorizedPubkey: params.authorizedPubkey
          };
          transaction.add(this.nonceInitialize(initParams));
          return transaction;
        }
        static nonceInitialize(params) {
          const type5 = SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount;
          const data = encodeData(type5, {
            authorized: toBuffer(params.authorizedPubkey.toBuffer())
          });
          const instructionData = {
            keys: [{
              pubkey: params.noncePubkey,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: SYSVAR_RENT_PUBKEY,
              isSigner: false,
              isWritable: false
            }],
            programId: this.programId,
            data
          };
          return new TransactionInstruction(instructionData);
        }
        static nonceAdvance(params) {
          const type5 = SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount;
          const data = encodeData(type5);
          const instructionData = {
            keys: [{
              pubkey: params.noncePubkey,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: params.authorizedPubkey,
              isSigner: true,
              isWritable: false
            }],
            programId: this.programId,
            data
          };
          return new TransactionInstruction(instructionData);
        }
        static nonceWithdraw(params) {
          const type5 = SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount;
          const data = encodeData(type5, {
            lamports: params.lamports
          });
          return new TransactionInstruction({
            keys: [{
              pubkey: params.noncePubkey,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: params.toPubkey,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: SYSVAR_RENT_PUBKEY,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: params.authorizedPubkey,
              isSigner: true,
              isWritable: false
            }],
            programId: this.programId,
            data
          });
        }
        static nonceAuthorize(params) {
          const type5 = SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount;
          const data = encodeData(type5, {
            authorized: toBuffer(params.newAuthorizedPubkey.toBuffer())
          });
          return new TransactionInstruction({
            keys: [{
              pubkey: params.noncePubkey,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: params.authorizedPubkey,
              isSigner: true,
              isWritable: false
            }],
            programId: this.programId,
            data
          });
        }
        static allocate(params) {
          let data;
          let keys;
          if ("basePubkey" in params) {
            const type5 = SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed;
            data = encodeData(type5, {
              base: toBuffer(params.basePubkey.toBuffer()),
              seed: params.seed,
              space: params.space,
              programId: toBuffer(params.programId.toBuffer())
            });
            keys = [{
              pubkey: params.accountPubkey,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: params.basePubkey,
              isSigner: true,
              isWritable: false
            }];
          } else {
            const type5 = SYSTEM_INSTRUCTION_LAYOUTS.Allocate;
            data = encodeData(type5, {
              space: params.space
            });
            keys = [{
              pubkey: params.accountPubkey,
              isSigner: true,
              isWritable: true
            }];
          }
          return new TransactionInstruction({
            keys,
            programId: this.programId,
            data
          });
        }
      };
      SystemProgram.programId = new PublicKey("11111111111111111111111111111111");
      CHUNK_SIZE = PACKET_DATA_SIZE - 300;
      Loader = class {
        constructor() {
        }
        static getMinNumSignatures(dataLength) {
          return 2 * (Math.ceil(dataLength / Loader.chunkSize) + 1 + 1);
        }
        static async load(connection, payer, program, programId, data) {
          {
            const balanceNeeded = await connection.getMinimumBalanceForRentExemption(data.length);
            const programInfo = await connection.getAccountInfo(program.publicKey, "confirmed");
            let transaction = null;
            if (programInfo !== null) {
              if (programInfo.executable) {
                console.error("Program load failed, account is already executable");
                return false;
              }
              if (programInfo.data.length !== data.length) {
                transaction = transaction || new Transaction();
                transaction.add(SystemProgram.allocate({
                  accountPubkey: program.publicKey,
                  space: data.length
                }));
              }
              if (!programInfo.owner.equals(programId)) {
                transaction = transaction || new Transaction();
                transaction.add(SystemProgram.assign({
                  accountPubkey: program.publicKey,
                  programId
                }));
              }
              if (programInfo.lamports < balanceNeeded) {
                transaction = transaction || new Transaction();
                transaction.add(SystemProgram.transfer({
                  fromPubkey: payer.publicKey,
                  toPubkey: program.publicKey,
                  lamports: balanceNeeded - programInfo.lamports
                }));
              }
            } else {
              transaction = new Transaction().add(SystemProgram.createAccount({
                fromPubkey: payer.publicKey,
                newAccountPubkey: program.publicKey,
                lamports: balanceNeeded > 0 ? balanceNeeded : 1,
                space: data.length,
                programId
              }));
            }
            if (transaction !== null) {
              await sendAndConfirmTransaction(connection, transaction, [payer, program], {
                commitment: "confirmed"
              });
            }
          }
          const dataLayout = BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.u32("offset"), BufferLayout.u32("bytesLength"), BufferLayout.u32("bytesLengthPadding"), BufferLayout.seq(BufferLayout.u8("byte"), BufferLayout.offset(BufferLayout.u32(), -8), "bytes")]);
          const chunkSize = Loader.chunkSize;
          let offset3 = 0;
          let array6 = data;
          let transactions = [];
          while (array6.length > 0) {
            const bytes2 = array6.slice(0, chunkSize);
            const data2 = import_buffer86.Buffer.alloc(chunkSize + 16);
            dataLayout.encode({
              instruction: 0,
              offset: offset3,
              bytes: bytes2,
              bytesLength: 0,
              bytesLengthPadding: 0
            }, data2);
            const transaction = new Transaction().add({
              keys: [{
                pubkey: program.publicKey,
                isSigner: true,
                isWritable: true
              }],
              programId,
              data: data2
            });
            transactions.push(sendAndConfirmTransaction(connection, transaction, [payer, program], {
              commitment: "confirmed"
            }));
            if (connection._rpcEndpoint.includes("solana.com")) {
              const REQUESTS_PER_SECOND = 4;
              await sleep(1e3 / REQUESTS_PER_SECOND);
            }
            offset3 += chunkSize;
            array6 = array6.slice(chunkSize);
          }
          await Promise.all(transactions);
          {
            const dataLayout2 = BufferLayout.struct([BufferLayout.u32("instruction")]);
            const data2 = import_buffer86.Buffer.alloc(dataLayout2.span);
            dataLayout2.encode({
              instruction: 1
            }, data2);
            const transaction = new Transaction().add({
              keys: [{
                pubkey: program.publicKey,
                isSigner: true,
                isWritable: true
              }, {
                pubkey: SYSVAR_RENT_PUBKEY,
                isSigner: false,
                isWritable: false
              }],
              programId,
              data: data2
            });
            const deployCommitment = "processed";
            const finalizeSignature = await connection.sendTransaction(transaction, [payer, program], {
              preflightCommitment: deployCommitment
            });
            const {
              context,
              value
            } = await connection.confirmTransaction({
              signature: finalizeSignature,
              lastValidBlockHeight: transaction.lastValidBlockHeight,
              blockhash: transaction.recentBlockhash
            }, deployCommitment);
            if (value.err) {
              throw new Error(`Transaction ${finalizeSignature} failed (${JSON.stringify(value)})`);
            }
            while (true) {
              try {
                const currentSlot = await connection.getSlot({
                  commitment: deployCommitment
                });
                if (currentSlot > context.slot) {
                  break;
                }
              } catch {
              }
              await new Promise((resolve) => setTimeout(resolve, Math.round(MS_PER_SLOT / 2)));
            }
          }
          return true;
        }
      };
      Loader.chunkSize = CHUNK_SIZE;
      BPF_LOADER_PROGRAM_ID = new PublicKey("BPFLoader2111111111111111111111111111111111");
      BpfLoader = class {
        static getMinNumSignatures(dataLength) {
          return Loader.getMinNumSignatures(dataLength);
        }
        static load(connection, payer, program, elf, loaderProgramId) {
          return Loader.load(connection, payer, program, loaderProgramId, elf);
        }
      };
      objToString = Object.prototype.toString;
      objKeys = Object.keys || function(obj) {
        var keys = [];
        for (var name2 in obj) {
          keys.push(name2);
        }
        return keys;
      };
      fastStableStringify = function(val) {
        var returnVal = stringify2(val, false);
        if (returnVal !== void 0) {
          return "" + returnVal;
        }
      };
      fastStableStringify$1 = /* @__PURE__ */ getDefaultExportFromCjs(fastStableStringify);
      MINIMUM_SLOT_PER_EPOCH = 32;
      EpochSchedule = class {
        constructor(slotsPerEpoch, leaderScheduleSlotOffset, warmup, firstNormalEpoch, firstNormalSlot) {
          this.slotsPerEpoch = void 0;
          this.leaderScheduleSlotOffset = void 0;
          this.warmup = void 0;
          this.firstNormalEpoch = void 0;
          this.firstNormalSlot = void 0;
          this.slotsPerEpoch = slotsPerEpoch;
          this.leaderScheduleSlotOffset = leaderScheduleSlotOffset;
          this.warmup = warmup;
          this.firstNormalEpoch = firstNormalEpoch;
          this.firstNormalSlot = firstNormalSlot;
        }
        getEpoch(slot) {
          return this.getEpochAndSlotIndex(slot)[0];
        }
        getEpochAndSlotIndex(slot) {
          if (slot < this.firstNormalSlot) {
            const epoch = trailingZeros(nextPowerOfTwo(slot + MINIMUM_SLOT_PER_EPOCH + 1)) - trailingZeros(MINIMUM_SLOT_PER_EPOCH) - 1;
            const epochLen = this.getSlotsInEpoch(epoch);
            const slotIndex = slot - (epochLen - MINIMUM_SLOT_PER_EPOCH);
            return [epoch, slotIndex];
          } else {
            const normalSlotIndex = slot - this.firstNormalSlot;
            const normalEpochIndex = Math.floor(normalSlotIndex / this.slotsPerEpoch);
            const epoch = this.firstNormalEpoch + normalEpochIndex;
            const slotIndex = normalSlotIndex % this.slotsPerEpoch;
            return [epoch, slotIndex];
          }
        }
        getFirstSlotInEpoch(epoch) {
          if (epoch <= this.firstNormalEpoch) {
            return (Math.pow(2, epoch) - 1) * MINIMUM_SLOT_PER_EPOCH;
          } else {
            return (epoch - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot;
          }
        }
        getLastSlotInEpoch(epoch) {
          return this.getFirstSlotInEpoch(epoch) + this.getSlotsInEpoch(epoch) - 1;
        }
        getSlotsInEpoch(epoch) {
          if (epoch < this.firstNormalEpoch) {
            return Math.pow(2, epoch + trailingZeros(MINIMUM_SLOT_PER_EPOCH));
          } else {
            return this.slotsPerEpoch;
          }
        }
      };
      SendTransactionError = class extends Error {
        constructor(message, logs) {
          super(message);
          this.logs = void 0;
          this.logs = logs;
        }
      };
      SolanaJSONRPCErrorCode = {
        JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP: -32001,
        JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: -32002,
        JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: -32003,
        JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE: -32004,
        JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY: -32005,
        JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: -32006,
        JSON_RPC_SERVER_ERROR_SLOT_SKIPPED: -32007,
        JSON_RPC_SERVER_ERROR_NO_SNAPSHOT: -32008,
        JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: -32009,
        JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: -32010,
        JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: -32011,
        JSON_RPC_SCAN_ERROR: -32012,
        JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: -32013,
        JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: -32014,
        JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: -32015,
        JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: -32016
      };
      SolanaJSONRPCError = class extends Error {
        constructor({
          code: code2,
          message,
          data
        }, customMessage) {
          super(customMessage != null ? `${customMessage}: ${message}` : message);
          this.code = void 0;
          this.data = void 0;
          this.code = code2;
          this.data = data;
          this.name = "SolanaJSONRPCError";
        }
      };
      fetchImpl = globalThis.fetch;
      RpcWebSocketClient = class extends import_client.default {
        constructor(address, options, generate_request_id) {
          const webSocketFactory = (url2) => {
            const rpc = (0, import_websocket.default)(url2, {
              autoconnect: true,
              max_reconnects: 5,
              reconnect: true,
              reconnect_interval: 1e3,
              ...options
            });
            if ("socket" in rpc) {
              this.underlyingSocket = rpc.socket;
            } else {
              this.underlyingSocket = rpc;
            }
            return rpc;
          };
          super(webSocketFactory, address, options, generate_request_id);
          this.underlyingSocket = void 0;
        }
        call(...args) {
          const readyState = this.underlyingSocket?.readyState;
          if (readyState === 1) {
            return super.call(...args);
          }
          return Promise.reject(new Error("Tried to call a JSON-RPC method `" + args[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + readyState + ")"));
        }
        notify(...args) {
          const readyState = this.underlyingSocket?.readyState;
          if (readyState === 1) {
            return super.notify(...args);
          }
          return Promise.reject(new Error("Tried to send a JSON-RPC notification `" + args[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + readyState + ")"));
        }
      };
      LOOKUP_TABLE_META_SIZE = 56;
      AddressLookupTableAccount = class {
        constructor(args) {
          this.key = void 0;
          this.state = void 0;
          this.key = args.key;
          this.state = args.state;
        }
        isActive() {
          const U64_MAX = BigInt("0xffffffffffffffff");
          return this.state.deactivationSlot === U64_MAX;
        }
        static deserialize(accountData) {
          const meta = decodeData(LookupTableMetaLayout, accountData);
          const serializedAddressesLen = accountData.length - LOOKUP_TABLE_META_SIZE;
          assert4(serializedAddressesLen >= 0, "lookup table is invalid");
          assert4(serializedAddressesLen % 32 === 0, "lookup table is invalid");
          const numSerializedAddresses = serializedAddressesLen / 32;
          const {
            addresses
          } = BufferLayout.struct([BufferLayout.seq(publicKey(), numSerializedAddresses, "addresses")]).decode(accountData.slice(LOOKUP_TABLE_META_SIZE));
          return {
            deactivationSlot: meta.deactivationSlot,
            lastExtendedSlot: meta.lastExtendedSlot,
            lastExtendedSlotStartIndex: meta.lastExtendedStartIndex,
            authority: meta.authority.length !== 0 ? new PublicKey(meta.authority[0]) : void 0,
            addresses: addresses.map((address) => new PublicKey(address))
          };
        }
      };
      LookupTableMetaLayout = {
        index: 1,
        layout: BufferLayout.struct([
          BufferLayout.u32("typeIndex"),
          u642("deactivationSlot"),
          BufferLayout.nu64("lastExtendedSlot"),
          BufferLayout.u8("lastExtendedStartIndex"),
          BufferLayout.u8(),
          BufferLayout.seq(publicKey(), BufferLayout.offset(BufferLayout.u8(), -1), "authority")
        ])
      };
      URL_RE = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;
      PublicKeyFromString = coerce(instance(PublicKey), string2(), (value) => new PublicKey(value));
      RawAccountDataResult = tuple3([string2(), literal2("base64")]);
      BufferFromRawAccountData = coerce(instance(import_buffer86.Buffer), RawAccountDataResult, (value) => import_buffer86.Buffer.from(value[0], "base64"));
      BLOCKHASH_CACHE_TIMEOUT_MS = 30 * 1e3;
      UnknownRpcResult = createRpcResult(unknown2());
      GetInflationGovernorResult = type3({
        foundation: number3(),
        foundationTerm: number3(),
        initial: number3(),
        taper: number3(),
        terminal: number3()
      });
      GetInflationRewardResult = jsonRpcResult(array2(nullable4(type3({
        epoch: number3(),
        effectiveSlot: number3(),
        amount: number3(),
        postBalance: number3(),
        commission: optional2(nullable4(number3()))
      }))));
      GetRecentPrioritizationFeesResult = array2(type3({
        slot: number3(),
        prioritizationFee: number3()
      }));
      GetInflationRateResult = type3({
        total: number3(),
        validator: number3(),
        foundation: number3(),
        epoch: number3()
      });
      GetEpochInfoResult = type3({
        epoch: number3(),
        slotIndex: number3(),
        slotsInEpoch: number3(),
        absoluteSlot: number3(),
        blockHeight: optional2(number3()),
        transactionCount: optional2(number3())
      });
      GetEpochScheduleResult = type3({
        slotsPerEpoch: number3(),
        leaderScheduleSlotOffset: number3(),
        warmup: boolean2(),
        firstNormalEpoch: number3(),
        firstNormalSlot: number3()
      });
      GetLeaderScheduleResult = record2(string2(), array2(number3()));
      TransactionErrorResult = nullable4(union2([type3({}), string2()]));
      SignatureStatusResult = type3({
        err: TransactionErrorResult
      });
      SignatureReceivedResult = literal2("receivedSignature");
      VersionResult = type3({
        "solana-core": string2(),
        "feature-set": optional2(number3())
      });
      SimulatedTransactionResponseStruct = jsonRpcResultAndContext(type3({
        err: nullable4(union2([type3({}), string2()])),
        logs: nullable4(array2(string2())),
        accounts: optional2(nullable4(array2(nullable4(type3({
          executable: boolean2(),
          owner: string2(),
          lamports: number3(),
          data: array2(string2()),
          rentEpoch: optional2(number3())
        }))))),
        unitsConsumed: optional2(number3()),
        returnData: optional2(nullable4(type3({
          programId: string2(),
          data: tuple3([string2(), literal2("base64")])
        })))
      }));
      BlockProductionResponseStruct = jsonRpcResultAndContext(type3({
        byIdentity: record2(string2(), array2(number3())),
        range: type3({
          firstSlot: number3(),
          lastSlot: number3()
        })
      }));
      GetInflationGovernorRpcResult = jsonRpcResult(GetInflationGovernorResult);
      GetInflationRateRpcResult = jsonRpcResult(GetInflationRateResult);
      GetRecentPrioritizationFeesRpcResult = jsonRpcResult(GetRecentPrioritizationFeesResult);
      GetEpochInfoRpcResult = jsonRpcResult(GetEpochInfoResult);
      GetEpochScheduleRpcResult = jsonRpcResult(GetEpochScheduleResult);
      GetLeaderScheduleRpcResult = jsonRpcResult(GetLeaderScheduleResult);
      SlotRpcResult = jsonRpcResult(number3());
      GetSupplyRpcResult = jsonRpcResultAndContext(type3({
        total: number3(),
        circulating: number3(),
        nonCirculating: number3(),
        nonCirculatingAccounts: array2(PublicKeyFromString)
      }));
      TokenAmountResult = type3({
        amount: string2(),
        uiAmount: nullable4(number3()),
        decimals: number3(),
        uiAmountString: optional2(string2())
      });
      GetTokenLargestAccountsResult = jsonRpcResultAndContext(array2(type3({
        address: PublicKeyFromString,
        amount: string2(),
        uiAmount: nullable4(number3()),
        decimals: number3(),
        uiAmountString: optional2(string2())
      })));
      GetTokenAccountsByOwner = jsonRpcResultAndContext(array2(type3({
        pubkey: PublicKeyFromString,
        account: type3({
          executable: boolean2(),
          owner: PublicKeyFromString,
          lamports: number3(),
          data: BufferFromRawAccountData,
          rentEpoch: number3()
        })
      })));
      ParsedAccountDataResult = type3({
        program: string2(),
        parsed: unknown2(),
        space: number3()
      });
      GetParsedTokenAccountsByOwner = jsonRpcResultAndContext(array2(type3({
        pubkey: PublicKeyFromString,
        account: type3({
          executable: boolean2(),
          owner: PublicKeyFromString,
          lamports: number3(),
          data: ParsedAccountDataResult,
          rentEpoch: number3()
        })
      })));
      GetLargestAccountsRpcResult = jsonRpcResultAndContext(array2(type3({
        lamports: number3(),
        address: PublicKeyFromString
      })));
      AccountInfoResult = type3({
        executable: boolean2(),
        owner: PublicKeyFromString,
        lamports: number3(),
        data: BufferFromRawAccountData,
        rentEpoch: number3()
      });
      KeyedAccountInfoResult = type3({
        pubkey: PublicKeyFromString,
        account: AccountInfoResult
      });
      ParsedOrRawAccountData = coerce(union2([instance(import_buffer86.Buffer), ParsedAccountDataResult]), union2([RawAccountDataResult, ParsedAccountDataResult]), (value) => {
        if (Array.isArray(value)) {
          return create3(value, BufferFromRawAccountData);
        } else {
          return value;
        }
      });
      ParsedAccountInfoResult = type3({
        executable: boolean2(),
        owner: PublicKeyFromString,
        lamports: number3(),
        data: ParsedOrRawAccountData,
        rentEpoch: number3()
      });
      KeyedParsedAccountInfoResult = type3({
        pubkey: PublicKeyFromString,
        account: ParsedAccountInfoResult
      });
      StakeActivationResult = type3({
        state: union2([literal2("active"), literal2("inactive"), literal2("activating"), literal2("deactivating")]),
        active: number3(),
        inactive: number3()
      });
      GetConfirmedSignaturesForAddress2RpcResult = jsonRpcResult(array2(type3({
        signature: string2(),
        slot: number3(),
        err: TransactionErrorResult,
        memo: nullable4(string2()),
        blockTime: optional2(nullable4(number3()))
      })));
      GetSignaturesForAddressRpcResult = jsonRpcResult(array2(type3({
        signature: string2(),
        slot: number3(),
        err: TransactionErrorResult,
        memo: nullable4(string2()),
        blockTime: optional2(nullable4(number3()))
      })));
      AccountNotificationResult = type3({
        subscription: number3(),
        result: notificationResultAndContext(AccountInfoResult)
      });
      ProgramAccountInfoResult = type3({
        pubkey: PublicKeyFromString,
        account: AccountInfoResult
      });
      ProgramAccountNotificationResult = type3({
        subscription: number3(),
        result: notificationResultAndContext(ProgramAccountInfoResult)
      });
      SlotInfoResult = type3({
        parent: number3(),
        slot: number3(),
        root: number3()
      });
      SlotNotificationResult = type3({
        subscription: number3(),
        result: SlotInfoResult
      });
      SlotUpdateResult = union2([type3({
        type: union2([literal2("firstShredReceived"), literal2("completed"), literal2("optimisticConfirmation"), literal2("root")]),
        slot: number3(),
        timestamp: number3()
      }), type3({
        type: literal2("createdBank"),
        parent: number3(),
        slot: number3(),
        timestamp: number3()
      }), type3({
        type: literal2("frozen"),
        slot: number3(),
        timestamp: number3(),
        stats: type3({
          numTransactionEntries: number3(),
          numSuccessfulTransactions: number3(),
          numFailedTransactions: number3(),
          maxTransactionsPerEntry: number3()
        })
      }), type3({
        type: literal2("dead"),
        slot: number3(),
        timestamp: number3(),
        err: string2()
      })]);
      SlotUpdateNotificationResult = type3({
        subscription: number3(),
        result: SlotUpdateResult
      });
      SignatureNotificationResult = type3({
        subscription: number3(),
        result: notificationResultAndContext(union2([SignatureStatusResult, SignatureReceivedResult]))
      });
      RootNotificationResult = type3({
        subscription: number3(),
        result: number3()
      });
      ContactInfoResult = type3({
        pubkey: string2(),
        gossip: nullable4(string2()),
        tpu: nullable4(string2()),
        rpc: nullable4(string2()),
        version: nullable4(string2())
      });
      VoteAccountInfoResult = type3({
        votePubkey: string2(),
        nodePubkey: string2(),
        activatedStake: number3(),
        epochVoteAccount: boolean2(),
        epochCredits: array2(tuple3([number3(), number3(), number3()])),
        commission: number3(),
        lastVote: number3(),
        rootSlot: nullable4(number3())
      });
      GetVoteAccounts = jsonRpcResult(type3({
        current: array2(VoteAccountInfoResult),
        delinquent: array2(VoteAccountInfoResult)
      }));
      ConfirmationStatus = union2([literal2("processed"), literal2("confirmed"), literal2("finalized")]);
      SignatureStatusResponse = type3({
        slot: number3(),
        confirmations: nullable4(number3()),
        err: TransactionErrorResult,
        confirmationStatus: optional2(ConfirmationStatus)
      });
      GetSignatureStatusesRpcResult = jsonRpcResultAndContext(array2(nullable4(SignatureStatusResponse)));
      GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult(number3());
      AddressTableLookupStruct = type3({
        accountKey: PublicKeyFromString,
        writableIndexes: array2(number3()),
        readonlyIndexes: array2(number3())
      });
      ConfirmedTransactionResult = type3({
        signatures: array2(string2()),
        message: type3({
          accountKeys: array2(string2()),
          header: type3({
            numRequiredSignatures: number3(),
            numReadonlySignedAccounts: number3(),
            numReadonlyUnsignedAccounts: number3()
          }),
          instructions: array2(type3({
            accounts: array2(number3()),
            data: string2(),
            programIdIndex: number3()
          })),
          recentBlockhash: string2(),
          addressTableLookups: optional2(array2(AddressTableLookupStruct))
        })
      });
      AnnotatedAccountKey = type3({
        pubkey: PublicKeyFromString,
        signer: boolean2(),
        writable: boolean2(),
        source: optional2(union2([literal2("transaction"), literal2("lookupTable")]))
      });
      ConfirmedTransactionAccountsModeResult = type3({
        accountKeys: array2(AnnotatedAccountKey),
        signatures: array2(string2())
      });
      ParsedInstructionResult = type3({
        parsed: unknown2(),
        program: string2(),
        programId: PublicKeyFromString
      });
      RawInstructionResult = type3({
        accounts: array2(PublicKeyFromString),
        data: string2(),
        programId: PublicKeyFromString
      });
      InstructionResult = union2([RawInstructionResult, ParsedInstructionResult]);
      UnknownInstructionResult = union2([type3({
        parsed: unknown2(),
        program: string2(),
        programId: string2()
      }), type3({
        accounts: array2(string2()),
        data: string2(),
        programId: string2()
      })]);
      ParsedOrRawInstruction = coerce(InstructionResult, UnknownInstructionResult, (value) => {
        if ("accounts" in value) {
          return create3(value, RawInstructionResult);
        } else {
          return create3(value, ParsedInstructionResult);
        }
      });
      ParsedConfirmedTransactionResult = type3({
        signatures: array2(string2()),
        message: type3({
          accountKeys: array2(AnnotatedAccountKey),
          instructions: array2(ParsedOrRawInstruction),
          recentBlockhash: string2(),
          addressTableLookups: optional2(nullable4(array2(AddressTableLookupStruct)))
        })
      });
      TokenBalanceResult = type3({
        accountIndex: number3(),
        mint: string2(),
        owner: optional2(string2()),
        uiTokenAmount: TokenAmountResult
      });
      LoadedAddressesResult = type3({
        writable: array2(PublicKeyFromString),
        readonly: array2(PublicKeyFromString)
      });
      ConfirmedTransactionMetaResult = type3({
        err: TransactionErrorResult,
        fee: number3(),
        innerInstructions: optional2(nullable4(array2(type3({
          index: number3(),
          instructions: array2(type3({
            accounts: array2(number3()),
            data: string2(),
            programIdIndex: number3()
          }))
        })))),
        preBalances: array2(number3()),
        postBalances: array2(number3()),
        logMessages: optional2(nullable4(array2(string2()))),
        preTokenBalances: optional2(nullable4(array2(TokenBalanceResult))),
        postTokenBalances: optional2(nullable4(array2(TokenBalanceResult))),
        loadedAddresses: optional2(LoadedAddressesResult),
        computeUnitsConsumed: optional2(number3())
      });
      ParsedConfirmedTransactionMetaResult = type3({
        err: TransactionErrorResult,
        fee: number3(),
        innerInstructions: optional2(nullable4(array2(type3({
          index: number3(),
          instructions: array2(ParsedOrRawInstruction)
        })))),
        preBalances: array2(number3()),
        postBalances: array2(number3()),
        logMessages: optional2(nullable4(array2(string2()))),
        preTokenBalances: optional2(nullable4(array2(TokenBalanceResult))),
        postTokenBalances: optional2(nullable4(array2(TokenBalanceResult))),
        loadedAddresses: optional2(LoadedAddressesResult),
        computeUnitsConsumed: optional2(number3())
      });
      TransactionVersionStruct = union2([literal2(0), literal2("legacy")]);
      RewardsResult = type3({
        pubkey: string2(),
        lamports: number3(),
        postBalance: nullable4(number3()),
        rewardType: nullable4(string2()),
        commission: optional2(nullable4(number3()))
      });
      GetBlockRpcResult = jsonRpcResult(nullable4(type3({
        blockhash: string2(),
        previousBlockhash: string2(),
        parentSlot: number3(),
        transactions: array2(type3({
          transaction: ConfirmedTransactionResult,
          meta: nullable4(ConfirmedTransactionMetaResult),
          version: optional2(TransactionVersionStruct)
        })),
        rewards: optional2(array2(RewardsResult)),
        blockTime: nullable4(number3()),
        blockHeight: nullable4(number3())
      })));
      GetNoneModeBlockRpcResult = jsonRpcResult(nullable4(type3({
        blockhash: string2(),
        previousBlockhash: string2(),
        parentSlot: number3(),
        rewards: optional2(array2(RewardsResult)),
        blockTime: nullable4(number3()),
        blockHeight: nullable4(number3())
      })));
      GetAccountsModeBlockRpcResult = jsonRpcResult(nullable4(type3({
        blockhash: string2(),
        previousBlockhash: string2(),
        parentSlot: number3(),
        transactions: array2(type3({
          transaction: ConfirmedTransactionAccountsModeResult,
          meta: nullable4(ConfirmedTransactionMetaResult),
          version: optional2(TransactionVersionStruct)
        })),
        rewards: optional2(array2(RewardsResult)),
        blockTime: nullable4(number3()),
        blockHeight: nullable4(number3())
      })));
      GetParsedBlockRpcResult = jsonRpcResult(nullable4(type3({
        blockhash: string2(),
        previousBlockhash: string2(),
        parentSlot: number3(),
        transactions: array2(type3({
          transaction: ParsedConfirmedTransactionResult,
          meta: nullable4(ParsedConfirmedTransactionMetaResult),
          version: optional2(TransactionVersionStruct)
        })),
        rewards: optional2(array2(RewardsResult)),
        blockTime: nullable4(number3()),
        blockHeight: nullable4(number3())
      })));
      GetParsedAccountsModeBlockRpcResult = jsonRpcResult(nullable4(type3({
        blockhash: string2(),
        previousBlockhash: string2(),
        parentSlot: number3(),
        transactions: array2(type3({
          transaction: ConfirmedTransactionAccountsModeResult,
          meta: nullable4(ParsedConfirmedTransactionMetaResult),
          version: optional2(TransactionVersionStruct)
        })),
        rewards: optional2(array2(RewardsResult)),
        blockTime: nullable4(number3()),
        blockHeight: nullable4(number3())
      })));
      GetParsedNoneModeBlockRpcResult = jsonRpcResult(nullable4(type3({
        blockhash: string2(),
        previousBlockhash: string2(),
        parentSlot: number3(),
        rewards: optional2(array2(RewardsResult)),
        blockTime: nullable4(number3()),
        blockHeight: nullable4(number3())
      })));
      GetConfirmedBlockRpcResult = jsonRpcResult(nullable4(type3({
        blockhash: string2(),
        previousBlockhash: string2(),
        parentSlot: number3(),
        transactions: array2(type3({
          transaction: ConfirmedTransactionResult,
          meta: nullable4(ConfirmedTransactionMetaResult)
        })),
        rewards: optional2(array2(RewardsResult)),
        blockTime: nullable4(number3())
      })));
      GetBlockSignaturesRpcResult = jsonRpcResult(nullable4(type3({
        blockhash: string2(),
        previousBlockhash: string2(),
        parentSlot: number3(),
        signatures: array2(string2()),
        blockTime: nullable4(number3())
      })));
      GetTransactionRpcResult = jsonRpcResult(nullable4(type3({
        slot: number3(),
        meta: ConfirmedTransactionMetaResult,
        blockTime: optional2(nullable4(number3())),
        transaction: ConfirmedTransactionResult,
        version: optional2(TransactionVersionStruct)
      })));
      GetParsedTransactionRpcResult = jsonRpcResult(nullable4(type3({
        slot: number3(),
        transaction: ParsedConfirmedTransactionResult,
        meta: nullable4(ParsedConfirmedTransactionMetaResult),
        blockTime: optional2(nullable4(number3())),
        version: optional2(TransactionVersionStruct)
      })));
      GetRecentBlockhashAndContextRpcResult = jsonRpcResultAndContext(type3({
        blockhash: string2(),
        feeCalculator: type3({
          lamportsPerSignature: number3()
        })
      }));
      GetLatestBlockhashRpcResult = jsonRpcResultAndContext(type3({
        blockhash: string2(),
        lastValidBlockHeight: number3()
      }));
      IsBlockhashValidRpcResult = jsonRpcResultAndContext(boolean2());
      PerfSampleResult = type3({
        slot: number3(),
        numTransactions: number3(),
        numSlots: number3(),
        samplePeriodSecs: number3()
      });
      GetRecentPerformanceSamplesRpcResult = jsonRpcResult(array2(PerfSampleResult));
      GetFeeCalculatorRpcResult = jsonRpcResultAndContext(nullable4(type3({
        feeCalculator: type3({
          lamportsPerSignature: number3()
        })
      })));
      RequestAirdropRpcResult = jsonRpcResult(string2());
      SendTransactionRpcResult = jsonRpcResult(string2());
      LogsResult = type3({
        err: TransactionErrorResult,
        logs: array2(string2()),
        signature: string2()
      });
      LogsNotificationResult = type3({
        result: notificationResultAndContext(LogsResult),
        subscription: number3()
      });
      COMMON_HTTP_HEADERS = {
        "solana-client": `js/${"0.0.0-development"}`
      };
      Connection = class {
        constructor(endpoint2, _commitmentOrConfig) {
          this._commitment = void 0;
          this._confirmTransactionInitialTimeout = void 0;
          this._rpcEndpoint = void 0;
          this._rpcWsEndpoint = void 0;
          this._rpcClient = void 0;
          this._rpcRequest = void 0;
          this._rpcBatchRequest = void 0;
          this._rpcWebSocket = void 0;
          this._rpcWebSocketConnected = false;
          this._rpcWebSocketHeartbeat = null;
          this._rpcWebSocketIdleTimeout = null;
          this._rpcWebSocketGeneration = 0;
          this._disableBlockhashCaching = false;
          this._pollingBlockhash = false;
          this._blockhashInfo = {
            latestBlockhash: null,
            lastFetch: 0,
            transactionSignatures: [],
            simulatedSignatures: []
          };
          this._nextClientSubscriptionId = 0;
          this._subscriptionDisposeFunctionsByClientSubscriptionId = {};
          this._subscriptionHashByClientSubscriptionId = {};
          this._subscriptionStateChangeCallbacksByHash = {};
          this._subscriptionCallbacksByServerSubscriptionId = {};
          this._subscriptionsByHash = {};
          this._subscriptionsAutoDisposedByRpc = /* @__PURE__ */ new Set();
          this.getBlockHeight = (() => {
            const requestPromises = {};
            return async (commitmentOrConfig) => {
              const {
                commitment,
                config: config2
              } = extractCommitmentFromConfig(commitmentOrConfig);
              const args = this._buildArgs([], commitment, void 0, config2);
              const requestHash = fastStableStringify$1(args);
              requestPromises[requestHash] = requestPromises[requestHash] ?? (async () => {
                try {
                  const unsafeRes = await this._rpcRequest("getBlockHeight", args);
                  const res = create3(unsafeRes, jsonRpcResult(number3()));
                  if ("error" in res) {
                    throw new SolanaJSONRPCError(res.error, "failed to get block height information");
                  }
                  return res.result;
                } finally {
                  delete requestPromises[requestHash];
                }
              })();
              return await requestPromises[requestHash];
            };
          })();
          let wsEndpoint;
          let httpHeaders;
          let fetch3;
          let fetchMiddleware;
          let disableRetryOnRateLimit;
          let httpAgent;
          if (_commitmentOrConfig && typeof _commitmentOrConfig === "string") {
            this._commitment = _commitmentOrConfig;
          } else if (_commitmentOrConfig) {
            this._commitment = _commitmentOrConfig.commitment;
            this._confirmTransactionInitialTimeout = _commitmentOrConfig.confirmTransactionInitialTimeout;
            wsEndpoint = _commitmentOrConfig.wsEndpoint;
            httpHeaders = _commitmentOrConfig.httpHeaders;
            fetch3 = _commitmentOrConfig.fetch;
            fetchMiddleware = _commitmentOrConfig.fetchMiddleware;
            disableRetryOnRateLimit = _commitmentOrConfig.disableRetryOnRateLimit;
            httpAgent = _commitmentOrConfig.httpAgent;
          }
          this._rpcEndpoint = assertEndpointUrl(endpoint2);
          this._rpcWsEndpoint = wsEndpoint || makeWebsocketUrl(endpoint2);
          this._rpcClient = createRpcClient(endpoint2, httpHeaders, fetch3, fetchMiddleware, disableRetryOnRateLimit, httpAgent);
          this._rpcRequest = createRpcRequest(this._rpcClient);
          this._rpcBatchRequest = createRpcBatchRequest(this._rpcClient);
          this._rpcWebSocket = new RpcWebSocketClient(this._rpcWsEndpoint, {
            autoconnect: false,
            max_reconnects: Infinity
          });
          this._rpcWebSocket.on("open", this._wsOnOpen.bind(this));
          this._rpcWebSocket.on("error", this._wsOnError.bind(this));
          this._rpcWebSocket.on("close", this._wsOnClose.bind(this));
          this._rpcWebSocket.on("accountNotification", this._wsOnAccountNotification.bind(this));
          this._rpcWebSocket.on("programNotification", this._wsOnProgramAccountNotification.bind(this));
          this._rpcWebSocket.on("slotNotification", this._wsOnSlotNotification.bind(this));
          this._rpcWebSocket.on("slotsUpdatesNotification", this._wsOnSlotUpdatesNotification.bind(this));
          this._rpcWebSocket.on("signatureNotification", this._wsOnSignatureNotification.bind(this));
          this._rpcWebSocket.on("rootNotification", this._wsOnRootNotification.bind(this));
          this._rpcWebSocket.on("logsNotification", this._wsOnLogsNotification.bind(this));
        }
        get commitment() {
          return this._commitment;
        }
        get rpcEndpoint() {
          return this._rpcEndpoint;
        }
        async getBalanceAndContext(publicKey6, commitmentOrConfig) {
          const {
            commitment,
            config: config2
          } = extractCommitmentFromConfig(commitmentOrConfig);
          const args = this._buildArgs([publicKey6.toBase58()], commitment, void 0, config2);
          const unsafeRes = await this._rpcRequest("getBalance", args);
          const res = create3(unsafeRes, jsonRpcResultAndContext(number3()));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get balance for ${publicKey6.toBase58()}`);
          }
          return res.result;
        }
        async getBalance(publicKey6, commitmentOrConfig) {
          return await this.getBalanceAndContext(publicKey6, commitmentOrConfig).then((x2) => x2.value).catch((e) => {
            throw new Error("failed to get balance of account " + publicKey6.toBase58() + ": " + e);
          });
        }
        async getBlockTime(slot) {
          const unsafeRes = await this._rpcRequest("getBlockTime", [slot]);
          const res = create3(unsafeRes, jsonRpcResult(nullable4(number3())));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get block time for slot ${slot}`);
          }
          return res.result;
        }
        async getMinimumLedgerSlot() {
          const unsafeRes = await this._rpcRequest("minimumLedgerSlot", []);
          const res = create3(unsafeRes, jsonRpcResult(number3()));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get minimum ledger slot");
          }
          return res.result;
        }
        async getFirstAvailableBlock() {
          const unsafeRes = await this._rpcRequest("getFirstAvailableBlock", []);
          const res = create3(unsafeRes, SlotRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get first available block");
          }
          return res.result;
        }
        async getSupply(config2) {
          let configArg = {};
          if (typeof config2 === "string") {
            configArg = {
              commitment: config2
            };
          } else if (config2) {
            configArg = {
              ...config2,
              commitment: config2 && config2.commitment || this.commitment
            };
          } else {
            configArg = {
              commitment: this.commitment
            };
          }
          const unsafeRes = await this._rpcRequest("getSupply", [configArg]);
          const res = create3(unsafeRes, GetSupplyRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get supply");
          }
          return res.result;
        }
        async getTokenSupply(tokenMintAddress, commitment) {
          const args = this._buildArgs([tokenMintAddress.toBase58()], commitment);
          const unsafeRes = await this._rpcRequest("getTokenSupply", args);
          const res = create3(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get token supply");
          }
          return res.result;
        }
        async getTokenAccountBalance(tokenAddress, commitment) {
          const args = this._buildArgs([tokenAddress.toBase58()], commitment);
          const unsafeRes = await this._rpcRequest("getTokenAccountBalance", args);
          const res = create3(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get token account balance");
          }
          return res.result;
        }
        async getTokenAccountsByOwner(ownerAddress, filter, commitmentOrConfig) {
          const {
            commitment,
            config: config2
          } = extractCommitmentFromConfig(commitmentOrConfig);
          let _args = [ownerAddress.toBase58()];
          if ("mint" in filter) {
            _args.push({
              mint: filter.mint.toBase58()
            });
          } else {
            _args.push({
              programId: filter.programId.toBase58()
            });
          }
          const args = this._buildArgs(_args, commitment, "base64", config2);
          const unsafeRes = await this._rpcRequest("getTokenAccountsByOwner", args);
          const res = create3(unsafeRes, GetTokenAccountsByOwner);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);
          }
          return res.result;
        }
        async getParsedTokenAccountsByOwner(ownerAddress, filter, commitment) {
          let _args = [ownerAddress.toBase58()];
          if ("mint" in filter) {
            _args.push({
              mint: filter.mint.toBase58()
            });
          } else {
            _args.push({
              programId: filter.programId.toBase58()
            });
          }
          const args = this._buildArgs(_args, commitment, "jsonParsed");
          const unsafeRes = await this._rpcRequest("getTokenAccountsByOwner", args);
          const res = create3(unsafeRes, GetParsedTokenAccountsByOwner);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);
          }
          return res.result;
        }
        async getLargestAccounts(config2) {
          const arg = {
            ...config2,
            commitment: config2 && config2.commitment || this.commitment
          };
          const args = arg.filter || arg.commitment ? [arg] : [];
          const unsafeRes = await this._rpcRequest("getLargestAccounts", args);
          const res = create3(unsafeRes, GetLargestAccountsRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get largest accounts");
          }
          return res.result;
        }
        async getTokenLargestAccounts(mintAddress, commitment) {
          const args = this._buildArgs([mintAddress.toBase58()], commitment);
          const unsafeRes = await this._rpcRequest("getTokenLargestAccounts", args);
          const res = create3(unsafeRes, GetTokenLargestAccountsResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get token largest accounts");
          }
          return res.result;
        }
        async getAccountInfoAndContext(publicKey6, commitmentOrConfig) {
          const {
            commitment,
            config: config2
          } = extractCommitmentFromConfig(commitmentOrConfig);
          const args = this._buildArgs([publicKey6.toBase58()], commitment, "base64", config2);
          const unsafeRes = await this._rpcRequest("getAccountInfo", args);
          const res = create3(unsafeRes, jsonRpcResultAndContext(nullable4(AccountInfoResult)));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey6.toBase58()}`);
          }
          return res.result;
        }
        async getParsedAccountInfo(publicKey6, commitmentOrConfig) {
          const {
            commitment,
            config: config2
          } = extractCommitmentFromConfig(commitmentOrConfig);
          const args = this._buildArgs([publicKey6.toBase58()], commitment, "jsonParsed", config2);
          const unsafeRes = await this._rpcRequest("getAccountInfo", args);
          const res = create3(unsafeRes, jsonRpcResultAndContext(nullable4(ParsedAccountInfoResult)));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey6.toBase58()}`);
          }
          return res.result;
        }
        async getAccountInfo(publicKey6, commitmentOrConfig) {
          try {
            const res = await this.getAccountInfoAndContext(publicKey6, commitmentOrConfig);
            return res.value;
          } catch (e) {
            throw new Error("failed to get info about account " + publicKey6.toBase58() + ": " + e);
          }
        }
        async getMultipleParsedAccounts(publicKeys, rawConfig) {
          const {
            commitment,
            config: config2
          } = extractCommitmentFromConfig(rawConfig);
          const keys = publicKeys.map((key) => key.toBase58());
          const args = this._buildArgs([keys], commitment, "jsonParsed", config2);
          const unsafeRes = await this._rpcRequest("getMultipleAccounts", args);
          const res = create3(unsafeRes, jsonRpcResultAndContext(array2(nullable4(ParsedAccountInfoResult))));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);
          }
          return res.result;
        }
        async getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig) {
          const {
            commitment,
            config: config2
          } = extractCommitmentFromConfig(commitmentOrConfig);
          const keys = publicKeys.map((key) => key.toBase58());
          const args = this._buildArgs([keys], commitment, "base64", config2);
          const unsafeRes = await this._rpcRequest("getMultipleAccounts", args);
          const res = create3(unsafeRes, jsonRpcResultAndContext(array2(nullable4(AccountInfoResult))));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);
          }
          return res.result;
        }
        async getMultipleAccountsInfo(publicKeys, commitmentOrConfig) {
          const res = await this.getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig);
          return res.value;
        }
        async getStakeActivation(publicKey6, commitmentOrConfig, epoch) {
          const {
            commitment,
            config: config2
          } = extractCommitmentFromConfig(commitmentOrConfig);
          const args = this._buildArgs([publicKey6.toBase58()], commitment, void 0, {
            ...config2,
            epoch: epoch != null ? epoch : config2?.epoch
          });
          const unsafeRes = await this._rpcRequest("getStakeActivation", args);
          const res = create3(unsafeRes, jsonRpcResult(StakeActivationResult));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get Stake Activation ${publicKey6.toBase58()}`);
          }
          return res.result;
        }
        async getProgramAccounts(programId, configOrCommitment) {
          const {
            commitment,
            config: config2
          } = extractCommitmentFromConfig(configOrCommitment);
          const {
            encoding,
            ...configWithoutEncoding
          } = config2 || {};
          const args = this._buildArgs([programId.toBase58()], commitment, encoding || "base64", configWithoutEncoding);
          const unsafeRes = await this._rpcRequest("getProgramAccounts", args);
          const baseSchema = array2(KeyedAccountInfoResult);
          const res = configWithoutEncoding.withContext === true ? create3(unsafeRes, jsonRpcResultAndContext(baseSchema)) : create3(unsafeRes, jsonRpcResult(baseSchema));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);
          }
          return res.result;
        }
        async getParsedProgramAccounts(programId, configOrCommitment) {
          const {
            commitment,
            config: config2
          } = extractCommitmentFromConfig(configOrCommitment);
          const args = this._buildArgs([programId.toBase58()], commitment, "jsonParsed", config2);
          const unsafeRes = await this._rpcRequest("getProgramAccounts", args);
          const res = create3(unsafeRes, jsonRpcResult(array2(KeyedParsedAccountInfoResult)));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);
          }
          return res.result;
        }
        async confirmTransaction(strategy, commitment) {
          let rawSignature;
          if (typeof strategy == "string") {
            rawSignature = strategy;
          } else {
            const config2 = strategy;
            if (config2.abortSignal?.aborted) {
              return Promise.reject(config2.abortSignal.reason);
            }
            rawSignature = config2.signature;
          }
          let decodedSignature;
          try {
            decodedSignature = import_bs58.default.decode(rawSignature);
          } catch (err2) {
            throw new Error("signature must be base58 encoded: " + rawSignature);
          }
          assert4(decodedSignature.length === 64, "signature has invalid length");
          if (typeof strategy === "string") {
            return await this.confirmTransactionUsingLegacyTimeoutStrategy({
              commitment: commitment || this.commitment,
              signature: rawSignature
            });
          } else if ("lastValidBlockHeight" in strategy) {
            return await this.confirmTransactionUsingBlockHeightExceedanceStrategy({
              commitment: commitment || this.commitment,
              strategy
            });
          } else {
            return await this.confirmTransactionUsingDurableNonceStrategy({
              commitment: commitment || this.commitment,
              strategy
            });
          }
        }
        getCancellationPromise(signal) {
          return new Promise((_2, reject) => {
            if (signal == null) {
              return;
            }
            if (signal.aborted) {
              reject(signal.reason);
            } else {
              signal.addEventListener("abort", () => {
                reject(signal.reason);
              });
            }
          });
        }
        getTransactionConfirmationPromise({
          commitment,
          signature: signature2
        }) {
          let signatureSubscriptionId;
          let disposeSignatureSubscriptionStateChangeObserver;
          let done = false;
          const confirmationPromise = new Promise((resolve, reject) => {
            try {
              signatureSubscriptionId = this.onSignature(signature2, (result, context) => {
                signatureSubscriptionId = void 0;
                const response = {
                  context,
                  value: result
                };
                resolve({
                  __type: TransactionStatus.PROCESSED,
                  response
                });
              }, commitment);
              const subscriptionSetupPromise = new Promise((resolveSubscriptionSetup) => {
                if (signatureSubscriptionId == null) {
                  resolveSubscriptionSetup();
                } else {
                  disposeSignatureSubscriptionStateChangeObserver = this._onSubscriptionStateChange(signatureSubscriptionId, (nextState) => {
                    if (nextState === "subscribed") {
                      resolveSubscriptionSetup();
                    }
                  });
                }
              });
              (async () => {
                await subscriptionSetupPromise;
                if (done)
                  return;
                const response = await this.getSignatureStatus(signature2);
                if (done)
                  return;
                if (response == null) {
                  return;
                }
                const {
                  context,
                  value
                } = response;
                if (value == null) {
                  return;
                }
                if (value?.err) {
                  reject(value.err);
                } else {
                  switch (commitment) {
                    case "confirmed":
                    case "single":
                    case "singleGossip": {
                      if (value.confirmationStatus === "processed") {
                        return;
                      }
                      break;
                    }
                    case "finalized":
                    case "max":
                    case "root": {
                      if (value.confirmationStatus === "processed" || value.confirmationStatus === "confirmed") {
                        return;
                      }
                      break;
                    }
                    case "processed":
                    case "recent":
                  }
                  done = true;
                  resolve({
                    __type: TransactionStatus.PROCESSED,
                    response: {
                      context,
                      value
                    }
                  });
                }
              })();
            } catch (err2) {
              reject(err2);
            }
          });
          const abortConfirmation = () => {
            if (disposeSignatureSubscriptionStateChangeObserver) {
              disposeSignatureSubscriptionStateChangeObserver();
              disposeSignatureSubscriptionStateChangeObserver = void 0;
            }
            if (signatureSubscriptionId != null) {
              this.removeSignatureListener(signatureSubscriptionId);
              signatureSubscriptionId = void 0;
            }
          };
          return {
            abortConfirmation,
            confirmationPromise
          };
        }
        async confirmTransactionUsingBlockHeightExceedanceStrategy({
          commitment,
          strategy: {
            abortSignal,
            lastValidBlockHeight,
            signature: signature2
          }
        }) {
          let done = false;
          const expiryPromise = new Promise((resolve) => {
            const checkBlockHeight = async () => {
              try {
                const blockHeight = await this.getBlockHeight(commitment);
                return blockHeight;
              } catch (_e2) {
                return -1;
              }
            };
            (async () => {
              let currentBlockHeight = await checkBlockHeight();
              if (done)
                return;
              while (currentBlockHeight <= lastValidBlockHeight) {
                await sleep(1e3);
                if (done)
                  return;
                currentBlockHeight = await checkBlockHeight();
                if (done)
                  return;
              }
              resolve({
                __type: TransactionStatus.BLOCKHEIGHT_EXCEEDED
              });
            })();
          });
          const {
            abortConfirmation,
            confirmationPromise
          } = this.getTransactionConfirmationPromise({
            commitment,
            signature: signature2
          });
          const cancellationPromise = this.getCancellationPromise(abortSignal);
          let result;
          try {
            const outcome = await Promise.race([cancellationPromise, confirmationPromise, expiryPromise]);
            if (outcome.__type === TransactionStatus.PROCESSED) {
              result = outcome.response;
            } else {
              throw new TransactionExpiredBlockheightExceededError(signature2);
            }
          } finally {
            done = true;
            abortConfirmation();
          }
          return result;
        }
        async confirmTransactionUsingDurableNonceStrategy({
          commitment,
          strategy: {
            abortSignal,
            minContextSlot,
            nonceAccountPubkey,
            nonceValue,
            signature: signature2
          }
        }) {
          let done = false;
          const expiryPromise = new Promise((resolve) => {
            let currentNonceValue = nonceValue;
            let lastCheckedSlot = null;
            const getCurrentNonceValue = async () => {
              try {
                const {
                  context,
                  value: nonceAccount
                } = await this.getNonceAndContext(nonceAccountPubkey, {
                  commitment,
                  minContextSlot
                });
                lastCheckedSlot = context.slot;
                return nonceAccount?.nonce;
              } catch (e) {
                return currentNonceValue;
              }
            };
            (async () => {
              currentNonceValue = await getCurrentNonceValue();
              if (done)
                return;
              while (true) {
                if (nonceValue !== currentNonceValue) {
                  resolve({
                    __type: TransactionStatus.NONCE_INVALID,
                    slotInWhichNonceDidAdvance: lastCheckedSlot
                  });
                  return;
                }
                await sleep(2e3);
                if (done)
                  return;
                currentNonceValue = await getCurrentNonceValue();
                if (done)
                  return;
              }
            })();
          });
          const {
            abortConfirmation,
            confirmationPromise
          } = this.getTransactionConfirmationPromise({
            commitment,
            signature: signature2
          });
          const cancellationPromise = this.getCancellationPromise(abortSignal);
          let result;
          try {
            const outcome = await Promise.race([cancellationPromise, confirmationPromise, expiryPromise]);
            if (outcome.__type === TransactionStatus.PROCESSED) {
              result = outcome.response;
            } else {
              let signatureStatus;
              while (true) {
                const status = await this.getSignatureStatus(signature2);
                if (status == null) {
                  break;
                }
                if (status.context.slot < (outcome.slotInWhichNonceDidAdvance ?? minContextSlot)) {
                  await sleep(400);
                  continue;
                }
                signatureStatus = status;
                break;
              }
              if (signatureStatus?.value) {
                const commitmentForStatus = commitment || "finalized";
                const {
                  confirmationStatus
                } = signatureStatus.value;
                switch (commitmentForStatus) {
                  case "processed":
                  case "recent":
                    if (confirmationStatus !== "processed" && confirmationStatus !== "confirmed" && confirmationStatus !== "finalized") {
                      throw new TransactionExpiredNonceInvalidError(signature2);
                    }
                    break;
                  case "confirmed":
                  case "single":
                  case "singleGossip":
                    if (confirmationStatus !== "confirmed" && confirmationStatus !== "finalized") {
                      throw new TransactionExpiredNonceInvalidError(signature2);
                    }
                    break;
                  case "finalized":
                  case "max":
                  case "root":
                    if (confirmationStatus !== "finalized") {
                      throw new TransactionExpiredNonceInvalidError(signature2);
                    }
                    break;
                  default:
                    ((_2) => {
                    })(commitmentForStatus);
                }
                result = {
                  context: signatureStatus.context,
                  value: {
                    err: signatureStatus.value.err
                  }
                };
              } else {
                throw new TransactionExpiredNonceInvalidError(signature2);
              }
            }
          } finally {
            done = true;
            abortConfirmation();
          }
          return result;
        }
        async confirmTransactionUsingLegacyTimeoutStrategy({
          commitment,
          signature: signature2
        }) {
          let timeoutId;
          const expiryPromise = new Promise((resolve) => {
            let timeoutMs = this._confirmTransactionInitialTimeout || 60 * 1e3;
            switch (commitment) {
              case "processed":
              case "recent":
              case "single":
              case "confirmed":
              case "singleGossip": {
                timeoutMs = this._confirmTransactionInitialTimeout || 30 * 1e3;
                break;
              }
            }
            timeoutId = setTimeout(() => resolve({
              __type: TransactionStatus.TIMED_OUT,
              timeoutMs
            }), timeoutMs);
          });
          const {
            abortConfirmation,
            confirmationPromise
          } = this.getTransactionConfirmationPromise({
            commitment,
            signature: signature2
          });
          let result;
          try {
            const outcome = await Promise.race([confirmationPromise, expiryPromise]);
            if (outcome.__type === TransactionStatus.PROCESSED) {
              result = outcome.response;
            } else {
              throw new TransactionExpiredTimeoutError(signature2, outcome.timeoutMs / 1e3);
            }
          } finally {
            clearTimeout(timeoutId);
            abortConfirmation();
          }
          return result;
        }
        async getClusterNodes() {
          const unsafeRes = await this._rpcRequest("getClusterNodes", []);
          const res = create3(unsafeRes, jsonRpcResult(array2(ContactInfoResult)));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get cluster nodes");
          }
          return res.result;
        }
        async getVoteAccounts(commitment) {
          const args = this._buildArgs([], commitment);
          const unsafeRes = await this._rpcRequest("getVoteAccounts", args);
          const res = create3(unsafeRes, GetVoteAccounts);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get vote accounts");
          }
          return res.result;
        }
        async getSlot(commitmentOrConfig) {
          const {
            commitment,
            config: config2
          } = extractCommitmentFromConfig(commitmentOrConfig);
          const args = this._buildArgs([], commitment, void 0, config2);
          const unsafeRes = await this._rpcRequest("getSlot", args);
          const res = create3(unsafeRes, jsonRpcResult(number3()));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get slot");
          }
          return res.result;
        }
        async getSlotLeader(commitmentOrConfig) {
          const {
            commitment,
            config: config2
          } = extractCommitmentFromConfig(commitmentOrConfig);
          const args = this._buildArgs([], commitment, void 0, config2);
          const unsafeRes = await this._rpcRequest("getSlotLeader", args);
          const res = create3(unsafeRes, jsonRpcResult(string2()));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get slot leader");
          }
          return res.result;
        }
        async getSlotLeaders(startSlot, limit) {
          const args = [startSlot, limit];
          const unsafeRes = await this._rpcRequest("getSlotLeaders", args);
          const res = create3(unsafeRes, jsonRpcResult(array2(PublicKeyFromString)));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get slot leaders");
          }
          return res.result;
        }
        async getSignatureStatus(signature2, config2) {
          const {
            context,
            value: values
          } = await this.getSignatureStatuses([signature2], config2);
          assert4(values.length === 1);
          const value = values[0];
          return {
            context,
            value
          };
        }
        async getSignatureStatuses(signatures, config2) {
          const params = [signatures];
          if (config2) {
            params.push(config2);
          }
          const unsafeRes = await this._rpcRequest("getSignatureStatuses", params);
          const res = create3(unsafeRes, GetSignatureStatusesRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get signature status");
          }
          return res.result;
        }
        async getTransactionCount(commitmentOrConfig) {
          const {
            commitment,
            config: config2
          } = extractCommitmentFromConfig(commitmentOrConfig);
          const args = this._buildArgs([], commitment, void 0, config2);
          const unsafeRes = await this._rpcRequest("getTransactionCount", args);
          const res = create3(unsafeRes, jsonRpcResult(number3()));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get transaction count");
          }
          return res.result;
        }
        async getTotalSupply(commitment) {
          const result = await this.getSupply({
            commitment,
            excludeNonCirculatingAccountsList: true
          });
          return result.value.total;
        }
        async getInflationGovernor(commitment) {
          const args = this._buildArgs([], commitment);
          const unsafeRes = await this._rpcRequest("getInflationGovernor", args);
          const res = create3(unsafeRes, GetInflationGovernorRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get inflation");
          }
          return res.result;
        }
        async getInflationReward(addresses, epoch, commitmentOrConfig) {
          const {
            commitment,
            config: config2
          } = extractCommitmentFromConfig(commitmentOrConfig);
          const args = this._buildArgs([addresses.map((pubkey) => pubkey.toBase58())], commitment, void 0, {
            ...config2,
            epoch: epoch != null ? epoch : config2?.epoch
          });
          const unsafeRes = await this._rpcRequest("getInflationReward", args);
          const res = create3(unsafeRes, GetInflationRewardResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get inflation reward");
          }
          return res.result;
        }
        async getInflationRate() {
          const unsafeRes = await this._rpcRequest("getInflationRate", []);
          const res = create3(unsafeRes, GetInflationRateRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get inflation rate");
          }
          return res.result;
        }
        async getEpochInfo(commitmentOrConfig) {
          const {
            commitment,
            config: config2
          } = extractCommitmentFromConfig(commitmentOrConfig);
          const args = this._buildArgs([], commitment, void 0, config2);
          const unsafeRes = await this._rpcRequest("getEpochInfo", args);
          const res = create3(unsafeRes, GetEpochInfoRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get epoch info");
          }
          return res.result;
        }
        async getEpochSchedule() {
          const unsafeRes = await this._rpcRequest("getEpochSchedule", []);
          const res = create3(unsafeRes, GetEpochScheduleRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get epoch schedule");
          }
          const epochSchedule = res.result;
          return new EpochSchedule(epochSchedule.slotsPerEpoch, epochSchedule.leaderScheduleSlotOffset, epochSchedule.warmup, epochSchedule.firstNormalEpoch, epochSchedule.firstNormalSlot);
        }
        async getLeaderSchedule() {
          const unsafeRes = await this._rpcRequest("getLeaderSchedule", []);
          const res = create3(unsafeRes, GetLeaderScheduleRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get leader schedule");
          }
          return res.result;
        }
        async getMinimumBalanceForRentExemption(dataLength, commitment) {
          const args = this._buildArgs([dataLength], commitment);
          const unsafeRes = await this._rpcRequest("getMinimumBalanceForRentExemption", args);
          const res = create3(unsafeRes, GetMinimumBalanceForRentExemptionRpcResult);
          if ("error" in res) {
            console.warn("Unable to fetch minimum balance for rent exemption");
            return 0;
          }
          return res.result;
        }
        async getRecentBlockhashAndContext(commitment) {
          const args = this._buildArgs([], commitment);
          const unsafeRes = await this._rpcRequest("getRecentBlockhash", args);
          const res = create3(unsafeRes, GetRecentBlockhashAndContextRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get recent blockhash");
          }
          return res.result;
        }
        async getRecentPerformanceSamples(limit) {
          const unsafeRes = await this._rpcRequest("getRecentPerformanceSamples", limit ? [limit] : []);
          const res = create3(unsafeRes, GetRecentPerformanceSamplesRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get recent performance samples");
          }
          return res.result;
        }
        async getFeeCalculatorForBlockhash(blockhash, commitment) {
          const args = this._buildArgs([blockhash], commitment);
          const unsafeRes = await this._rpcRequest("getFeeCalculatorForBlockhash", args);
          const res = create3(unsafeRes, GetFeeCalculatorRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get fee calculator");
          }
          const {
            context,
            value
          } = res.result;
          return {
            context,
            value: value !== null ? value.feeCalculator : null
          };
        }
        async getFeeForMessage(message, commitment) {
          const wireMessage = toBuffer(message.serialize()).toString("base64");
          const args = this._buildArgs([wireMessage], commitment);
          const unsafeRes = await this._rpcRequest("getFeeForMessage", args);
          const res = create3(unsafeRes, jsonRpcResultAndContext(nullable4(number3())));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get fee for message");
          }
          if (res.result === null) {
            throw new Error("invalid blockhash");
          }
          return res.result;
        }
        async getRecentPrioritizationFees(config2) {
          const accounts = config2?.lockedWritableAccounts?.map((key) => key.toBase58());
          const args = this._buildArgs(accounts?.length ? [accounts] : []);
          const unsafeRes = await this._rpcRequest("getRecentPrioritizationFees", args);
          const res = create3(unsafeRes, GetRecentPrioritizationFeesRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get recent prioritization fees");
          }
          return res.result;
        }
        async getRecentBlockhash(commitment) {
          try {
            const res = await this.getRecentBlockhashAndContext(commitment);
            return res.value;
          } catch (e) {
            throw new Error("failed to get recent blockhash: " + e);
          }
        }
        async getLatestBlockhash(commitmentOrConfig) {
          try {
            const res = await this.getLatestBlockhashAndContext(commitmentOrConfig);
            return res.value;
          } catch (e) {
            throw new Error("failed to get recent blockhash: " + e);
          }
        }
        async getLatestBlockhashAndContext(commitmentOrConfig) {
          const {
            commitment,
            config: config2
          } = extractCommitmentFromConfig(commitmentOrConfig);
          const args = this._buildArgs([], commitment, void 0, config2);
          const unsafeRes = await this._rpcRequest("getLatestBlockhash", args);
          const res = create3(unsafeRes, GetLatestBlockhashRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get latest blockhash");
          }
          return res.result;
        }
        async isBlockhashValid(blockhash, rawConfig) {
          const {
            commitment,
            config: config2
          } = extractCommitmentFromConfig(rawConfig);
          const args = this._buildArgs([blockhash], commitment, void 0, config2);
          const unsafeRes = await this._rpcRequest("isBlockhashValid", args);
          const res = create3(unsafeRes, IsBlockhashValidRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to determine if the blockhash `" + blockhash + "`is valid");
          }
          return res.result;
        }
        async getVersion() {
          const unsafeRes = await this._rpcRequest("getVersion", []);
          const res = create3(unsafeRes, jsonRpcResult(VersionResult));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get version");
          }
          return res.result;
        }
        async getGenesisHash() {
          const unsafeRes = await this._rpcRequest("getGenesisHash", []);
          const res = create3(unsafeRes, jsonRpcResult(string2()));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get genesis hash");
          }
          return res.result;
        }
        async getBlock(slot, rawConfig) {
          const {
            commitment,
            config: config2
          } = extractCommitmentFromConfig(rawConfig);
          const args = this._buildArgsAtLeastConfirmed([slot], commitment, void 0, config2);
          const unsafeRes = await this._rpcRequest("getBlock", args);
          try {
            switch (config2?.transactionDetails) {
              case "accounts": {
                const res = create3(unsafeRes, GetAccountsModeBlockRpcResult);
                if ("error" in res) {
                  throw res.error;
                }
                return res.result;
              }
              case "none": {
                const res = create3(unsafeRes, GetNoneModeBlockRpcResult);
                if ("error" in res) {
                  throw res.error;
                }
                return res.result;
              }
              default: {
                const res = create3(unsafeRes, GetBlockRpcResult);
                if ("error" in res) {
                  throw res.error;
                }
                const {
                  result
                } = res;
                return result ? {
                  ...result,
                  transactions: result.transactions.map(({
                    transaction,
                    meta,
                    version: version4
                  }) => ({
                    meta,
                    transaction: {
                      ...transaction,
                      message: versionedMessageFromResponse(version4, transaction.message)
                    },
                    version: version4
                  }))
                } : null;
              }
            }
          } catch (e) {
            throw new SolanaJSONRPCError(e, "failed to get confirmed block");
          }
        }
        async getParsedBlock(slot, rawConfig) {
          const {
            commitment,
            config: config2
          } = extractCommitmentFromConfig(rawConfig);
          const args = this._buildArgsAtLeastConfirmed([slot], commitment, "jsonParsed", config2);
          const unsafeRes = await this._rpcRequest("getBlock", args);
          try {
            switch (config2?.transactionDetails) {
              case "accounts": {
                const res = create3(unsafeRes, GetParsedAccountsModeBlockRpcResult);
                if ("error" in res) {
                  throw res.error;
                }
                return res.result;
              }
              case "none": {
                const res = create3(unsafeRes, GetParsedNoneModeBlockRpcResult);
                if ("error" in res) {
                  throw res.error;
                }
                return res.result;
              }
              default: {
                const res = create3(unsafeRes, GetParsedBlockRpcResult);
                if ("error" in res) {
                  throw res.error;
                }
                return res.result;
              }
            }
          } catch (e) {
            throw new SolanaJSONRPCError(e, "failed to get block");
          }
        }
        async getBlockProduction(configOrCommitment) {
          let extra;
          let commitment;
          if (typeof configOrCommitment === "string") {
            commitment = configOrCommitment;
          } else if (configOrCommitment) {
            const {
              commitment: c2,
              ...rest
            } = configOrCommitment;
            commitment = c2;
            extra = rest;
          }
          const args = this._buildArgs([], commitment, "base64", extra);
          const unsafeRes = await this._rpcRequest("getBlockProduction", args);
          const res = create3(unsafeRes, BlockProductionResponseStruct);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get block production information");
          }
          return res.result;
        }
        async getTransaction(signature2, rawConfig) {
          const {
            commitment,
            config: config2
          } = extractCommitmentFromConfig(rawConfig);
          const args = this._buildArgsAtLeastConfirmed([signature2], commitment, void 0, config2);
          const unsafeRes = await this._rpcRequest("getTransaction", args);
          const res = create3(unsafeRes, GetTransactionRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get transaction");
          }
          const result = res.result;
          if (!result)
            return result;
          return {
            ...result,
            transaction: {
              ...result.transaction,
              message: versionedMessageFromResponse(result.version, result.transaction.message)
            }
          };
        }
        async getParsedTransaction(signature2, commitmentOrConfig) {
          const {
            commitment,
            config: config2
          } = extractCommitmentFromConfig(commitmentOrConfig);
          const args = this._buildArgsAtLeastConfirmed([signature2], commitment, "jsonParsed", config2);
          const unsafeRes = await this._rpcRequest("getTransaction", args);
          const res = create3(unsafeRes, GetParsedTransactionRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get transaction");
          }
          return res.result;
        }
        async getParsedTransactions(signatures, commitmentOrConfig) {
          const {
            commitment,
            config: config2
          } = extractCommitmentFromConfig(commitmentOrConfig);
          const batch = signatures.map((signature2) => {
            const args = this._buildArgsAtLeastConfirmed([signature2], commitment, "jsonParsed", config2);
            return {
              methodName: "getTransaction",
              args
            };
          });
          const unsafeRes = await this._rpcBatchRequest(batch);
          const res = unsafeRes.map((unsafeRes2) => {
            const res2 = create3(unsafeRes2, GetParsedTransactionRpcResult);
            if ("error" in res2) {
              throw new SolanaJSONRPCError(res2.error, "failed to get transactions");
            }
            return res2.result;
          });
          return res;
        }
        async getTransactions(signatures, commitmentOrConfig) {
          const {
            commitment,
            config: config2
          } = extractCommitmentFromConfig(commitmentOrConfig);
          const batch = signatures.map((signature2) => {
            const args = this._buildArgsAtLeastConfirmed([signature2], commitment, void 0, config2);
            return {
              methodName: "getTransaction",
              args
            };
          });
          const unsafeRes = await this._rpcBatchRequest(batch);
          const res = unsafeRes.map((unsafeRes2) => {
            const res2 = create3(unsafeRes2, GetTransactionRpcResult);
            if ("error" in res2) {
              throw new SolanaJSONRPCError(res2.error, "failed to get transactions");
            }
            const result = res2.result;
            if (!result)
              return result;
            return {
              ...result,
              transaction: {
                ...result.transaction,
                message: versionedMessageFromResponse(result.version, result.transaction.message)
              }
            };
          });
          return res;
        }
        async getConfirmedBlock(slot, commitment) {
          const args = this._buildArgsAtLeastConfirmed([slot], commitment);
          const unsafeRes = await this._rpcRequest("getConfirmedBlock", args);
          const res = create3(unsafeRes, GetConfirmedBlockRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get confirmed block");
          }
          const result = res.result;
          if (!result) {
            throw new Error("Confirmed block " + slot + " not found");
          }
          const block = {
            ...result,
            transactions: result.transactions.map(({
              transaction,
              meta
            }) => {
              const message = new Message(transaction.message);
              return {
                meta,
                transaction: {
                  ...transaction,
                  message
                }
              };
            })
          };
          return {
            ...block,
            transactions: block.transactions.map(({
              transaction,
              meta
            }) => {
              return {
                meta,
                transaction: Transaction.populate(transaction.message, transaction.signatures)
              };
            })
          };
        }
        async getBlocks(startSlot, endSlot, commitment) {
          const args = this._buildArgsAtLeastConfirmed(endSlot !== void 0 ? [startSlot, endSlot] : [startSlot], commitment);
          const unsafeRes = await this._rpcRequest("getBlocks", args);
          const res = create3(unsafeRes, jsonRpcResult(array2(number3())));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get blocks");
          }
          return res.result;
        }
        async getBlockSignatures(slot, commitment) {
          const args = this._buildArgsAtLeastConfirmed([slot], commitment, void 0, {
            transactionDetails: "signatures",
            rewards: false
          });
          const unsafeRes = await this._rpcRequest("getBlock", args);
          const res = create3(unsafeRes, GetBlockSignaturesRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get block");
          }
          const result = res.result;
          if (!result) {
            throw new Error("Block " + slot + " not found");
          }
          return result;
        }
        async getConfirmedBlockSignatures(slot, commitment) {
          const args = this._buildArgsAtLeastConfirmed([slot], commitment, void 0, {
            transactionDetails: "signatures",
            rewards: false
          });
          const unsafeRes = await this._rpcRequest("getConfirmedBlock", args);
          const res = create3(unsafeRes, GetBlockSignaturesRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get confirmed block");
          }
          const result = res.result;
          if (!result) {
            throw new Error("Confirmed block " + slot + " not found");
          }
          return result;
        }
        async getConfirmedTransaction(signature2, commitment) {
          const args = this._buildArgsAtLeastConfirmed([signature2], commitment);
          const unsafeRes = await this._rpcRequest("getConfirmedTransaction", args);
          const res = create3(unsafeRes, GetTransactionRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get transaction");
          }
          const result = res.result;
          if (!result)
            return result;
          const message = new Message(result.transaction.message);
          const signatures = result.transaction.signatures;
          return {
            ...result,
            transaction: Transaction.populate(message, signatures)
          };
        }
        async getParsedConfirmedTransaction(signature2, commitment) {
          const args = this._buildArgsAtLeastConfirmed([signature2], commitment, "jsonParsed");
          const unsafeRes = await this._rpcRequest("getConfirmedTransaction", args);
          const res = create3(unsafeRes, GetParsedTransactionRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get confirmed transaction");
          }
          return res.result;
        }
        async getParsedConfirmedTransactions(signatures, commitment) {
          const batch = signatures.map((signature2) => {
            const args = this._buildArgsAtLeastConfirmed([signature2], commitment, "jsonParsed");
            return {
              methodName: "getConfirmedTransaction",
              args
            };
          });
          const unsafeRes = await this._rpcBatchRequest(batch);
          const res = unsafeRes.map((unsafeRes2) => {
            const res2 = create3(unsafeRes2, GetParsedTransactionRpcResult);
            if ("error" in res2) {
              throw new SolanaJSONRPCError(res2.error, "failed to get confirmed transactions");
            }
            return res2.result;
          });
          return res;
        }
        async getConfirmedSignaturesForAddress(address, startSlot, endSlot) {
          let options = {};
          let firstAvailableBlock = await this.getFirstAvailableBlock();
          while (!("until" in options)) {
            startSlot--;
            if (startSlot <= 0 || startSlot < firstAvailableBlock) {
              break;
            }
            try {
              const block = await this.getConfirmedBlockSignatures(startSlot, "finalized");
              if (block.signatures.length > 0) {
                options.until = block.signatures[block.signatures.length - 1].toString();
              }
            } catch (err2) {
              if (err2 instanceof Error && err2.message.includes("skipped")) {
                continue;
              } else {
                throw err2;
              }
            }
          }
          let highestConfirmedRoot = await this.getSlot("finalized");
          while (!("before" in options)) {
            endSlot++;
            if (endSlot > highestConfirmedRoot) {
              break;
            }
            try {
              const block = await this.getConfirmedBlockSignatures(endSlot);
              if (block.signatures.length > 0) {
                options.before = block.signatures[block.signatures.length - 1].toString();
              }
            } catch (err2) {
              if (err2 instanceof Error && err2.message.includes("skipped")) {
                continue;
              } else {
                throw err2;
              }
            }
          }
          const confirmedSignatureInfo = await this.getConfirmedSignaturesForAddress2(address, options);
          return confirmedSignatureInfo.map((info) => info.signature);
        }
        async getConfirmedSignaturesForAddress2(address, options, commitment) {
          const args = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, void 0, options);
          const unsafeRes = await this._rpcRequest("getConfirmedSignaturesForAddress2", args);
          const res = create3(unsafeRes, GetConfirmedSignaturesForAddress2RpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get confirmed signatures for address");
          }
          return res.result;
        }
        async getSignaturesForAddress(address, options, commitment) {
          const args = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, void 0, options);
          const unsafeRes = await this._rpcRequest("getSignaturesForAddress", args);
          const res = create3(unsafeRes, GetSignaturesForAddressRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get signatures for address");
          }
          return res.result;
        }
        async getAddressLookupTable(accountKey, config2) {
          const {
            context,
            value: accountInfo
          } = await this.getAccountInfoAndContext(accountKey, config2);
          let value = null;
          if (accountInfo !== null) {
            value = new AddressLookupTableAccount({
              key: accountKey,
              state: AddressLookupTableAccount.deserialize(accountInfo.data)
            });
          }
          return {
            context,
            value
          };
        }
        async getNonceAndContext(nonceAccount, commitmentOrConfig) {
          const {
            context,
            value: accountInfo
          } = await this.getAccountInfoAndContext(nonceAccount, commitmentOrConfig);
          let value = null;
          if (accountInfo !== null) {
            value = NonceAccount.fromAccountData(accountInfo.data);
          }
          return {
            context,
            value
          };
        }
        async getNonce(nonceAccount, commitmentOrConfig) {
          return await this.getNonceAndContext(nonceAccount, commitmentOrConfig).then((x2) => x2.value).catch((e) => {
            throw new Error("failed to get nonce for account " + nonceAccount.toBase58() + ": " + e);
          });
        }
        async requestAirdrop(to, lamports) {
          const unsafeRes = await this._rpcRequest("requestAirdrop", [to.toBase58(), lamports]);
          const res = create3(unsafeRes, RequestAirdropRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, `airdrop to ${to.toBase58()} failed`);
          }
          return res.result;
        }
        async _blockhashWithExpiryBlockHeight(disableCache) {
          if (!disableCache) {
            while (this._pollingBlockhash) {
              await sleep(100);
            }
            const timeSinceFetch = Date.now() - this._blockhashInfo.lastFetch;
            const expired = timeSinceFetch >= BLOCKHASH_CACHE_TIMEOUT_MS;
            if (this._blockhashInfo.latestBlockhash !== null && !expired) {
              return this._blockhashInfo.latestBlockhash;
            }
          }
          return await this._pollNewBlockhash();
        }
        async _pollNewBlockhash() {
          this._pollingBlockhash = true;
          try {
            const startTime2 = Date.now();
            const cachedLatestBlockhash = this._blockhashInfo.latestBlockhash;
            const cachedBlockhash = cachedLatestBlockhash ? cachedLatestBlockhash.blockhash : null;
            for (let i = 0; i < 50; i++) {
              const latestBlockhash = await this.getLatestBlockhash("finalized");
              if (cachedBlockhash !== latestBlockhash.blockhash) {
                this._blockhashInfo = {
                  latestBlockhash,
                  lastFetch: Date.now(),
                  transactionSignatures: [],
                  simulatedSignatures: []
                };
                return latestBlockhash;
              }
              await sleep(MS_PER_SLOT / 2);
            }
            throw new Error(`Unable to obtain a new blockhash after ${Date.now() - startTime2}ms`);
          } finally {
            this._pollingBlockhash = false;
          }
        }
        async getStakeMinimumDelegation(config2) {
          const {
            commitment,
            config: configArg
          } = extractCommitmentFromConfig(config2);
          const args = this._buildArgs([], commitment, "base64", configArg);
          const unsafeRes = await this._rpcRequest("getStakeMinimumDelegation", args);
          const res = create3(unsafeRes, jsonRpcResultAndContext(number3()));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get stake minimum delegation`);
          }
          return res.result;
        }
        async simulateTransaction(transactionOrMessage, configOrSigners, includeAccounts) {
          if ("message" in transactionOrMessage) {
            const versionedTx = transactionOrMessage;
            const wireTransaction2 = versionedTx.serialize();
            const encodedTransaction2 = import_buffer86.Buffer.from(wireTransaction2).toString("base64");
            if (Array.isArray(configOrSigners) || includeAccounts !== void 0) {
              throw new Error("Invalid arguments");
            }
            const config3 = configOrSigners || {};
            config3.encoding = "base64";
            if (!("commitment" in config3)) {
              config3.commitment = this.commitment;
            }
            const args2 = [encodedTransaction2, config3];
            const unsafeRes2 = await this._rpcRequest("simulateTransaction", args2);
            const res2 = create3(unsafeRes2, SimulatedTransactionResponseStruct);
            if ("error" in res2) {
              throw new Error("failed to simulate transaction: " + res2.error.message);
            }
            return res2.result;
          }
          let transaction;
          if (transactionOrMessage instanceof Transaction) {
            let originalTx = transactionOrMessage;
            transaction = new Transaction();
            transaction.feePayer = originalTx.feePayer;
            transaction.instructions = transactionOrMessage.instructions;
            transaction.nonceInfo = originalTx.nonceInfo;
            transaction.signatures = originalTx.signatures;
          } else {
            transaction = Transaction.populate(transactionOrMessage);
            transaction._message = transaction._json = void 0;
          }
          if (configOrSigners !== void 0 && !Array.isArray(configOrSigners)) {
            throw new Error("Invalid arguments");
          }
          const signers = configOrSigners;
          if (transaction.nonceInfo && signers) {
            transaction.sign(...signers);
          } else {
            let disableCache = this._disableBlockhashCaching;
            for (; ; ) {
              const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);
              transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;
              transaction.recentBlockhash = latestBlockhash.blockhash;
              if (!signers)
                break;
              transaction.sign(...signers);
              if (!transaction.signature) {
                throw new Error("!signature");
              }
              const signature2 = transaction.signature.toString("base64");
              if (!this._blockhashInfo.simulatedSignatures.includes(signature2) && !this._blockhashInfo.transactionSignatures.includes(signature2)) {
                this._blockhashInfo.simulatedSignatures.push(signature2);
                break;
              } else {
                disableCache = true;
              }
            }
          }
          const message = transaction._compile();
          const signData = message.serialize();
          const wireTransaction = transaction._serialize(signData);
          const encodedTransaction = wireTransaction.toString("base64");
          const config2 = {
            encoding: "base64",
            commitment: this.commitment
          };
          if (includeAccounts) {
            const addresses = (Array.isArray(includeAccounts) ? includeAccounts : message.nonProgramIds()).map((key) => key.toBase58());
            config2["accounts"] = {
              encoding: "base64",
              addresses
            };
          }
          if (signers) {
            config2.sigVerify = true;
          }
          const args = [encodedTransaction, config2];
          const unsafeRes = await this._rpcRequest("simulateTransaction", args);
          const res = create3(unsafeRes, SimulatedTransactionResponseStruct);
          if ("error" in res) {
            let logs;
            if ("data" in res.error) {
              logs = res.error.data.logs;
              if (logs && Array.isArray(logs)) {
                const traceIndent = "\n    ";
                const logTrace = traceIndent + logs.join(traceIndent);
                console.error(res.error.message, logTrace);
              }
            }
            throw new SendTransactionError("failed to simulate transaction: " + res.error.message, logs);
          }
          return res.result;
        }
        async sendTransaction(transaction, signersOrOptions, options) {
          if ("version" in transaction) {
            if (signersOrOptions && Array.isArray(signersOrOptions)) {
              throw new Error("Invalid arguments");
            }
            const wireTransaction2 = transaction.serialize();
            return await this.sendRawTransaction(wireTransaction2, signersOrOptions);
          }
          if (signersOrOptions === void 0 || !Array.isArray(signersOrOptions)) {
            throw new Error("Invalid arguments");
          }
          const signers = signersOrOptions;
          if (transaction.nonceInfo) {
            transaction.sign(...signers);
          } else {
            let disableCache = this._disableBlockhashCaching;
            for (; ; ) {
              const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);
              transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;
              transaction.recentBlockhash = latestBlockhash.blockhash;
              transaction.sign(...signers);
              if (!transaction.signature) {
                throw new Error("!signature");
              }
              const signature2 = transaction.signature.toString("base64");
              if (!this._blockhashInfo.transactionSignatures.includes(signature2)) {
                this._blockhashInfo.transactionSignatures.push(signature2);
                break;
              } else {
                disableCache = true;
              }
            }
          }
          const wireTransaction = transaction.serialize();
          return await this.sendRawTransaction(wireTransaction, options);
        }
        async sendRawTransaction(rawTransaction, options) {
          const encodedTransaction = toBuffer(rawTransaction).toString("base64");
          const result = await this.sendEncodedTransaction(encodedTransaction, options);
          return result;
        }
        async sendEncodedTransaction(encodedTransaction, options) {
          const config2 = {
            encoding: "base64"
          };
          const skipPreflight = options && options.skipPreflight;
          const preflightCommitment = options && options.preflightCommitment || this.commitment;
          if (options && options.maxRetries != null) {
            config2.maxRetries = options.maxRetries;
          }
          if (options && options.minContextSlot != null) {
            config2.minContextSlot = options.minContextSlot;
          }
          if (skipPreflight) {
            config2.skipPreflight = skipPreflight;
          }
          if (preflightCommitment) {
            config2.preflightCommitment = preflightCommitment;
          }
          const args = [encodedTransaction, config2];
          const unsafeRes = await this._rpcRequest("sendTransaction", args);
          const res = create3(unsafeRes, SendTransactionRpcResult);
          if ("error" in res) {
            let logs;
            if ("data" in res.error) {
              logs = res.error.data.logs;
            }
            throw new SendTransactionError("failed to send transaction: " + res.error.message, logs);
          }
          return res.result;
        }
        _wsOnOpen() {
          this._rpcWebSocketConnected = true;
          this._rpcWebSocketHeartbeat = setInterval(() => {
            (async () => {
              try {
                await this._rpcWebSocket.notify("ping");
              } catch {
              }
            })();
          }, 5e3);
          this._updateSubscriptions();
        }
        _wsOnError(err2) {
          this._rpcWebSocketConnected = false;
          console.error("ws error:", err2.message);
        }
        _wsOnClose(code2) {
          this._rpcWebSocketConnected = false;
          this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER;
          if (this._rpcWebSocketIdleTimeout) {
            clearTimeout(this._rpcWebSocketIdleTimeout);
            this._rpcWebSocketIdleTimeout = null;
          }
          if (this._rpcWebSocketHeartbeat) {
            clearInterval(this._rpcWebSocketHeartbeat);
            this._rpcWebSocketHeartbeat = null;
          }
          if (code2 === 1e3) {
            this._updateSubscriptions();
            return;
          }
          this._subscriptionCallbacksByServerSubscriptionId = {};
          Object.entries(this._subscriptionsByHash).forEach(([hash2, subscription]) => {
            this._setSubscription(hash2, {
              ...subscription,
              state: "pending"
            });
          });
        }
        _setSubscription(hash2, nextSubscription) {
          const prevState = this._subscriptionsByHash[hash2]?.state;
          this._subscriptionsByHash[hash2] = nextSubscription;
          if (prevState !== nextSubscription.state) {
            const stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash2];
            if (stateChangeCallbacks) {
              stateChangeCallbacks.forEach((cb) => {
                try {
                  cb(nextSubscription.state);
                } catch {
                }
              });
            }
          }
        }
        _onSubscriptionStateChange(clientSubscriptionId, callback) {
          const hash2 = this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];
          if (hash2 == null) {
            return () => {
            };
          }
          const stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash2] ||= /* @__PURE__ */ new Set();
          stateChangeCallbacks.add(callback);
          return () => {
            stateChangeCallbacks.delete(callback);
            if (stateChangeCallbacks.size === 0) {
              delete this._subscriptionStateChangeCallbacksByHash[hash2];
            }
          };
        }
        async _updateSubscriptions() {
          if (Object.keys(this._subscriptionsByHash).length === 0) {
            if (this._rpcWebSocketConnected) {
              this._rpcWebSocketConnected = false;
              this._rpcWebSocketIdleTimeout = setTimeout(() => {
                this._rpcWebSocketIdleTimeout = null;
                try {
                  this._rpcWebSocket.close();
                } catch (err2) {
                  if (err2 instanceof Error) {
                    console.log(`Error when closing socket connection: ${err2.message}`);
                  }
                }
              }, 500);
            }
            return;
          }
          if (this._rpcWebSocketIdleTimeout !== null) {
            clearTimeout(this._rpcWebSocketIdleTimeout);
            this._rpcWebSocketIdleTimeout = null;
            this._rpcWebSocketConnected = true;
          }
          if (!this._rpcWebSocketConnected) {
            this._rpcWebSocket.connect();
            return;
          }
          const activeWebSocketGeneration = this._rpcWebSocketGeneration;
          const isCurrentConnectionStillActive = () => {
            return activeWebSocketGeneration === this._rpcWebSocketGeneration;
          };
          await Promise.all(
            Object.keys(this._subscriptionsByHash).map(async (hash2) => {
              const subscription = this._subscriptionsByHash[hash2];
              if (subscription === void 0) {
                return;
              }
              switch (subscription.state) {
                case "pending":
                case "unsubscribed":
                  if (subscription.callbacks.size === 0) {
                    delete this._subscriptionsByHash[hash2];
                    if (subscription.state === "unsubscribed") {
                      delete this._subscriptionCallbacksByServerSubscriptionId[subscription.serverSubscriptionId];
                    }
                    await this._updateSubscriptions();
                    return;
                  }
                  await (async () => {
                    const {
                      args,
                      method: method2
                    } = subscription;
                    try {
                      this._setSubscription(hash2, {
                        ...subscription,
                        state: "subscribing"
                      });
                      const serverSubscriptionId = await this._rpcWebSocket.call(method2, args);
                      this._setSubscription(hash2, {
                        ...subscription,
                        serverSubscriptionId,
                        state: "subscribed"
                      });
                      this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId] = subscription.callbacks;
                      await this._updateSubscriptions();
                    } catch (e) {
                      if (e instanceof Error) {
                        console.error(`${method2} error for argument`, args, e.message);
                      }
                      if (!isCurrentConnectionStillActive()) {
                        return;
                      }
                      this._setSubscription(hash2, {
                        ...subscription,
                        state: "pending"
                      });
                      await this._updateSubscriptions();
                    }
                  })();
                  break;
                case "subscribed":
                  if (subscription.callbacks.size === 0) {
                    await (async () => {
                      const {
                        serverSubscriptionId,
                        unsubscribeMethod
                      } = subscription;
                      if (this._subscriptionsAutoDisposedByRpc.has(serverSubscriptionId)) {
                        this._subscriptionsAutoDisposedByRpc.delete(serverSubscriptionId);
                      } else {
                        this._setSubscription(hash2, {
                          ...subscription,
                          state: "unsubscribing"
                        });
                        this._setSubscription(hash2, {
                          ...subscription,
                          state: "unsubscribing"
                        });
                        try {
                          await this._rpcWebSocket.call(unsubscribeMethod, [serverSubscriptionId]);
                        } catch (e) {
                          if (e instanceof Error) {
                            console.error(`${unsubscribeMethod} error:`, e.message);
                          }
                          if (!isCurrentConnectionStillActive()) {
                            return;
                          }
                          this._setSubscription(hash2, {
                            ...subscription,
                            state: "subscribed"
                          });
                          await this._updateSubscriptions();
                          return;
                        }
                      }
                      this._setSubscription(hash2, {
                        ...subscription,
                        state: "unsubscribed"
                      });
                      await this._updateSubscriptions();
                    })();
                  }
                  break;
              }
            })
          );
        }
        _handleServerNotification(serverSubscriptionId, callbackArgs) {
          const callbacks = this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId];
          if (callbacks === void 0) {
            return;
          }
          callbacks.forEach((cb) => {
            try {
              cb(
                ...callbackArgs
              );
            } catch (e) {
              console.error(e);
            }
          });
        }
        _wsOnAccountNotification(notification) {
          const {
            result,
            subscription
          } = create3(notification, AccountNotificationResult);
          this._handleServerNotification(subscription, [result.value, result.context]);
        }
        _makeSubscription(subscriptionConfig, args) {
          const clientSubscriptionId = this._nextClientSubscriptionId++;
          const hash2 = fastStableStringify$1([subscriptionConfig.method, args], true);
          const existingSubscription = this._subscriptionsByHash[hash2];
          if (existingSubscription === void 0) {
            this._subscriptionsByHash[hash2] = {
              ...subscriptionConfig,
              args,
              callbacks: /* @__PURE__ */ new Set([subscriptionConfig.callback]),
              state: "pending"
            };
          } else {
            existingSubscription.callbacks.add(subscriptionConfig.callback);
          }
          this._subscriptionHashByClientSubscriptionId[clientSubscriptionId] = hash2;
          this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId] = async () => {
            delete this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];
            delete this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];
            const subscription = this._subscriptionsByHash[hash2];
            assert4(subscription !== void 0, `Could not find a \`Subscription\` when tearing down client subscription #${clientSubscriptionId}`);
            subscription.callbacks.delete(subscriptionConfig.callback);
            await this._updateSubscriptions();
          };
          this._updateSubscriptions();
          return clientSubscriptionId;
        }
        onAccountChange(publicKey6, callback, commitment) {
          const args = this._buildArgs(
            [publicKey6.toBase58()],
            commitment || this._commitment || "finalized",
            "base64"
          );
          return this._makeSubscription({
            callback,
            method: "accountSubscribe",
            unsubscribeMethod: "accountUnsubscribe"
          }, args);
        }
        async removeAccountChangeListener(clientSubscriptionId) {
          await this._unsubscribeClientSubscription(clientSubscriptionId, "account change");
        }
        _wsOnProgramAccountNotification(notification) {
          const {
            result,
            subscription
          } = create3(notification, ProgramAccountNotificationResult);
          this._handleServerNotification(subscription, [{
            accountId: result.value.pubkey,
            accountInfo: result.value.account
          }, result.context]);
        }
        onProgramAccountChange(programId, callback, commitment, filters) {
          const args = this._buildArgs(
            [programId.toBase58()],
            commitment || this._commitment || "finalized",
            "base64",
            filters ? {
              filters
            } : void 0
          );
          return this._makeSubscription({
            callback,
            method: "programSubscribe",
            unsubscribeMethod: "programUnsubscribe"
          }, args);
        }
        async removeProgramAccountChangeListener(clientSubscriptionId) {
          await this._unsubscribeClientSubscription(clientSubscriptionId, "program account change");
        }
        onLogs(filter, callback, commitment) {
          const args = this._buildArgs(
            [typeof filter === "object" ? {
              mentions: [filter.toString()]
            } : filter],
            commitment || this._commitment || "finalized"
          );
          return this._makeSubscription({
            callback,
            method: "logsSubscribe",
            unsubscribeMethod: "logsUnsubscribe"
          }, args);
        }
        async removeOnLogsListener(clientSubscriptionId) {
          await this._unsubscribeClientSubscription(clientSubscriptionId, "logs");
        }
        _wsOnLogsNotification(notification) {
          const {
            result,
            subscription
          } = create3(notification, LogsNotificationResult);
          this._handleServerNotification(subscription, [result.value, result.context]);
        }
        _wsOnSlotNotification(notification) {
          const {
            result,
            subscription
          } = create3(notification, SlotNotificationResult);
          this._handleServerNotification(subscription, [result]);
        }
        onSlotChange(callback) {
          return this._makeSubscription({
            callback,
            method: "slotSubscribe",
            unsubscribeMethod: "slotUnsubscribe"
          }, []);
        }
        async removeSlotChangeListener(clientSubscriptionId) {
          await this._unsubscribeClientSubscription(clientSubscriptionId, "slot change");
        }
        _wsOnSlotUpdatesNotification(notification) {
          const {
            result,
            subscription
          } = create3(notification, SlotUpdateNotificationResult);
          this._handleServerNotification(subscription, [result]);
        }
        onSlotUpdate(callback) {
          return this._makeSubscription({
            callback,
            method: "slotsUpdatesSubscribe",
            unsubscribeMethod: "slotsUpdatesUnsubscribe"
          }, []);
        }
        async removeSlotUpdateListener(clientSubscriptionId) {
          await this._unsubscribeClientSubscription(clientSubscriptionId, "slot update");
        }
        async _unsubscribeClientSubscription(clientSubscriptionId, subscriptionName) {
          const dispose = this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];
          if (dispose) {
            await dispose();
          } else {
            console.warn(`Ignored unsubscribe request because an active subscription with id \`${clientSubscriptionId}\` for '${subscriptionName}' events could not be found.`);
          }
        }
        _buildArgs(args, override, encoding, extra) {
          const commitment = override || this._commitment;
          if (commitment || encoding || extra) {
            let options = {};
            if (encoding) {
              options.encoding = encoding;
            }
            if (commitment) {
              options.commitment = commitment;
            }
            if (extra) {
              options = Object.assign(options, extra);
            }
            args.push(options);
          }
          return args;
        }
        _buildArgsAtLeastConfirmed(args, override, encoding, extra) {
          const commitment = override || this._commitment;
          if (commitment && !["confirmed", "finalized"].includes(commitment)) {
            throw new Error("Using Connection with default commitment: `" + this._commitment + "`, but method requires at least `confirmed`");
          }
          return this._buildArgs(args, override, encoding, extra);
        }
        _wsOnSignatureNotification(notification) {
          const {
            result,
            subscription
          } = create3(notification, SignatureNotificationResult);
          if (result.value !== "receivedSignature") {
            this._subscriptionsAutoDisposedByRpc.add(subscription);
          }
          this._handleServerNotification(subscription, result.value === "receivedSignature" ? [{
            type: "received"
          }, result.context] : [{
            type: "status",
            result: result.value
          }, result.context]);
        }
        onSignature(signature2, callback, commitment) {
          const args = this._buildArgs(
            [signature2],
            commitment || this._commitment || "finalized"
          );
          const clientSubscriptionId = this._makeSubscription({
            callback: (notification, context) => {
              if (notification.type === "status") {
                callback(notification.result, context);
                try {
                  this.removeSignatureListener(clientSubscriptionId);
                } catch (_err) {
                }
              }
            },
            method: "signatureSubscribe",
            unsubscribeMethod: "signatureUnsubscribe"
          }, args);
          return clientSubscriptionId;
        }
        onSignatureWithOptions(signature2, callback, options) {
          const {
            commitment,
            ...extra
          } = {
            ...options,
            commitment: options && options.commitment || this._commitment || "finalized"
          };
          const args = this._buildArgs([signature2], commitment, void 0, extra);
          const clientSubscriptionId = this._makeSubscription({
            callback: (notification, context) => {
              callback(notification, context);
              try {
                this.removeSignatureListener(clientSubscriptionId);
              } catch (_err) {
              }
            },
            method: "signatureSubscribe",
            unsubscribeMethod: "signatureUnsubscribe"
          }, args);
          return clientSubscriptionId;
        }
        async removeSignatureListener(clientSubscriptionId) {
          await this._unsubscribeClientSubscription(clientSubscriptionId, "signature result");
        }
        _wsOnRootNotification(notification) {
          const {
            result,
            subscription
          } = create3(notification, RootNotificationResult);
          this._handleServerNotification(subscription, [result]);
        }
        onRootChange(callback) {
          return this._makeSubscription({
            callback,
            method: "rootSubscribe",
            unsubscribeMethod: "rootUnsubscribe"
          }, []);
        }
        async removeRootChangeListener(clientSubscriptionId) {
          await this._unsubscribeClientSubscription(clientSubscriptionId, "root change");
        }
      };
      Keypair = class {
        constructor(keypair) {
          this._keypair = void 0;
          this._keypair = keypair ?? generateKeypair();
        }
        static generate() {
          return new Keypair(generateKeypair());
        }
        static fromSecretKey(secretKey, options) {
          if (secretKey.byteLength !== 64) {
            throw new Error("bad secret key size");
          }
          const publicKey6 = secretKey.slice(32, 64);
          if (!options || !options.skipValidation) {
            const privateScalar = secretKey.slice(0, 32);
            const computedPublicKey = getPublicKey(privateScalar);
            for (let ii = 0; ii < 32; ii++) {
              if (publicKey6[ii] !== computedPublicKey[ii]) {
                throw new Error("provided secretKey is invalid");
              }
            }
          }
          return new Keypair({
            publicKey: publicKey6,
            secretKey
          });
        }
        static fromSeed(seed2) {
          const publicKey6 = getPublicKey(seed2);
          const secretKey = new Uint8Array(64);
          secretKey.set(seed2);
          secretKey.set(publicKey6, 32);
          return new Keypair({
            publicKey: publicKey6,
            secretKey
          });
        }
        get publicKey() {
          return new PublicKey(this._keypair.publicKey);
        }
        get secretKey() {
          return new Uint8Array(this._keypair.secretKey);
        }
      };
      LOOKUP_TABLE_INSTRUCTION_LAYOUTS = Object.freeze({
        CreateLookupTable: {
          index: 0,
          layout: BufferLayout.struct([BufferLayout.u32("instruction"), u642("recentSlot"), BufferLayout.u8("bumpSeed")])
        },
        FreezeLookupTable: {
          index: 1,
          layout: BufferLayout.struct([BufferLayout.u32("instruction")])
        },
        ExtendLookupTable: {
          index: 2,
          layout: BufferLayout.struct([BufferLayout.u32("instruction"), u642(), BufferLayout.seq(publicKey(), BufferLayout.offset(BufferLayout.u32(), -8), "addresses")])
        },
        DeactivateLookupTable: {
          index: 3,
          layout: BufferLayout.struct([BufferLayout.u32("instruction")])
        },
        CloseLookupTable: {
          index: 4,
          layout: BufferLayout.struct([BufferLayout.u32("instruction")])
        }
      });
      AddressLookupTableInstruction = class {
        constructor() {
        }
        static decodeInstructionType(instruction) {
          this.checkProgramId(instruction.programId);
          const instructionTypeLayout = BufferLayout.u32("instruction");
          const index = instructionTypeLayout.decode(instruction.data);
          let type5;
          for (const [layoutType, layout] of Object.entries(LOOKUP_TABLE_INSTRUCTION_LAYOUTS)) {
            if (layout.index == index) {
              type5 = layoutType;
              break;
            }
          }
          if (!type5) {
            throw new Error("Invalid Instruction. Should be a LookupTable Instruction");
          }
          return type5;
        }
        static decodeCreateLookupTable(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeysLength(instruction.keys, 4);
          const {
            recentSlot
          } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable, instruction.data);
          return {
            authority: instruction.keys[1].pubkey,
            payer: instruction.keys[2].pubkey,
            recentSlot: Number(recentSlot)
          };
        }
        static decodeExtendLookupTable(instruction) {
          this.checkProgramId(instruction.programId);
          if (instruction.keys.length < 2) {
            throw new Error(`invalid instruction; found ${instruction.keys.length} keys, expected at least 2`);
          }
          const {
            addresses
          } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable, instruction.data);
          return {
            lookupTable: instruction.keys[0].pubkey,
            authority: instruction.keys[1].pubkey,
            payer: instruction.keys.length > 2 ? instruction.keys[2].pubkey : void 0,
            addresses: addresses.map((buffer2) => new PublicKey(buffer2))
          };
        }
        static decodeCloseLookupTable(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeysLength(instruction.keys, 3);
          return {
            lookupTable: instruction.keys[0].pubkey,
            authority: instruction.keys[1].pubkey,
            recipient: instruction.keys[2].pubkey
          };
        }
        static decodeFreezeLookupTable(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeysLength(instruction.keys, 2);
          return {
            lookupTable: instruction.keys[0].pubkey,
            authority: instruction.keys[1].pubkey
          };
        }
        static decodeDeactivateLookupTable(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeysLength(instruction.keys, 2);
          return {
            lookupTable: instruction.keys[0].pubkey,
            authority: instruction.keys[1].pubkey
          };
        }
        static checkProgramId(programId) {
          if (!programId.equals(AddressLookupTableProgram.programId)) {
            throw new Error("invalid instruction; programId is not AddressLookupTable Program");
          }
        }
        static checkKeysLength(keys, expectedLength) {
          if (keys.length < expectedLength) {
            throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
          }
        }
      };
      AddressLookupTableProgram = class {
        constructor() {
        }
        static createLookupTable(params) {
          const [lookupTableAddress, bumpSeed] = PublicKey.findProgramAddressSync([params.authority.toBuffer(), (0, import_bigint_buffer.toBufferLE)(BigInt(params.recentSlot), 8)], this.programId);
          const type5 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable;
          const data = encodeData(type5, {
            recentSlot: BigInt(params.recentSlot),
            bumpSeed
          });
          const keys = [{
            pubkey: lookupTableAddress,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: params.authority,
            isSigner: true,
            isWritable: false
          }, {
            pubkey: params.payer,
            isSigner: true,
            isWritable: true
          }, {
            pubkey: SystemProgram.programId,
            isSigner: false,
            isWritable: false
          }];
          return [new TransactionInstruction({
            programId: this.programId,
            keys,
            data
          }), lookupTableAddress];
        }
        static freezeLookupTable(params) {
          const type5 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.FreezeLookupTable;
          const data = encodeData(type5);
          const keys = [{
            pubkey: params.lookupTable,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: params.authority,
            isSigner: true,
            isWritable: false
          }];
          return new TransactionInstruction({
            programId: this.programId,
            keys,
            data
          });
        }
        static extendLookupTable(params) {
          const type5 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable;
          const data = encodeData(type5, {
            addresses: params.addresses.map((addr) => addr.toBytes())
          });
          const keys = [{
            pubkey: params.lookupTable,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: params.authority,
            isSigner: true,
            isWritable: false
          }];
          if (params.payer) {
            keys.push({
              pubkey: params.payer,
              isSigner: true,
              isWritable: true
            }, {
              pubkey: SystemProgram.programId,
              isSigner: false,
              isWritable: false
            });
          }
          return new TransactionInstruction({
            programId: this.programId,
            keys,
            data
          });
        }
        static deactivateLookupTable(params) {
          const type5 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.DeactivateLookupTable;
          const data = encodeData(type5);
          const keys = [{
            pubkey: params.lookupTable,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: params.authority,
            isSigner: true,
            isWritable: false
          }];
          return new TransactionInstruction({
            programId: this.programId,
            keys,
            data
          });
        }
        static closeLookupTable(params) {
          const type5 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CloseLookupTable;
          const data = encodeData(type5);
          const keys = [{
            pubkey: params.lookupTable,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: params.authority,
            isSigner: true,
            isWritable: false
          }, {
            pubkey: params.recipient,
            isSigner: false,
            isWritable: true
          }];
          return new TransactionInstruction({
            programId: this.programId,
            keys,
            data
          });
        }
      };
      AddressLookupTableProgram.programId = new PublicKey("AddressLookupTab1e1111111111111111111111111");
      ComputeBudgetInstruction = class {
        constructor() {
        }
        static decodeInstructionType(instruction) {
          this.checkProgramId(instruction.programId);
          const instructionTypeLayout = BufferLayout.u8("instruction");
          const typeIndex = instructionTypeLayout.decode(instruction.data);
          let type5;
          for (const [ixType, layout] of Object.entries(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS)) {
            if (layout.index == typeIndex) {
              type5 = ixType;
              break;
            }
          }
          if (!type5) {
            throw new Error("Instruction type incorrect; not a ComputeBudgetInstruction");
          }
          return type5;
        }
        static decodeRequestUnits(instruction) {
          this.checkProgramId(instruction.programId);
          const {
            units,
            additionalFee
          } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits, instruction.data);
          return {
            units,
            additionalFee
          };
        }
        static decodeRequestHeapFrame(instruction) {
          this.checkProgramId(instruction.programId);
          const {
            bytes: bytes2
          } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame, instruction.data);
          return {
            bytes: bytes2
          };
        }
        static decodeSetComputeUnitLimit(instruction) {
          this.checkProgramId(instruction.programId);
          const {
            units
          } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit, instruction.data);
          return {
            units
          };
        }
        static decodeSetComputeUnitPrice(instruction) {
          this.checkProgramId(instruction.programId);
          const {
            microLamports
          } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice, instruction.data);
          return {
            microLamports
          };
        }
        static checkProgramId(programId) {
          if (!programId.equals(ComputeBudgetProgram.programId)) {
            throw new Error("invalid instruction; programId is not ComputeBudgetProgram");
          }
        }
      };
      COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = Object.freeze({
        RequestUnits: {
          index: 0,
          layout: BufferLayout.struct([BufferLayout.u8("instruction"), BufferLayout.u32("units"), BufferLayout.u32("additionalFee")])
        },
        RequestHeapFrame: {
          index: 1,
          layout: BufferLayout.struct([BufferLayout.u8("instruction"), BufferLayout.u32("bytes")])
        },
        SetComputeUnitLimit: {
          index: 2,
          layout: BufferLayout.struct([BufferLayout.u8("instruction"), BufferLayout.u32("units")])
        },
        SetComputeUnitPrice: {
          index: 3,
          layout: BufferLayout.struct([BufferLayout.u8("instruction"), u642("microLamports")])
        }
      });
      ComputeBudgetProgram = class {
        constructor() {
        }
        static requestUnits(params) {
          const type5 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits;
          const data = encodeData(type5, params);
          return new TransactionInstruction({
            keys: [],
            programId: this.programId,
            data
          });
        }
        static requestHeapFrame(params) {
          const type5 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame;
          const data = encodeData(type5, params);
          return new TransactionInstruction({
            keys: [],
            programId: this.programId,
            data
          });
        }
        static setComputeUnitLimit(params) {
          const type5 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit;
          const data = encodeData(type5, params);
          return new TransactionInstruction({
            keys: [],
            programId: this.programId,
            data
          });
        }
        static setComputeUnitPrice(params) {
          const type5 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice;
          const data = encodeData(type5, {
            microLamports: BigInt(params.microLamports)
          });
          return new TransactionInstruction({
            keys: [],
            programId: this.programId,
            data
          });
        }
      };
      ComputeBudgetProgram.programId = new PublicKey("ComputeBudget111111111111111111111111111111");
      PRIVATE_KEY_BYTES$1 = 64;
      PUBLIC_KEY_BYTES$1 = 32;
      SIGNATURE_BYTES = 64;
      ED25519_INSTRUCTION_LAYOUT = BufferLayout.struct([BufferLayout.u8("numSignatures"), BufferLayout.u8("padding"), BufferLayout.u16("signatureOffset"), BufferLayout.u16("signatureInstructionIndex"), BufferLayout.u16("publicKeyOffset"), BufferLayout.u16("publicKeyInstructionIndex"), BufferLayout.u16("messageDataOffset"), BufferLayout.u16("messageDataSize"), BufferLayout.u16("messageInstructionIndex")]);
      Ed25519Program = class {
        constructor() {
        }
        static createInstructionWithPublicKey(params) {
          const {
            publicKey: publicKey6,
            message,
            signature: signature2,
            instructionIndex
          } = params;
          assert4(publicKey6.length === PUBLIC_KEY_BYTES$1, `Public Key must be ${PUBLIC_KEY_BYTES$1} bytes but received ${publicKey6.length} bytes`);
          assert4(signature2.length === SIGNATURE_BYTES, `Signature must be ${SIGNATURE_BYTES} bytes but received ${signature2.length} bytes`);
          const publicKeyOffset = ED25519_INSTRUCTION_LAYOUT.span;
          const signatureOffset = publicKeyOffset + publicKey6.length;
          const messageDataOffset = signatureOffset + signature2.length;
          const numSignatures = 1;
          const instructionData = import_buffer86.Buffer.alloc(messageDataOffset + message.length);
          const index = instructionIndex == null ? 65535 : instructionIndex;
          ED25519_INSTRUCTION_LAYOUT.encode({
            numSignatures,
            padding: 0,
            signatureOffset,
            signatureInstructionIndex: index,
            publicKeyOffset,
            publicKeyInstructionIndex: index,
            messageDataOffset,
            messageDataSize: message.length,
            messageInstructionIndex: index
          }, instructionData);
          instructionData.fill(publicKey6, publicKeyOffset);
          instructionData.fill(signature2, signatureOffset);
          instructionData.fill(message, messageDataOffset);
          return new TransactionInstruction({
            keys: [],
            programId: Ed25519Program.programId,
            data: instructionData
          });
        }
        static createInstructionWithPrivateKey(params) {
          const {
            privateKey,
            message,
            instructionIndex
          } = params;
          assert4(privateKey.length === PRIVATE_KEY_BYTES$1, `Private key must be ${PRIVATE_KEY_BYTES$1} bytes but received ${privateKey.length} bytes`);
          try {
            const keypair = Keypair.fromSecretKey(privateKey);
            const publicKey6 = keypair.publicKey.toBytes();
            const signature2 = sign(message, keypair.secretKey);
            return this.createInstructionWithPublicKey({
              publicKey: publicKey6,
              message,
              signature: signature2,
              instructionIndex
            });
          } catch (error2) {
            throw new Error(`Error creating instruction; ${error2}`);
          }
        }
      };
      Ed25519Program.programId = new PublicKey("Ed25519SigVerify111111111111111111111111111");
      ecdsaSign = (msgHash, privKey) => {
        const signature2 = secp256k1.sign(msgHash, privKey);
        return [signature2.toCompactRawBytes(), signature2.recovery];
      };
      secp256k1.utils.isValidPrivateKey;
      publicKeyCreate = secp256k1.getPublicKey;
      PRIVATE_KEY_BYTES = 32;
      ETHEREUM_ADDRESS_BYTES = 20;
      PUBLIC_KEY_BYTES = 64;
      SIGNATURE_OFFSETS_SERIALIZED_SIZE = 11;
      SECP256K1_INSTRUCTION_LAYOUT = BufferLayout.struct([BufferLayout.u8("numSignatures"), BufferLayout.u16("signatureOffset"), BufferLayout.u8("signatureInstructionIndex"), BufferLayout.u16("ethAddressOffset"), BufferLayout.u8("ethAddressInstructionIndex"), BufferLayout.u16("messageDataOffset"), BufferLayout.u16("messageDataSize"), BufferLayout.u8("messageInstructionIndex"), BufferLayout.blob(20, "ethAddress"), BufferLayout.blob(64, "signature"), BufferLayout.u8("recoveryId")]);
      Secp256k1Program = class {
        constructor() {
        }
        static publicKeyToEthAddress(publicKey6) {
          assert4(publicKey6.length === PUBLIC_KEY_BYTES, `Public key must be ${PUBLIC_KEY_BYTES} bytes but received ${publicKey6.length} bytes`);
          try {
            return import_buffer86.Buffer.from(keccak_256(toBuffer(publicKey6))).slice(-ETHEREUM_ADDRESS_BYTES);
          } catch (error2) {
            throw new Error(`Error constructing Ethereum address: ${error2}`);
          }
        }
        static createInstructionWithPublicKey(params) {
          const {
            publicKey: publicKey6,
            message,
            signature: signature2,
            recoveryId,
            instructionIndex
          } = params;
          return Secp256k1Program.createInstructionWithEthAddress({
            ethAddress: Secp256k1Program.publicKeyToEthAddress(publicKey6),
            message,
            signature: signature2,
            recoveryId,
            instructionIndex
          });
        }
        static createInstructionWithEthAddress(params) {
          const {
            ethAddress: rawAddress,
            message,
            signature: signature2,
            recoveryId,
            instructionIndex = 0
          } = params;
          let ethAddress;
          if (typeof rawAddress === "string") {
            if (rawAddress.startsWith("0x")) {
              ethAddress = import_buffer86.Buffer.from(rawAddress.substr(2), "hex");
            } else {
              ethAddress = import_buffer86.Buffer.from(rawAddress, "hex");
            }
          } else {
            ethAddress = rawAddress;
          }
          assert4(ethAddress.length === ETHEREUM_ADDRESS_BYTES, `Address must be ${ETHEREUM_ADDRESS_BYTES} bytes but received ${ethAddress.length} bytes`);
          const dataStart = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE;
          const ethAddressOffset = dataStart;
          const signatureOffset = dataStart + ethAddress.length;
          const messageDataOffset = signatureOffset + signature2.length + 1;
          const numSignatures = 1;
          const instructionData = import_buffer86.Buffer.alloc(SECP256K1_INSTRUCTION_LAYOUT.span + message.length);
          SECP256K1_INSTRUCTION_LAYOUT.encode({
            numSignatures,
            signatureOffset,
            signatureInstructionIndex: instructionIndex,
            ethAddressOffset,
            ethAddressInstructionIndex: instructionIndex,
            messageDataOffset,
            messageDataSize: message.length,
            messageInstructionIndex: instructionIndex,
            signature: toBuffer(signature2),
            ethAddress: toBuffer(ethAddress),
            recoveryId
          }, instructionData);
          instructionData.fill(toBuffer(message), SECP256K1_INSTRUCTION_LAYOUT.span);
          return new TransactionInstruction({
            keys: [],
            programId: Secp256k1Program.programId,
            data: instructionData
          });
        }
        static createInstructionWithPrivateKey(params) {
          const {
            privateKey: pkey,
            message,
            instructionIndex
          } = params;
          assert4(pkey.length === PRIVATE_KEY_BYTES, `Private key must be ${PRIVATE_KEY_BYTES} bytes but received ${pkey.length} bytes`);
          try {
            const privateKey = toBuffer(pkey);
            const publicKey6 = publicKeyCreate(privateKey, false).slice(1);
            const messageHash = import_buffer86.Buffer.from(keccak_256(toBuffer(message)));
            const [signature2, recoveryId] = ecdsaSign(messageHash, privateKey);
            return this.createInstructionWithPublicKey({
              publicKey: publicKey6,
              message,
              signature: signature2,
              recoveryId,
              instructionIndex
            });
          } catch (error2) {
            throw new Error(`Error creating instruction; ${error2}`);
          }
        }
      };
      Secp256k1Program.programId = new PublicKey("KeccakSecp256k11111111111111111111111111111");
      STAKE_CONFIG_ID = new PublicKey("StakeConfig11111111111111111111111111111111");
      Authorized = class {
        constructor(staker, withdrawer) {
          this.staker = void 0;
          this.withdrawer = void 0;
          this.staker = staker;
          this.withdrawer = withdrawer;
        }
      };
      Lockup = class {
        constructor(unixTimestamp, epoch, custodian) {
          this.unixTimestamp = void 0;
          this.epoch = void 0;
          this.custodian = void 0;
          this.unixTimestamp = unixTimestamp;
          this.epoch = epoch;
          this.custodian = custodian;
        }
      };
      Lockup.default = new Lockup(0, 0, PublicKey.default);
      StakeInstruction = class {
        constructor() {
        }
        static decodeInstructionType(instruction) {
          this.checkProgramId(instruction.programId);
          const instructionTypeLayout = BufferLayout.u32("instruction");
          const typeIndex = instructionTypeLayout.decode(instruction.data);
          let type5;
          for (const [ixType, layout] of Object.entries(STAKE_INSTRUCTION_LAYOUTS)) {
            if (layout.index == typeIndex) {
              type5 = ixType;
              break;
            }
          }
          if (!type5) {
            throw new Error("Instruction type incorrect; not a StakeInstruction");
          }
          return type5;
        }
        static decodeInitialize(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 2);
          const {
            authorized: authorized2,
            lockup: lockup2
          } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Initialize, instruction.data);
          return {
            stakePubkey: instruction.keys[0].pubkey,
            authorized: new Authorized(new PublicKey(authorized2.staker), new PublicKey(authorized2.withdrawer)),
            lockup: new Lockup(lockup2.unixTimestamp, lockup2.epoch, new PublicKey(lockup2.custodian))
          };
        }
        static decodeDelegate(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 6);
          decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Delegate, instruction.data);
          return {
            stakePubkey: instruction.keys[0].pubkey,
            votePubkey: instruction.keys[1].pubkey,
            authorizedPubkey: instruction.keys[5].pubkey
          };
        }
        static decodeAuthorize(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 3);
          const {
            newAuthorized,
            stakeAuthorizationType
          } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Authorize, instruction.data);
          const o = {
            stakePubkey: instruction.keys[0].pubkey,
            authorizedPubkey: instruction.keys[2].pubkey,
            newAuthorizedPubkey: new PublicKey(newAuthorized),
            stakeAuthorizationType: {
              index: stakeAuthorizationType
            }
          };
          if (instruction.keys.length > 3) {
            o.custodianPubkey = instruction.keys[3].pubkey;
          }
          return o;
        }
        static decodeAuthorizeWithSeed(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 2);
          const {
            newAuthorized,
            stakeAuthorizationType,
            authoritySeed,
            authorityOwner
          } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data);
          const o = {
            stakePubkey: instruction.keys[0].pubkey,
            authorityBase: instruction.keys[1].pubkey,
            authoritySeed,
            authorityOwner: new PublicKey(authorityOwner),
            newAuthorizedPubkey: new PublicKey(newAuthorized),
            stakeAuthorizationType: {
              index: stakeAuthorizationType
            }
          };
          if (instruction.keys.length > 3) {
            o.custodianPubkey = instruction.keys[3].pubkey;
          }
          return o;
        }
        static decodeSplit(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 3);
          const {
            lamports
          } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Split, instruction.data);
          return {
            stakePubkey: instruction.keys[0].pubkey,
            splitStakePubkey: instruction.keys[1].pubkey,
            authorizedPubkey: instruction.keys[2].pubkey,
            lamports
          };
        }
        static decodeMerge(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 3);
          decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Merge, instruction.data);
          return {
            stakePubkey: instruction.keys[0].pubkey,
            sourceStakePubKey: instruction.keys[1].pubkey,
            authorizedPubkey: instruction.keys[4].pubkey
          };
        }
        static decodeWithdraw(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 5);
          const {
            lamports
          } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data);
          const o = {
            stakePubkey: instruction.keys[0].pubkey,
            toPubkey: instruction.keys[1].pubkey,
            authorizedPubkey: instruction.keys[4].pubkey,
            lamports
          };
          if (instruction.keys.length > 5) {
            o.custodianPubkey = instruction.keys[5].pubkey;
          }
          return o;
        }
        static decodeDeactivate(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 3);
          decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Deactivate, instruction.data);
          return {
            stakePubkey: instruction.keys[0].pubkey,
            authorizedPubkey: instruction.keys[2].pubkey
          };
        }
        static checkProgramId(programId) {
          if (!programId.equals(StakeProgram.programId)) {
            throw new Error("invalid instruction; programId is not StakeProgram");
          }
        }
        static checkKeyLength(keys, expectedLength) {
          if (keys.length < expectedLength) {
            throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
          }
        }
      };
      STAKE_INSTRUCTION_LAYOUTS = Object.freeze({
        Initialize: {
          index: 0,
          layout: BufferLayout.struct([BufferLayout.u32("instruction"), authorized(), lockup()])
        },
        Authorize: {
          index: 1,
          layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("newAuthorized"), BufferLayout.u32("stakeAuthorizationType")])
        },
        Delegate: {
          index: 2,
          layout: BufferLayout.struct([BufferLayout.u32("instruction")])
        },
        Split: {
          index: 3,
          layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports")])
        },
        Withdraw: {
          index: 4,
          layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports")])
        },
        Deactivate: {
          index: 5,
          layout: BufferLayout.struct([BufferLayout.u32("instruction")])
        },
        Merge: {
          index: 7,
          layout: BufferLayout.struct([BufferLayout.u32("instruction")])
        },
        AuthorizeWithSeed: {
          index: 8,
          layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("newAuthorized"), BufferLayout.u32("stakeAuthorizationType"), rustString("authoritySeed"), publicKey("authorityOwner")])
        }
      });
      StakeAuthorizationLayout = Object.freeze({
        Staker: {
          index: 0
        },
        Withdrawer: {
          index: 1
        }
      });
      StakeProgram = class {
        constructor() {
        }
        static initialize(params) {
          const {
            stakePubkey,
            authorized: authorized2,
            lockup: maybeLockup
          } = params;
          const lockup2 = maybeLockup || Lockup.default;
          const type5 = STAKE_INSTRUCTION_LAYOUTS.Initialize;
          const data = encodeData(type5, {
            authorized: {
              staker: toBuffer(authorized2.staker.toBuffer()),
              withdrawer: toBuffer(authorized2.withdrawer.toBuffer())
            },
            lockup: {
              unixTimestamp: lockup2.unixTimestamp,
              epoch: lockup2.epoch,
              custodian: toBuffer(lockup2.custodian.toBuffer())
            }
          });
          const instructionData = {
            keys: [{
              pubkey: stakePubkey,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: SYSVAR_RENT_PUBKEY,
              isSigner: false,
              isWritable: false
            }],
            programId: this.programId,
            data
          };
          return new TransactionInstruction(instructionData);
        }
        static createAccountWithSeed(params) {
          const transaction = new Transaction();
          transaction.add(SystemProgram.createAccountWithSeed({
            fromPubkey: params.fromPubkey,
            newAccountPubkey: params.stakePubkey,
            basePubkey: params.basePubkey,
            seed: params.seed,
            lamports: params.lamports,
            space: this.space,
            programId: this.programId
          }));
          const {
            stakePubkey,
            authorized: authorized2,
            lockup: lockup2
          } = params;
          return transaction.add(this.initialize({
            stakePubkey,
            authorized: authorized2,
            lockup: lockup2
          }));
        }
        static createAccount(params) {
          const transaction = new Transaction();
          transaction.add(SystemProgram.createAccount({
            fromPubkey: params.fromPubkey,
            newAccountPubkey: params.stakePubkey,
            lamports: params.lamports,
            space: this.space,
            programId: this.programId
          }));
          const {
            stakePubkey,
            authorized: authorized2,
            lockup: lockup2
          } = params;
          return transaction.add(this.initialize({
            stakePubkey,
            authorized: authorized2,
            lockup: lockup2
          }));
        }
        static delegate(params) {
          const {
            stakePubkey,
            authorizedPubkey,
            votePubkey
          } = params;
          const type5 = STAKE_INSTRUCTION_LAYOUTS.Delegate;
          const data = encodeData(type5);
          return new Transaction().add({
            keys: [{
              pubkey: stakePubkey,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: votePubkey,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: SYSVAR_CLOCK_PUBKEY,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: STAKE_CONFIG_ID,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: authorizedPubkey,
              isSigner: true,
              isWritable: false
            }],
            programId: this.programId,
            data
          });
        }
        static authorize(params) {
          const {
            stakePubkey,
            authorizedPubkey,
            newAuthorizedPubkey,
            stakeAuthorizationType,
            custodianPubkey
          } = params;
          const type5 = STAKE_INSTRUCTION_LAYOUTS.Authorize;
          const data = encodeData(type5, {
            newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
            stakeAuthorizationType: stakeAuthorizationType.index
          });
          const keys = [{
            pubkey: stakePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: SYSVAR_CLOCK_PUBKEY,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: authorizedPubkey,
            isSigner: true,
            isWritable: false
          }];
          if (custodianPubkey) {
            keys.push({
              pubkey: custodianPubkey,
              isSigner: false,
              isWritable: false
            });
          }
          return new Transaction().add({
            keys,
            programId: this.programId,
            data
          });
        }
        static authorizeWithSeed(params) {
          const {
            stakePubkey,
            authorityBase,
            authoritySeed,
            authorityOwner,
            newAuthorizedPubkey,
            stakeAuthorizationType,
            custodianPubkey
          } = params;
          const type5 = STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;
          const data = encodeData(type5, {
            newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
            stakeAuthorizationType: stakeAuthorizationType.index,
            authoritySeed,
            authorityOwner: toBuffer(authorityOwner.toBuffer())
          });
          const keys = [{
            pubkey: stakePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: authorityBase,
            isSigner: true,
            isWritable: false
          }, {
            pubkey: SYSVAR_CLOCK_PUBKEY,
            isSigner: false,
            isWritable: false
          }];
          if (custodianPubkey) {
            keys.push({
              pubkey: custodianPubkey,
              isSigner: false,
              isWritable: false
            });
          }
          return new Transaction().add({
            keys,
            programId: this.programId,
            data
          });
        }
        static splitInstruction(params) {
          const {
            stakePubkey,
            authorizedPubkey,
            splitStakePubkey,
            lamports
          } = params;
          const type5 = STAKE_INSTRUCTION_LAYOUTS.Split;
          const data = encodeData(type5, {
            lamports
          });
          return new TransactionInstruction({
            keys: [{
              pubkey: stakePubkey,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: splitStakePubkey,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: authorizedPubkey,
              isSigner: true,
              isWritable: false
            }],
            programId: this.programId,
            data
          });
        }
        static split(params) {
          const transaction = new Transaction();
          transaction.add(SystemProgram.createAccount({
            fromPubkey: params.authorizedPubkey,
            newAccountPubkey: params.splitStakePubkey,
            lamports: 0,
            space: this.space,
            programId: this.programId
          }));
          return transaction.add(this.splitInstruction(params));
        }
        static splitWithSeed(params) {
          const {
            stakePubkey,
            authorizedPubkey,
            splitStakePubkey,
            basePubkey,
            seed: seed2,
            lamports
          } = params;
          const transaction = new Transaction();
          transaction.add(SystemProgram.allocate({
            accountPubkey: splitStakePubkey,
            basePubkey,
            seed: seed2,
            space: this.space,
            programId: this.programId
          }));
          return transaction.add(this.splitInstruction({
            stakePubkey,
            authorizedPubkey,
            splitStakePubkey,
            lamports
          }));
        }
        static merge(params) {
          const {
            stakePubkey,
            sourceStakePubKey,
            authorizedPubkey
          } = params;
          const type5 = STAKE_INSTRUCTION_LAYOUTS.Merge;
          const data = encodeData(type5);
          return new Transaction().add({
            keys: [{
              pubkey: stakePubkey,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: sourceStakePubKey,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: SYSVAR_CLOCK_PUBKEY,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: authorizedPubkey,
              isSigner: true,
              isWritable: false
            }],
            programId: this.programId,
            data
          });
        }
        static withdraw(params) {
          const {
            stakePubkey,
            authorizedPubkey,
            toPubkey,
            lamports,
            custodianPubkey
          } = params;
          const type5 = STAKE_INSTRUCTION_LAYOUTS.Withdraw;
          const data = encodeData(type5, {
            lamports
          });
          const keys = [{
            pubkey: stakePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: toPubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: SYSVAR_CLOCK_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: authorizedPubkey,
            isSigner: true,
            isWritable: false
          }];
          if (custodianPubkey) {
            keys.push({
              pubkey: custodianPubkey,
              isSigner: false,
              isWritable: false
            });
          }
          return new Transaction().add({
            keys,
            programId: this.programId,
            data
          });
        }
        static deactivate(params) {
          const {
            stakePubkey,
            authorizedPubkey
          } = params;
          const type5 = STAKE_INSTRUCTION_LAYOUTS.Deactivate;
          const data = encodeData(type5);
          return new Transaction().add({
            keys: [{
              pubkey: stakePubkey,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: SYSVAR_CLOCK_PUBKEY,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: authorizedPubkey,
              isSigner: true,
              isWritable: false
            }],
            programId: this.programId,
            data
          });
        }
      };
      StakeProgram.programId = new PublicKey("Stake11111111111111111111111111111111111111");
      StakeProgram.space = 200;
      VoteInit = class {
        constructor(nodePubkey, authorizedVoter, authorizedWithdrawer, commission) {
          this.nodePubkey = void 0;
          this.authorizedVoter = void 0;
          this.authorizedWithdrawer = void 0;
          this.commission = void 0;
          this.nodePubkey = nodePubkey;
          this.authorizedVoter = authorizedVoter;
          this.authorizedWithdrawer = authorizedWithdrawer;
          this.commission = commission;
        }
      };
      VoteInstruction = class {
        constructor() {
        }
        static decodeInstructionType(instruction) {
          this.checkProgramId(instruction.programId);
          const instructionTypeLayout = BufferLayout.u32("instruction");
          const typeIndex = instructionTypeLayout.decode(instruction.data);
          let type5;
          for (const [ixType, layout] of Object.entries(VOTE_INSTRUCTION_LAYOUTS)) {
            if (layout.index == typeIndex) {
              type5 = ixType;
              break;
            }
          }
          if (!type5) {
            throw new Error("Instruction type incorrect; not a VoteInstruction");
          }
          return type5;
        }
        static decodeInitializeAccount(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 4);
          const {
            voteInit: voteInit2
          } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.InitializeAccount, instruction.data);
          return {
            votePubkey: instruction.keys[0].pubkey,
            nodePubkey: instruction.keys[3].pubkey,
            voteInit: new VoteInit(new PublicKey(voteInit2.nodePubkey), new PublicKey(voteInit2.authorizedVoter), new PublicKey(voteInit2.authorizedWithdrawer), voteInit2.commission)
          };
        }
        static decodeAuthorize(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 3);
          const {
            newAuthorized,
            voteAuthorizationType
          } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Authorize, instruction.data);
          return {
            votePubkey: instruction.keys[0].pubkey,
            authorizedPubkey: instruction.keys[2].pubkey,
            newAuthorizedPubkey: new PublicKey(newAuthorized),
            voteAuthorizationType: {
              index: voteAuthorizationType
            }
          };
        }
        static decodeAuthorizeWithSeed(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 3);
          const {
            voteAuthorizeWithSeedArgs: {
              currentAuthorityDerivedKeyOwnerPubkey,
              currentAuthorityDerivedKeySeed,
              newAuthorized,
              voteAuthorizationType
            }
          } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data);
          return {
            currentAuthorityDerivedKeyBasePubkey: instruction.keys[2].pubkey,
            currentAuthorityDerivedKeyOwnerPubkey: new PublicKey(currentAuthorityDerivedKeyOwnerPubkey),
            currentAuthorityDerivedKeySeed,
            newAuthorizedPubkey: new PublicKey(newAuthorized),
            voteAuthorizationType: {
              index: voteAuthorizationType
            },
            votePubkey: instruction.keys[0].pubkey
          };
        }
        static decodeWithdraw(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 3);
          const {
            lamports
          } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data);
          return {
            votePubkey: instruction.keys[0].pubkey,
            authorizedWithdrawerPubkey: instruction.keys[2].pubkey,
            lamports,
            toPubkey: instruction.keys[1].pubkey
          };
        }
        static checkProgramId(programId) {
          if (!programId.equals(VoteProgram.programId)) {
            throw new Error("invalid instruction; programId is not VoteProgram");
          }
        }
        static checkKeyLength(keys, expectedLength) {
          if (keys.length < expectedLength) {
            throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
          }
        }
      };
      VOTE_INSTRUCTION_LAYOUTS = Object.freeze({
        InitializeAccount: {
          index: 0,
          layout: BufferLayout.struct([BufferLayout.u32("instruction"), voteInit()])
        },
        Authorize: {
          index: 1,
          layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("newAuthorized"), BufferLayout.u32("voteAuthorizationType")])
        },
        Withdraw: {
          index: 3,
          layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports")])
        },
        AuthorizeWithSeed: {
          index: 10,
          layout: BufferLayout.struct([BufferLayout.u32("instruction"), voteAuthorizeWithSeedArgs()])
        }
      });
      VoteAuthorizationLayout = Object.freeze({
        Voter: {
          index: 0
        },
        Withdrawer: {
          index: 1
        }
      });
      VoteProgram = class {
        constructor() {
        }
        static initializeAccount(params) {
          const {
            votePubkey,
            nodePubkey,
            voteInit: voteInit2
          } = params;
          const type5 = VOTE_INSTRUCTION_LAYOUTS.InitializeAccount;
          const data = encodeData(type5, {
            voteInit: {
              nodePubkey: toBuffer(voteInit2.nodePubkey.toBuffer()),
              authorizedVoter: toBuffer(voteInit2.authorizedVoter.toBuffer()),
              authorizedWithdrawer: toBuffer(voteInit2.authorizedWithdrawer.toBuffer()),
              commission: voteInit2.commission
            }
          });
          const instructionData = {
            keys: [{
              pubkey: votePubkey,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: SYSVAR_RENT_PUBKEY,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: SYSVAR_CLOCK_PUBKEY,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: nodePubkey,
              isSigner: true,
              isWritable: false
            }],
            programId: this.programId,
            data
          };
          return new TransactionInstruction(instructionData);
        }
        static createAccount(params) {
          const transaction = new Transaction();
          transaction.add(SystemProgram.createAccount({
            fromPubkey: params.fromPubkey,
            newAccountPubkey: params.votePubkey,
            lamports: params.lamports,
            space: this.space,
            programId: this.programId
          }));
          return transaction.add(this.initializeAccount({
            votePubkey: params.votePubkey,
            nodePubkey: params.voteInit.nodePubkey,
            voteInit: params.voteInit
          }));
        }
        static authorize(params) {
          const {
            votePubkey,
            authorizedPubkey,
            newAuthorizedPubkey,
            voteAuthorizationType
          } = params;
          const type5 = VOTE_INSTRUCTION_LAYOUTS.Authorize;
          const data = encodeData(type5, {
            newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
            voteAuthorizationType: voteAuthorizationType.index
          });
          const keys = [{
            pubkey: votePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: SYSVAR_CLOCK_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: authorizedPubkey,
            isSigner: true,
            isWritable: false
          }];
          return new Transaction().add({
            keys,
            programId: this.programId,
            data
          });
        }
        static authorizeWithSeed(params) {
          const {
            currentAuthorityDerivedKeyBasePubkey,
            currentAuthorityDerivedKeyOwnerPubkey,
            currentAuthorityDerivedKeySeed,
            newAuthorizedPubkey,
            voteAuthorizationType,
            votePubkey
          } = params;
          const type5 = VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;
          const data = encodeData(type5, {
            voteAuthorizeWithSeedArgs: {
              currentAuthorityDerivedKeyOwnerPubkey: toBuffer(currentAuthorityDerivedKeyOwnerPubkey.toBuffer()),
              currentAuthorityDerivedKeySeed,
              newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
              voteAuthorizationType: voteAuthorizationType.index
            }
          });
          const keys = [{
            pubkey: votePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: SYSVAR_CLOCK_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: currentAuthorityDerivedKeyBasePubkey,
            isSigner: true,
            isWritable: false
          }];
          return new Transaction().add({
            keys,
            programId: this.programId,
            data
          });
        }
        static withdraw(params) {
          const {
            votePubkey,
            authorizedWithdrawerPubkey,
            lamports,
            toPubkey
          } = params;
          const type5 = VOTE_INSTRUCTION_LAYOUTS.Withdraw;
          const data = encodeData(type5, {
            lamports
          });
          const keys = [{
            pubkey: votePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: toPubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: authorizedWithdrawerPubkey,
            isSigner: true,
            isWritable: false
          }];
          return new Transaction().add({
            keys,
            programId: this.programId,
            data
          });
        }
        static safeWithdraw(params, currentVoteAccountBalance, rentExemptMinimum) {
          if (params.lamports > currentVoteAccountBalance - rentExemptMinimum) {
            throw new Error("Withdraw will leave vote account with insuffcient funds.");
          }
          return VoteProgram.withdraw(params);
        }
      };
      VoteProgram.programId = new PublicKey("Vote111111111111111111111111111111111111111");
      VoteProgram.space = 3731;
      VALIDATOR_INFO_KEY = new PublicKey("Va1idator1nfo111111111111111111111111111111");
      InfoString = type3({
        name: string2(),
        website: optional2(string2()),
        details: optional2(string2()),
        keybaseUsername: optional2(string2())
      });
      ValidatorInfo = class {
        constructor(key, info) {
          this.key = void 0;
          this.info = void 0;
          this.key = key;
          this.info = info;
        }
        static fromConfigData(buffer2) {
          let byteArray = [...buffer2];
          const configKeyCount = decodeLength(byteArray);
          if (configKeyCount !== 2)
            return null;
          const configKeys = [];
          for (let i = 0; i < 2; i++) {
            const publicKey6 = new PublicKey(byteArray.slice(0, PUBLIC_KEY_LENGTH));
            byteArray = byteArray.slice(PUBLIC_KEY_LENGTH);
            const isSigner = byteArray.slice(0, 1)[0] === 1;
            byteArray = byteArray.slice(1);
            configKeys.push({
              publicKey: publicKey6,
              isSigner
            });
          }
          if (configKeys[0].publicKey.equals(VALIDATOR_INFO_KEY)) {
            if (configKeys[1].isSigner) {
              const rawInfo = rustString().decode(import_buffer86.Buffer.from(byteArray));
              const info = JSON.parse(rawInfo);
              assert3(info, InfoString);
              return new ValidatorInfo(configKeys[1].publicKey, info);
            }
          }
          return null;
        }
      };
      VOTE_PROGRAM_ID = new PublicKey("Vote111111111111111111111111111111111111111");
      VoteAccountLayout = BufferLayout.struct([
        publicKey("nodePubkey"),
        publicKey("authorizedWithdrawer"),
        BufferLayout.u8("commission"),
        BufferLayout.nu64(),
        BufferLayout.seq(BufferLayout.struct([BufferLayout.nu64("slot"), BufferLayout.u32("confirmationCount")]), BufferLayout.offset(BufferLayout.u32(), -8), "votes"),
        BufferLayout.u8("rootSlotValid"),
        BufferLayout.nu64("rootSlot"),
        BufferLayout.nu64(),
        BufferLayout.seq(BufferLayout.struct([BufferLayout.nu64("epoch"), publicKey("authorizedVoter")]), BufferLayout.offset(BufferLayout.u32(), -8), "authorizedVoters"),
        BufferLayout.struct([BufferLayout.seq(BufferLayout.struct([publicKey("authorizedPubkey"), BufferLayout.nu64("epochOfLastAuthorizedSwitch"), BufferLayout.nu64("targetEpoch")]), 32, "buf"), BufferLayout.nu64("idx"), BufferLayout.u8("isEmpty")], "priorVoters"),
        BufferLayout.nu64(),
        BufferLayout.seq(BufferLayout.struct([BufferLayout.nu64("epoch"), BufferLayout.nu64("credits"), BufferLayout.nu64("prevCredits")]), BufferLayout.offset(BufferLayout.u32(), -8), "epochCredits"),
        BufferLayout.struct([BufferLayout.nu64("slot"), BufferLayout.nu64("timestamp")], "lastTimestamp")
      ]);
      VoteAccount = class {
        constructor(args) {
          this.nodePubkey = void 0;
          this.authorizedWithdrawer = void 0;
          this.commission = void 0;
          this.rootSlot = void 0;
          this.votes = void 0;
          this.authorizedVoters = void 0;
          this.priorVoters = void 0;
          this.epochCredits = void 0;
          this.lastTimestamp = void 0;
          this.nodePubkey = args.nodePubkey;
          this.authorizedWithdrawer = args.authorizedWithdrawer;
          this.commission = args.commission;
          this.rootSlot = args.rootSlot;
          this.votes = args.votes;
          this.authorizedVoters = args.authorizedVoters;
          this.priorVoters = args.priorVoters;
          this.epochCredits = args.epochCredits;
          this.lastTimestamp = args.lastTimestamp;
        }
        static fromAccountData(buffer2) {
          const versionOffset = 4;
          const va = VoteAccountLayout.decode(toBuffer(buffer2), versionOffset);
          let rootSlot = va.rootSlot;
          if (!va.rootSlotValid) {
            rootSlot = null;
          }
          return new VoteAccount({
            nodePubkey: new PublicKey(va.nodePubkey),
            authorizedWithdrawer: new PublicKey(va.authorizedWithdrawer),
            commission: va.commission,
            votes: va.votes,
            rootSlot,
            authorizedVoters: va.authorizedVoters.map(parseAuthorizedVoter),
            priorVoters: getPriorVoters(va.priorVoters),
            epochCredits: va.epochCredits,
            lastTimestamp: va.lastTimestamp
          });
        }
      };
      endpoint = {
        http: {
          devnet: "http://api.devnet.solana.com",
          testnet: "http://api.testnet.solana.com",
          "mainnet-beta": "http://api.mainnet-beta.solana.com/"
        },
        https: {
          devnet: "https://api.devnet.solana.com",
          testnet: "https://api.testnet.solana.com",
          "mainnet-beta": "https://api.mainnet-beta.solana.com/"
        }
      };
      LAMPORTS_PER_SOL = 1e9;
    }
  });

  // node_modules/@coral-xyz/anchor/node_modules/camelcase/index.js
  var require_camelcase = __commonJS({
    "node_modules/@coral-xyz/anchor/node_modules/camelcase/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var UPPERCASE = /[\p{Lu}]/u;
      var LOWERCASE = /[\p{Ll}]/u;
      var LEADING_CAPITAL = /^[\p{Lu}](?![\p{Lu}])/gu;
      var IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u;
      var SEPARATORS = /[_.\- ]+/;
      var LEADING_SEPARATORS = new RegExp("^" + SEPARATORS.source);
      var SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, "gu");
      var NUMBERS_AND_IDENTIFIER = new RegExp("\\d+" + IDENTIFIER.source, "gu");
      var preserveCamelCase = (string4, toLowerCase, toUpperCase) => {
        let isLastCharLower = false;
        let isLastCharUpper = false;
        let isLastLastCharUpper = false;
        for (let i = 0; i < string4.length; i++) {
          const character = string4[i];
          if (isLastCharLower && UPPERCASE.test(character)) {
            string4 = string4.slice(0, i) + "-" + string4.slice(i);
            isLastCharLower = false;
            isLastLastCharUpper = isLastCharUpper;
            isLastCharUpper = true;
            i++;
          } else if (isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character)) {
            string4 = string4.slice(0, i - 1) + "-" + string4.slice(i - 1);
            isLastLastCharUpper = isLastCharUpper;
            isLastCharUpper = false;
            isLastCharLower = true;
          } else {
            isLastCharLower = toLowerCase(character) === character && toUpperCase(character) !== character;
            isLastLastCharUpper = isLastCharUpper;
            isLastCharUpper = toUpperCase(character) === character && toLowerCase(character) !== character;
          }
        }
        return string4;
      };
      var preserveConsecutiveUppercase = (input, toLowerCase) => {
        LEADING_CAPITAL.lastIndex = 0;
        return input.replace(LEADING_CAPITAL, (m1) => toLowerCase(m1));
      };
      var postProcess = (input, toUpperCase) => {
        SEPARATORS_AND_IDENTIFIER.lastIndex = 0;
        NUMBERS_AND_IDENTIFIER.lastIndex = 0;
        return input.replace(SEPARATORS_AND_IDENTIFIER, (_2, identifier) => toUpperCase(identifier)).replace(NUMBERS_AND_IDENTIFIER, (m) => toUpperCase(m));
      };
      var camelCase2 = (input, options) => {
        if (!(typeof input === "string" || Array.isArray(input))) {
          throw new TypeError("Expected the input to be `string | string[]`");
        }
        options = {
          pascalCase: false,
          preserveConsecutiveUppercase: false,
          ...options
        };
        if (Array.isArray(input)) {
          input = input.map((x2) => x2.trim()).filter((x2) => x2.length).join("-");
        } else {
          input = input.trim();
        }
        if (input.length === 0) {
          return "";
        }
        const toLowerCase = options.locale === false ? (string4) => string4.toLowerCase() : (string4) => string4.toLocaleLowerCase(options.locale);
        const toUpperCase = options.locale === false ? (string4) => string4.toUpperCase() : (string4) => string4.toLocaleUpperCase(options.locale);
        if (input.length === 1) {
          return options.pascalCase ? toUpperCase(input) : toLowerCase(input);
        }
        const hasUpperCase = input !== toLowerCase(input);
        if (hasUpperCase) {
          input = preserveCamelCase(input, toLowerCase, toUpperCase);
        }
        input = input.replace(LEADING_SEPARATORS, "");
        if (options.preserveConsecutiveUppercase) {
          input = preserveConsecutiveUppercase(input, toLowerCase);
        } else {
          input = toLowerCase(input);
        }
        if (options.pascalCase) {
          input = toUpperCase(input.charAt(0)) + input.slice(1);
        }
        return postProcess(input, toUpperCase);
      };
      module2.exports = camelCase2;
      module2.exports.default = camelCase2;
    }
  });

  // node_modules/js-sha256/src/sha256.js
  var require_sha256 = __commonJS({
    "node_modules/js-sha256/src/sha256.js"(exports, module) {
      init_virtual_process_polyfill();
      init_buffer();
      (function() {
        "use strict";
        var ERROR = "input is invalid type";
        var WINDOW = typeof window === "object";
        var root = WINDOW ? window : {};
        if (root.JS_SHA256_NO_WINDOW) {
          WINDOW = false;
        }
        var WEB_WORKER = !WINDOW && typeof self === "object";
        var NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
        if (NODE_JS) {
          root = window;
        } else if (WEB_WORKER) {
          root = self;
        }
        var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && typeof module === "object" && module.exports;
        var AMD = typeof define === "function" && define.amd;
        var ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
        var HEX_CHARS = "0123456789abcdef".split("");
        var EXTRA = [-2147483648, 8388608, 32768, 128];
        var SHIFT = [24, 16, 8, 0];
        var K = [
          1116352408,
          1899447441,
          3049323471,
          3921009573,
          961987163,
          1508970993,
          2453635748,
          2870763221,
          3624381080,
          310598401,
          607225278,
          1426881987,
          1925078388,
          2162078206,
          2614888103,
          3248222580,
          3835390401,
          4022224774,
          264347078,
          604807628,
          770255983,
          1249150122,
          1555081692,
          1996064986,
          2554220882,
          2821834349,
          2952996808,
          3210313671,
          3336571891,
          3584528711,
          113926993,
          338241895,
          666307205,
          773529912,
          1294757372,
          1396182291,
          1695183700,
          1986661051,
          2177026350,
          2456956037,
          2730485921,
          2820302411,
          3259730800,
          3345764771,
          3516065817,
          3600352804,
          4094571909,
          275423344,
          430227734,
          506948616,
          659060556,
          883997877,
          958139571,
          1322822218,
          1537002063,
          1747873779,
          1955562222,
          2024104815,
          2227730452,
          2361852424,
          2428436474,
          2756734187,
          3204031479,
          3329325298
        ];
        var OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"];
        var blocks = [];
        if (root.JS_SHA256_NO_NODE_JS || !Array.isArray) {
          Array.isArray = function(obj) {
            return Object.prototype.toString.call(obj) === "[object Array]";
          };
        }
        if (ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
          ArrayBuffer.isView = function(obj) {
            return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
          };
        }
        var createOutputMethod = function(outputType, is2242) {
          return function(message) {
            return new Sha256(is2242, true).update(message)[outputType]();
          };
        };
        var createMethod = function(is2242) {
          var method2 = createOutputMethod("hex", is2242);
          if (NODE_JS) {
            method2 = nodeWrap(method2, is2242);
          }
          method2.create = function() {
            return new Sha256(is2242);
          };
          method2.update = function(message) {
            return method2.create().update(message);
          };
          for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
            var type5 = OUTPUT_TYPES[i];
            method2[type5] = createOutputMethod(type5, is2242);
          }
          return method2;
        };
        var nodeWrap = function(method, is224) {
          var crypto = eval("require('crypto')");
          var Buffer = eval("require('buffer').Buffer");
          var algorithm = is224 ? "sha224" : "sha256";
          var nodeMethod = function(message) {
            if (typeof message === "string") {
              return crypto.createHash(algorithm).update(message, "utf8").digest("hex");
            } else {
              if (message === null || message === void 0) {
                throw new Error(ERROR);
              } else if (message.constructor === ArrayBuffer) {
                message = new Uint8Array(message);
              }
            }
            if (Array.isArray(message) || ArrayBuffer.isView(message) || message.constructor === Buffer) {
              return crypto.createHash(algorithm).update(new Buffer(message)).digest("hex");
            } else {
              return method(message);
            }
          };
          return nodeMethod;
        };
        var createHmacOutputMethod = function(outputType, is2242) {
          return function(key, message) {
            return new HmacSha256(key, is2242, true).update(message)[outputType]();
          };
        };
        var createHmacMethod = function(is2242) {
          var method2 = createHmacOutputMethod("hex", is2242);
          method2.create = function(key) {
            return new HmacSha256(key, is2242);
          };
          method2.update = function(key, message) {
            return method2.create(key).update(message);
          };
          for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
            var type5 = OUTPUT_TYPES[i];
            method2[type5] = createHmacOutputMethod(type5, is2242);
          }
          return method2;
        };
        function Sha256(is2242, sharedMemory) {
          if (sharedMemory) {
            blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
            this.blocks = blocks;
          } else {
            this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
          }
          if (is2242) {
            this.h0 = 3238371032;
            this.h1 = 914150663;
            this.h2 = 812702999;
            this.h3 = 4144912697;
            this.h4 = 4290775857;
            this.h5 = 1750603025;
            this.h6 = 1694076839;
            this.h7 = 3204075428;
          } else {
            this.h0 = 1779033703;
            this.h1 = 3144134277;
            this.h2 = 1013904242;
            this.h3 = 2773480762;
            this.h4 = 1359893119;
            this.h5 = 2600822924;
            this.h6 = 528734635;
            this.h7 = 1541459225;
          }
          this.block = this.start = this.bytes = this.hBytes = 0;
          this.finalized = this.hashed = false;
          this.first = true;
          this.is224 = is2242;
        }
        Sha256.prototype.update = function(message) {
          if (this.finalized) {
            return;
          }
          var notString, type5 = typeof message;
          if (type5 !== "string") {
            if (type5 === "object") {
              if (message === null) {
                throw new Error(ERROR);
              } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
                message = new Uint8Array(message);
              } else if (!Array.isArray(message)) {
                if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                  throw new Error(ERROR);
                }
              }
            } else {
              throw new Error(ERROR);
            }
            notString = true;
          }
          var code2, index = 0, i, length = message.length, blocks2 = this.blocks;
          while (index < length) {
            if (this.hashed) {
              this.hashed = false;
              blocks2[0] = this.block;
              blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
            }
            if (notString) {
              for (i = this.start; index < length && i < 64; ++index) {
                blocks2[i >> 2] |= message[index] << SHIFT[i++ & 3];
              }
            } else {
              for (i = this.start; index < length && i < 64; ++index) {
                code2 = message.charCodeAt(index);
                if (code2 < 128) {
                  blocks2[i >> 2] |= code2 << SHIFT[i++ & 3];
                } else if (code2 < 2048) {
                  blocks2[i >> 2] |= (192 | code2 >> 6) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code2 & 63) << SHIFT[i++ & 3];
                } else if (code2 < 55296 || code2 >= 57344) {
                  blocks2[i >> 2] |= (224 | code2 >> 12) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code2 & 63) << SHIFT[i++ & 3];
                } else {
                  code2 = 65536 + ((code2 & 1023) << 10 | message.charCodeAt(++index) & 1023);
                  blocks2[i >> 2] |= (240 | code2 >> 18) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code2 >> 12 & 63) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code2 & 63) << SHIFT[i++ & 3];
                }
              }
            }
            this.lastByteIndex = i;
            this.bytes += i - this.start;
            if (i >= 64) {
              this.block = blocks2[16];
              this.start = i - 64;
              this.hash();
              this.hashed = true;
            } else {
              this.start = i;
            }
          }
          if (this.bytes > 4294967295) {
            this.hBytes += this.bytes / 4294967296 << 0;
            this.bytes = this.bytes % 4294967296;
          }
          return this;
        };
        Sha256.prototype.finalize = function() {
          if (this.finalized) {
            return;
          }
          this.finalized = true;
          var blocks2 = this.blocks, i = this.lastByteIndex;
          blocks2[16] = this.block;
          blocks2[i >> 2] |= EXTRA[i & 3];
          this.block = blocks2[16];
          if (i >= 56) {
            if (!this.hashed) {
              this.hash();
            }
            blocks2[0] = this.block;
            blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
          }
          blocks2[14] = this.hBytes << 3 | this.bytes >>> 29;
          blocks2[15] = this.bytes << 3;
          this.hash();
        };
        Sha256.prototype.hash = function() {
          var a = this.h0, b2 = this.h1, c2 = this.h2, d2 = this.h3, e = this.h4, f3 = this.h5, g2 = this.h6, h2 = this.h7, blocks2 = this.blocks, j2, s0, s1, maj, t1, t2, ch, ab, da, cd, bc;
          for (j2 = 16; j2 < 64; ++j2) {
            t1 = blocks2[j2 - 15];
            s0 = (t1 >>> 7 | t1 << 25) ^ (t1 >>> 18 | t1 << 14) ^ t1 >>> 3;
            t1 = blocks2[j2 - 2];
            s1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
            blocks2[j2] = blocks2[j2 - 16] + s0 + blocks2[j2 - 7] + s1 << 0;
          }
          bc = b2 & c2;
          for (j2 = 0; j2 < 64; j2 += 4) {
            if (this.first) {
              if (this.is224) {
                ab = 300032;
                t1 = blocks2[0] - 1413257819;
                h2 = t1 - 150054599 << 0;
                d2 = t1 + 24177077 << 0;
              } else {
                ab = 704751109;
                t1 = blocks2[0] - 210244248;
                h2 = t1 - 1521486534 << 0;
                d2 = t1 + 143694565 << 0;
              }
              this.first = false;
            } else {
              s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
              s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
              ab = a & b2;
              maj = ab ^ a & c2 ^ bc;
              ch = e & f3 ^ ~e & g2;
              t1 = h2 + s1 + ch + K[j2] + blocks2[j2];
              t2 = s0 + maj;
              h2 = d2 + t1 << 0;
              d2 = t1 + t2 << 0;
            }
            s0 = (d2 >>> 2 | d2 << 30) ^ (d2 >>> 13 | d2 << 19) ^ (d2 >>> 22 | d2 << 10);
            s1 = (h2 >>> 6 | h2 << 26) ^ (h2 >>> 11 | h2 << 21) ^ (h2 >>> 25 | h2 << 7);
            da = d2 & a;
            maj = da ^ d2 & b2 ^ ab;
            ch = h2 & e ^ ~h2 & f3;
            t1 = g2 + s1 + ch + K[j2 + 1] + blocks2[j2 + 1];
            t2 = s0 + maj;
            g2 = c2 + t1 << 0;
            c2 = t1 + t2 << 0;
            s0 = (c2 >>> 2 | c2 << 30) ^ (c2 >>> 13 | c2 << 19) ^ (c2 >>> 22 | c2 << 10);
            s1 = (g2 >>> 6 | g2 << 26) ^ (g2 >>> 11 | g2 << 21) ^ (g2 >>> 25 | g2 << 7);
            cd = c2 & d2;
            maj = cd ^ c2 & a ^ da;
            ch = g2 & h2 ^ ~g2 & e;
            t1 = f3 + s1 + ch + K[j2 + 2] + blocks2[j2 + 2];
            t2 = s0 + maj;
            f3 = b2 + t1 << 0;
            b2 = t1 + t2 << 0;
            s0 = (b2 >>> 2 | b2 << 30) ^ (b2 >>> 13 | b2 << 19) ^ (b2 >>> 22 | b2 << 10);
            s1 = (f3 >>> 6 | f3 << 26) ^ (f3 >>> 11 | f3 << 21) ^ (f3 >>> 25 | f3 << 7);
            bc = b2 & c2;
            maj = bc ^ b2 & d2 ^ cd;
            ch = f3 & g2 ^ ~f3 & h2;
            t1 = e + s1 + ch + K[j2 + 3] + blocks2[j2 + 3];
            t2 = s0 + maj;
            e = a + t1 << 0;
            a = t1 + t2 << 0;
          }
          this.h0 = this.h0 + a << 0;
          this.h1 = this.h1 + b2 << 0;
          this.h2 = this.h2 + c2 << 0;
          this.h3 = this.h3 + d2 << 0;
          this.h4 = this.h4 + e << 0;
          this.h5 = this.h5 + f3 << 0;
          this.h6 = this.h6 + g2 << 0;
          this.h7 = this.h7 + h2 << 0;
        };
        Sha256.prototype.hex = function() {
          this.finalize();
          var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
          var hex = HEX_CHARS[h0 >> 28 & 15] + HEX_CHARS[h0 >> 24 & 15] + HEX_CHARS[h0 >> 20 & 15] + HEX_CHARS[h0 >> 16 & 15] + HEX_CHARS[h0 >> 12 & 15] + HEX_CHARS[h0 >> 8 & 15] + HEX_CHARS[h0 >> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h1 >> 28 & 15] + HEX_CHARS[h1 >> 24 & 15] + HEX_CHARS[h1 >> 20 & 15] + HEX_CHARS[h1 >> 16 & 15] + HEX_CHARS[h1 >> 12 & 15] + HEX_CHARS[h1 >> 8 & 15] + HEX_CHARS[h1 >> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h2 >> 28 & 15] + HEX_CHARS[h2 >> 24 & 15] + HEX_CHARS[h2 >> 20 & 15] + HEX_CHARS[h2 >> 16 & 15] + HEX_CHARS[h2 >> 12 & 15] + HEX_CHARS[h2 >> 8 & 15] + HEX_CHARS[h2 >> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h3 >> 28 & 15] + HEX_CHARS[h3 >> 24 & 15] + HEX_CHARS[h3 >> 20 & 15] + HEX_CHARS[h3 >> 16 & 15] + HEX_CHARS[h3 >> 12 & 15] + HEX_CHARS[h3 >> 8 & 15] + HEX_CHARS[h3 >> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h4 >> 28 & 15] + HEX_CHARS[h4 >> 24 & 15] + HEX_CHARS[h4 >> 20 & 15] + HEX_CHARS[h4 >> 16 & 15] + HEX_CHARS[h4 >> 12 & 15] + HEX_CHARS[h4 >> 8 & 15] + HEX_CHARS[h4 >> 4 & 15] + HEX_CHARS[h4 & 15] + HEX_CHARS[h5 >> 28 & 15] + HEX_CHARS[h5 >> 24 & 15] + HEX_CHARS[h5 >> 20 & 15] + HEX_CHARS[h5 >> 16 & 15] + HEX_CHARS[h5 >> 12 & 15] + HEX_CHARS[h5 >> 8 & 15] + HEX_CHARS[h5 >> 4 & 15] + HEX_CHARS[h5 & 15] + HEX_CHARS[h6 >> 28 & 15] + HEX_CHARS[h6 >> 24 & 15] + HEX_CHARS[h6 >> 20 & 15] + HEX_CHARS[h6 >> 16 & 15] + HEX_CHARS[h6 >> 12 & 15] + HEX_CHARS[h6 >> 8 & 15] + HEX_CHARS[h6 >> 4 & 15] + HEX_CHARS[h6 & 15];
          if (!this.is224) {
            hex += HEX_CHARS[h7 >> 28 & 15] + HEX_CHARS[h7 >> 24 & 15] + HEX_CHARS[h7 >> 20 & 15] + HEX_CHARS[h7 >> 16 & 15] + HEX_CHARS[h7 >> 12 & 15] + HEX_CHARS[h7 >> 8 & 15] + HEX_CHARS[h7 >> 4 & 15] + HEX_CHARS[h7 & 15];
          }
          return hex;
        };
        Sha256.prototype.toString = Sha256.prototype.hex;
        Sha256.prototype.digest = function() {
          this.finalize();
          var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
          var arr = [
            h0 >> 24 & 255,
            h0 >> 16 & 255,
            h0 >> 8 & 255,
            h0 & 255,
            h1 >> 24 & 255,
            h1 >> 16 & 255,
            h1 >> 8 & 255,
            h1 & 255,
            h2 >> 24 & 255,
            h2 >> 16 & 255,
            h2 >> 8 & 255,
            h2 & 255,
            h3 >> 24 & 255,
            h3 >> 16 & 255,
            h3 >> 8 & 255,
            h3 & 255,
            h4 >> 24 & 255,
            h4 >> 16 & 255,
            h4 >> 8 & 255,
            h4 & 255,
            h5 >> 24 & 255,
            h5 >> 16 & 255,
            h5 >> 8 & 255,
            h5 & 255,
            h6 >> 24 & 255,
            h6 >> 16 & 255,
            h6 >> 8 & 255,
            h6 & 255
          ];
          if (!this.is224) {
            arr.push(h7 >> 24 & 255, h7 >> 16 & 255, h7 >> 8 & 255, h7 & 255);
          }
          return arr;
        };
        Sha256.prototype.array = Sha256.prototype.digest;
        Sha256.prototype.arrayBuffer = function() {
          this.finalize();
          var buffer2 = new ArrayBuffer(this.is224 ? 28 : 32);
          var dataView = new DataView(buffer2);
          dataView.setUint32(0, this.h0);
          dataView.setUint32(4, this.h1);
          dataView.setUint32(8, this.h2);
          dataView.setUint32(12, this.h3);
          dataView.setUint32(16, this.h4);
          dataView.setUint32(20, this.h5);
          dataView.setUint32(24, this.h6);
          if (!this.is224) {
            dataView.setUint32(28, this.h7);
          }
          return buffer2;
        };
        function HmacSha256(key, is2242, sharedMemory) {
          var i, type5 = typeof key;
          if (type5 === "string") {
            var bytes2 = [], length = key.length, index = 0, code2;
            for (i = 0; i < length; ++i) {
              code2 = key.charCodeAt(i);
              if (code2 < 128) {
                bytes2[index++] = code2;
              } else if (code2 < 2048) {
                bytes2[index++] = 192 | code2 >> 6;
                bytes2[index++] = 128 | code2 & 63;
              } else if (code2 < 55296 || code2 >= 57344) {
                bytes2[index++] = 224 | code2 >> 12;
                bytes2[index++] = 128 | code2 >> 6 & 63;
                bytes2[index++] = 128 | code2 & 63;
              } else {
                code2 = 65536 + ((code2 & 1023) << 10 | key.charCodeAt(++i) & 1023);
                bytes2[index++] = 240 | code2 >> 18;
                bytes2[index++] = 128 | code2 >> 12 & 63;
                bytes2[index++] = 128 | code2 >> 6 & 63;
                bytes2[index++] = 128 | code2 & 63;
              }
            }
            key = bytes2;
          } else {
            if (type5 === "object") {
              if (key === null) {
                throw new Error(ERROR);
              } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {
                key = new Uint8Array(key);
              } else if (!Array.isArray(key)) {
                if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {
                  throw new Error(ERROR);
                }
              }
            } else {
              throw new Error(ERROR);
            }
          }
          if (key.length > 64) {
            key = new Sha256(is2242, true).update(key).array();
          }
          var oKeyPad = [], iKeyPad = [];
          for (i = 0; i < 64; ++i) {
            var b2 = key[i] || 0;
            oKeyPad[i] = 92 ^ b2;
            iKeyPad[i] = 54 ^ b2;
          }
          Sha256.call(this, is2242, sharedMemory);
          this.update(iKeyPad);
          this.oKeyPad = oKeyPad;
          this.inner = true;
          this.sharedMemory = sharedMemory;
        }
        HmacSha256.prototype = new Sha256();
        HmacSha256.prototype.finalize = function() {
          Sha256.prototype.finalize.call(this);
          if (this.inner) {
            this.inner = false;
            var innerHash = this.array();
            Sha256.call(this, this.is224, this.sharedMemory);
            this.update(this.oKeyPad);
            this.update(innerHash);
            Sha256.prototype.finalize.call(this);
          }
        };
        var exports = createMethod();
        exports.sha256 = exports;
        exports.sha224 = createMethod(true);
        exports.sha256.hmac = createHmacMethod();
        exports.sha224.hmac = createHmacMethod(true);
        if (COMMON_JS) {
          module.exports = exports;
        } else {
          root.sha256 = exports.sha256;
          root.sha224 = exports.sha224;
          if (AMD) {
            define(function() {
              return exports;
            });
          }
        }
      })();
    }
  });

  // node_modules/buffer-layout/lib/Layout.js
  var require_Layout2 = __commonJS({
    "node_modules/buffer-layout/lib/Layout.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var Layout3 = class {
        constructor(span, property) {
          if (!Number.isInteger(span)) {
            throw new TypeError("span must be an integer");
          }
          this.span = span;
          this.property = property;
        }
        makeDestinationObject() {
          return {};
        }
        decode(b2, offset3) {
          throw new Error("Layout is abstract");
        }
        encode(src, b2, offset3) {
          throw new Error("Layout is abstract");
        }
        getSpan(b2, offset3) {
          if (0 > this.span) {
            throw new RangeError("indeterminate span");
          }
          return this.span;
        }
        replicate(property) {
          const rv = Object.create(this.constructor.prototype);
          Object.assign(rv, this);
          rv.property = property;
          return rv;
        }
        fromArray(values) {
          return void 0;
        }
      };
      exports2.Layout = Layout3;
      function nameWithProperty3(name2, lo) {
        if (lo.property) {
          return name2 + "[" + lo.property + "]";
        }
        return name2;
      }
      exports2.nameWithProperty = nameWithProperty3;
      function bindConstructorLayout2(Class, layout) {
        if ("function" !== typeof Class) {
          throw new TypeError("Class must be constructor");
        }
        if (Class.hasOwnProperty("layout_")) {
          throw new Error("Class is already bound to a layout");
        }
        if (!(layout && layout instanceof Layout3)) {
          throw new TypeError("layout must be a Layout");
        }
        if (layout.hasOwnProperty("boundConstructor_")) {
          throw new Error("layout is already bound to a constructor");
        }
        Class.layout_ = layout;
        layout.boundConstructor_ = Class;
        layout.makeDestinationObject = () => new Class();
        Object.defineProperty(Class.prototype, "encode", {
          value: function(b2, offset3) {
            return layout.encode(this, b2, offset3);
          },
          writable: true
        });
        Object.defineProperty(Class, "decode", {
          value: function(b2, offset3) {
            return layout.decode(b2, offset3);
          },
          writable: true
        });
      }
      exports2.bindConstructorLayout = bindConstructorLayout2;
      var ExternalLayout3 = class extends Layout3 {
        isCount() {
          throw new Error("ExternalLayout is abstract");
        }
      };
      var GreedyCount2 = class extends ExternalLayout3 {
        constructor(elementSpan, property) {
          if (void 0 === elementSpan) {
            elementSpan = 1;
          }
          if (!Number.isInteger(elementSpan) || 0 >= elementSpan) {
            throw new TypeError("elementSpan must be a (positive) integer");
          }
          super(-1, property);
          this.elementSpan = elementSpan;
        }
        isCount() {
          return true;
        }
        decode(b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          const rem = b2.length - offset3;
          return Math.floor(rem / this.elementSpan);
        }
        encode(src, b2, offset3) {
          return 0;
        }
      };
      var OffsetLayout3 = class extends ExternalLayout3 {
        constructor(layout, offset3, property) {
          if (!(layout instanceof Layout3)) {
            throw new TypeError("layout must be a Layout");
          }
          if (void 0 === offset3) {
            offset3 = 0;
          } else if (!Number.isInteger(offset3)) {
            throw new TypeError("offset must be integer or undefined");
          }
          super(layout.span, property || layout.property);
          this.layout = layout;
          this.offset = offset3;
        }
        isCount() {
          return this.layout instanceof UInt3 || this.layout instanceof UIntBE3;
        }
        decode(b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          return this.layout.decode(b2, offset3 + this.offset);
        }
        encode(src, b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          return this.layout.encode(src, b2, offset3 + this.offset);
        }
      };
      var UInt3 = class extends Layout3 {
        constructor(span, property) {
          super(span, property);
          if (6 < this.span) {
            throw new RangeError("span must not exceed 6 bytes");
          }
        }
        decode(b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          return b2.readUIntLE(offset3, this.span);
        }
        encode(src, b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          b2.writeUIntLE(src, offset3, this.span);
          return this.span;
        }
      };
      var UIntBE3 = class extends Layout3 {
        constructor(span, property) {
          super(span, property);
          if (6 < this.span) {
            throw new RangeError("span must not exceed 6 bytes");
          }
        }
        decode(b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          return b2.readUIntBE(offset3, this.span);
        }
        encode(src, b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          b2.writeUIntBE(src, offset3, this.span);
          return this.span;
        }
      };
      var Int2 = class extends Layout3 {
        constructor(span, property) {
          super(span, property);
          if (6 < this.span) {
            throw new RangeError("span must not exceed 6 bytes");
          }
        }
        decode(b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          return b2.readIntLE(offset3, this.span);
        }
        encode(src, b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          b2.writeIntLE(src, offset3, this.span);
          return this.span;
        }
      };
      var IntBE2 = class extends Layout3 {
        constructor(span, property) {
          super(span, property);
          if (6 < this.span) {
            throw new RangeError("span must not exceed 6 bytes");
          }
        }
        decode(b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          return b2.readIntBE(offset3, this.span);
        }
        encode(src, b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          b2.writeIntBE(src, offset3, this.span);
          return this.span;
        }
      };
      var V2E323 = Math.pow(2, 32);
      function divmodInt643(src) {
        const hi32 = Math.floor(src / V2E323);
        const lo32 = src - hi32 * V2E323;
        return { hi32, lo32 };
      }
      function roundedInt643(hi32, lo32) {
        return hi32 * V2E323 + lo32;
      }
      var NearUInt643 = class extends Layout3 {
        constructor(property) {
          super(8, property);
        }
        decode(b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          const lo32 = b2.readUInt32LE(offset3);
          const hi32 = b2.readUInt32LE(offset3 + 4);
          return roundedInt643(hi32, lo32);
        }
        encode(src, b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          const split2 = divmodInt643(src);
          b2.writeUInt32LE(split2.lo32, offset3);
          b2.writeUInt32LE(split2.hi32, offset3 + 4);
          return 8;
        }
      };
      var NearUInt64BE2 = class extends Layout3 {
        constructor(property) {
          super(8, property);
        }
        decode(b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          const hi32 = b2.readUInt32BE(offset3);
          const lo32 = b2.readUInt32BE(offset3 + 4);
          return roundedInt643(hi32, lo32);
        }
        encode(src, b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          const split2 = divmodInt643(src);
          b2.writeUInt32BE(split2.hi32, offset3);
          b2.writeUInt32BE(split2.lo32, offset3 + 4);
          return 8;
        }
      };
      var NearInt643 = class extends Layout3 {
        constructor(property) {
          super(8, property);
        }
        decode(b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          const lo32 = b2.readUInt32LE(offset3);
          const hi32 = b2.readInt32LE(offset3 + 4);
          return roundedInt643(hi32, lo32);
        }
        encode(src, b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          const split2 = divmodInt643(src);
          b2.writeUInt32LE(split2.lo32, offset3);
          b2.writeInt32LE(split2.hi32, offset3 + 4);
          return 8;
        }
      };
      var NearInt64BE2 = class extends Layout3 {
        constructor(property) {
          super(8, property);
        }
        decode(b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          const hi32 = b2.readInt32BE(offset3);
          const lo32 = b2.readUInt32BE(offset3 + 4);
          return roundedInt643(hi32, lo32);
        }
        encode(src, b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          const split2 = divmodInt643(src);
          b2.writeInt32BE(split2.hi32, offset3);
          b2.writeUInt32BE(split2.lo32, offset3 + 4);
          return 8;
        }
      };
      var Float2 = class extends Layout3 {
        constructor(property) {
          super(4, property);
        }
        decode(b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          return b2.readFloatLE(offset3);
        }
        encode(src, b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          b2.writeFloatLE(src, offset3);
          return 4;
        }
      };
      var FloatBE2 = class extends Layout3 {
        constructor(property) {
          super(4, property);
        }
        decode(b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          return b2.readFloatBE(offset3);
        }
        encode(src, b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          b2.writeFloatBE(src, offset3);
          return 4;
        }
      };
      var Double2 = class extends Layout3 {
        constructor(property) {
          super(8, property);
        }
        decode(b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          return b2.readDoubleLE(offset3);
        }
        encode(src, b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          b2.writeDoubleLE(src, offset3);
          return 8;
        }
      };
      var DoubleBE2 = class extends Layout3 {
        constructor(property) {
          super(8, property);
        }
        decode(b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          return b2.readDoubleBE(offset3);
        }
        encode(src, b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          b2.writeDoubleBE(src, offset3);
          return 8;
        }
      };
      var Sequence2 = class extends Layout3 {
        constructor(elementLayout, count, property) {
          if (!(elementLayout instanceof Layout3)) {
            throw new TypeError("elementLayout must be a Layout");
          }
          if (!(count instanceof ExternalLayout3 && count.isCount() || Number.isInteger(count) && 0 <= count)) {
            throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
          }
          let span = -1;
          if (!(count instanceof ExternalLayout3) && 0 < elementLayout.span) {
            span = count * elementLayout.span;
          }
          super(span, property);
          this.elementLayout = elementLayout;
          this.count = count;
        }
        getSpan(b2, offset3) {
          if (0 <= this.span) {
            return this.span;
          }
          if (void 0 === offset3) {
            offset3 = 0;
          }
          let span = 0;
          let count = this.count;
          if (count instanceof ExternalLayout3) {
            count = count.decode(b2, offset3);
          }
          if (0 < this.elementLayout.span) {
            span = count * this.elementLayout.span;
          } else {
            let idx = 0;
            while (idx < count) {
              span += this.elementLayout.getSpan(b2, offset3 + span);
              ++idx;
            }
          }
          return span;
        }
        decode(b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          const rv = [];
          let i = 0;
          let count = this.count;
          if (count instanceof ExternalLayout3) {
            count = count.decode(b2, offset3);
          }
          while (i < count) {
            rv.push(this.elementLayout.decode(b2, offset3));
            offset3 += this.elementLayout.getSpan(b2, offset3);
            i += 1;
          }
          return rv;
        }
        encode(src, b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          const elo = this.elementLayout;
          const span = src.reduce((span2, v2) => {
            return span2 + elo.encode(v2, b2, offset3 + span2);
          }, 0);
          if (this.count instanceof ExternalLayout3) {
            this.count.encode(src.length, b2, offset3);
          }
          return span;
        }
      };
      var Structure3 = class extends Layout3 {
        constructor(fields, property, decodePrefixes) {
          if (!(Array.isArray(fields) && fields.reduce((acc, v2) => acc && v2 instanceof Layout3, true))) {
            throw new TypeError("fields must be array of Layout instances");
          }
          if ("boolean" === typeof property && void 0 === decodePrefixes) {
            decodePrefixes = property;
            property = void 0;
          }
          for (const fd of fields) {
            if (0 > fd.span && void 0 === fd.property) {
              throw new Error("fields cannot contain unnamed variable-length layout");
            }
          }
          let span = -1;
          try {
            span = fields.reduce((span2, fd) => span2 + fd.getSpan(), 0);
          } catch (e) {
          }
          super(span, property);
          this.fields = fields;
          this.decodePrefixes = !!decodePrefixes;
        }
        getSpan(b2, offset3) {
          if (0 <= this.span) {
            return this.span;
          }
          if (void 0 === offset3) {
            offset3 = 0;
          }
          let span = 0;
          try {
            span = this.fields.reduce((span2, fd) => {
              const fsp = fd.getSpan(b2, offset3);
              offset3 += fsp;
              return span2 + fsp;
            }, 0);
          } catch (e) {
            throw new RangeError("indeterminate span");
          }
          return span;
        }
        decode(b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          const dest = this.makeDestinationObject();
          for (const fd of this.fields) {
            if (void 0 !== fd.property) {
              dest[fd.property] = fd.decode(b2, offset3);
            }
            offset3 += fd.getSpan(b2, offset3);
            if (this.decodePrefixes && b2.length === offset3) {
              break;
            }
          }
          return dest;
        }
        encode(src, b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          const firstOffset = offset3;
          let lastOffset = 0;
          let lastWrote = 0;
          for (const fd of this.fields) {
            let span = fd.span;
            lastWrote = 0 < span ? span : 0;
            if (void 0 !== fd.property) {
              const fv = src[fd.property];
              if (void 0 !== fv) {
                lastWrote = fd.encode(fv, b2, offset3);
                if (0 > span) {
                  span = fd.getSpan(b2, offset3);
                }
              }
            }
            lastOffset = offset3;
            offset3 += span;
          }
          return lastOffset + lastWrote - firstOffset;
        }
        fromArray(values) {
          const dest = this.makeDestinationObject();
          for (const fd of this.fields) {
            if (void 0 !== fd.property && 0 < values.length) {
              dest[fd.property] = values.shift();
            }
          }
          return dest;
        }
        layoutFor(property) {
          if ("string" !== typeof property) {
            throw new TypeError("property must be string");
          }
          for (const fd of this.fields) {
            if (fd.property === property) {
              return fd;
            }
          }
        }
        offsetOf(property) {
          if ("string" !== typeof property) {
            throw new TypeError("property must be string");
          }
          let offset3 = 0;
          for (const fd of this.fields) {
            if (fd.property === property) {
              return offset3;
            }
            if (0 > fd.span) {
              offset3 = -1;
            } else if (0 <= offset3) {
              offset3 += fd.span;
            }
          }
        }
      };
      var UnionDiscriminator3 = class {
        constructor(property) {
          this.property = property;
        }
        decode() {
          throw new Error("UnionDiscriminator is abstract");
        }
        encode() {
          throw new Error("UnionDiscriminator is abstract");
        }
      };
      var UnionLayoutDiscriminator3 = class extends UnionDiscriminator3 {
        constructor(layout, property) {
          if (!(layout instanceof ExternalLayout3 && layout.isCount())) {
            throw new TypeError("layout must be an unsigned integer ExternalLayout");
          }
          super(property || layout.property || "variant");
          this.layout = layout;
        }
        decode(b2, offset3) {
          return this.layout.decode(b2, offset3);
        }
        encode(src, b2, offset3) {
          return this.layout.encode(src, b2, offset3);
        }
      };
      var Union3 = class extends Layout3 {
        constructor(discr, defaultLayout, property) {
          const upv = discr instanceof UInt3 || discr instanceof UIntBE3;
          if (upv) {
            discr = new UnionLayoutDiscriminator3(new OffsetLayout3(discr));
          } else if (discr instanceof ExternalLayout3 && discr.isCount()) {
            discr = new UnionLayoutDiscriminator3(discr);
          } else if (!(discr instanceof UnionDiscriminator3)) {
            throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
          }
          if (void 0 === defaultLayout) {
            defaultLayout = null;
          }
          if (!(null === defaultLayout || defaultLayout instanceof Layout3)) {
            throw new TypeError("defaultLayout must be null or a Layout");
          }
          if (null !== defaultLayout) {
            if (0 > defaultLayout.span) {
              throw new Error("defaultLayout must have constant span");
            }
            if (void 0 === defaultLayout.property) {
              defaultLayout = defaultLayout.replicate("content");
            }
          }
          let span = -1;
          if (defaultLayout) {
            span = defaultLayout.span;
            if (0 <= span && upv) {
              span += discr.layout.span;
            }
          }
          super(span, property);
          this.discriminator = discr;
          this.usesPrefixDiscriminator = upv;
          this.defaultLayout = defaultLayout;
          this.registry = {};
          let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);
          this.getSourceVariant = function(src) {
            return boundGetSourceVariant(src);
          };
          this.configGetSourceVariant = function(gsv) {
            boundGetSourceVariant = gsv.bind(this);
          };
        }
        getSpan(b2, offset3) {
          if (0 <= this.span) {
            return this.span;
          }
          if (void 0 === offset3) {
            offset3 = 0;
          }
          const vlo = this.getVariant(b2, offset3);
          if (!vlo) {
            throw new Error("unable to determine span for unrecognized variant");
          }
          return vlo.getSpan(b2, offset3);
        }
        defaultGetSourceVariant(src) {
          if (src.hasOwnProperty(this.discriminator.property)) {
            if (this.defaultLayout && src.hasOwnProperty(this.defaultLayout.property)) {
              return void 0;
            }
            const vlo = this.registry[src[this.discriminator.property]];
            if (vlo && (!vlo.layout || src.hasOwnProperty(vlo.property))) {
              return vlo;
            }
          } else {
            for (const tag in this.registry) {
              const vlo = this.registry[tag];
              if (src.hasOwnProperty(vlo.property)) {
                return vlo;
              }
            }
          }
          throw new Error("unable to infer src variant");
        }
        decode(b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          let dest;
          const dlo = this.discriminator;
          const discr = dlo.decode(b2, offset3);
          let clo = this.registry[discr];
          if (void 0 === clo) {
            let contentOffset = 0;
            clo = this.defaultLayout;
            if (this.usesPrefixDiscriminator) {
              contentOffset = dlo.layout.span;
            }
            dest = this.makeDestinationObject();
            dest[dlo.property] = discr;
            dest[clo.property] = this.defaultLayout.decode(b2, offset3 + contentOffset);
          } else {
            dest = clo.decode(b2, offset3);
          }
          return dest;
        }
        encode(src, b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          const vlo = this.getSourceVariant(src);
          if (void 0 === vlo) {
            const dlo = this.discriminator;
            const clo = this.defaultLayout;
            let contentOffset = 0;
            if (this.usesPrefixDiscriminator) {
              contentOffset = dlo.layout.span;
            }
            dlo.encode(src[dlo.property], b2, offset3);
            return contentOffset + clo.encode(
              src[clo.property],
              b2,
              offset3 + contentOffset
            );
          }
          return vlo.encode(src, b2, offset3);
        }
        addVariant(variant, layout, property) {
          const rv = new VariantLayout3(this, variant, layout, property);
          this.registry[variant] = rv;
          return rv;
        }
        getVariant(vb, offset3) {
          let variant = vb;
          if (Buffer.isBuffer(vb)) {
            if (void 0 === offset3) {
              offset3 = 0;
            }
            variant = this.discriminator.decode(vb, offset3);
          }
          return this.registry[variant];
        }
      };
      var VariantLayout3 = class extends Layout3 {
        constructor(union4, variant, layout, property) {
          if (!(union4 instanceof Union3)) {
            throw new TypeError("union must be a Union");
          }
          if (!Number.isInteger(variant) || 0 > variant) {
            throw new TypeError("variant must be a (non-negative) integer");
          }
          if ("string" === typeof layout && void 0 === property) {
            property = layout;
            layout = null;
          }
          if (layout) {
            if (!(layout instanceof Layout3)) {
              throw new TypeError("layout must be a Layout");
            }
            if (null !== union4.defaultLayout && 0 <= layout.span && layout.span > union4.defaultLayout.span) {
              throw new Error("variant span exceeds span of containing union");
            }
            if ("string" !== typeof property) {
              throw new TypeError("variant must have a String property");
            }
          }
          let span = union4.span;
          if (0 > union4.span) {
            span = layout ? layout.span : 0;
            if (0 <= span && union4.usesPrefixDiscriminator) {
              span += union4.discriminator.layout.span;
            }
          }
          super(span, property);
          this.union = union4;
          this.variant = variant;
          this.layout = layout || null;
        }
        getSpan(b2, offset3) {
          if (0 <= this.span) {
            return this.span;
          }
          if (void 0 === offset3) {
            offset3 = 0;
          }
          let contentOffset = 0;
          if (this.union.usesPrefixDiscriminator) {
            contentOffset = this.union.discriminator.layout.span;
          }
          return contentOffset + this.layout.getSpan(b2, offset3 + contentOffset);
        }
        decode(b2, offset3) {
          const dest = this.makeDestinationObject();
          if (void 0 === offset3) {
            offset3 = 0;
          }
          if (this !== this.union.getVariant(b2, offset3)) {
            throw new Error("variant mismatch");
          }
          let contentOffset = 0;
          if (this.union.usesPrefixDiscriminator) {
            contentOffset = this.union.discriminator.layout.span;
          }
          if (this.layout) {
            dest[this.property] = this.layout.decode(b2, offset3 + contentOffset);
          } else if (this.property) {
            dest[this.property] = true;
          } else if (this.union.usesPrefixDiscriminator) {
            dest[this.union.discriminator.property] = this.variant;
          }
          return dest;
        }
        encode(src, b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          let contentOffset = 0;
          if (this.union.usesPrefixDiscriminator) {
            contentOffset = this.union.discriminator.layout.span;
          }
          if (this.layout && !src.hasOwnProperty(this.property)) {
            throw new TypeError("variant lacks property " + this.property);
          }
          this.union.discriminator.encode(this.variant, b2, offset3);
          let span = contentOffset;
          if (this.layout) {
            this.layout.encode(src[this.property], b2, offset3 + contentOffset);
            span += this.layout.getSpan(b2, offset3 + contentOffset);
            if (0 <= this.union.span && span > this.union.span) {
              throw new Error("encoded variant overruns containing union");
            }
          }
          return span;
        }
        fromArray(values) {
          if (this.layout) {
            return this.layout.fromArray(values);
          }
        }
      };
      function fixBitwiseResult2(v2) {
        if (0 > v2) {
          v2 += 4294967296;
        }
        return v2;
      }
      var BitStructure2 = class extends Layout3 {
        constructor(word, msb, property) {
          if (!(word instanceof UInt3 || word instanceof UIntBE3)) {
            throw new TypeError("word must be a UInt or UIntBE layout");
          }
          if ("string" === typeof msb && void 0 === property) {
            property = msb;
            msb = void 0;
          }
          if (4 < word.span) {
            throw new RangeError("word cannot exceed 32 bits");
          }
          super(word.span, property);
          this.word = word;
          this.msb = !!msb;
          this.fields = [];
          let value = 0;
          this._packedSetValue = function(v2) {
            value = fixBitwiseResult2(v2);
            return this;
          };
          this._packedGetValue = function() {
            return value;
          };
        }
        decode(b2, offset3) {
          const dest = this.makeDestinationObject();
          if (void 0 === offset3) {
            offset3 = 0;
          }
          const value = this.word.decode(b2, offset3);
          this._packedSetValue(value);
          for (const fd of this.fields) {
            if (void 0 !== fd.property) {
              dest[fd.property] = fd.decode(value);
            }
          }
          return dest;
        }
        encode(src, b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          const value = this.word.decode(b2, offset3);
          this._packedSetValue(value);
          for (const fd of this.fields) {
            if (void 0 !== fd.property) {
              const fv = src[fd.property];
              if (void 0 !== fv) {
                fd.encode(fv);
              }
            }
          }
          return this.word.encode(this._packedGetValue(), b2, offset3);
        }
        addField(bits, property) {
          const bf = new BitField2(this, bits, property);
          this.fields.push(bf);
          return bf;
        }
        addBoolean(property) {
          const bf = new Boolean3(this, property);
          this.fields.push(bf);
          return bf;
        }
        fieldFor(property) {
          if ("string" !== typeof property) {
            throw new TypeError("property must be string");
          }
          for (const fd of this.fields) {
            if (fd.property === property) {
              return fd;
            }
          }
        }
      };
      var BitField2 = class {
        constructor(container, bits, property) {
          if (!(container instanceof BitStructure2)) {
            throw new TypeError("container must be a BitStructure");
          }
          if (!Number.isInteger(bits) || 0 >= bits) {
            throw new TypeError("bits must be positive integer");
          }
          const totalBits = 8 * container.span;
          const usedBits = container.fields.reduce((sum, fd) => sum + fd.bits, 0);
          if (bits + usedBits > totalBits) {
            throw new Error("bits too long for span remainder (" + (totalBits - usedBits) + " of " + totalBits + " remain)");
          }
          this.container = container;
          this.bits = bits;
          this.valueMask = (1 << bits) - 1;
          if (32 === bits) {
            this.valueMask = 4294967295;
          }
          this.start = usedBits;
          if (this.container.msb) {
            this.start = totalBits - usedBits - bits;
          }
          this.wordMask = fixBitwiseResult2(this.valueMask << this.start);
          this.property = property;
        }
        decode() {
          const word = this.container._packedGetValue();
          const wordValue = fixBitwiseResult2(word & this.wordMask);
          const value = wordValue >>> this.start;
          return value;
        }
        encode(value) {
          if (!Number.isInteger(value) || value !== fixBitwiseResult2(value & this.valueMask)) {
            throw new TypeError(nameWithProperty3("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
          }
          const word = this.container._packedGetValue();
          const wordValue = fixBitwiseResult2(value << this.start);
          this.container._packedSetValue(fixBitwiseResult2(word & ~this.wordMask) | wordValue);
        }
      };
      var Boolean3 = class extends BitField2 {
        constructor(container, property) {
          super(container, 1, property);
        }
        decode(b2, offset3) {
          return !!BitField2.prototype.decode.call(this, b2, offset3);
        }
        encode(value) {
          if ("boolean" === typeof value) {
            value = +value;
          }
          return BitField2.prototype.encode.call(this, value);
        }
      };
      var Blob3 = class extends Layout3 {
        constructor(length, property) {
          if (!(length instanceof ExternalLayout3 && length.isCount() || Number.isInteger(length) && 0 <= length)) {
            throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
          }
          let span = -1;
          if (!(length instanceof ExternalLayout3)) {
            span = length;
          }
          super(span, property);
          this.length = length;
        }
        getSpan(b2, offset3) {
          let span = this.span;
          if (0 > span) {
            span = this.length.decode(b2, offset3);
          }
          return span;
        }
        decode(b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          let span = this.span;
          if (0 > span) {
            span = this.length.decode(b2, offset3);
          }
          return b2.slice(offset3, offset3 + span);
        }
        encode(src, b2, offset3) {
          let span = this.length;
          if (this.length instanceof ExternalLayout3) {
            span = src.length;
          }
          if (!(Buffer.isBuffer(src) && span === src.length)) {
            throw new TypeError(nameWithProperty3("Blob.encode", this) + " requires (length " + span + ") Buffer as src");
          }
          if (offset3 + span > b2.length) {
            throw new RangeError("encoding overruns Buffer");
          }
          b2.write(src.toString("hex"), offset3, span, "hex");
          if (this.length instanceof ExternalLayout3) {
            this.length.encode(span, b2, offset3);
          }
          return span;
        }
      };
      var CString2 = class extends Layout3 {
        constructor(property) {
          super(-1, property);
        }
        getSpan(b2, offset3) {
          if (!Buffer.isBuffer(b2)) {
            throw new TypeError("b must be a Buffer");
          }
          if (void 0 === offset3) {
            offset3 = 0;
          }
          let idx = offset3;
          while (idx < b2.length && 0 !== b2[idx]) {
            idx += 1;
          }
          return 1 + idx - offset3;
        }
        decode(b2, offset3, dest) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          let span = this.getSpan(b2, offset3);
          return b2.slice(offset3, offset3 + span - 1).toString("utf-8");
        }
        encode(src, b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          if ("string" !== typeof src) {
            src = src.toString();
          }
          const srcb = new Buffer(src, "utf8");
          const span = srcb.length;
          if (offset3 + span > b2.length) {
            throw new RangeError("encoding overruns Buffer");
          }
          srcb.copy(b2, offset3);
          b2[offset3 + span] = 0;
          return span + 1;
        }
      };
      var UTF82 = class extends Layout3 {
        constructor(maxSpan, property) {
          if ("string" === typeof maxSpan && void 0 === property) {
            property = maxSpan;
            maxSpan = void 0;
          }
          if (void 0 === maxSpan) {
            maxSpan = -1;
          } else if (!Number.isInteger(maxSpan)) {
            throw new TypeError("maxSpan must be an integer");
          }
          super(-1, property);
          this.maxSpan = maxSpan;
        }
        getSpan(b2, offset3) {
          if (!Buffer.isBuffer(b2)) {
            throw new TypeError("b must be a Buffer");
          }
          if (void 0 === offset3) {
            offset3 = 0;
          }
          return b2.length - offset3;
        }
        decode(b2, offset3, dest) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          let span = this.getSpan(b2, offset3);
          if (0 <= this.maxSpan && this.maxSpan < span) {
            throw new RangeError("text length exceeds maxSpan");
          }
          return b2.slice(offset3, offset3 + span).toString("utf-8");
        }
        encode(src, b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          if ("string" !== typeof src) {
            src = src.toString();
          }
          const srcb = new Buffer(src, "utf8");
          const span = srcb.length;
          if (0 <= this.maxSpan && this.maxSpan < span) {
            throw new RangeError("text length exceeds maxSpan");
          }
          if (offset3 + span > b2.length) {
            throw new RangeError("encoding overruns Buffer");
          }
          srcb.copy(b2, offset3);
          return span;
        }
      };
      var Constant2 = class extends Layout3 {
        constructor(value, property) {
          super(0, property);
          this.value = value;
        }
        decode(b2, offset3, dest) {
          return this.value;
        }
        encode(src, b2, offset3) {
          return 0;
        }
      };
      exports2.ExternalLayout = ExternalLayout3;
      exports2.GreedyCount = GreedyCount2;
      exports2.OffsetLayout = OffsetLayout3;
      exports2.UInt = UInt3;
      exports2.UIntBE = UIntBE3;
      exports2.Int = Int2;
      exports2.IntBE = IntBE2;
      exports2.Float = Float2;
      exports2.FloatBE = FloatBE2;
      exports2.Double = Double2;
      exports2.DoubleBE = DoubleBE2;
      exports2.Sequence = Sequence2;
      exports2.Structure = Structure3;
      exports2.UnionDiscriminator = UnionDiscriminator3;
      exports2.UnionLayoutDiscriminator = UnionLayoutDiscriminator3;
      exports2.Union = Union3;
      exports2.VariantLayout = VariantLayout3;
      exports2.BitStructure = BitStructure2;
      exports2.BitField = BitField2;
      exports2.Boolean = Boolean3;
      exports2.Blob = Blob3;
      exports2.CString = CString2;
      exports2.UTF8 = UTF82;
      exports2.Constant = Constant2;
      exports2.greedy = (elementSpan, property) => new GreedyCount2(elementSpan, property);
      exports2.offset = (layout, offset3, property) => new OffsetLayout3(layout, offset3, property);
      exports2.u8 = (property) => new UInt3(1, property);
      exports2.u16 = (property) => new UInt3(2, property);
      exports2.u24 = (property) => new UInt3(3, property);
      exports2.u32 = (property) => new UInt3(4, property);
      exports2.u40 = (property) => new UInt3(5, property);
      exports2.u48 = (property) => new UInt3(6, property);
      exports2.nu64 = (property) => new NearUInt643(property);
      exports2.u16be = (property) => new UIntBE3(2, property);
      exports2.u24be = (property) => new UIntBE3(3, property);
      exports2.u32be = (property) => new UIntBE3(4, property);
      exports2.u40be = (property) => new UIntBE3(5, property);
      exports2.u48be = (property) => new UIntBE3(6, property);
      exports2.nu64be = (property) => new NearUInt64BE2(property);
      exports2.s8 = (property) => new Int2(1, property);
      exports2.s16 = (property) => new Int2(2, property);
      exports2.s24 = (property) => new Int2(3, property);
      exports2.s32 = (property) => new Int2(4, property);
      exports2.s40 = (property) => new Int2(5, property);
      exports2.s48 = (property) => new Int2(6, property);
      exports2.ns64 = (property) => new NearInt643(property);
      exports2.s16be = (property) => new IntBE2(2, property);
      exports2.s24be = (property) => new IntBE2(3, property);
      exports2.s32be = (property) => new IntBE2(4, property);
      exports2.s40be = (property) => new IntBE2(5, property);
      exports2.s48be = (property) => new IntBE2(6, property);
      exports2.ns64be = (property) => new NearInt64BE2(property);
      exports2.f32 = (property) => new Float2(property);
      exports2.f32be = (property) => new FloatBE2(property);
      exports2.f64 = (property) => new Double2(property);
      exports2.f64be = (property) => new DoubleBE2(property);
      exports2.struct = (fields, property, decodePrefixes) => new Structure3(fields, property, decodePrefixes);
      exports2.bits = (word, msb, property) => new BitStructure2(word, msb, property);
      exports2.seq = (elementLayout, count, property) => new Sequence2(elementLayout, count, property);
      exports2.union = (discr, defaultLayout, property) => new Union3(discr, defaultLayout, property);
      exports2.unionLayoutDiscriminator = (layout, property) => new UnionLayoutDiscriminator3(layout, property);
      exports2.blob = (length, property) => new Blob3(length, property);
      exports2.cstr = (property) => new CString2(property);
      exports2.utf8 = (maxSpan, property) => new UTF82(maxSpan, property);
      exports2.const = (value, property) => new Constant2(value, property);
    }
  });

  // node_modules/@coral-xyz/borsh/dist/index.js
  var require_dist = __commonJS({
    "node_modules/@coral-xyz/borsh/dist/index.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.map = exports2.array = exports2.rustEnum = exports2.str = exports2.vecU8 = exports2.tagged = exports2.vec = exports2.bool = exports2.option = exports2.publicKey = exports2.i256 = exports2.u256 = exports2.i128 = exports2.u128 = exports2.i64 = exports2.u64 = exports2.struct = exports2.f64 = exports2.f32 = exports2.i32 = exports2.u32 = exports2.i16 = exports2.u16 = exports2.i8 = exports2.u8 = void 0;
      var buffer_layout_1 = require_Layout2();
      var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
      var bn_js_1 = __importDefault(require_bn());
      var buffer_layout_2 = require_Layout2();
      Object.defineProperty(exports2, "u8", { enumerable: true, get: function() {
        return buffer_layout_2.u8;
      } });
      Object.defineProperty(exports2, "i8", { enumerable: true, get: function() {
        return buffer_layout_2.s8;
      } });
      Object.defineProperty(exports2, "u16", { enumerable: true, get: function() {
        return buffer_layout_2.u16;
      } });
      Object.defineProperty(exports2, "i16", { enumerable: true, get: function() {
        return buffer_layout_2.s16;
      } });
      Object.defineProperty(exports2, "u32", { enumerable: true, get: function() {
        return buffer_layout_2.u32;
      } });
      Object.defineProperty(exports2, "i32", { enumerable: true, get: function() {
        return buffer_layout_2.s32;
      } });
      Object.defineProperty(exports2, "f32", { enumerable: true, get: function() {
        return buffer_layout_2.f32;
      } });
      Object.defineProperty(exports2, "f64", { enumerable: true, get: function() {
        return buffer_layout_2.f64;
      } });
      Object.defineProperty(exports2, "struct", { enumerable: true, get: function() {
        return buffer_layout_2.struct;
      } });
      var BNLayout = class extends buffer_layout_1.Layout {
        constructor(span, signed, property) {
          super(span, property);
          this.blob = (0, buffer_layout_1.blob)(span);
          this.signed = signed;
        }
        decode(b2, offset3 = 0) {
          const num = new bn_js_1.default(this.blob.decode(b2, offset3), 10, "le");
          if (this.signed) {
            return num.fromTwos(this.span * 8).clone();
          }
          return num;
        }
        encode(src, b2, offset3 = 0) {
          if (this.signed) {
            src = src.toTwos(this.span * 8);
          }
          return this.blob.encode(src.toArrayLike(Buffer, "le", this.span), b2, offset3);
        }
      };
      function u647(property) {
        return new BNLayout(8, false, property);
      }
      exports2.u64 = u647;
      function i643(property) {
        return new BNLayout(8, true, property);
      }
      exports2.i64 = i643;
      function u1283(property) {
        return new BNLayout(16, false, property);
      }
      exports2.u128 = u1283;
      function i1283(property) {
        return new BNLayout(16, true, property);
      }
      exports2.i128 = i1283;
      function u2562(property) {
        return new BNLayout(32, false, property);
      }
      exports2.u256 = u2562;
      function i2562(property) {
        return new BNLayout(32, true, property);
      }
      exports2.i256 = i2562;
      var WrappedLayout2 = class extends buffer_layout_1.Layout {
        constructor(layout, decoder, encoder, property) {
          super(layout.span, property);
          this.layout = layout;
          this.decoder = decoder;
          this.encoder = encoder;
        }
        decode(b2, offset3) {
          return this.decoder(this.layout.decode(b2, offset3));
        }
        encode(src, b2, offset3) {
          return this.layout.encode(this.encoder(src), b2, offset3);
        }
        getSpan(b2, offset3) {
          return this.layout.getSpan(b2, offset3);
        }
      };
      function publicKey6(property) {
        return new WrappedLayout2((0, buffer_layout_1.blob)(32), (b2) => new web3_js_1.PublicKey(b2), (key) => key.toBuffer(), property);
      }
      exports2.publicKey = publicKey6;
      var OptionLayout = class extends buffer_layout_1.Layout {
        constructor(layout, property) {
          super(-1, property);
          this.layout = layout;
          this.discriminator = (0, buffer_layout_1.u8)();
        }
        encode(src, b2, offset3 = 0) {
          if (src === null || src === void 0) {
            return this.discriminator.encode(0, b2, offset3);
          }
          this.discriminator.encode(1, b2, offset3);
          return this.layout.encode(src, b2, offset3 + 1) + 1;
        }
        decode(b2, offset3 = 0) {
          const discriminator = this.discriminator.decode(b2, offset3);
          if (discriminator === 0) {
            return null;
          } else if (discriminator === 1) {
            return this.layout.decode(b2, offset3 + 1);
          }
          throw new Error("Invalid option " + this.property);
        }
        getSpan(b2, offset3 = 0) {
          const discriminator = this.discriminator.decode(b2, offset3);
          if (discriminator === 0) {
            return 1;
          } else if (discriminator === 1) {
            return this.layout.getSpan(b2, offset3 + 1) + 1;
          }
          throw new Error("Invalid option " + this.property);
        }
      };
      function option3(layout, property) {
        return new OptionLayout(layout, property);
      }
      exports2.option = option3;
      function bool4(property) {
        return new WrappedLayout2((0, buffer_layout_1.u8)(), decodeBool, encodeBool, property);
      }
      exports2.bool = bool4;
      function decodeBool(value) {
        if (value === 0) {
          return false;
        } else if (value === 1) {
          return true;
        }
        throw new Error("Invalid bool: " + value);
      }
      function encodeBool(value) {
        return value ? 1 : 0;
      }
      function vec3(elementLayout, property) {
        const length = (0, buffer_layout_1.u32)("length");
        const layout = (0, buffer_layout_1.struct)([
          length,
          (0, buffer_layout_1.seq)(elementLayout, (0, buffer_layout_1.offset)(length, -length.span), "values")
        ]);
        return new WrappedLayout2(layout, ({ values }) => values, (values) => ({ values }), property);
      }
      exports2.vec = vec3;
      function tagged(tag, layout, property) {
        const wrappedLayout = (0, buffer_layout_1.struct)([
          u647("tag"),
          layout.replicate("data")
        ]);
        function decodeTag({ tag: receivedTag, data }) {
          if (!receivedTag.eq(tag)) {
            throw new Error("Invalid tag, expected: " + tag.toString("hex") + ", got: " + receivedTag.toString("hex"));
          }
          return data;
        }
        return new WrappedLayout2(wrappedLayout, decodeTag, (data) => ({ tag, data }), property);
      }
      exports2.tagged = tagged;
      function vecU83(property) {
        const length = (0, buffer_layout_1.u32)("length");
        const layout = (0, buffer_layout_1.struct)([
          length,
          (0, buffer_layout_1.blob)((0, buffer_layout_1.offset)(length, -length.span), "data")
        ]);
        return new WrappedLayout2(layout, ({ data }) => data, (data) => ({ data }), property);
      }
      exports2.vecU8 = vecU83;
      function str3(property) {
        return new WrappedLayout2(vecU83(), (data) => data.toString("utf-8"), (s) => Buffer.from(s, "utf-8"), property);
      }
      exports2.str = str3;
      function rustEnum3(variants, property, discriminant) {
        const unionLayout = (0, buffer_layout_1.union)(discriminant !== null && discriminant !== void 0 ? discriminant : (0, buffer_layout_1.u8)(), property);
        variants.forEach((variant, index) => unionLayout.addVariant(index, variant, variant.property));
        return unionLayout;
      }
      exports2.rustEnum = rustEnum3;
      function array6(elementLayout, length, property) {
        const layout = (0, buffer_layout_1.struct)([
          (0, buffer_layout_1.seq)(elementLayout, length, "values")
        ]);
        return new WrappedLayout2(layout, ({ values }) => values, (values) => ({ values }), property);
      }
      exports2.array = array6;
      var MapEntryLayout = class extends buffer_layout_1.Layout {
        constructor(keyLayout, valueLayout, property) {
          super(keyLayout.span + valueLayout.span, property);
          this.keyLayout = keyLayout;
          this.valueLayout = valueLayout;
        }
        decode(b2, offset3) {
          offset3 = offset3 || 0;
          const key = this.keyLayout.decode(b2, offset3);
          const value = this.valueLayout.decode(b2, offset3 + this.keyLayout.getSpan(b2, offset3));
          return [key, value];
        }
        encode(src, b2, offset3) {
          offset3 = offset3 || 0;
          const keyBytes = this.keyLayout.encode(src[0], b2, offset3);
          const valueBytes = this.valueLayout.encode(src[1], b2, offset3 + keyBytes);
          return keyBytes + valueBytes;
        }
        getSpan(b2, offset3) {
          return this.keyLayout.getSpan(b2, offset3) + this.valueLayout.getSpan(b2, offset3);
        }
      };
      function map(keyLayout, valueLayout, property) {
        const length = (0, buffer_layout_1.u32)("length");
        const layout = (0, buffer_layout_1.struct)([
          length,
          (0, buffer_layout_1.seq)(new MapEntryLayout(keyLayout, valueLayout), (0, buffer_layout_1.offset)(length, -length.span), "values")
        ]);
        return new WrappedLayout2(layout, ({ values }) => new Map(values), (values) => ({ values: Array.from(values.entries()) }), property);
      }
      exports2.map = map;
    }
  });

  // node_modules/pako/dist/pako.esm.mjs
  function zero$1(buf) {
    let len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
    this.static_tree = static_tree;
    this.extra_bits = extra_bits;
    this.extra_base = extra_base;
    this.elems = elems;
    this.max_length = max_length;
    this.has_stree = static_tree && static_tree.length;
  }
  function TreeDesc(dyn_tree, stat_desc) {
    this.dyn_tree = dyn_tree;
    this.max_code = 0;
    this.stat_desc = stat_desc;
  }
  function Config(good_length, max_lazy, nice_length, max_chain, func) {
    this.good_length = good_length;
    this.max_lazy = max_lazy;
    this.nice_length = nice_length;
    this.max_chain = max_chain;
    this.func = func;
  }
  function DeflateState() {
    this.strm = null;
    this.status = 0;
    this.pending_buf = null;
    this.pending_buf_size = 0;
    this.pending_out = 0;
    this.pending = 0;
    this.wrap = 0;
    this.gzhead = null;
    this.gzindex = 0;
    this.method = Z_DEFLATED$2;
    this.last_flush = -1;
    this.w_size = 0;
    this.w_bits = 0;
    this.w_mask = 0;
    this.window = null;
    this.window_size = 0;
    this.prev = null;
    this.head = null;
    this.ins_h = 0;
    this.hash_size = 0;
    this.hash_bits = 0;
    this.hash_mask = 0;
    this.hash_shift = 0;
    this.block_start = 0;
    this.match_length = 0;
    this.prev_match = 0;
    this.match_available = 0;
    this.strstart = 0;
    this.match_start = 0;
    this.lookahead = 0;
    this.prev_length = 0;
    this.max_chain_length = 0;
    this.max_lazy_match = 0;
    this.level = 0;
    this.strategy = 0;
    this.good_match = 0;
    this.nice_match = 0;
    this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
    this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
    this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
    zero(this.dyn_ltree);
    zero(this.dyn_dtree);
    zero(this.bl_tree);
    this.l_desc = null;
    this.d_desc = null;
    this.bl_desc = null;
    this.bl_count = new Uint16Array(MAX_BITS + 1);
    this.heap = new Uint16Array(2 * L_CODES + 1);
    zero(this.heap);
    this.heap_len = 0;
    this.heap_max = 0;
    this.depth = new Uint16Array(2 * L_CODES + 1);
    zero(this.depth);
    this.sym_buf = 0;
    this.lit_bufsize = 0;
    this.sym_next = 0;
    this.sym_end = 0;
    this.opt_len = 0;
    this.static_len = 0;
    this.matches = 0;
    this.insert = 0;
    this.bi_buf = 0;
    this.bi_valid = 0;
  }
  function ZStream() {
    this.input = null;
    this.next_in = 0;
    this.avail_in = 0;
    this.total_in = 0;
    this.output = null;
    this.next_out = 0;
    this.avail_out = 0;
    this.total_out = 0;
    this.msg = "";
    this.state = null;
    this.data_type = 2;
    this.adler = 0;
  }
  function Deflate$1(options) {
    this.options = common.assign({
      level: Z_DEFAULT_COMPRESSION,
      method: Z_DEFLATED$1,
      chunkSize: 16384,
      windowBits: 15,
      memLevel: 8,
      strategy: Z_DEFAULT_STRATEGY
    }, options || {});
    let opt = this.options;
    if (opt.raw && opt.windowBits > 0) {
      opt.windowBits = -opt.windowBits;
    } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
      opt.windowBits += 16;
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new zstream();
    this.strm.avail_out = 0;
    let status = deflate_1$2.deflateInit2(
      this.strm,
      opt.level,
      opt.method,
      opt.windowBits,
      opt.memLevel,
      opt.strategy
    );
    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }
    if (opt.header) {
      deflate_1$2.deflateSetHeader(this.strm, opt.header);
    }
    if (opt.dictionary) {
      let dict;
      if (typeof opt.dictionary === "string") {
        dict = strings.string2buf(opt.dictionary);
      } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
        dict = new Uint8Array(opt.dictionary);
      } else {
        dict = opt.dictionary;
      }
      status = deflate_1$2.deflateSetDictionary(this.strm, dict);
      if (status !== Z_OK$2) {
        throw new Error(messages[status]);
      }
      this._dict_set = true;
    }
  }
  function deflate$1(input, options) {
    const deflator = new Deflate$1(options);
    deflator.push(input, true);
    if (deflator.err) {
      throw deflator.msg || messages[deflator.err];
    }
    return deflator.result;
  }
  function deflateRaw$1(input, options) {
    options = options || {};
    options.raw = true;
    return deflate$1(input, options);
  }
  function gzip$1(input, options) {
    options = options || {};
    options.gzip = true;
    return deflate$1(input, options);
  }
  function InflateState() {
    this.strm = null;
    this.mode = 0;
    this.last = false;
    this.wrap = 0;
    this.havedict = false;
    this.flags = 0;
    this.dmax = 0;
    this.check = 0;
    this.total = 0;
    this.head = null;
    this.wbits = 0;
    this.wsize = 0;
    this.whave = 0;
    this.wnext = 0;
    this.window = null;
    this.hold = 0;
    this.bits = 0;
    this.length = 0;
    this.offset = 0;
    this.extra = 0;
    this.lencode = null;
    this.distcode = null;
    this.lenbits = 0;
    this.distbits = 0;
    this.ncode = 0;
    this.nlen = 0;
    this.ndist = 0;
    this.have = 0;
    this.next = null;
    this.lens = new Uint16Array(320);
    this.work = new Uint16Array(288);
    this.lendyn = null;
    this.distdyn = null;
    this.sane = 0;
    this.back = 0;
    this.was = 0;
  }
  function GZheader() {
    this.text = 0;
    this.time = 0;
    this.xflags = 0;
    this.os = 0;
    this.extra = null;
    this.extra_len = 0;
    this.name = "";
    this.comment = "";
    this.hcrc = 0;
    this.done = false;
  }
  function Inflate$1(options) {
    this.options = common.assign({
      chunkSize: 1024 * 64,
      windowBits: 15,
      to: ""
    }, options || {});
    const opt = this.options;
    if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
      opt.windowBits = -opt.windowBits;
      if (opt.windowBits === 0) {
        opt.windowBits = -15;
      }
    }
    if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
      opt.windowBits += 32;
    }
    if (opt.windowBits > 15 && opt.windowBits < 48) {
      if ((opt.windowBits & 15) === 0) {
        opt.windowBits |= 15;
      }
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new zstream();
    this.strm.avail_out = 0;
    let status = inflate_1$2.inflateInit2(
      this.strm,
      opt.windowBits
    );
    if (status !== Z_OK) {
      throw new Error(messages[status]);
    }
    this.header = new gzheader();
    inflate_1$2.inflateGetHeader(this.strm, this.header);
    if (opt.dictionary) {
      if (typeof opt.dictionary === "string") {
        opt.dictionary = strings.string2buf(opt.dictionary);
      } else if (toString2.call(opt.dictionary) === "[object ArrayBuffer]") {
        opt.dictionary = new Uint8Array(opt.dictionary);
      }
      if (opt.raw) {
        status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
        if (status !== Z_OK) {
          throw new Error(messages[status]);
        }
      }
    }
  }
  function inflate$1(input, options) {
    const inflator = new Inflate$1(options);
    inflator.push(input);
    if (inflator.err)
      throw inflator.msg || messages[inflator.err];
    return inflator.result;
  }
  function inflateRaw$1(input, options) {
    options = options || {};
    options.raw = true;
    return inflate$1(input, options);
  }
  var Z_FIXED$1, Z_BINARY, Z_TEXT, Z_UNKNOWN$1, STORED_BLOCK, STATIC_TREES, DYN_TREES, MIN_MATCH$1, MAX_MATCH$1, LENGTH_CODES$1, LITERALS$1, L_CODES$1, D_CODES$1, BL_CODES$1, HEAP_SIZE$1, MAX_BITS$1, Buf_size, MAX_BL_BITS, END_BLOCK, REP_3_6, REPZ_3_10, REPZ_11_138, extra_lbits, extra_dbits, extra_blbits, bl_order, DIST_CODE_LEN, static_ltree, static_dtree, _dist_code, _length_code, base_length, base_dist, static_l_desc, static_d_desc, static_bl_desc, d_code, put_short, send_bits, send_code, bi_reverse, bi_flush, gen_bitlen, gen_codes, tr_static_init, init_block, bi_windup, smaller, pqdownheap, compress_block, build_tree, scan_tree, send_tree, build_bl_tree, send_all_trees, detect_data_type, static_init_done, _tr_init$1, _tr_stored_block$1, _tr_align$1, _tr_flush_block$1, _tr_tally$1, _tr_init_1, _tr_stored_block_1, _tr_flush_block_1, _tr_tally_1, _tr_align_1, trees, adler32, adler32_1, makeTable, crcTable, crc32, crc32_1, messages, constants$2, _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align, Z_NO_FLUSH$2, Z_PARTIAL_FLUSH, Z_FULL_FLUSH$1, Z_FINISH$3, Z_BLOCK$1, Z_OK$3, Z_STREAM_END$3, Z_STREAM_ERROR$2, Z_DATA_ERROR$2, Z_BUF_ERROR$1, Z_DEFAULT_COMPRESSION$1, Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED, Z_DEFAULT_STRATEGY$1, Z_UNKNOWN, Z_DEFLATED$2, MAX_MEM_LEVEL, MAX_WBITS$1, DEF_MEM_LEVEL, LENGTH_CODES, LITERALS, L_CODES, D_CODES, BL_CODES, HEAP_SIZE, MAX_BITS, MIN_MATCH, MAX_MATCH, MIN_LOOKAHEAD, PRESET_DICT, INIT_STATE, GZIP_STATE, EXTRA_STATE, NAME_STATE, COMMENT_STATE, HCRC_STATE, BUSY_STATE, FINISH_STATE, BS_NEED_MORE, BS_BLOCK_DONE, BS_FINISH_STARTED, BS_FINISH_DONE, OS_CODE, err, rank, zero, slide_hash, HASH_ZLIB, HASH, flush_pending, flush_block_only, put_byte, putShortMSB, read_buf, longest_match, fill_window, deflate_stored, deflate_fast, deflate_slow, deflate_rle, deflate_huff, configuration_table, lm_init, deflateStateCheck, deflateResetKeep, deflateReset, deflateSetHeader, deflateInit2, deflateInit, deflate$2, deflateEnd, deflateSetDictionary, deflateInit_1, deflateInit2_1, deflateReset_1, deflateResetKeep_1, deflateSetHeader_1, deflate_2$1, deflateEnd_1, deflateSetDictionary_1, deflateInfo, deflate_1$2, _has, assign, flattenChunks, common, STR_APPLY_UIA_OK, _utf8len, string2buf, buf2binstring, buf2string, utf8border, strings, zstream, toString$1, Z_NO_FLUSH$1, Z_SYNC_FLUSH, Z_FULL_FLUSH, Z_FINISH$2, Z_OK$2, Z_STREAM_END$2, Z_DEFAULT_COMPRESSION, Z_DEFAULT_STRATEGY, Z_DEFLATED$1, Deflate_1$1, deflate_2, deflateRaw_1$1, gzip_1$1, constants$1, deflate_1$1, BAD$1, TYPE$1, inffast, MAXBITS, ENOUGH_LENS$1, ENOUGH_DISTS$1, CODES$1, LENS$1, DISTS$1, lbase, lext, dbase, dext, inflate_table, inftrees, CODES, LENS, DISTS, Z_FINISH$1, Z_BLOCK, Z_TREES, Z_OK$1, Z_STREAM_END$1, Z_NEED_DICT$1, Z_STREAM_ERROR$1, Z_DATA_ERROR$1, Z_MEM_ERROR$1, Z_BUF_ERROR, Z_DEFLATED, HEAD, FLAGS, TIME, OS, EXLEN, EXTRA2, NAME, COMMENT, HCRC, DICTID, DICT, TYPE, TYPEDO, STORED, COPY_, COPY, TABLE, LENLENS, CODELENS, LEN_, LEN, LENEXT, DIST, DISTEXT, MATCH, LIT, CHECK, LENGTH, DONE, BAD, MEM, SYNC, ENOUGH_LENS, ENOUGH_DISTS, MAX_WBITS, DEF_WBITS, zswap32, inflateStateCheck, inflateResetKeep, inflateReset, inflateReset2, inflateInit2, inflateInit, virgin, lenfix, distfix, fixedtables, updatewindow, inflate$2, inflateEnd, inflateGetHeader, inflateSetDictionary, inflateReset_1, inflateReset2_1, inflateResetKeep_1, inflateInit_1, inflateInit2_1, inflate_2$1, inflateEnd_1, inflateGetHeader_1, inflateSetDictionary_1, inflateInfo, inflate_1$2, gzheader, toString2, Z_NO_FLUSH, Z_FINISH, Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR, Inflate_1$1, inflate_2, inflateRaw_1$1, ungzip$1, constants, inflate_1$1, Deflate, deflate, deflateRaw, gzip, Inflate, inflate, inflateRaw, ungzip, inflate_1;
  var init_pako_esm = __esm({
    "node_modules/pako/dist/pako.esm.mjs"() {
      init_virtual_process_polyfill();
      init_buffer();
      Z_FIXED$1 = 4;
      Z_BINARY = 0;
      Z_TEXT = 1;
      Z_UNKNOWN$1 = 2;
      STORED_BLOCK = 0;
      STATIC_TREES = 1;
      DYN_TREES = 2;
      MIN_MATCH$1 = 3;
      MAX_MATCH$1 = 258;
      LENGTH_CODES$1 = 29;
      LITERALS$1 = 256;
      L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
      D_CODES$1 = 30;
      BL_CODES$1 = 19;
      HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
      MAX_BITS$1 = 15;
      Buf_size = 16;
      MAX_BL_BITS = 7;
      END_BLOCK = 256;
      REP_3_6 = 16;
      REPZ_3_10 = 17;
      REPZ_11_138 = 18;
      extra_lbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);
      extra_dbits = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
      extra_blbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);
      bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
      DIST_CODE_LEN = 512;
      static_ltree = new Array((L_CODES$1 + 2) * 2);
      zero$1(static_ltree);
      static_dtree = new Array(D_CODES$1 * 2);
      zero$1(static_dtree);
      _dist_code = new Array(DIST_CODE_LEN);
      zero$1(_dist_code);
      _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
      zero$1(_length_code);
      base_length = new Array(LENGTH_CODES$1);
      zero$1(base_length);
      base_dist = new Array(D_CODES$1);
      zero$1(base_dist);
      d_code = (dist) => {
        return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
      };
      put_short = (s, w2) => {
        s.pending_buf[s.pending++] = w2 & 255;
        s.pending_buf[s.pending++] = w2 >>> 8 & 255;
      };
      send_bits = (s, value, length) => {
        if (s.bi_valid > Buf_size - length) {
          s.bi_buf |= value << s.bi_valid & 65535;
          put_short(s, s.bi_buf);
          s.bi_buf = value >> Buf_size - s.bi_valid;
          s.bi_valid += length - Buf_size;
        } else {
          s.bi_buf |= value << s.bi_valid & 65535;
          s.bi_valid += length;
        }
      };
      send_code = (s, c2, tree) => {
        send_bits(s, tree[c2 * 2], tree[c2 * 2 + 1]);
      };
      bi_reverse = (code2, len) => {
        let res = 0;
        do {
          res |= code2 & 1;
          code2 >>>= 1;
          res <<= 1;
        } while (--len > 0);
        return res >>> 1;
      };
      bi_flush = (s) => {
        if (s.bi_valid === 16) {
          put_short(s, s.bi_buf);
          s.bi_buf = 0;
          s.bi_valid = 0;
        } else if (s.bi_valid >= 8) {
          s.pending_buf[s.pending++] = s.bi_buf & 255;
          s.bi_buf >>= 8;
          s.bi_valid -= 8;
        }
      };
      gen_bitlen = (s, desc) => {
        const tree = desc.dyn_tree;
        const max_code = desc.max_code;
        const stree = desc.stat_desc.static_tree;
        const has_stree = desc.stat_desc.has_stree;
        const extra = desc.stat_desc.extra_bits;
        const base = desc.stat_desc.extra_base;
        const max_length = desc.stat_desc.max_length;
        let h2;
        let n, m;
        let bits;
        let xbits;
        let f3;
        let overflow = 0;
        for (bits = 0; bits <= MAX_BITS$1; bits++) {
          s.bl_count[bits] = 0;
        }
        tree[s.heap[s.heap_max] * 2 + 1] = 0;
        for (h2 = s.heap_max + 1; h2 < HEAP_SIZE$1; h2++) {
          n = s.heap[h2];
          bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
          if (bits > max_length) {
            bits = max_length;
            overflow++;
          }
          tree[n * 2 + 1] = bits;
          if (n > max_code) {
            continue;
          }
          s.bl_count[bits]++;
          xbits = 0;
          if (n >= base) {
            xbits = extra[n - base];
          }
          f3 = tree[n * 2];
          s.opt_len += f3 * (bits + xbits);
          if (has_stree) {
            s.static_len += f3 * (stree[n * 2 + 1] + xbits);
          }
        }
        if (overflow === 0) {
          return;
        }
        do {
          bits = max_length - 1;
          while (s.bl_count[bits] === 0) {
            bits--;
          }
          s.bl_count[bits]--;
          s.bl_count[bits + 1] += 2;
          s.bl_count[max_length]--;
          overflow -= 2;
        } while (overflow > 0);
        for (bits = max_length; bits !== 0; bits--) {
          n = s.bl_count[bits];
          while (n !== 0) {
            m = s.heap[--h2];
            if (m > max_code) {
              continue;
            }
            if (tree[m * 2 + 1] !== bits) {
              s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
              tree[m * 2 + 1] = bits;
            }
            n--;
          }
        }
      };
      gen_codes = (tree, max_code, bl_count) => {
        const next_code = new Array(MAX_BITS$1 + 1);
        let code2 = 0;
        let bits;
        let n;
        for (bits = 1; bits <= MAX_BITS$1; bits++) {
          code2 = code2 + bl_count[bits - 1] << 1;
          next_code[bits] = code2;
        }
        for (n = 0; n <= max_code; n++) {
          let len = tree[n * 2 + 1];
          if (len === 0) {
            continue;
          }
          tree[n * 2] = bi_reverse(next_code[len]++, len);
        }
      };
      tr_static_init = () => {
        let n;
        let bits;
        let length;
        let code2;
        let dist;
        const bl_count = new Array(MAX_BITS$1 + 1);
        length = 0;
        for (code2 = 0; code2 < LENGTH_CODES$1 - 1; code2++) {
          base_length[code2] = length;
          for (n = 0; n < 1 << extra_lbits[code2]; n++) {
            _length_code[length++] = code2;
          }
        }
        _length_code[length - 1] = code2;
        dist = 0;
        for (code2 = 0; code2 < 16; code2++) {
          base_dist[code2] = dist;
          for (n = 0; n < 1 << extra_dbits[code2]; n++) {
            _dist_code[dist++] = code2;
          }
        }
        dist >>= 7;
        for (; code2 < D_CODES$1; code2++) {
          base_dist[code2] = dist << 7;
          for (n = 0; n < 1 << extra_dbits[code2] - 7; n++) {
            _dist_code[256 + dist++] = code2;
          }
        }
        for (bits = 0; bits <= MAX_BITS$1; bits++) {
          bl_count[bits] = 0;
        }
        n = 0;
        while (n <= 143) {
          static_ltree[n * 2 + 1] = 8;
          n++;
          bl_count[8]++;
        }
        while (n <= 255) {
          static_ltree[n * 2 + 1] = 9;
          n++;
          bl_count[9]++;
        }
        while (n <= 279) {
          static_ltree[n * 2 + 1] = 7;
          n++;
          bl_count[7]++;
        }
        while (n <= 287) {
          static_ltree[n * 2 + 1] = 8;
          n++;
          bl_count[8]++;
        }
        gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
        for (n = 0; n < D_CODES$1; n++) {
          static_dtree[n * 2 + 1] = 5;
          static_dtree[n * 2] = bi_reverse(n, 5);
        }
        static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
        static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
        static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
      };
      init_block = (s) => {
        let n;
        for (n = 0; n < L_CODES$1; n++) {
          s.dyn_ltree[n * 2] = 0;
        }
        for (n = 0; n < D_CODES$1; n++) {
          s.dyn_dtree[n * 2] = 0;
        }
        for (n = 0; n < BL_CODES$1; n++) {
          s.bl_tree[n * 2] = 0;
        }
        s.dyn_ltree[END_BLOCK * 2] = 1;
        s.opt_len = s.static_len = 0;
        s.sym_next = s.matches = 0;
      };
      bi_windup = (s) => {
        if (s.bi_valid > 8) {
          put_short(s, s.bi_buf);
        } else if (s.bi_valid > 0) {
          s.pending_buf[s.pending++] = s.bi_buf;
        }
        s.bi_buf = 0;
        s.bi_valid = 0;
      };
      smaller = (tree, n, m, depth) => {
        const _n2 = n * 2;
        const _m2 = m * 2;
        return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
      };
      pqdownheap = (s, tree, k2) => {
        const v2 = s.heap[k2];
        let j2 = k2 << 1;
        while (j2 <= s.heap_len) {
          if (j2 < s.heap_len && smaller(tree, s.heap[j2 + 1], s.heap[j2], s.depth)) {
            j2++;
          }
          if (smaller(tree, v2, s.heap[j2], s.depth)) {
            break;
          }
          s.heap[k2] = s.heap[j2];
          k2 = j2;
          j2 <<= 1;
        }
        s.heap[k2] = v2;
      };
      compress_block = (s, ltree, dtree) => {
        let dist;
        let lc;
        let sx = 0;
        let code2;
        let extra;
        if (s.sym_next !== 0) {
          do {
            dist = s.pending_buf[s.sym_buf + sx++] & 255;
            dist += (s.pending_buf[s.sym_buf + sx++] & 255) << 8;
            lc = s.pending_buf[s.sym_buf + sx++];
            if (dist === 0) {
              send_code(s, lc, ltree);
            } else {
              code2 = _length_code[lc];
              send_code(s, code2 + LITERALS$1 + 1, ltree);
              extra = extra_lbits[code2];
              if (extra !== 0) {
                lc -= base_length[code2];
                send_bits(s, lc, extra);
              }
              dist--;
              code2 = d_code(dist);
              send_code(s, code2, dtree);
              extra = extra_dbits[code2];
              if (extra !== 0) {
                dist -= base_dist[code2];
                send_bits(s, dist, extra);
              }
            }
          } while (sx < s.sym_next);
        }
        send_code(s, END_BLOCK, ltree);
      };
      build_tree = (s, desc) => {
        const tree = desc.dyn_tree;
        const stree = desc.stat_desc.static_tree;
        const has_stree = desc.stat_desc.has_stree;
        const elems = desc.stat_desc.elems;
        let n, m;
        let max_code = -1;
        let node;
        s.heap_len = 0;
        s.heap_max = HEAP_SIZE$1;
        for (n = 0; n < elems; n++) {
          if (tree[n * 2] !== 0) {
            s.heap[++s.heap_len] = max_code = n;
            s.depth[n] = 0;
          } else {
            tree[n * 2 + 1] = 0;
          }
        }
        while (s.heap_len < 2) {
          node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
          tree[node * 2] = 1;
          s.depth[node] = 0;
          s.opt_len--;
          if (has_stree) {
            s.static_len -= stree[node * 2 + 1];
          }
        }
        desc.max_code = max_code;
        for (n = s.heap_len >> 1; n >= 1; n--) {
          pqdownheap(s, tree, n);
        }
        node = elems;
        do {
          n = s.heap[1];
          s.heap[1] = s.heap[s.heap_len--];
          pqdownheap(s, tree, 1);
          m = s.heap[1];
          s.heap[--s.heap_max] = n;
          s.heap[--s.heap_max] = m;
          tree[node * 2] = tree[n * 2] + tree[m * 2];
          s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
          tree[n * 2 + 1] = tree[m * 2 + 1] = node;
          s.heap[1] = node++;
          pqdownheap(s, tree, 1);
        } while (s.heap_len >= 2);
        s.heap[--s.heap_max] = s.heap[1];
        gen_bitlen(s, desc);
        gen_codes(tree, max_code, s.bl_count);
      };
      scan_tree = (s, tree, max_code) => {
        let n;
        let prevlen = -1;
        let curlen;
        let nextlen = tree[0 * 2 + 1];
        let count = 0;
        let max_count = 7;
        let min_count = 4;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        }
        tree[(max_code + 1) * 2 + 1] = 65535;
        for (n = 0; n <= max_code; n++) {
          curlen = nextlen;
          nextlen = tree[(n + 1) * 2 + 1];
          if (++count < max_count && curlen === nextlen) {
            continue;
          } else if (count < min_count) {
            s.bl_tree[curlen * 2] += count;
          } else if (curlen !== 0) {
            if (curlen !== prevlen) {
              s.bl_tree[curlen * 2]++;
            }
            s.bl_tree[REP_3_6 * 2]++;
          } else if (count <= 10) {
            s.bl_tree[REPZ_3_10 * 2]++;
          } else {
            s.bl_tree[REPZ_11_138 * 2]++;
          }
          count = 0;
          prevlen = curlen;
          if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
          } else if (curlen === nextlen) {
            max_count = 6;
            min_count = 3;
          } else {
            max_count = 7;
            min_count = 4;
          }
        }
      };
      send_tree = (s, tree, max_code) => {
        let n;
        let prevlen = -1;
        let curlen;
        let nextlen = tree[0 * 2 + 1];
        let count = 0;
        let max_count = 7;
        let min_count = 4;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        }
        for (n = 0; n <= max_code; n++) {
          curlen = nextlen;
          nextlen = tree[(n + 1) * 2 + 1];
          if (++count < max_count && curlen === nextlen) {
            continue;
          } else if (count < min_count) {
            do {
              send_code(s, curlen, s.bl_tree);
            } while (--count !== 0);
          } else if (curlen !== 0) {
            if (curlen !== prevlen) {
              send_code(s, curlen, s.bl_tree);
              count--;
            }
            send_code(s, REP_3_6, s.bl_tree);
            send_bits(s, count - 3, 2);
          } else if (count <= 10) {
            send_code(s, REPZ_3_10, s.bl_tree);
            send_bits(s, count - 3, 3);
          } else {
            send_code(s, REPZ_11_138, s.bl_tree);
            send_bits(s, count - 11, 7);
          }
          count = 0;
          prevlen = curlen;
          if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
          } else if (curlen === nextlen) {
            max_count = 6;
            min_count = 3;
          } else {
            max_count = 7;
            min_count = 4;
          }
        }
      };
      build_bl_tree = (s) => {
        let max_blindex;
        scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
        scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
        build_tree(s, s.bl_desc);
        for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
          if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
            break;
          }
        }
        s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
        return max_blindex;
      };
      send_all_trees = (s, lcodes, dcodes, blcodes) => {
        let rank2;
        send_bits(s, lcodes - 257, 5);
        send_bits(s, dcodes - 1, 5);
        send_bits(s, blcodes - 4, 4);
        for (rank2 = 0; rank2 < blcodes; rank2++) {
          send_bits(s, s.bl_tree[bl_order[rank2] * 2 + 1], 3);
        }
        send_tree(s, s.dyn_ltree, lcodes - 1);
        send_tree(s, s.dyn_dtree, dcodes - 1);
      };
      detect_data_type = (s) => {
        let block_mask = 4093624447;
        let n;
        for (n = 0; n <= 31; n++, block_mask >>>= 1) {
          if (block_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
            return Z_BINARY;
          }
        }
        if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
          return Z_TEXT;
        }
        for (n = 32; n < LITERALS$1; n++) {
          if (s.dyn_ltree[n * 2] !== 0) {
            return Z_TEXT;
          }
        }
        return Z_BINARY;
      };
      static_init_done = false;
      _tr_init$1 = (s) => {
        if (!static_init_done) {
          tr_static_init();
          static_init_done = true;
        }
        s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
        s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
        s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
        s.bi_buf = 0;
        s.bi_valid = 0;
        init_block(s);
      };
      _tr_stored_block$1 = (s, buf, stored_len, last) => {
        send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
        bi_windup(s);
        put_short(s, stored_len);
        put_short(s, ~stored_len);
        if (stored_len) {
          s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
        }
        s.pending += stored_len;
      };
      _tr_align$1 = (s) => {
        send_bits(s, STATIC_TREES << 1, 3);
        send_code(s, END_BLOCK, static_ltree);
        bi_flush(s);
      };
      _tr_flush_block$1 = (s, buf, stored_len, last) => {
        let opt_lenb, static_lenb;
        let max_blindex = 0;
        if (s.level > 0) {
          if (s.strm.data_type === Z_UNKNOWN$1) {
            s.strm.data_type = detect_data_type(s);
          }
          build_tree(s, s.l_desc);
          build_tree(s, s.d_desc);
          max_blindex = build_bl_tree(s);
          opt_lenb = s.opt_len + 3 + 7 >>> 3;
          static_lenb = s.static_len + 3 + 7 >>> 3;
          if (static_lenb <= opt_lenb) {
            opt_lenb = static_lenb;
          }
        } else {
          opt_lenb = static_lenb = stored_len + 5;
        }
        if (stored_len + 4 <= opt_lenb && buf !== -1) {
          _tr_stored_block$1(s, buf, stored_len, last);
        } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
          send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
          compress_block(s, static_ltree, static_dtree);
        } else {
          send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
          send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
          compress_block(s, s.dyn_ltree, s.dyn_dtree);
        }
        init_block(s);
        if (last) {
          bi_windup(s);
        }
      };
      _tr_tally$1 = (s, dist, lc) => {
        s.pending_buf[s.sym_buf + s.sym_next++] = dist;
        s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
        s.pending_buf[s.sym_buf + s.sym_next++] = lc;
        if (dist === 0) {
          s.dyn_ltree[lc * 2]++;
        } else {
          s.matches++;
          dist--;
          s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
          s.dyn_dtree[d_code(dist) * 2]++;
        }
        return s.sym_next === s.sym_end;
      };
      _tr_init_1 = _tr_init$1;
      _tr_stored_block_1 = _tr_stored_block$1;
      _tr_flush_block_1 = _tr_flush_block$1;
      _tr_tally_1 = _tr_tally$1;
      _tr_align_1 = _tr_align$1;
      trees = {
        _tr_init: _tr_init_1,
        _tr_stored_block: _tr_stored_block_1,
        _tr_flush_block: _tr_flush_block_1,
        _tr_tally: _tr_tally_1,
        _tr_align: _tr_align_1
      };
      adler32 = (adler, buf, len, pos) => {
        let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
        while (len !== 0) {
          n = len > 2e3 ? 2e3 : len;
          len -= n;
          do {
            s1 = s1 + buf[pos++] | 0;
            s2 = s2 + s1 | 0;
          } while (--n);
          s1 %= 65521;
          s2 %= 65521;
        }
        return s1 | s2 << 16 | 0;
      };
      adler32_1 = adler32;
      makeTable = () => {
        let c2, table = [];
        for (var n = 0; n < 256; n++) {
          c2 = n;
          for (var k2 = 0; k2 < 8; k2++) {
            c2 = c2 & 1 ? 3988292384 ^ c2 >>> 1 : c2 >>> 1;
          }
          table[n] = c2;
        }
        return table;
      };
      crcTable = new Uint32Array(makeTable());
      crc32 = (crc, buf, len, pos) => {
        const t2 = crcTable;
        const end = pos + len;
        crc ^= -1;
        for (let i = pos; i < end; i++) {
          crc = crc >>> 8 ^ t2[(crc ^ buf[i]) & 255];
        }
        return crc ^ -1;
      };
      crc32_1 = crc32;
      messages = {
        2: "need dictionary",
        1: "stream end",
        0: "",
        "-1": "file error",
        "-2": "stream error",
        "-3": "data error",
        "-4": "insufficient memory",
        "-5": "buffer error",
        "-6": "incompatible version"
      };
      constants$2 = {
        Z_NO_FLUSH: 0,
        Z_PARTIAL_FLUSH: 1,
        Z_SYNC_FLUSH: 2,
        Z_FULL_FLUSH: 3,
        Z_FINISH: 4,
        Z_BLOCK: 5,
        Z_TREES: 6,
        Z_OK: 0,
        Z_STREAM_END: 1,
        Z_NEED_DICT: 2,
        Z_ERRNO: -1,
        Z_STREAM_ERROR: -2,
        Z_DATA_ERROR: -3,
        Z_MEM_ERROR: -4,
        Z_BUF_ERROR: -5,
        Z_NO_COMPRESSION: 0,
        Z_BEST_SPEED: 1,
        Z_BEST_COMPRESSION: 9,
        Z_DEFAULT_COMPRESSION: -1,
        Z_FILTERED: 1,
        Z_HUFFMAN_ONLY: 2,
        Z_RLE: 3,
        Z_FIXED: 4,
        Z_DEFAULT_STRATEGY: 0,
        Z_BINARY: 0,
        Z_TEXT: 1,
        Z_UNKNOWN: 2,
        Z_DEFLATED: 8
      };
      ({ _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees);
      ({
        Z_NO_FLUSH: Z_NO_FLUSH$2,
        Z_PARTIAL_FLUSH,
        Z_FULL_FLUSH: Z_FULL_FLUSH$1,
        Z_FINISH: Z_FINISH$3,
        Z_BLOCK: Z_BLOCK$1,
        Z_OK: Z_OK$3,
        Z_STREAM_END: Z_STREAM_END$3,
        Z_STREAM_ERROR: Z_STREAM_ERROR$2,
        Z_DATA_ERROR: Z_DATA_ERROR$2,
        Z_BUF_ERROR: Z_BUF_ERROR$1,
        Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
        Z_FILTERED,
        Z_HUFFMAN_ONLY,
        Z_RLE,
        Z_FIXED,
        Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
        Z_UNKNOWN,
        Z_DEFLATED: Z_DEFLATED$2
      } = constants$2);
      MAX_MEM_LEVEL = 9;
      MAX_WBITS$1 = 15;
      DEF_MEM_LEVEL = 8;
      LENGTH_CODES = 29;
      LITERALS = 256;
      L_CODES = LITERALS + 1 + LENGTH_CODES;
      D_CODES = 30;
      BL_CODES = 19;
      HEAP_SIZE = 2 * L_CODES + 1;
      MAX_BITS = 15;
      MIN_MATCH = 3;
      MAX_MATCH = 258;
      MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
      PRESET_DICT = 32;
      INIT_STATE = 42;
      GZIP_STATE = 57;
      EXTRA_STATE = 69;
      NAME_STATE = 73;
      COMMENT_STATE = 91;
      HCRC_STATE = 103;
      BUSY_STATE = 113;
      FINISH_STATE = 666;
      BS_NEED_MORE = 1;
      BS_BLOCK_DONE = 2;
      BS_FINISH_STARTED = 3;
      BS_FINISH_DONE = 4;
      OS_CODE = 3;
      err = (strm, errorCode) => {
        strm.msg = messages[errorCode];
        return errorCode;
      };
      rank = (f3) => {
        return f3 * 2 - (f3 > 4 ? 9 : 0);
      };
      zero = (buf) => {
        let len = buf.length;
        while (--len >= 0) {
          buf[len] = 0;
        }
      };
      slide_hash = (s) => {
        let n, m;
        let p2;
        let wsize = s.w_size;
        n = s.hash_size;
        p2 = n;
        do {
          m = s.head[--p2];
          s.head[p2] = m >= wsize ? m - wsize : 0;
        } while (--n);
        n = wsize;
        p2 = n;
        do {
          m = s.prev[--p2];
          s.prev[p2] = m >= wsize ? m - wsize : 0;
        } while (--n);
      };
      HASH_ZLIB = (s, prev, data) => (prev << s.hash_shift ^ data) & s.hash_mask;
      HASH = HASH_ZLIB;
      flush_pending = (strm) => {
        const s = strm.state;
        let len = s.pending;
        if (len > strm.avail_out) {
          len = strm.avail_out;
        }
        if (len === 0) {
          return;
        }
        strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
        strm.next_out += len;
        s.pending_out += len;
        strm.total_out += len;
        strm.avail_out -= len;
        s.pending -= len;
        if (s.pending === 0) {
          s.pending_out = 0;
        }
      };
      flush_block_only = (s, last) => {
        _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
        s.block_start = s.strstart;
        flush_pending(s.strm);
      };
      put_byte = (s, b2) => {
        s.pending_buf[s.pending++] = b2;
      };
      putShortMSB = (s, b2) => {
        s.pending_buf[s.pending++] = b2 >>> 8 & 255;
        s.pending_buf[s.pending++] = b2 & 255;
      };
      read_buf = (strm, buf, start, size) => {
        let len = strm.avail_in;
        if (len > size) {
          len = size;
        }
        if (len === 0) {
          return 0;
        }
        strm.avail_in -= len;
        buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
        if (strm.state.wrap === 1) {
          strm.adler = adler32_1(strm.adler, buf, len, start);
        } else if (strm.state.wrap === 2) {
          strm.adler = crc32_1(strm.adler, buf, len, start);
        }
        strm.next_in += len;
        strm.total_in += len;
        return len;
      };
      longest_match = (s, cur_match) => {
        let chain_length = s.max_chain_length;
        let scan = s.strstart;
        let match;
        let len;
        let best_len = s.prev_length;
        let nice_match = s.nice_match;
        const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
        const _win = s.window;
        const wmask = s.w_mask;
        const prev = s.prev;
        const strend = s.strstart + MAX_MATCH;
        let scan_end1 = _win[scan + best_len - 1];
        let scan_end = _win[scan + best_len];
        if (s.prev_length >= s.good_match) {
          chain_length >>= 2;
        }
        if (nice_match > s.lookahead) {
          nice_match = s.lookahead;
        }
        do {
          match = cur_match;
          if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
            continue;
          }
          scan += 2;
          match++;
          do {
          } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
          len = MAX_MATCH - (strend - scan);
          scan = strend - MAX_MATCH;
          if (len > best_len) {
            s.match_start = cur_match;
            best_len = len;
            if (len >= nice_match) {
              break;
            }
            scan_end1 = _win[scan + best_len - 1];
            scan_end = _win[scan + best_len];
          }
        } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
        if (best_len <= s.lookahead) {
          return best_len;
        }
        return s.lookahead;
      };
      fill_window = (s) => {
        const _w_size = s.w_size;
        let n, more, str3;
        do {
          more = s.window_size - s.lookahead - s.strstart;
          if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
            s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
            s.match_start -= _w_size;
            s.strstart -= _w_size;
            s.block_start -= _w_size;
            if (s.insert > s.strstart) {
              s.insert = s.strstart;
            }
            slide_hash(s);
            more += _w_size;
          }
          if (s.strm.avail_in === 0) {
            break;
          }
          n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
          s.lookahead += n;
          if (s.lookahead + s.insert >= MIN_MATCH) {
            str3 = s.strstart - s.insert;
            s.ins_h = s.window[str3];
            s.ins_h = HASH(s, s.ins_h, s.window[str3 + 1]);
            while (s.insert) {
              s.ins_h = HASH(s, s.ins_h, s.window[str3 + MIN_MATCH - 1]);
              s.prev[str3 & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = str3;
              str3++;
              s.insert--;
              if (s.lookahead + s.insert < MIN_MATCH) {
                break;
              }
            }
          }
        } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
      };
      deflate_stored = (s, flush) => {
        let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;
        let len, left, have, last = 0;
        let used = s.strm.avail_in;
        do {
          len = 65535;
          have = s.bi_valid + 42 >> 3;
          if (s.strm.avail_out < have) {
            break;
          }
          have = s.strm.avail_out - have;
          left = s.strstart - s.block_start;
          if (len > left + s.strm.avail_in) {
            len = left + s.strm.avail_in;
          }
          if (len > have) {
            len = have;
          }
          if (len < min_block && (len === 0 && flush !== Z_FINISH$3 || flush === Z_NO_FLUSH$2 || len !== left + s.strm.avail_in)) {
            break;
          }
          last = flush === Z_FINISH$3 && len === left + s.strm.avail_in ? 1 : 0;
          _tr_stored_block(s, 0, 0, last);
          s.pending_buf[s.pending - 4] = len;
          s.pending_buf[s.pending - 3] = len >> 8;
          s.pending_buf[s.pending - 2] = ~len;
          s.pending_buf[s.pending - 1] = ~len >> 8;
          flush_pending(s.strm);
          if (left) {
            if (left > len) {
              left = len;
            }
            s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
            s.strm.next_out += left;
            s.strm.avail_out -= left;
            s.strm.total_out += left;
            s.block_start += left;
            len -= left;
          }
          if (len) {
            read_buf(s.strm, s.strm.output, s.strm.next_out, len);
            s.strm.next_out += len;
            s.strm.avail_out -= len;
            s.strm.total_out += len;
          }
        } while (last === 0);
        used -= s.strm.avail_in;
        if (used) {
          if (used >= s.w_size) {
            s.matches = 2;
            s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
            s.strstart = s.w_size;
            s.insert = s.strstart;
          } else {
            if (s.window_size - s.strstart <= used) {
              s.strstart -= s.w_size;
              s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
              if (s.matches < 2) {
                s.matches++;
              }
              if (s.insert > s.strstart) {
                s.insert = s.strstart;
              }
            }
            s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
            s.strstart += used;
            s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
          }
          s.block_start = s.strstart;
        }
        if (s.high_water < s.strstart) {
          s.high_water = s.strstart;
        }
        if (last) {
          return BS_FINISH_DONE;
        }
        if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 && s.strm.avail_in === 0 && s.strstart === s.block_start) {
          return BS_BLOCK_DONE;
        }
        have = s.window_size - s.strstart;
        if (s.strm.avail_in > have && s.block_start >= s.w_size) {
          s.block_start -= s.w_size;
          s.strstart -= s.w_size;
          s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
          if (s.matches < 2) {
            s.matches++;
          }
          have += s.w_size;
          if (s.insert > s.strstart) {
            s.insert = s.strstart;
          }
        }
        if (have > s.strm.avail_in) {
          have = s.strm.avail_in;
        }
        if (have) {
          read_buf(s.strm, s.window, s.strstart, have);
          s.strstart += have;
          s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
        }
        if (s.high_water < s.strstart) {
          s.high_water = s.strstart;
        }
        have = s.bi_valid + 42 >> 3;
        have = s.pending_buf_size - have > 65535 ? 65535 : s.pending_buf_size - have;
        min_block = have > s.w_size ? s.w_size : have;
        left = s.strstart - s.block_start;
        if (left >= min_block || (left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 && s.strm.avail_in === 0 && left <= have) {
          len = left > have ? have : left;
          last = flush === Z_FINISH$3 && s.strm.avail_in === 0 && len === left ? 1 : 0;
          _tr_stored_block(s, s.block_start, len, last);
          s.block_start += len;
          flush_pending(s.strm);
        }
        return last ? BS_FINISH_STARTED : BS_NEED_MORE;
      };
      deflate_fast = (s, flush) => {
        let hash_head;
        let bflush;
        for (; ; ) {
          if (s.lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
              return BS_NEED_MORE;
            }
            if (s.lookahead === 0) {
              break;
            }
          }
          hash_head = 0;
          if (s.lookahead >= MIN_MATCH) {
            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
          if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
            s.match_length = longest_match(s, hash_head);
          }
          if (s.match_length >= MIN_MATCH) {
            bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
            s.lookahead -= s.match_length;
            if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
              s.match_length--;
              do {
                s.strstart++;
                s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart;
              } while (--s.match_length !== 0);
              s.strstart++;
            } else {
              s.strstart += s.match_length;
              s.match_length = 0;
              s.ins_h = s.window[s.strstart];
              s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
            }
          } else {
            bflush = _tr_tally(s, 0, s.window[s.strstart]);
            s.lookahead--;
            s.strstart++;
          }
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        }
        s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
        if (flush === Z_FINISH$3) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.sym_next) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_BLOCK_DONE;
      };
      deflate_slow = (s, flush) => {
        let hash_head;
        let bflush;
        let max_insert;
        for (; ; ) {
          if (s.lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
              return BS_NEED_MORE;
            }
            if (s.lookahead === 0) {
              break;
            }
          }
          hash_head = 0;
          if (s.lookahead >= MIN_MATCH) {
            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
          s.prev_length = s.match_length;
          s.prev_match = s.match_start;
          s.match_length = MIN_MATCH - 1;
          if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
            s.match_length = longest_match(s, hash_head);
            if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
              s.match_length = MIN_MATCH - 1;
            }
          }
          if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
            max_insert = s.strstart + s.lookahead - MIN_MATCH;
            bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
            s.lookahead -= s.prev_length - 1;
            s.prev_length -= 2;
            do {
              if (++s.strstart <= max_insert) {
                s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart;
              }
            } while (--s.prev_length !== 0);
            s.match_available = 0;
            s.match_length = MIN_MATCH - 1;
            s.strstart++;
            if (bflush) {
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
          } else if (s.match_available) {
            bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
            if (bflush) {
              flush_block_only(s, false);
            }
            s.strstart++;
            s.lookahead--;
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          } else {
            s.match_available = 1;
            s.strstart++;
            s.lookahead--;
          }
        }
        if (s.match_available) {
          bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
          s.match_available = 0;
        }
        s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
        if (flush === Z_FINISH$3) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.sym_next) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_BLOCK_DONE;
      };
      deflate_rle = (s, flush) => {
        let bflush;
        let prev;
        let scan, strend;
        const _win = s.window;
        for (; ; ) {
          if (s.lookahead <= MAX_MATCH) {
            fill_window(s);
            if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
              return BS_NEED_MORE;
            }
            if (s.lookahead === 0) {
              break;
            }
          }
          s.match_length = 0;
          if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
            scan = s.strstart - 1;
            prev = _win[scan];
            if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
              strend = s.strstart + MAX_MATCH;
              do {
              } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
              s.match_length = MAX_MATCH - (strend - scan);
              if (s.match_length > s.lookahead) {
                s.match_length = s.lookahead;
              }
            }
          }
          if (s.match_length >= MIN_MATCH) {
            bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
            s.lookahead -= s.match_length;
            s.strstart += s.match_length;
            s.match_length = 0;
          } else {
            bflush = _tr_tally(s, 0, s.window[s.strstart]);
            s.lookahead--;
            s.strstart++;
          }
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        }
        s.insert = 0;
        if (flush === Z_FINISH$3) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.sym_next) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_BLOCK_DONE;
      };
      deflate_huff = (s, flush) => {
        let bflush;
        for (; ; ) {
          if (s.lookahead === 0) {
            fill_window(s);
            if (s.lookahead === 0) {
              if (flush === Z_NO_FLUSH$2) {
                return BS_NEED_MORE;
              }
              break;
            }
          }
          s.match_length = 0;
          bflush = _tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        }
        s.insert = 0;
        if (flush === Z_FINISH$3) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.sym_next) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_BLOCK_DONE;
      };
      configuration_table = [
        new Config(0, 0, 0, 0, deflate_stored),
        new Config(4, 4, 8, 4, deflate_fast),
        new Config(4, 5, 16, 8, deflate_fast),
        new Config(4, 6, 32, 32, deflate_fast),
        new Config(4, 4, 16, 16, deflate_slow),
        new Config(8, 16, 32, 32, deflate_slow),
        new Config(8, 16, 128, 128, deflate_slow),
        new Config(8, 32, 128, 256, deflate_slow),
        new Config(32, 128, 258, 1024, deflate_slow),
        new Config(32, 258, 258, 4096, deflate_slow)
      ];
      lm_init = (s) => {
        s.window_size = 2 * s.w_size;
        zero(s.head);
        s.max_lazy_match = configuration_table[s.level].max_lazy;
        s.good_match = configuration_table[s.level].good_length;
        s.nice_match = configuration_table[s.level].nice_length;
        s.max_chain_length = configuration_table[s.level].max_chain;
        s.strstart = 0;
        s.block_start = 0;
        s.lookahead = 0;
        s.insert = 0;
        s.match_length = s.prev_length = MIN_MATCH - 1;
        s.match_available = 0;
        s.ins_h = 0;
      };
      deflateStateCheck = (strm) => {
        if (!strm) {
          return 1;
        }
        const s = strm.state;
        if (!s || s.strm !== strm || s.status !== INIT_STATE && s.status !== GZIP_STATE && s.status !== EXTRA_STATE && s.status !== NAME_STATE && s.status !== COMMENT_STATE && s.status !== HCRC_STATE && s.status !== BUSY_STATE && s.status !== FINISH_STATE) {
          return 1;
        }
        return 0;
      };
      deflateResetKeep = (strm) => {
        if (deflateStateCheck(strm)) {
          return err(strm, Z_STREAM_ERROR$2);
        }
        strm.total_in = strm.total_out = 0;
        strm.data_type = Z_UNKNOWN;
        const s = strm.state;
        s.pending = 0;
        s.pending_out = 0;
        if (s.wrap < 0) {
          s.wrap = -s.wrap;
        }
        s.status = s.wrap === 2 ? GZIP_STATE : s.wrap ? INIT_STATE : BUSY_STATE;
        strm.adler = s.wrap === 2 ? 0 : 1;
        s.last_flush = -2;
        _tr_init(s);
        return Z_OK$3;
      };
      deflateReset = (strm) => {
        const ret = deflateResetKeep(strm);
        if (ret === Z_OK$3) {
          lm_init(strm.state);
        }
        return ret;
      };
      deflateSetHeader = (strm, head) => {
        if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
          return Z_STREAM_ERROR$2;
        }
        strm.state.gzhead = head;
        return Z_OK$3;
      };
      deflateInit2 = (strm, level, method2, windowBits, memLevel, strategy) => {
        if (!strm) {
          return Z_STREAM_ERROR$2;
        }
        let wrap = 1;
        if (level === Z_DEFAULT_COMPRESSION$1) {
          level = 6;
        }
        if (windowBits < 0) {
          wrap = 0;
          windowBits = -windowBits;
        } else if (windowBits > 15) {
          wrap = 2;
          windowBits -= 16;
        }
        if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method2 !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap !== 1) {
          return err(strm, Z_STREAM_ERROR$2);
        }
        if (windowBits === 8) {
          windowBits = 9;
        }
        const s = new DeflateState();
        strm.state = s;
        s.strm = strm;
        s.status = INIT_STATE;
        s.wrap = wrap;
        s.gzhead = null;
        s.w_bits = windowBits;
        s.w_size = 1 << s.w_bits;
        s.w_mask = s.w_size - 1;
        s.hash_bits = memLevel + 7;
        s.hash_size = 1 << s.hash_bits;
        s.hash_mask = s.hash_size - 1;
        s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
        s.window = new Uint8Array(s.w_size * 2);
        s.head = new Uint16Array(s.hash_size);
        s.prev = new Uint16Array(s.w_size);
        s.lit_bufsize = 1 << memLevel + 6;
        s.pending_buf_size = s.lit_bufsize * 4;
        s.pending_buf = new Uint8Array(s.pending_buf_size);
        s.sym_buf = s.lit_bufsize;
        s.sym_end = (s.lit_bufsize - 1) * 3;
        s.level = level;
        s.strategy = strategy;
        s.method = method2;
        return deflateReset(strm);
      };
      deflateInit = (strm, level) => {
        return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
      };
      deflate$2 = (strm, flush) => {
        if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {
          return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
        }
        const s = strm.state;
        if (!strm.output || strm.avail_in !== 0 && !strm.input || s.status === FINISH_STATE && flush !== Z_FINISH$3) {
          return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
        }
        const old_flush = s.last_flush;
        s.last_flush = flush;
        if (s.pending !== 0) {
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
        } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) {
          return err(strm, Z_BUF_ERROR$1);
        }
        if (s.status === FINISH_STATE && strm.avail_in !== 0) {
          return err(strm, Z_BUF_ERROR$1);
        }
        if (s.status === INIT_STATE && s.wrap === 0) {
          s.status = BUSY_STATE;
        }
        if (s.status === INIT_STATE) {
          let header = Z_DEFLATED$2 + (s.w_bits - 8 << 4) << 8;
          let level_flags = -1;
          if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
            level_flags = 0;
          } else if (s.level < 6) {
            level_flags = 1;
          } else if (s.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header |= level_flags << 6;
          if (s.strstart !== 0) {
            header |= PRESET_DICT;
          }
          header += 31 - header % 31;
          putShortMSB(s, header);
          if (s.strstart !== 0) {
            putShortMSB(s, strm.adler >>> 16);
            putShortMSB(s, strm.adler & 65535);
          }
          strm.adler = 1;
          s.status = BUSY_STATE;
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
        }
        if (s.status === GZIP_STATE) {
          strm.adler = 0;
          put_byte(s, 31);
          put_byte(s, 139);
          put_byte(s, 8);
          if (!s.gzhead) {
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, OS_CODE);
            s.status = BUSY_STATE;
            flush_pending(strm);
            if (s.pending !== 0) {
              s.last_flush = -1;
              return Z_OK$3;
            }
          } else {
            put_byte(
              s,
              (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
            );
            put_byte(s, s.gzhead.time & 255);
            put_byte(s, s.gzhead.time >> 8 & 255);
            put_byte(s, s.gzhead.time >> 16 & 255);
            put_byte(s, s.gzhead.time >> 24 & 255);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, s.gzhead.os & 255);
            if (s.gzhead.extra && s.gzhead.extra.length) {
              put_byte(s, s.gzhead.extra.length & 255);
              put_byte(s, s.gzhead.extra.length >> 8 & 255);
            }
            if (s.gzhead.hcrc) {
              strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
            }
            s.gzindex = 0;
            s.status = EXTRA_STATE;
          }
        }
        if (s.status === EXTRA_STATE) {
          if (s.gzhead.extra) {
            let beg = s.pending;
            let left = (s.gzhead.extra.length & 65535) - s.gzindex;
            while (s.pending + left > s.pending_buf_size) {
              let copy2 = s.pending_buf_size - s.pending;
              s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy2), s.pending);
              s.pending = s.pending_buf_size;
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              s.gzindex += copy2;
              flush_pending(strm);
              if (s.pending !== 0) {
                s.last_flush = -1;
                return Z_OK$3;
              }
              beg = 0;
              left -= copy2;
            }
            let gzhead_extra = new Uint8Array(s.gzhead.extra);
            s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
            s.pending += left;
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            s.gzindex = 0;
          }
          s.status = NAME_STATE;
        }
        if (s.status === NAME_STATE) {
          if (s.gzhead.name) {
            let beg = s.pending;
            let val;
            do {
              if (s.pending === s.pending_buf_size) {
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                flush_pending(strm);
                if (s.pending !== 0) {
                  s.last_flush = -1;
                  return Z_OK$3;
                }
                beg = 0;
              }
              if (s.gzindex < s.gzhead.name.length) {
                val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
              } else {
                val = 0;
              }
              put_byte(s, val);
            } while (val !== 0);
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            s.gzindex = 0;
          }
          s.status = COMMENT_STATE;
        }
        if (s.status === COMMENT_STATE) {
          if (s.gzhead.comment) {
            let beg = s.pending;
            let val;
            do {
              if (s.pending === s.pending_buf_size) {
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                flush_pending(strm);
                if (s.pending !== 0) {
                  s.last_flush = -1;
                  return Z_OK$3;
                }
                beg = 0;
              }
              if (s.gzindex < s.gzhead.comment.length) {
                val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
              } else {
                val = 0;
              }
              put_byte(s, val);
            } while (val !== 0);
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
          }
          s.status = HCRC_STATE;
        }
        if (s.status === HCRC_STATE) {
          if (s.gzhead.hcrc) {
            if (s.pending + 2 > s.pending_buf_size) {
              flush_pending(strm);
              if (s.pending !== 0) {
                s.last_flush = -1;
                return Z_OK$3;
              }
            }
            put_byte(s, strm.adler & 255);
            put_byte(s, strm.adler >> 8 & 255);
            strm.adler = 0;
          }
          s.status = BUSY_STATE;
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
        }
        if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE) {
          let bstate = s.level === 0 ? deflate_stored(s, flush) : s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
          if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
            s.status = FINISH_STATE;
          }
          if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
            if (strm.avail_out === 0) {
              s.last_flush = -1;
            }
            return Z_OK$3;
          }
          if (bstate === BS_BLOCK_DONE) {
            if (flush === Z_PARTIAL_FLUSH) {
              _tr_align(s);
            } else if (flush !== Z_BLOCK$1) {
              _tr_stored_block(s, 0, 0, false);
              if (flush === Z_FULL_FLUSH$1) {
                zero(s.head);
                if (s.lookahead === 0) {
                  s.strstart = 0;
                  s.block_start = 0;
                  s.insert = 0;
                }
              }
            }
            flush_pending(strm);
            if (strm.avail_out === 0) {
              s.last_flush = -1;
              return Z_OK$3;
            }
          }
        }
        if (flush !== Z_FINISH$3) {
          return Z_OK$3;
        }
        if (s.wrap <= 0) {
          return Z_STREAM_END$3;
        }
        if (s.wrap === 2) {
          put_byte(s, strm.adler & 255);
          put_byte(s, strm.adler >> 8 & 255);
          put_byte(s, strm.adler >> 16 & 255);
          put_byte(s, strm.adler >> 24 & 255);
          put_byte(s, strm.total_in & 255);
          put_byte(s, strm.total_in >> 8 & 255);
          put_byte(s, strm.total_in >> 16 & 255);
          put_byte(s, strm.total_in >> 24 & 255);
        } else {
          putShortMSB(s, strm.adler >>> 16);
          putShortMSB(s, strm.adler & 65535);
        }
        flush_pending(strm);
        if (s.wrap > 0) {
          s.wrap = -s.wrap;
        }
        return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
      };
      deflateEnd = (strm) => {
        if (deflateStateCheck(strm)) {
          return Z_STREAM_ERROR$2;
        }
        const status = strm.state.status;
        strm.state = null;
        return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
      };
      deflateSetDictionary = (strm, dictionary) => {
        let dictLength = dictionary.length;
        if (deflateStateCheck(strm)) {
          return Z_STREAM_ERROR$2;
        }
        const s = strm.state;
        const wrap = s.wrap;
        if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
          return Z_STREAM_ERROR$2;
        }
        if (wrap === 1) {
          strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
        }
        s.wrap = 0;
        if (dictLength >= s.w_size) {
          if (wrap === 0) {
            zero(s.head);
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
          let tmpDict = new Uint8Array(s.w_size);
          tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
          dictionary = tmpDict;
          dictLength = s.w_size;
        }
        const avail = strm.avail_in;
        const next = strm.next_in;
        const input = strm.input;
        strm.avail_in = dictLength;
        strm.next_in = 0;
        strm.input = dictionary;
        fill_window(s);
        while (s.lookahead >= MIN_MATCH) {
          let str3 = s.strstart;
          let n = s.lookahead - (MIN_MATCH - 1);
          do {
            s.ins_h = HASH(s, s.ins_h, s.window[str3 + MIN_MATCH - 1]);
            s.prev[str3 & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str3;
            str3++;
          } while (--n);
          s.strstart = str3;
          s.lookahead = MIN_MATCH - 1;
          fill_window(s);
        }
        s.strstart += s.lookahead;
        s.block_start = s.strstart;
        s.insert = s.lookahead;
        s.lookahead = 0;
        s.match_length = s.prev_length = MIN_MATCH - 1;
        s.match_available = 0;
        strm.next_in = next;
        strm.input = input;
        strm.avail_in = avail;
        s.wrap = wrap;
        return Z_OK$3;
      };
      deflateInit_1 = deflateInit;
      deflateInit2_1 = deflateInit2;
      deflateReset_1 = deflateReset;
      deflateResetKeep_1 = deflateResetKeep;
      deflateSetHeader_1 = deflateSetHeader;
      deflate_2$1 = deflate$2;
      deflateEnd_1 = deflateEnd;
      deflateSetDictionary_1 = deflateSetDictionary;
      deflateInfo = "pako deflate (from Nodeca project)";
      deflate_1$2 = {
        deflateInit: deflateInit_1,
        deflateInit2: deflateInit2_1,
        deflateReset: deflateReset_1,
        deflateResetKeep: deflateResetKeep_1,
        deflateSetHeader: deflateSetHeader_1,
        deflate: deflate_2$1,
        deflateEnd: deflateEnd_1,
        deflateSetDictionary: deflateSetDictionary_1,
        deflateInfo
      };
      _has = (obj, key) => {
        return Object.prototype.hasOwnProperty.call(obj, key);
      };
      assign = function(obj) {
        const sources = Array.prototype.slice.call(arguments, 1);
        while (sources.length) {
          const source = sources.shift();
          if (!source) {
            continue;
          }
          if (typeof source !== "object") {
            throw new TypeError(source + "must be non-object");
          }
          for (const p2 in source) {
            if (_has(source, p2)) {
              obj[p2] = source[p2];
            }
          }
        }
        return obj;
      };
      flattenChunks = (chunks2) => {
        let len = 0;
        for (let i = 0, l2 = chunks2.length; i < l2; i++) {
          len += chunks2[i].length;
        }
        const result = new Uint8Array(len);
        for (let i = 0, pos = 0, l2 = chunks2.length; i < l2; i++) {
          let chunk = chunks2[i];
          result.set(chunk, pos);
          pos += chunk.length;
        }
        return result;
      };
      common = {
        assign,
        flattenChunks
      };
      STR_APPLY_UIA_OK = true;
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch (__) {
        STR_APPLY_UIA_OK = false;
      }
      _utf8len = new Uint8Array(256);
      for (let q2 = 0; q2 < 256; q2++) {
        _utf8len[q2] = q2 >= 252 ? 6 : q2 >= 248 ? 5 : q2 >= 240 ? 4 : q2 >= 224 ? 3 : q2 >= 192 ? 2 : 1;
      }
      _utf8len[254] = _utf8len[254] = 1;
      string2buf = (str3) => {
        if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
          return new TextEncoder().encode(str3);
        }
        let buf, c2, c22, m_pos, i, str_len = str3.length, buf_len = 0;
        for (m_pos = 0; m_pos < str_len; m_pos++) {
          c2 = str3.charCodeAt(m_pos);
          if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
            c22 = str3.charCodeAt(m_pos + 1);
            if ((c22 & 64512) === 56320) {
              c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
              m_pos++;
            }
          }
          buf_len += c2 < 128 ? 1 : c2 < 2048 ? 2 : c2 < 65536 ? 3 : 4;
        }
        buf = new Uint8Array(buf_len);
        for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
          c2 = str3.charCodeAt(m_pos);
          if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
            c22 = str3.charCodeAt(m_pos + 1);
            if ((c22 & 64512) === 56320) {
              c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
              m_pos++;
            }
          }
          if (c2 < 128) {
            buf[i++] = c2;
          } else if (c2 < 2048) {
            buf[i++] = 192 | c2 >>> 6;
            buf[i++] = 128 | c2 & 63;
          } else if (c2 < 65536) {
            buf[i++] = 224 | c2 >>> 12;
            buf[i++] = 128 | c2 >>> 6 & 63;
            buf[i++] = 128 | c2 & 63;
          } else {
            buf[i++] = 240 | c2 >>> 18;
            buf[i++] = 128 | c2 >>> 12 & 63;
            buf[i++] = 128 | c2 >>> 6 & 63;
            buf[i++] = 128 | c2 & 63;
          }
        }
        return buf;
      };
      buf2binstring = (buf, len) => {
        if (len < 65534) {
          if (buf.subarray && STR_APPLY_UIA_OK) {
            return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
          }
        }
        let result = "";
        for (let i = 0; i < len; i++) {
          result += String.fromCharCode(buf[i]);
        }
        return result;
      };
      buf2string = (buf, max) => {
        const len = max || buf.length;
        if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
          return new TextDecoder().decode(buf.subarray(0, max));
        }
        let i, out;
        const utf16buf = new Array(len * 2);
        for (out = 0, i = 0; i < len; ) {
          let c2 = buf[i++];
          if (c2 < 128) {
            utf16buf[out++] = c2;
            continue;
          }
          let c_len = _utf8len[c2];
          if (c_len > 4) {
            utf16buf[out++] = 65533;
            i += c_len - 1;
            continue;
          }
          c2 &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
          while (c_len > 1 && i < len) {
            c2 = c2 << 6 | buf[i++] & 63;
            c_len--;
          }
          if (c_len > 1) {
            utf16buf[out++] = 65533;
            continue;
          }
          if (c2 < 65536) {
            utf16buf[out++] = c2;
          } else {
            c2 -= 65536;
            utf16buf[out++] = 55296 | c2 >> 10 & 1023;
            utf16buf[out++] = 56320 | c2 & 1023;
          }
        }
        return buf2binstring(utf16buf, out);
      };
      utf8border = (buf, max) => {
        max = max || buf.length;
        if (max > buf.length) {
          max = buf.length;
        }
        let pos = max - 1;
        while (pos >= 0 && (buf[pos] & 192) === 128) {
          pos--;
        }
        if (pos < 0) {
          return max;
        }
        if (pos === 0) {
          return max;
        }
        return pos + _utf8len[buf[pos]] > max ? pos : max;
      };
      strings = {
        string2buf,
        buf2string,
        utf8border
      };
      zstream = ZStream;
      toString$1 = Object.prototype.toString;
      ({
        Z_NO_FLUSH: Z_NO_FLUSH$1,
        Z_SYNC_FLUSH,
        Z_FULL_FLUSH,
        Z_FINISH: Z_FINISH$2,
        Z_OK: Z_OK$2,
        Z_STREAM_END: Z_STREAM_END$2,
        Z_DEFAULT_COMPRESSION,
        Z_DEFAULT_STRATEGY,
        Z_DEFLATED: Z_DEFLATED$1
      } = constants$2);
      Deflate$1.prototype.push = function(data, flush_mode) {
        const strm = this.strm;
        const chunkSize = this.options.chunkSize;
        let status, _flush_mode;
        if (this.ended) {
          return false;
        }
        if (flush_mode === ~~flush_mode)
          _flush_mode = flush_mode;
        else
          _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
        if (typeof data === "string") {
          strm.input = strings.string2buf(data);
        } else if (toString$1.call(data) === "[object ArrayBuffer]") {
          strm.input = new Uint8Array(data);
        } else {
          strm.input = data;
        }
        strm.next_in = 0;
        strm.avail_in = strm.input.length;
        for (; ; ) {
          if (strm.avail_out === 0) {
            strm.output = new Uint8Array(chunkSize);
            strm.next_out = 0;
            strm.avail_out = chunkSize;
          }
          if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
            this.onData(strm.output.subarray(0, strm.next_out));
            strm.avail_out = 0;
            continue;
          }
          status = deflate_1$2.deflate(strm, _flush_mode);
          if (status === Z_STREAM_END$2) {
            if (strm.next_out > 0) {
              this.onData(strm.output.subarray(0, strm.next_out));
            }
            status = deflate_1$2.deflateEnd(this.strm);
            this.onEnd(status);
            this.ended = true;
            return status === Z_OK$2;
          }
          if (strm.avail_out === 0) {
            this.onData(strm.output);
            continue;
          }
          if (_flush_mode > 0 && strm.next_out > 0) {
            this.onData(strm.output.subarray(0, strm.next_out));
            strm.avail_out = 0;
            continue;
          }
          if (strm.avail_in === 0)
            break;
        }
        return true;
      };
      Deflate$1.prototype.onData = function(chunk) {
        this.chunks.push(chunk);
      };
      Deflate$1.prototype.onEnd = function(status) {
        if (status === Z_OK$2) {
          this.result = common.flattenChunks(this.chunks);
        }
        this.chunks = [];
        this.err = status;
        this.msg = this.strm.msg;
      };
      Deflate_1$1 = Deflate$1;
      deflate_2 = deflate$1;
      deflateRaw_1$1 = deflateRaw$1;
      gzip_1$1 = gzip$1;
      constants$1 = constants$2;
      deflate_1$1 = {
        Deflate: Deflate_1$1,
        deflate: deflate_2,
        deflateRaw: deflateRaw_1$1,
        gzip: gzip_1$1,
        constants: constants$1
      };
      BAD$1 = 16209;
      TYPE$1 = 16191;
      inffast = function inflate_fast(strm, start) {
        let _in;
        let last;
        let _out;
        let beg;
        let end;
        let dmax;
        let wsize;
        let whave;
        let wnext;
        let s_window;
        let hold;
        let bits;
        let lcode;
        let dcode;
        let lmask;
        let dmask;
        let here;
        let op;
        let len;
        let dist;
        let from2;
        let from_source;
        let input, output2;
        const state = strm.state;
        _in = strm.next_in;
        input = strm.input;
        last = _in + (strm.avail_in - 5);
        _out = strm.next_out;
        output2 = strm.output;
        beg = _out - (start - strm.avail_out);
        end = _out + (strm.avail_out - 257);
        dmax = state.dmax;
        wsize = state.wsize;
        whave = state.whave;
        wnext = state.wnext;
        s_window = state.window;
        hold = state.hold;
        bits = state.bits;
        lcode = state.lencode;
        dcode = state.distcode;
        lmask = (1 << state.lenbits) - 1;
        dmask = (1 << state.distbits) - 1;
        top:
          do {
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = lcode[hold & lmask];
            dolen:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op === 0) {
                  output2[_out++] = here & 65535;
                } else if (op & 16) {
                  len = here & 65535;
                  op &= 15;
                  if (op) {
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                    len += hold & (1 << op) - 1;
                    hold >>>= op;
                    bits -= op;
                  }
                  if (bits < 15) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  here = dcode[hold & dmask];
                  dodist:
                    for (; ; ) {
                      op = here >>> 24;
                      hold >>>= op;
                      bits -= op;
                      op = here >>> 16 & 255;
                      if (op & 16) {
                        dist = here & 65535;
                        op &= 15;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                          if (bits < op) {
                            hold += input[_in++] << bits;
                            bits += 8;
                          }
                        }
                        dist += hold & (1 << op) - 1;
                        if (dist > dmax) {
                          strm.msg = "invalid distance too far back";
                          state.mode = BAD$1;
                          break top;
                        }
                        hold >>>= op;
                        bits -= op;
                        op = _out - beg;
                        if (dist > op) {
                          op = dist - op;
                          if (op > whave) {
                            if (state.sane) {
                              strm.msg = "invalid distance too far back";
                              state.mode = BAD$1;
                              break top;
                            }
                          }
                          from2 = 0;
                          from_source = s_window;
                          if (wnext === 0) {
                            from2 += wsize - op;
                            if (op < len) {
                              len -= op;
                              do {
                                output2[_out++] = s_window[from2++];
                              } while (--op);
                              from2 = _out - dist;
                              from_source = output2;
                            }
                          } else if (wnext < op) {
                            from2 += wsize + wnext - op;
                            op -= wnext;
                            if (op < len) {
                              len -= op;
                              do {
                                output2[_out++] = s_window[from2++];
                              } while (--op);
                              from2 = 0;
                              if (wnext < len) {
                                op = wnext;
                                len -= op;
                                do {
                                  output2[_out++] = s_window[from2++];
                                } while (--op);
                                from2 = _out - dist;
                                from_source = output2;
                              }
                            }
                          } else {
                            from2 += wnext - op;
                            if (op < len) {
                              len -= op;
                              do {
                                output2[_out++] = s_window[from2++];
                              } while (--op);
                              from2 = _out - dist;
                              from_source = output2;
                            }
                          }
                          while (len > 2) {
                            output2[_out++] = from_source[from2++];
                            output2[_out++] = from_source[from2++];
                            output2[_out++] = from_source[from2++];
                            len -= 3;
                          }
                          if (len) {
                            output2[_out++] = from_source[from2++];
                            if (len > 1) {
                              output2[_out++] = from_source[from2++];
                            }
                          }
                        } else {
                          from2 = _out - dist;
                          do {
                            output2[_out++] = output2[from2++];
                            output2[_out++] = output2[from2++];
                            output2[_out++] = output2[from2++];
                            len -= 3;
                          } while (len > 2);
                          if (len) {
                            output2[_out++] = output2[from2++];
                            if (len > 1) {
                              output2[_out++] = output2[from2++];
                            }
                          }
                        }
                      } else if ((op & 64) === 0) {
                        here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                        continue dodist;
                      } else {
                        strm.msg = "invalid distance code";
                        state.mode = BAD$1;
                        break top;
                      }
                      break;
                    }
                } else if ((op & 64) === 0) {
                  here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dolen;
                } else if (op & 32) {
                  state.mode = TYPE$1;
                  break top;
                } else {
                  strm.msg = "invalid literal/length code";
                  state.mode = BAD$1;
                  break top;
                }
                break;
              }
          } while (_in < last && _out < end);
        len = bits >> 3;
        _in -= len;
        bits -= len << 3;
        hold &= (1 << bits) - 1;
        strm.next_in = _in;
        strm.next_out = _out;
        strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
        strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
        state.hold = hold;
        state.bits = bits;
        return;
      };
      MAXBITS = 15;
      ENOUGH_LENS$1 = 852;
      ENOUGH_DISTS$1 = 592;
      CODES$1 = 0;
      LENS$1 = 1;
      DISTS$1 = 2;
      lbase = new Uint16Array([
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        13,
        15,
        17,
        19,
        23,
        27,
        31,
        35,
        43,
        51,
        59,
        67,
        83,
        99,
        115,
        131,
        163,
        195,
        227,
        258,
        0,
        0
      ]);
      lext = new Uint8Array([
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        17,
        17,
        17,
        17,
        18,
        18,
        18,
        18,
        19,
        19,
        19,
        19,
        20,
        20,
        20,
        20,
        21,
        21,
        21,
        21,
        16,
        72,
        78
      ]);
      dbase = new Uint16Array([
        1,
        2,
        3,
        4,
        5,
        7,
        9,
        13,
        17,
        25,
        33,
        49,
        65,
        97,
        129,
        193,
        257,
        385,
        513,
        769,
        1025,
        1537,
        2049,
        3073,
        4097,
        6145,
        8193,
        12289,
        16385,
        24577,
        0,
        0
      ]);
      dext = new Uint8Array([
        16,
        16,
        16,
        16,
        17,
        17,
        18,
        18,
        19,
        19,
        20,
        20,
        21,
        21,
        22,
        22,
        23,
        23,
        24,
        24,
        25,
        25,
        26,
        26,
        27,
        27,
        28,
        28,
        29,
        29,
        64,
        64
      ]);
      inflate_table = (type5, lens, lens_index, codes, table, table_index, work, opts) => {
        const bits = opts.bits;
        let len = 0;
        let sym = 0;
        let min = 0, max = 0;
        let root2 = 0;
        let curr = 0;
        let drop = 0;
        let left = 0;
        let used = 0;
        let huff = 0;
        let incr;
        let fill2;
        let low;
        let mask4;
        let next;
        let base = null;
        let match;
        const count = new Uint16Array(MAXBITS + 1);
        const offs = new Uint16Array(MAXBITS + 1);
        let extra = null;
        let here_bits, here_op, here_val;
        for (len = 0; len <= MAXBITS; len++) {
          count[len] = 0;
        }
        for (sym = 0; sym < codes; sym++) {
          count[lens[lens_index + sym]]++;
        }
        root2 = bits;
        for (max = MAXBITS; max >= 1; max--) {
          if (count[max] !== 0) {
            break;
          }
        }
        if (root2 > max) {
          root2 = max;
        }
        if (max === 0) {
          table[table_index++] = 1 << 24 | 64 << 16 | 0;
          table[table_index++] = 1 << 24 | 64 << 16 | 0;
          opts.bits = 1;
          return 0;
        }
        for (min = 1; min < max; min++) {
          if (count[min] !== 0) {
            break;
          }
        }
        if (root2 < min) {
          root2 = min;
        }
        left = 1;
        for (len = 1; len <= MAXBITS; len++) {
          left <<= 1;
          left -= count[len];
          if (left < 0) {
            return -1;
          }
        }
        if (left > 0 && (type5 === CODES$1 || max !== 1)) {
          return -1;
        }
        offs[1] = 0;
        for (len = 1; len < MAXBITS; len++) {
          offs[len + 1] = offs[len] + count[len];
        }
        for (sym = 0; sym < codes; sym++) {
          if (lens[lens_index + sym] !== 0) {
            work[offs[lens[lens_index + sym]]++] = sym;
          }
        }
        if (type5 === CODES$1) {
          base = extra = work;
          match = 20;
        } else if (type5 === LENS$1) {
          base = lbase;
          extra = lext;
          match = 257;
        } else {
          base = dbase;
          extra = dext;
          match = 0;
        }
        huff = 0;
        sym = 0;
        len = min;
        next = table_index;
        curr = root2;
        drop = 0;
        low = -1;
        used = 1 << root2;
        mask4 = used - 1;
        if (type5 === LENS$1 && used > ENOUGH_LENS$1 || type5 === DISTS$1 && used > ENOUGH_DISTS$1) {
          return 1;
        }
        for (; ; ) {
          here_bits = len - drop;
          if (work[sym] + 1 < match) {
            here_op = 0;
            here_val = work[sym];
          } else if (work[sym] >= match) {
            here_op = extra[work[sym] - match];
            here_val = base[work[sym] - match];
          } else {
            here_op = 32 + 64;
            here_val = 0;
          }
          incr = 1 << len - drop;
          fill2 = 1 << curr;
          min = fill2;
          do {
            fill2 -= incr;
            table[next + (huff >> drop) + fill2] = here_bits << 24 | here_op << 16 | here_val | 0;
          } while (fill2 !== 0);
          incr = 1 << len - 1;
          while (huff & incr) {
            incr >>= 1;
          }
          if (incr !== 0) {
            huff &= incr - 1;
            huff += incr;
          } else {
            huff = 0;
          }
          sym++;
          if (--count[len] === 0) {
            if (len === max) {
              break;
            }
            len = lens[lens_index + work[sym]];
          }
          if (len > root2 && (huff & mask4) !== low) {
            if (drop === 0) {
              drop = root2;
            }
            next += min;
            curr = len - drop;
            left = 1 << curr;
            while (curr + drop < max) {
              left -= count[curr + drop];
              if (left <= 0) {
                break;
              }
              curr++;
              left <<= 1;
            }
            used += 1 << curr;
            if (type5 === LENS$1 && used > ENOUGH_LENS$1 || type5 === DISTS$1 && used > ENOUGH_DISTS$1) {
              return 1;
            }
            low = huff & mask4;
            table[low] = root2 << 24 | curr << 16 | next - table_index | 0;
          }
        }
        if (huff !== 0) {
          table[next + huff] = len - drop << 24 | 64 << 16 | 0;
        }
        opts.bits = root2;
        return 0;
      };
      inftrees = inflate_table;
      CODES = 0;
      LENS = 1;
      DISTS = 2;
      ({
        Z_FINISH: Z_FINISH$1,
        Z_BLOCK,
        Z_TREES,
        Z_OK: Z_OK$1,
        Z_STREAM_END: Z_STREAM_END$1,
        Z_NEED_DICT: Z_NEED_DICT$1,
        Z_STREAM_ERROR: Z_STREAM_ERROR$1,
        Z_DATA_ERROR: Z_DATA_ERROR$1,
        Z_MEM_ERROR: Z_MEM_ERROR$1,
        Z_BUF_ERROR,
        Z_DEFLATED
      } = constants$2);
      HEAD = 16180;
      FLAGS = 16181;
      TIME = 16182;
      OS = 16183;
      EXLEN = 16184;
      EXTRA2 = 16185;
      NAME = 16186;
      COMMENT = 16187;
      HCRC = 16188;
      DICTID = 16189;
      DICT = 16190;
      TYPE = 16191;
      TYPEDO = 16192;
      STORED = 16193;
      COPY_ = 16194;
      COPY = 16195;
      TABLE = 16196;
      LENLENS = 16197;
      CODELENS = 16198;
      LEN_ = 16199;
      LEN = 16200;
      LENEXT = 16201;
      DIST = 16202;
      DISTEXT = 16203;
      MATCH = 16204;
      LIT = 16205;
      CHECK = 16206;
      LENGTH = 16207;
      DONE = 16208;
      BAD = 16209;
      MEM = 16210;
      SYNC = 16211;
      ENOUGH_LENS = 852;
      ENOUGH_DISTS = 592;
      MAX_WBITS = 15;
      DEF_WBITS = MAX_WBITS;
      zswap32 = (q2) => {
        return (q2 >>> 24 & 255) + (q2 >>> 8 & 65280) + ((q2 & 65280) << 8) + ((q2 & 255) << 24);
      };
      inflateStateCheck = (strm) => {
        if (!strm) {
          return 1;
        }
        const state = strm.state;
        if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
          return 1;
        }
        return 0;
      };
      inflateResetKeep = (strm) => {
        if (inflateStateCheck(strm)) {
          return Z_STREAM_ERROR$1;
        }
        const state = strm.state;
        strm.total_in = strm.total_out = state.total = 0;
        strm.msg = "";
        if (state.wrap) {
          strm.adler = state.wrap & 1;
        }
        state.mode = HEAD;
        state.last = 0;
        state.havedict = 0;
        state.flags = -1;
        state.dmax = 32768;
        state.head = null;
        state.hold = 0;
        state.bits = 0;
        state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
        state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
        state.sane = 1;
        state.back = -1;
        return Z_OK$1;
      };
      inflateReset = (strm) => {
        if (inflateStateCheck(strm)) {
          return Z_STREAM_ERROR$1;
        }
        const state = strm.state;
        state.wsize = 0;
        state.whave = 0;
        state.wnext = 0;
        return inflateResetKeep(strm);
      };
      inflateReset2 = (strm, windowBits) => {
        let wrap;
        if (inflateStateCheck(strm)) {
          return Z_STREAM_ERROR$1;
        }
        const state = strm.state;
        if (windowBits < 0) {
          wrap = 0;
          windowBits = -windowBits;
        } else {
          wrap = (windowBits >> 4) + 5;
          if (windowBits < 48) {
            windowBits &= 15;
          }
        }
        if (windowBits && (windowBits < 8 || windowBits > 15)) {
          return Z_STREAM_ERROR$1;
        }
        if (state.window !== null && state.wbits !== windowBits) {
          state.window = null;
        }
        state.wrap = wrap;
        state.wbits = windowBits;
        return inflateReset(strm);
      };
      inflateInit2 = (strm, windowBits) => {
        if (!strm) {
          return Z_STREAM_ERROR$1;
        }
        const state = new InflateState();
        strm.state = state;
        state.strm = strm;
        state.window = null;
        state.mode = HEAD;
        const ret = inflateReset2(strm, windowBits);
        if (ret !== Z_OK$1) {
          strm.state = null;
        }
        return ret;
      };
      inflateInit = (strm) => {
        return inflateInit2(strm, DEF_WBITS);
      };
      virgin = true;
      fixedtables = (state) => {
        if (virgin) {
          lenfix = new Int32Array(512);
          distfix = new Int32Array(32);
          let sym = 0;
          while (sym < 144) {
            state.lens[sym++] = 8;
          }
          while (sym < 256) {
            state.lens[sym++] = 9;
          }
          while (sym < 280) {
            state.lens[sym++] = 7;
          }
          while (sym < 288) {
            state.lens[sym++] = 8;
          }
          inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
          sym = 0;
          while (sym < 32) {
            state.lens[sym++] = 5;
          }
          inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
          virgin = false;
        }
        state.lencode = lenfix;
        state.lenbits = 9;
        state.distcode = distfix;
        state.distbits = 5;
      };
      updatewindow = (strm, src, end, copy2) => {
        let dist;
        const state = strm.state;
        if (state.window === null) {
          state.wsize = 1 << state.wbits;
          state.wnext = 0;
          state.whave = 0;
          state.window = new Uint8Array(state.wsize);
        }
        if (copy2 >= state.wsize) {
          state.window.set(src.subarray(end - state.wsize, end), 0);
          state.wnext = 0;
          state.whave = state.wsize;
        } else {
          dist = state.wsize - state.wnext;
          if (dist > copy2) {
            dist = copy2;
          }
          state.window.set(src.subarray(end - copy2, end - copy2 + dist), state.wnext);
          copy2 -= dist;
          if (copy2) {
            state.window.set(src.subarray(end - copy2, end), 0);
            state.wnext = copy2;
            state.whave = state.wsize;
          } else {
            state.wnext += dist;
            if (state.wnext === state.wsize) {
              state.wnext = 0;
            }
            if (state.whave < state.wsize) {
              state.whave += dist;
            }
          }
        }
        return 0;
      };
      inflate$2 = (strm, flush) => {
        let state;
        let input, output2;
        let next;
        let put;
        let have, left;
        let hold;
        let bits;
        let _in, _out;
        let copy2;
        let from2;
        let from_source;
        let here = 0;
        let here_bits, here_op, here_val;
        let last_bits, last_op, last_val;
        let len;
        let ret;
        const hbuf = new Uint8Array(4);
        let opts;
        let n;
        const order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
        if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
          return Z_STREAM_ERROR$1;
        }
        state = strm.state;
        if (state.mode === TYPE) {
          state.mode = TYPEDO;
        }
        put = strm.next_out;
        output2 = strm.output;
        left = strm.avail_out;
        next = strm.next_in;
        input = strm.input;
        have = strm.avail_in;
        hold = state.hold;
        bits = state.bits;
        _in = have;
        _out = left;
        ret = Z_OK$1;
        inf_leave:
          for (; ; ) {
            switch (state.mode) {
              case HEAD:
                if (state.wrap === 0) {
                  state.mode = TYPEDO;
                  break;
                }
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.wrap & 2 && hold === 35615) {
                  if (state.wbits === 0) {
                    state.wbits = 15;
                  }
                  state.check = 0;
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32_1(state.check, hbuf, 2, 0);
                  hold = 0;
                  bits = 0;
                  state.mode = FLAGS;
                  break;
                }
                if (state.head) {
                  state.head.done = false;
                }
                if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
                  strm.msg = "incorrect header check";
                  state.mode = BAD;
                  break;
                }
                if ((hold & 15) !== Z_DEFLATED) {
                  strm.msg = "unknown compression method";
                  state.mode = BAD;
                  break;
                }
                hold >>>= 4;
                bits -= 4;
                len = (hold & 15) + 8;
                if (state.wbits === 0) {
                  state.wbits = len;
                }
                if (len > 15 || len > state.wbits) {
                  strm.msg = "invalid window size";
                  state.mode = BAD;
                  break;
                }
                state.dmax = 1 << state.wbits;
                state.flags = 0;
                strm.adler = state.check = 1;
                state.mode = hold & 512 ? DICTID : TYPE;
                hold = 0;
                bits = 0;
                break;
              case FLAGS:
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.flags = hold;
                if ((state.flags & 255) !== Z_DEFLATED) {
                  strm.msg = "unknown compression method";
                  state.mode = BAD;
                  break;
                }
                if (state.flags & 57344) {
                  strm.msg = "unknown header flags set";
                  state.mode = BAD;
                  break;
                }
                if (state.head) {
                  state.head.text = hold >> 8 & 1;
                }
                if (state.flags & 512 && state.wrap & 4) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32_1(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = TIME;
              case TIME:
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.head) {
                  state.head.time = hold;
                }
                if (state.flags & 512 && state.wrap & 4) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  hbuf[2] = hold >>> 16 & 255;
                  hbuf[3] = hold >>> 24 & 255;
                  state.check = crc32_1(state.check, hbuf, 4, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = OS;
              case OS:
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.head) {
                  state.head.xflags = hold & 255;
                  state.head.os = hold >> 8;
                }
                if (state.flags & 512 && state.wrap & 4) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32_1(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = EXLEN;
              case EXLEN:
                if (state.flags & 1024) {
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.length = hold;
                  if (state.head) {
                    state.head.extra_len = hold;
                  }
                  if (state.flags & 512 && state.wrap & 4) {
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    state.check = crc32_1(state.check, hbuf, 2, 0);
                  }
                  hold = 0;
                  bits = 0;
                } else if (state.head) {
                  state.head.extra = null;
                }
                state.mode = EXTRA2;
              case EXTRA2:
                if (state.flags & 1024) {
                  copy2 = state.length;
                  if (copy2 > have) {
                    copy2 = have;
                  }
                  if (copy2) {
                    if (state.head) {
                      len = state.head.extra_len - state.length;
                      if (!state.head.extra) {
                        state.head.extra = new Uint8Array(state.head.extra_len);
                      }
                      state.head.extra.set(
                        input.subarray(
                          next,
                          next + copy2
                        ),
                        len
                      );
                    }
                    if (state.flags & 512 && state.wrap & 4) {
                      state.check = crc32_1(state.check, input, copy2, next);
                    }
                    have -= copy2;
                    next += copy2;
                    state.length -= copy2;
                  }
                  if (state.length) {
                    break inf_leave;
                  }
                }
                state.length = 0;
                state.mode = NAME;
              case NAME:
                if (state.flags & 2048) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  copy2 = 0;
                  do {
                    len = input[next + copy2++];
                    if (state.head && len && state.length < 65536) {
                      state.head.name += String.fromCharCode(len);
                    }
                  } while (len && copy2 < have);
                  if (state.flags & 512 && state.wrap & 4) {
                    state.check = crc32_1(state.check, input, copy2, next);
                  }
                  have -= copy2;
                  next += copy2;
                  if (len) {
                    break inf_leave;
                  }
                } else if (state.head) {
                  state.head.name = null;
                }
                state.length = 0;
                state.mode = COMMENT;
              case COMMENT:
                if (state.flags & 4096) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  copy2 = 0;
                  do {
                    len = input[next + copy2++];
                    if (state.head && len && state.length < 65536) {
                      state.head.comment += String.fromCharCode(len);
                    }
                  } while (len && copy2 < have);
                  if (state.flags & 512 && state.wrap & 4) {
                    state.check = crc32_1(state.check, input, copy2, next);
                  }
                  have -= copy2;
                  next += copy2;
                  if (len) {
                    break inf_leave;
                  }
                } else if (state.head) {
                  state.head.comment = null;
                }
                state.mode = HCRC;
              case HCRC:
                if (state.flags & 512) {
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (state.wrap & 4 && hold !== (state.check & 65535)) {
                    strm.msg = "header crc mismatch";
                    state.mode = BAD;
                    break;
                  }
                  hold = 0;
                  bits = 0;
                }
                if (state.head) {
                  state.head.hcrc = state.flags >> 9 & 1;
                  state.head.done = true;
                }
                strm.adler = state.check = 0;
                state.mode = TYPE;
                break;
              case DICTID:
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                strm.adler = state.check = zswap32(hold);
                hold = 0;
                bits = 0;
                state.mode = DICT;
              case DICT:
                if (state.havedict === 0) {
                  strm.next_out = put;
                  strm.avail_out = left;
                  strm.next_in = next;
                  strm.avail_in = have;
                  state.hold = hold;
                  state.bits = bits;
                  return Z_NEED_DICT$1;
                }
                strm.adler = state.check = 1;
                state.mode = TYPE;
              case TYPE:
                if (flush === Z_BLOCK || flush === Z_TREES) {
                  break inf_leave;
                }
              case TYPEDO:
                if (state.last) {
                  hold >>>= bits & 7;
                  bits -= bits & 7;
                  state.mode = CHECK;
                  break;
                }
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.last = hold & 1;
                hold >>>= 1;
                bits -= 1;
                switch (hold & 3) {
                  case 0:
                    state.mode = STORED;
                    break;
                  case 1:
                    fixedtables(state);
                    state.mode = LEN_;
                    if (flush === Z_TREES) {
                      hold >>>= 2;
                      bits -= 2;
                      break inf_leave;
                    }
                    break;
                  case 2:
                    state.mode = TABLE;
                    break;
                  case 3:
                    strm.msg = "invalid block type";
                    state.mode = BAD;
                }
                hold >>>= 2;
                bits -= 2;
                break;
              case STORED:
                hold >>>= bits & 7;
                bits -= bits & 7;
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                  strm.msg = "invalid stored block lengths";
                  state.mode = BAD;
                  break;
                }
                state.length = hold & 65535;
                hold = 0;
                bits = 0;
                state.mode = COPY_;
                if (flush === Z_TREES) {
                  break inf_leave;
                }
              case COPY_:
                state.mode = COPY;
              case COPY:
                copy2 = state.length;
                if (copy2) {
                  if (copy2 > have) {
                    copy2 = have;
                  }
                  if (copy2 > left) {
                    copy2 = left;
                  }
                  if (copy2 === 0) {
                    break inf_leave;
                  }
                  output2.set(input.subarray(next, next + copy2), put);
                  have -= copy2;
                  next += copy2;
                  left -= copy2;
                  put += copy2;
                  state.length -= copy2;
                  break;
                }
                state.mode = TYPE;
                break;
              case TABLE:
                while (bits < 14) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.nlen = (hold & 31) + 257;
                hold >>>= 5;
                bits -= 5;
                state.ndist = (hold & 31) + 1;
                hold >>>= 5;
                bits -= 5;
                state.ncode = (hold & 15) + 4;
                hold >>>= 4;
                bits -= 4;
                if (state.nlen > 286 || state.ndist > 30) {
                  strm.msg = "too many length or distance symbols";
                  state.mode = BAD;
                  break;
                }
                state.have = 0;
                state.mode = LENLENS;
              case LENLENS:
                while (state.have < state.ncode) {
                  while (bits < 3) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.lens[order[state.have++]] = hold & 7;
                  hold >>>= 3;
                  bits -= 3;
                }
                while (state.have < 19) {
                  state.lens[order[state.have++]] = 0;
                }
                state.lencode = state.lendyn;
                state.lenbits = 7;
                opts = { bits: state.lenbits };
                ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
                state.lenbits = opts.bits;
                if (ret) {
                  strm.msg = "invalid code lengths set";
                  state.mode = BAD;
                  break;
                }
                state.have = 0;
                state.mode = CODELENS;
              case CODELENS:
                while (state.have < state.nlen + state.ndist) {
                  for (; ; ) {
                    here = state.lencode[hold & (1 << state.lenbits) - 1];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (here_bits <= bits) {
                      break;
                    }
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (here_val < 16) {
                    hold >>>= here_bits;
                    bits -= here_bits;
                    state.lens[state.have++] = here_val;
                  } else {
                    if (here_val === 16) {
                      n = here_bits + 2;
                      while (bits < n) {
                        if (have === 0) {
                          break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                      }
                      hold >>>= here_bits;
                      bits -= here_bits;
                      if (state.have === 0) {
                        strm.msg = "invalid bit length repeat";
                        state.mode = BAD;
                        break;
                      }
                      len = state.lens[state.have - 1];
                      copy2 = 3 + (hold & 3);
                      hold >>>= 2;
                      bits -= 2;
                    } else if (here_val === 17) {
                      n = here_bits + 3;
                      while (bits < n) {
                        if (have === 0) {
                          break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                      }
                      hold >>>= here_bits;
                      bits -= here_bits;
                      len = 0;
                      copy2 = 3 + (hold & 7);
                      hold >>>= 3;
                      bits -= 3;
                    } else {
                      n = here_bits + 7;
                      while (bits < n) {
                        if (have === 0) {
                          break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                      }
                      hold >>>= here_bits;
                      bits -= here_bits;
                      len = 0;
                      copy2 = 11 + (hold & 127);
                      hold >>>= 7;
                      bits -= 7;
                    }
                    if (state.have + copy2 > state.nlen + state.ndist) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    while (copy2--) {
                      state.lens[state.have++] = len;
                    }
                  }
                }
                if (state.mode === BAD) {
                  break;
                }
                if (state.lens[256] === 0) {
                  strm.msg = "invalid code -- missing end-of-block";
                  state.mode = BAD;
                  break;
                }
                state.lenbits = 9;
                opts = { bits: state.lenbits };
                ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
                state.lenbits = opts.bits;
                if (ret) {
                  strm.msg = "invalid literal/lengths set";
                  state.mode = BAD;
                  break;
                }
                state.distbits = 6;
                state.distcode = state.distdyn;
                opts = { bits: state.distbits };
                ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
                state.distbits = opts.bits;
                if (ret) {
                  strm.msg = "invalid distances set";
                  state.mode = BAD;
                  break;
                }
                state.mode = LEN_;
                if (flush === Z_TREES) {
                  break inf_leave;
                }
              case LEN_:
                state.mode = LEN;
              case LEN:
                if (have >= 6 && left >= 258) {
                  strm.next_out = put;
                  strm.avail_out = left;
                  strm.next_in = next;
                  strm.avail_in = have;
                  state.hold = hold;
                  state.bits = bits;
                  inffast(strm, _out);
                  put = strm.next_out;
                  output2 = strm.output;
                  left = strm.avail_out;
                  next = strm.next_in;
                  input = strm.input;
                  have = strm.avail_in;
                  hold = state.hold;
                  bits = state.bits;
                  if (state.mode === TYPE) {
                    state.back = -1;
                  }
                  break;
                }
                state.back = 0;
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_op && (here_op & 240) === 0) {
                  last_bits = here_bits;
                  last_op = here_op;
                  last_val = here_val;
                  for (; ; ) {
                    here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (last_bits + here_bits <= bits) {
                      break;
                    }
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= last_bits;
                  bits -= last_bits;
                  state.back += last_bits;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                state.back += here_bits;
                state.length = here_val;
                if (here_op === 0) {
                  state.mode = LIT;
                  break;
                }
                if (here_op & 32) {
                  state.back = -1;
                  state.mode = TYPE;
                  break;
                }
                if (here_op & 64) {
                  strm.msg = "invalid literal/length code";
                  state.mode = BAD;
                  break;
                }
                state.extra = here_op & 15;
                state.mode = LENEXT;
              case LENEXT:
                if (state.extra) {
                  n = state.extra;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.length += hold & (1 << state.extra) - 1;
                  hold >>>= state.extra;
                  bits -= state.extra;
                  state.back += state.extra;
                }
                state.was = state.length;
                state.mode = DIST;
              case DIST:
                for (; ; ) {
                  here = state.distcode[hold & (1 << state.distbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if ((here_op & 240) === 0) {
                  last_bits = here_bits;
                  last_op = here_op;
                  last_val = here_val;
                  for (; ; ) {
                    here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (last_bits + here_bits <= bits) {
                      break;
                    }
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= last_bits;
                  bits -= last_bits;
                  state.back += last_bits;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                state.back += here_bits;
                if (here_op & 64) {
                  strm.msg = "invalid distance code";
                  state.mode = BAD;
                  break;
                }
                state.offset = here_val;
                state.extra = here_op & 15;
                state.mode = DISTEXT;
              case DISTEXT:
                if (state.extra) {
                  n = state.extra;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.offset += hold & (1 << state.extra) - 1;
                  hold >>>= state.extra;
                  bits -= state.extra;
                  state.back += state.extra;
                }
                if (state.offset > state.dmax) {
                  strm.msg = "invalid distance too far back";
                  state.mode = BAD;
                  break;
                }
                state.mode = MATCH;
              case MATCH:
                if (left === 0) {
                  break inf_leave;
                }
                copy2 = _out - left;
                if (state.offset > copy2) {
                  copy2 = state.offset - copy2;
                  if (copy2 > state.whave) {
                    if (state.sane) {
                      strm.msg = "invalid distance too far back";
                      state.mode = BAD;
                      break;
                    }
                  }
                  if (copy2 > state.wnext) {
                    copy2 -= state.wnext;
                    from2 = state.wsize - copy2;
                  } else {
                    from2 = state.wnext - copy2;
                  }
                  if (copy2 > state.length) {
                    copy2 = state.length;
                  }
                  from_source = state.window;
                } else {
                  from_source = output2;
                  from2 = put - state.offset;
                  copy2 = state.length;
                }
                if (copy2 > left) {
                  copy2 = left;
                }
                left -= copy2;
                state.length -= copy2;
                do {
                  output2[put++] = from_source[from2++];
                } while (--copy2);
                if (state.length === 0) {
                  state.mode = LEN;
                }
                break;
              case LIT:
                if (left === 0) {
                  break inf_leave;
                }
                output2[put++] = state.length;
                left--;
                state.mode = LEN;
                break;
              case CHECK:
                if (state.wrap) {
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold |= input[next++] << bits;
                    bits += 8;
                  }
                  _out -= left;
                  strm.total_out += _out;
                  state.total += _out;
                  if (state.wrap & 4 && _out) {
                    strm.adler = state.check = state.flags ? crc32_1(state.check, output2, _out, put - _out) : adler32_1(state.check, output2, _out, put - _out);
                  }
                  _out = left;
                  if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
                    strm.msg = "incorrect data check";
                    state.mode = BAD;
                    break;
                  }
                  hold = 0;
                  bits = 0;
                }
                state.mode = LENGTH;
              case LENGTH:
                if (state.wrap && state.flags) {
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
                    strm.msg = "incorrect length check";
                    state.mode = BAD;
                    break;
                  }
                  hold = 0;
                  bits = 0;
                }
                state.mode = DONE;
              case DONE:
                ret = Z_STREAM_END$1;
                break inf_leave;
              case BAD:
                ret = Z_DATA_ERROR$1;
                break inf_leave;
              case MEM:
                return Z_MEM_ERROR$1;
              case SYNC:
              default:
                return Z_STREAM_ERROR$1;
            }
          }
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH$1)) {
          if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out))
            ;
        }
        _in -= strm.avail_in;
        _out -= strm.avail_out;
        strm.total_in += _in;
        strm.total_out += _out;
        state.total += _out;
        if (state.wrap & 4 && _out) {
          strm.adler = state.check = state.flags ? crc32_1(state.check, output2, _out, strm.next_out - _out) : adler32_1(state.check, output2, _out, strm.next_out - _out);
        }
        strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
        if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
          ret = Z_BUF_ERROR;
        }
        return ret;
      };
      inflateEnd = (strm) => {
        if (inflateStateCheck(strm)) {
          return Z_STREAM_ERROR$1;
        }
        let state = strm.state;
        if (state.window) {
          state.window = null;
        }
        strm.state = null;
        return Z_OK$1;
      };
      inflateGetHeader = (strm, head) => {
        if (inflateStateCheck(strm)) {
          return Z_STREAM_ERROR$1;
        }
        const state = strm.state;
        if ((state.wrap & 2) === 0) {
          return Z_STREAM_ERROR$1;
        }
        state.head = head;
        head.done = false;
        return Z_OK$1;
      };
      inflateSetDictionary = (strm, dictionary) => {
        const dictLength = dictionary.length;
        let state;
        let dictid;
        let ret;
        if (inflateStateCheck(strm)) {
          return Z_STREAM_ERROR$1;
        }
        state = strm.state;
        if (state.wrap !== 0 && state.mode !== DICT) {
          return Z_STREAM_ERROR$1;
        }
        if (state.mode === DICT) {
          dictid = 1;
          dictid = adler32_1(dictid, dictionary, dictLength, 0);
          if (dictid !== state.check) {
            return Z_DATA_ERROR$1;
          }
        }
        ret = updatewindow(strm, dictionary, dictLength, dictLength);
        if (ret) {
          state.mode = MEM;
          return Z_MEM_ERROR$1;
        }
        state.havedict = 1;
        return Z_OK$1;
      };
      inflateReset_1 = inflateReset;
      inflateReset2_1 = inflateReset2;
      inflateResetKeep_1 = inflateResetKeep;
      inflateInit_1 = inflateInit;
      inflateInit2_1 = inflateInit2;
      inflate_2$1 = inflate$2;
      inflateEnd_1 = inflateEnd;
      inflateGetHeader_1 = inflateGetHeader;
      inflateSetDictionary_1 = inflateSetDictionary;
      inflateInfo = "pako inflate (from Nodeca project)";
      inflate_1$2 = {
        inflateReset: inflateReset_1,
        inflateReset2: inflateReset2_1,
        inflateResetKeep: inflateResetKeep_1,
        inflateInit: inflateInit_1,
        inflateInit2: inflateInit2_1,
        inflate: inflate_2$1,
        inflateEnd: inflateEnd_1,
        inflateGetHeader: inflateGetHeader_1,
        inflateSetDictionary: inflateSetDictionary_1,
        inflateInfo
      };
      gzheader = GZheader;
      toString2 = Object.prototype.toString;
      ({
        Z_NO_FLUSH,
        Z_FINISH,
        Z_OK,
        Z_STREAM_END,
        Z_NEED_DICT,
        Z_STREAM_ERROR,
        Z_DATA_ERROR,
        Z_MEM_ERROR
      } = constants$2);
      Inflate$1.prototype.push = function(data, flush_mode) {
        const strm = this.strm;
        const chunkSize = this.options.chunkSize;
        const dictionary = this.options.dictionary;
        let status, _flush_mode, last_avail_out;
        if (this.ended)
          return false;
        if (flush_mode === ~~flush_mode)
          _flush_mode = flush_mode;
        else
          _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
        if (toString2.call(data) === "[object ArrayBuffer]") {
          strm.input = new Uint8Array(data);
        } else {
          strm.input = data;
        }
        strm.next_in = 0;
        strm.avail_in = strm.input.length;
        for (; ; ) {
          if (strm.avail_out === 0) {
            strm.output = new Uint8Array(chunkSize);
            strm.next_out = 0;
            strm.avail_out = chunkSize;
          }
          status = inflate_1$2.inflate(strm, _flush_mode);
          if (status === Z_NEED_DICT && dictionary) {
            status = inflate_1$2.inflateSetDictionary(strm, dictionary);
            if (status === Z_OK) {
              status = inflate_1$2.inflate(strm, _flush_mode);
            } else if (status === Z_DATA_ERROR) {
              status = Z_NEED_DICT;
            }
          }
          while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
            inflate_1$2.inflateReset(strm);
            status = inflate_1$2.inflate(strm, _flush_mode);
          }
          switch (status) {
            case Z_STREAM_ERROR:
            case Z_DATA_ERROR:
            case Z_NEED_DICT:
            case Z_MEM_ERROR:
              this.onEnd(status);
              this.ended = true;
              return false;
          }
          last_avail_out = strm.avail_out;
          if (strm.next_out) {
            if (strm.avail_out === 0 || status === Z_STREAM_END) {
              if (this.options.to === "string") {
                let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
                let tail = strm.next_out - next_out_utf8;
                let utf8str = strings.buf2string(strm.output, next_out_utf8);
                strm.next_out = tail;
                strm.avail_out = chunkSize - tail;
                if (tail)
                  strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
                this.onData(utf8str);
              } else {
                this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
              }
            }
          }
          if (status === Z_OK && last_avail_out === 0)
            continue;
          if (status === Z_STREAM_END) {
            status = inflate_1$2.inflateEnd(this.strm);
            this.onEnd(status);
            this.ended = true;
            return true;
          }
          if (strm.avail_in === 0)
            break;
        }
        return true;
      };
      Inflate$1.prototype.onData = function(chunk) {
        this.chunks.push(chunk);
      };
      Inflate$1.prototype.onEnd = function(status) {
        if (status === Z_OK) {
          if (this.options.to === "string") {
            this.result = this.chunks.join("");
          } else {
            this.result = common.flattenChunks(this.chunks);
          }
        }
        this.chunks = [];
        this.err = status;
        this.msg = this.strm.msg;
      };
      Inflate_1$1 = Inflate$1;
      inflate_2 = inflate$1;
      inflateRaw_1$1 = inflateRaw$1;
      ungzip$1 = inflate$1;
      constants = constants$2;
      inflate_1$1 = {
        Inflate: Inflate_1$1,
        inflate: inflate_2,
        inflateRaw: inflateRaw_1$1,
        ungzip: ungzip$1,
        constants
      };
      ({ Deflate, deflate, deflateRaw, gzip } = deflate_1$1);
      ({ Inflate, inflate, inflateRaw, ungzip } = inflate_1$1);
      inflate_1 = inflate;
    }
  });

  // node_modules/decimal.js/decimal.js
  var require_decimal = __commonJS({
    "node_modules/decimal.js/decimal.js"(exports2, module2) {
      init_virtual_process_polyfill();
      init_buffer();
      (function(globalScope) {
        "use strict";
        var EXP_LIMIT = 9e15, MAX_DIGITS = 1e9, NUMERALS = "0123456789abcdef", LN10 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058", PI = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789", DEFAULTS = {
          precision: 20,
          rounding: 4,
          modulo: 1,
          toExpNeg: -7,
          toExpPos: 21,
          minE: -EXP_LIMIT,
          maxE: EXP_LIMIT,
          crypto: false
        }, Decimal, inexact, noConflict, quadrant, external = true, decimalError = "[DecimalError] ", invalidArgument = decimalError + "Invalid argument: ", precisionLimitExceeded = decimalError + "Precision limit exceeded", cryptoUnavailable = decimalError + "crypto unavailable", tag = "[object Decimal]", mathfloor = Math.floor, mathpow = Math.pow, isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i, isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i, isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i, isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, BASE = 1e7, LOG_BASE = 7, MAX_SAFE_INTEGER = 9007199254740991, LN10_PRECISION = LN10.length - 1, PI_PRECISION = PI.length - 1, P2 = { toStringTag: tag };
        P2.absoluteValue = P2.abs = function() {
          var x2 = new this.constructor(this);
          if (x2.s < 0)
            x2.s = 1;
          return finalise(x2);
        };
        P2.ceil = function() {
          return finalise(new this.constructor(this), this.e + 1, 2);
        };
        P2.clampedTo = P2.clamp = function(min2, max2) {
          var k2, x2 = this, Ctor = x2.constructor;
          min2 = new Ctor(min2);
          max2 = new Ctor(max2);
          if (!min2.s || !max2.s)
            return new Ctor(NaN);
          if (min2.gt(max2))
            throw Error(invalidArgument + max2);
          k2 = x2.cmp(min2);
          return k2 < 0 ? min2 : x2.cmp(max2) > 0 ? max2 : new Ctor(x2);
        };
        P2.comparedTo = P2.cmp = function(y2) {
          var i, j2, xdL, ydL, x2 = this, xd = x2.d, yd = (y2 = new x2.constructor(y2)).d, xs = x2.s, ys = y2.s;
          if (!xd || !yd) {
            return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
          }
          if (!xd[0] || !yd[0])
            return xd[0] ? xs : yd[0] ? -ys : 0;
          if (xs !== ys)
            return xs;
          if (x2.e !== y2.e)
            return x2.e > y2.e ^ xs < 0 ? 1 : -1;
          xdL = xd.length;
          ydL = yd.length;
          for (i = 0, j2 = xdL < ydL ? xdL : ydL; i < j2; ++i) {
            if (xd[i] !== yd[i])
              return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
          }
          return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
        };
        P2.cosine = P2.cos = function() {
          var pr, rm, x2 = this, Ctor = x2.constructor;
          if (!x2.d)
            return new Ctor(NaN);
          if (!x2.d[0])
            return new Ctor(1);
          pr = Ctor.precision;
          rm = Ctor.rounding;
          Ctor.precision = pr + Math.max(x2.e, x2.sd()) + LOG_BASE;
          Ctor.rounding = 1;
          x2 = cosine(Ctor, toLessThanHalfPi(Ctor, x2));
          Ctor.precision = pr;
          Ctor.rounding = rm;
          return finalise(quadrant == 2 || quadrant == 3 ? x2.neg() : x2, pr, rm, true);
        };
        P2.cubeRoot = P2.cbrt = function() {
          var e, m, n, r, rep, s, sd, t2, t3, t3plusx, x2 = this, Ctor = x2.constructor;
          if (!x2.isFinite() || x2.isZero())
            return new Ctor(x2);
          external = false;
          s = x2.s * mathpow(x2.s * x2, 1 / 3);
          if (!s || Math.abs(s) == 1 / 0) {
            n = digitsToString(x2.d);
            e = x2.e;
            if (s = (e - n.length + 1) % 3)
              n += s == 1 || s == -2 ? "0" : "00";
            s = mathpow(n, 1 / 3);
            e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));
            if (s == 1 / 0) {
              n = "5e" + e;
            } else {
              n = s.toExponential();
              n = n.slice(0, n.indexOf("e") + 1) + e;
            }
            r = new Ctor(n);
            r.s = x2.s;
          } else {
            r = new Ctor(s.toString());
          }
          sd = (e = Ctor.precision) + 3;
          for (; ; ) {
            t2 = r;
            t3 = t2.times(t2).times(t2);
            t3plusx = t3.plus(x2);
            r = divide(t3plusx.plus(x2).times(t2), t3plusx.plus(t3), sd + 2, 1);
            if (digitsToString(t2.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
              n = n.slice(sd - 3, sd + 1);
              if (n == "9999" || !rep && n == "4999") {
                if (!rep) {
                  finalise(t2, e + 1, 0);
                  if (t2.times(t2).times(t2).eq(x2)) {
                    r = t2;
                    break;
                  }
                }
                sd += 4;
                rep = 1;
              } else {
                if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                  finalise(r, e + 1, 1);
                  m = !r.times(r).times(r).eq(x2);
                }
                break;
              }
            }
          }
          external = true;
          return finalise(r, e, Ctor.rounding, m);
        };
        P2.decimalPlaces = P2.dp = function() {
          var w2, d2 = this.d, n = NaN;
          if (d2) {
            w2 = d2.length - 1;
            n = (w2 - mathfloor(this.e / LOG_BASE)) * LOG_BASE;
            w2 = d2[w2];
            if (w2)
              for (; w2 % 10 == 0; w2 /= 10)
                n--;
            if (n < 0)
              n = 0;
          }
          return n;
        };
        P2.dividedBy = P2.div = function(y2) {
          return divide(this, new this.constructor(y2));
        };
        P2.dividedToIntegerBy = P2.divToInt = function(y2) {
          var x2 = this, Ctor = x2.constructor;
          return finalise(divide(x2, new Ctor(y2), 0, 1, 1), Ctor.precision, Ctor.rounding);
        };
        P2.equals = P2.eq = function(y2) {
          return this.cmp(y2) === 0;
        };
        P2.floor = function() {
          return finalise(new this.constructor(this), this.e + 1, 3);
        };
        P2.greaterThan = P2.gt = function(y2) {
          return this.cmp(y2) > 0;
        };
        P2.greaterThanOrEqualTo = P2.gte = function(y2) {
          var k2 = this.cmp(y2);
          return k2 == 1 || k2 === 0;
        };
        P2.hyperbolicCosine = P2.cosh = function() {
          var k2, n, pr, rm, len, x2 = this, Ctor = x2.constructor, one = new Ctor(1);
          if (!x2.isFinite())
            return new Ctor(x2.s ? 1 / 0 : NaN);
          if (x2.isZero())
            return one;
          pr = Ctor.precision;
          rm = Ctor.rounding;
          Ctor.precision = pr + Math.max(x2.e, x2.sd()) + 4;
          Ctor.rounding = 1;
          len = x2.d.length;
          if (len < 32) {
            k2 = Math.ceil(len / 3);
            n = (1 / tinyPow(4, k2)).toString();
          } else {
            k2 = 16;
            n = "2.3283064365386962890625e-10";
          }
          x2 = taylorSeries(Ctor, 1, x2.times(n), new Ctor(1), true);
          var cosh2_x, i = k2, d8 = new Ctor(8);
          for (; i--; ) {
            cosh2_x = x2.times(x2);
            x2 = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
          }
          return finalise(x2, Ctor.precision = pr, Ctor.rounding = rm, true);
        };
        P2.hyperbolicSine = P2.sinh = function() {
          var k2, pr, rm, len, x2 = this, Ctor = x2.constructor;
          if (!x2.isFinite() || x2.isZero())
            return new Ctor(x2);
          pr = Ctor.precision;
          rm = Ctor.rounding;
          Ctor.precision = pr + Math.max(x2.e, x2.sd()) + 4;
          Ctor.rounding = 1;
          len = x2.d.length;
          if (len < 3) {
            x2 = taylorSeries(Ctor, 2, x2, x2, true);
          } else {
            k2 = 1.4 * Math.sqrt(len);
            k2 = k2 > 16 ? 16 : k2 | 0;
            x2 = x2.times(1 / tinyPow(5, k2));
            x2 = taylorSeries(Ctor, 2, x2, x2, true);
            var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
            for (; k2--; ) {
              sinh2_x = x2.times(x2);
              x2 = x2.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
            }
          }
          Ctor.precision = pr;
          Ctor.rounding = rm;
          return finalise(x2, pr, rm, true);
        };
        P2.hyperbolicTangent = P2.tanh = function() {
          var pr, rm, x2 = this, Ctor = x2.constructor;
          if (!x2.isFinite())
            return new Ctor(x2.s);
          if (x2.isZero())
            return new Ctor(x2);
          pr = Ctor.precision;
          rm = Ctor.rounding;
          Ctor.precision = pr + 7;
          Ctor.rounding = 1;
          return divide(x2.sinh(), x2.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
        };
        P2.inverseCosine = P2.acos = function() {
          var halfPi, x2 = this, Ctor = x2.constructor, k2 = x2.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;
          if (k2 !== -1) {
            return k2 === 0 ? x2.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);
          }
          if (x2.isZero())
            return getPi(Ctor, pr + 4, rm).times(0.5);
          Ctor.precision = pr + 6;
          Ctor.rounding = 1;
          x2 = x2.asin();
          halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
          Ctor.precision = pr;
          Ctor.rounding = rm;
          return halfPi.minus(x2);
        };
        P2.inverseHyperbolicCosine = P2.acosh = function() {
          var pr, rm, x2 = this, Ctor = x2.constructor;
          if (x2.lte(1))
            return new Ctor(x2.eq(1) ? 0 : NaN);
          if (!x2.isFinite())
            return new Ctor(x2);
          pr = Ctor.precision;
          rm = Ctor.rounding;
          Ctor.precision = pr + Math.max(Math.abs(x2.e), x2.sd()) + 4;
          Ctor.rounding = 1;
          external = false;
          x2 = x2.times(x2).minus(1).sqrt().plus(x2);
          external = true;
          Ctor.precision = pr;
          Ctor.rounding = rm;
          return x2.ln();
        };
        P2.inverseHyperbolicSine = P2.asinh = function() {
          var pr, rm, x2 = this, Ctor = x2.constructor;
          if (!x2.isFinite() || x2.isZero())
            return new Ctor(x2);
          pr = Ctor.precision;
          rm = Ctor.rounding;
          Ctor.precision = pr + 2 * Math.max(Math.abs(x2.e), x2.sd()) + 6;
          Ctor.rounding = 1;
          external = false;
          x2 = x2.times(x2).plus(1).sqrt().plus(x2);
          external = true;
          Ctor.precision = pr;
          Ctor.rounding = rm;
          return x2.ln();
        };
        P2.inverseHyperbolicTangent = P2.atanh = function() {
          var pr, rm, wpr, xsd, x2 = this, Ctor = x2.constructor;
          if (!x2.isFinite())
            return new Ctor(NaN);
          if (x2.e >= 0)
            return new Ctor(x2.abs().eq(1) ? x2.s / 0 : x2.isZero() ? x2 : NaN);
          pr = Ctor.precision;
          rm = Ctor.rounding;
          xsd = x2.sd();
          if (Math.max(xsd, pr) < 2 * -x2.e - 1)
            return finalise(new Ctor(x2), pr, rm, true);
          Ctor.precision = wpr = xsd - x2.e;
          x2 = divide(x2.plus(1), new Ctor(1).minus(x2), wpr + pr, 1);
          Ctor.precision = pr + 4;
          Ctor.rounding = 1;
          x2 = x2.ln();
          Ctor.precision = pr;
          Ctor.rounding = rm;
          return x2.times(0.5);
        };
        P2.inverseSine = P2.asin = function() {
          var halfPi, k2, pr, rm, x2 = this, Ctor = x2.constructor;
          if (x2.isZero())
            return new Ctor(x2);
          k2 = x2.abs().cmp(1);
          pr = Ctor.precision;
          rm = Ctor.rounding;
          if (k2 !== -1) {
            if (k2 === 0) {
              halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
              halfPi.s = x2.s;
              return halfPi;
            }
            return new Ctor(NaN);
          }
          Ctor.precision = pr + 6;
          Ctor.rounding = 1;
          x2 = x2.div(new Ctor(1).minus(x2.times(x2)).sqrt().plus(1)).atan();
          Ctor.precision = pr;
          Ctor.rounding = rm;
          return x2.times(2);
        };
        P2.inverseTangent = P2.atan = function() {
          var i, j2, k2, n, px, t2, r, wpr, x2, x3 = this, Ctor = x3.constructor, pr = Ctor.precision, rm = Ctor.rounding;
          if (!x3.isFinite()) {
            if (!x3.s)
              return new Ctor(NaN);
            if (pr + 4 <= PI_PRECISION) {
              r = getPi(Ctor, pr + 4, rm).times(0.5);
              r.s = x3.s;
              return r;
            }
          } else if (x3.isZero()) {
            return new Ctor(x3);
          } else if (x3.abs().eq(1) && pr + 4 <= PI_PRECISION) {
            r = getPi(Ctor, pr + 4, rm).times(0.25);
            r.s = x3.s;
            return r;
          }
          Ctor.precision = wpr = pr + 10;
          Ctor.rounding = 1;
          k2 = Math.min(28, wpr / LOG_BASE + 2 | 0);
          for (i = k2; i; --i)
            x3 = x3.div(x3.times(x3).plus(1).sqrt().plus(1));
          external = false;
          j2 = Math.ceil(wpr / LOG_BASE);
          n = 1;
          x2 = x3.times(x3);
          r = new Ctor(x3);
          px = x3;
          for (; i !== -1; ) {
            px = px.times(x2);
            t2 = r.minus(px.div(n += 2));
            px = px.times(x2);
            r = t2.plus(px.div(n += 2));
            if (r.d[j2] !== void 0)
              for (i = j2; r.d[i] === t2.d[i] && i--; )
                ;
          }
          if (k2)
            r = r.times(2 << k2 - 1);
          external = true;
          return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
        };
        P2.isFinite = function() {
          return !!this.d;
        };
        P2.isInteger = P2.isInt = function() {
          return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
        };
        P2.isNaN = function() {
          return !this.s;
        };
        P2.isNegative = P2.isNeg = function() {
          return this.s < 0;
        };
        P2.isPositive = P2.isPos = function() {
          return this.s > 0;
        };
        P2.isZero = function() {
          return !!this.d && this.d[0] === 0;
        };
        P2.lessThan = P2.lt = function(y2) {
          return this.cmp(y2) < 0;
        };
        P2.lessThanOrEqualTo = P2.lte = function(y2) {
          return this.cmp(y2) < 1;
        };
        P2.logarithm = P2.log = function(base) {
          var isBase10, d2, denominator, k2, inf, num, sd, r, arg = this, Ctor = arg.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;
          if (base == null) {
            base = new Ctor(10);
            isBase10 = true;
          } else {
            base = new Ctor(base);
            d2 = base.d;
            if (base.s < 0 || !d2 || !d2[0] || base.eq(1))
              return new Ctor(NaN);
            isBase10 = base.eq(10);
          }
          d2 = arg.d;
          if (arg.s < 0 || !d2 || !d2[0] || arg.eq(1)) {
            return new Ctor(d2 && !d2[0] ? -1 / 0 : arg.s != 1 ? NaN : d2 ? 0 : 1 / 0);
          }
          if (isBase10) {
            if (d2.length > 1) {
              inf = true;
            } else {
              for (k2 = d2[0]; k2 % 10 === 0; )
                k2 /= 10;
              inf = k2 !== 1;
            }
          }
          external = false;
          sd = pr + guard;
          num = naturalLogarithm(arg, sd);
          denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
          r = divide(num, denominator, sd, 1);
          if (checkRoundingDigits(r.d, k2 = pr, rm)) {
            do {
              sd += 10;
              num = naturalLogarithm(arg, sd);
              denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
              r = divide(num, denominator, sd, 1);
              if (!inf) {
                if (+digitsToString(r.d).slice(k2 + 1, k2 + 15) + 1 == 1e14) {
                  r = finalise(r, pr + 1, 0);
                }
                break;
              }
            } while (checkRoundingDigits(r.d, k2 += 10, rm));
          }
          external = true;
          return finalise(r, pr, rm);
        };
        P2.minus = P2.sub = function(y2) {
          var d2, e, i, j2, k2, len, pr, rm, xd, xe2, xLTy, yd, x2 = this, Ctor = x2.constructor;
          y2 = new Ctor(y2);
          if (!x2.d || !y2.d) {
            if (!x2.s || !y2.s)
              y2 = new Ctor(NaN);
            else if (x2.d)
              y2.s = -y2.s;
            else
              y2 = new Ctor(y2.d || x2.s !== y2.s ? x2 : NaN);
            return y2;
          }
          if (x2.s != y2.s) {
            y2.s = -y2.s;
            return x2.plus(y2);
          }
          xd = x2.d;
          yd = y2.d;
          pr = Ctor.precision;
          rm = Ctor.rounding;
          if (!xd[0] || !yd[0]) {
            if (yd[0])
              y2.s = -y2.s;
            else if (xd[0])
              y2 = new Ctor(x2);
            else
              return new Ctor(rm === 3 ? -0 : 0);
            return external ? finalise(y2, pr, rm) : y2;
          }
          e = mathfloor(y2.e / LOG_BASE);
          xe2 = mathfloor(x2.e / LOG_BASE);
          xd = xd.slice();
          k2 = xe2 - e;
          if (k2) {
            xLTy = k2 < 0;
            if (xLTy) {
              d2 = xd;
              k2 = -k2;
              len = yd.length;
            } else {
              d2 = yd;
              e = xe2;
              len = xd.length;
            }
            i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
            if (k2 > i) {
              k2 = i;
              d2.length = 1;
            }
            d2.reverse();
            for (i = k2; i--; )
              d2.push(0);
            d2.reverse();
          } else {
            i = xd.length;
            len = yd.length;
            xLTy = i < len;
            if (xLTy)
              len = i;
            for (i = 0; i < len; i++) {
              if (xd[i] != yd[i]) {
                xLTy = xd[i] < yd[i];
                break;
              }
            }
            k2 = 0;
          }
          if (xLTy) {
            d2 = xd;
            xd = yd;
            yd = d2;
            y2.s = -y2.s;
          }
          len = xd.length;
          for (i = yd.length - len; i > 0; --i)
            xd[len++] = 0;
          for (i = yd.length; i > k2; ) {
            if (xd[--i] < yd[i]) {
              for (j2 = i; j2 && xd[--j2] === 0; )
                xd[j2] = BASE - 1;
              --xd[j2];
              xd[i] += BASE;
            }
            xd[i] -= yd[i];
          }
          for (; xd[--len] === 0; )
            xd.pop();
          for (; xd[0] === 0; xd.shift())
            --e;
          if (!xd[0])
            return new Ctor(rm === 3 ? -0 : 0);
          y2.d = xd;
          y2.e = getBase10Exponent(xd, e);
          return external ? finalise(y2, pr, rm) : y2;
        };
        P2.modulo = P2.mod = function(y2) {
          var q2, x2 = this, Ctor = x2.constructor;
          y2 = new Ctor(y2);
          if (!x2.d || !y2.s || y2.d && !y2.d[0])
            return new Ctor(NaN);
          if (!y2.d || x2.d && !x2.d[0]) {
            return finalise(new Ctor(x2), Ctor.precision, Ctor.rounding);
          }
          external = false;
          if (Ctor.modulo == 9) {
            q2 = divide(x2, y2.abs(), 0, 3, 1);
            q2.s *= y2.s;
          } else {
            q2 = divide(x2, y2, 0, Ctor.modulo, 1);
          }
          q2 = q2.times(y2);
          external = true;
          return x2.minus(q2);
        };
        P2.naturalExponential = P2.exp = function() {
          return naturalExponential(this);
        };
        P2.naturalLogarithm = P2.ln = function() {
          return naturalLogarithm(this);
        };
        P2.negated = P2.neg = function() {
          var x2 = new this.constructor(this);
          x2.s = -x2.s;
          return finalise(x2);
        };
        P2.plus = P2.add = function(y2) {
          var carry, d2, e, i, k2, len, pr, rm, xd, yd, x2 = this, Ctor = x2.constructor;
          y2 = new Ctor(y2);
          if (!x2.d || !y2.d) {
            if (!x2.s || !y2.s)
              y2 = new Ctor(NaN);
            else if (!x2.d)
              y2 = new Ctor(y2.d || x2.s === y2.s ? x2 : NaN);
            return y2;
          }
          if (x2.s != y2.s) {
            y2.s = -y2.s;
            return x2.minus(y2);
          }
          xd = x2.d;
          yd = y2.d;
          pr = Ctor.precision;
          rm = Ctor.rounding;
          if (!xd[0] || !yd[0]) {
            if (!yd[0])
              y2 = new Ctor(x2);
            return external ? finalise(y2, pr, rm) : y2;
          }
          k2 = mathfloor(x2.e / LOG_BASE);
          e = mathfloor(y2.e / LOG_BASE);
          xd = xd.slice();
          i = k2 - e;
          if (i) {
            if (i < 0) {
              d2 = xd;
              i = -i;
              len = yd.length;
            } else {
              d2 = yd;
              e = k2;
              len = xd.length;
            }
            k2 = Math.ceil(pr / LOG_BASE);
            len = k2 > len ? k2 + 1 : len + 1;
            if (i > len) {
              i = len;
              d2.length = 1;
            }
            d2.reverse();
            for (; i--; )
              d2.push(0);
            d2.reverse();
          }
          len = xd.length;
          i = yd.length;
          if (len - i < 0) {
            i = len;
            d2 = yd;
            yd = xd;
            xd = d2;
          }
          for (carry = 0; i; ) {
            carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
            xd[i] %= BASE;
          }
          if (carry) {
            xd.unshift(carry);
            ++e;
          }
          for (len = xd.length; xd[--len] == 0; )
            xd.pop();
          y2.d = xd;
          y2.e = getBase10Exponent(xd, e);
          return external ? finalise(y2, pr, rm) : y2;
        };
        P2.precision = P2.sd = function(z2) {
          var k2, x2 = this;
          if (z2 !== void 0 && z2 !== !!z2 && z2 !== 1 && z2 !== 0)
            throw Error(invalidArgument + z2);
          if (x2.d) {
            k2 = getPrecision(x2.d);
            if (z2 && x2.e + 1 > k2)
              k2 = x2.e + 1;
          } else {
            k2 = NaN;
          }
          return k2;
        };
        P2.round = function() {
          var x2 = this, Ctor = x2.constructor;
          return finalise(new Ctor(x2), x2.e + 1, Ctor.rounding);
        };
        P2.sine = P2.sin = function() {
          var pr, rm, x2 = this, Ctor = x2.constructor;
          if (!x2.isFinite())
            return new Ctor(NaN);
          if (x2.isZero())
            return new Ctor(x2);
          pr = Ctor.precision;
          rm = Ctor.rounding;
          Ctor.precision = pr + Math.max(x2.e, x2.sd()) + LOG_BASE;
          Ctor.rounding = 1;
          x2 = sine(Ctor, toLessThanHalfPi(Ctor, x2));
          Ctor.precision = pr;
          Ctor.rounding = rm;
          return finalise(quadrant > 2 ? x2.neg() : x2, pr, rm, true);
        };
        P2.squareRoot = P2.sqrt = function() {
          var m, n, sd, r, rep, t2, x2 = this, d2 = x2.d, e = x2.e, s = x2.s, Ctor = x2.constructor;
          if (s !== 1 || !d2 || !d2[0]) {
            return new Ctor(!s || s < 0 && (!d2 || d2[0]) ? NaN : d2 ? x2 : 1 / 0);
          }
          external = false;
          s = Math.sqrt(+x2);
          if (s == 0 || s == 1 / 0) {
            n = digitsToString(d2);
            if ((n.length + e) % 2 == 0)
              n += "0";
            s = Math.sqrt(n);
            e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);
            if (s == 1 / 0) {
              n = "5e" + e;
            } else {
              n = s.toExponential();
              n = n.slice(0, n.indexOf("e") + 1) + e;
            }
            r = new Ctor(n);
          } else {
            r = new Ctor(s.toString());
          }
          sd = (e = Ctor.precision) + 3;
          for (; ; ) {
            t2 = r;
            r = t2.plus(divide(x2, t2, sd + 2, 1)).times(0.5);
            if (digitsToString(t2.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
              n = n.slice(sd - 3, sd + 1);
              if (n == "9999" || !rep && n == "4999") {
                if (!rep) {
                  finalise(t2, e + 1, 0);
                  if (t2.times(t2).eq(x2)) {
                    r = t2;
                    break;
                  }
                }
                sd += 4;
                rep = 1;
              } else {
                if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                  finalise(r, e + 1, 1);
                  m = !r.times(r).eq(x2);
                }
                break;
              }
            }
          }
          external = true;
          return finalise(r, e, Ctor.rounding, m);
        };
        P2.tangent = P2.tan = function() {
          var pr, rm, x2 = this, Ctor = x2.constructor;
          if (!x2.isFinite())
            return new Ctor(NaN);
          if (x2.isZero())
            return new Ctor(x2);
          pr = Ctor.precision;
          rm = Ctor.rounding;
          Ctor.precision = pr + 10;
          Ctor.rounding = 1;
          x2 = x2.sin();
          x2.s = 1;
          x2 = divide(x2, new Ctor(1).minus(x2.times(x2)).sqrt(), pr + 10, 0);
          Ctor.precision = pr;
          Ctor.rounding = rm;
          return finalise(quadrant == 2 || quadrant == 4 ? x2.neg() : x2, pr, rm, true);
        };
        P2.times = P2.mul = function(y2) {
          var carry, e, i, k2, r, rL, t2, xdL, ydL, x2 = this, Ctor = x2.constructor, xd = x2.d, yd = (y2 = new Ctor(y2)).d;
          y2.s *= x2.s;
          if (!xd || !xd[0] || !yd || !yd[0]) {
            return new Ctor(!y2.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y2.s / 0 : y2.s * 0);
          }
          e = mathfloor(x2.e / LOG_BASE) + mathfloor(y2.e / LOG_BASE);
          xdL = xd.length;
          ydL = yd.length;
          if (xdL < ydL) {
            r = xd;
            xd = yd;
            yd = r;
            rL = xdL;
            xdL = ydL;
            ydL = rL;
          }
          r = [];
          rL = xdL + ydL;
          for (i = rL; i--; )
            r.push(0);
          for (i = ydL; --i >= 0; ) {
            carry = 0;
            for (k2 = xdL + i; k2 > i; ) {
              t2 = r[k2] + yd[i] * xd[k2 - i - 1] + carry;
              r[k2--] = t2 % BASE | 0;
              carry = t2 / BASE | 0;
            }
            r[k2] = (r[k2] + carry) % BASE | 0;
          }
          for (; !r[--rL]; )
            r.pop();
          if (carry)
            ++e;
          else
            r.shift();
          y2.d = r;
          y2.e = getBase10Exponent(r, e);
          return external ? finalise(y2, Ctor.precision, Ctor.rounding) : y2;
        };
        P2.toBinary = function(sd, rm) {
          return toStringBinary(this, 2, sd, rm);
        };
        P2.toDecimalPlaces = P2.toDP = function(dp, rm) {
          var x2 = this, Ctor = x2.constructor;
          x2 = new Ctor(x2);
          if (dp === void 0)
            return x2;
          checkInt32(dp, 0, MAX_DIGITS);
          if (rm === void 0)
            rm = Ctor.rounding;
          else
            checkInt32(rm, 0, 8);
          return finalise(x2, dp + x2.e + 1, rm);
        };
        P2.toExponential = function(dp, rm) {
          var str3, x2 = this, Ctor = x2.constructor;
          if (dp === void 0) {
            str3 = finiteToString(x2, true);
          } else {
            checkInt32(dp, 0, MAX_DIGITS);
            if (rm === void 0)
              rm = Ctor.rounding;
            else
              checkInt32(rm, 0, 8);
            x2 = finalise(new Ctor(x2), dp + 1, rm);
            str3 = finiteToString(x2, true, dp + 1);
          }
          return x2.isNeg() && !x2.isZero() ? "-" + str3 : str3;
        };
        P2.toFixed = function(dp, rm) {
          var str3, y2, x2 = this, Ctor = x2.constructor;
          if (dp === void 0) {
            str3 = finiteToString(x2);
          } else {
            checkInt32(dp, 0, MAX_DIGITS);
            if (rm === void 0)
              rm = Ctor.rounding;
            else
              checkInt32(rm, 0, 8);
            y2 = finalise(new Ctor(x2), dp + x2.e + 1, rm);
            str3 = finiteToString(y2, false, dp + y2.e + 1);
          }
          return x2.isNeg() && !x2.isZero() ? "-" + str3 : str3;
        };
        P2.toFraction = function(maxD) {
          var d2, d0, d1, d22, e, k2, n, n0, n1, pr, q2, r, x2 = this, xd = x2.d, Ctor = x2.constructor;
          if (!xd)
            return new Ctor(x2);
          n1 = d0 = new Ctor(1);
          d1 = n0 = new Ctor(0);
          d2 = new Ctor(d1);
          e = d2.e = getPrecision(xd) - x2.e - 1;
          k2 = e % LOG_BASE;
          d2.d[0] = mathpow(10, k2 < 0 ? LOG_BASE + k2 : k2);
          if (maxD == null) {
            maxD = e > 0 ? d2 : n1;
          } else {
            n = new Ctor(maxD);
            if (!n.isInt() || n.lt(n1))
              throw Error(invalidArgument + n);
            maxD = n.gt(d2) ? e > 0 ? d2 : n1 : n;
          }
          external = false;
          n = new Ctor(digitsToString(xd));
          pr = Ctor.precision;
          Ctor.precision = e = xd.length * LOG_BASE * 2;
          for (; ; ) {
            q2 = divide(n, d2, 0, 1, 1);
            d22 = d0.plus(q2.times(d1));
            if (d22.cmp(maxD) == 1)
              break;
            d0 = d1;
            d1 = d22;
            d22 = n1;
            n1 = n0.plus(q2.times(d22));
            n0 = d22;
            d22 = d2;
            d2 = n.minus(q2.times(d22));
            n = d22;
          }
          d22 = divide(maxD.minus(d0), d1, 0, 1, 1);
          n0 = n0.plus(d22.times(n1));
          d0 = d0.plus(d22.times(d1));
          n0.s = n1.s = x2.s;
          r = divide(n1, d1, e, 1).minus(x2).abs().cmp(divide(n0, d0, e, 1).minus(x2).abs()) < 1 ? [n1, d1] : [n0, d0];
          Ctor.precision = pr;
          external = true;
          return r;
        };
        P2.toHexadecimal = P2.toHex = function(sd, rm) {
          return toStringBinary(this, 16, sd, rm);
        };
        P2.toNearest = function(y2, rm) {
          var x2 = this, Ctor = x2.constructor;
          x2 = new Ctor(x2);
          if (y2 == null) {
            if (!x2.d)
              return x2;
            y2 = new Ctor(1);
            rm = Ctor.rounding;
          } else {
            y2 = new Ctor(y2);
            if (rm === void 0) {
              rm = Ctor.rounding;
            } else {
              checkInt32(rm, 0, 8);
            }
            if (!x2.d)
              return y2.s ? x2 : y2;
            if (!y2.d) {
              if (y2.s)
                y2.s = x2.s;
              return y2;
            }
          }
          if (y2.d[0]) {
            external = false;
            x2 = divide(x2, y2, 0, rm, 1).times(y2);
            external = true;
            finalise(x2);
          } else {
            y2.s = x2.s;
            x2 = y2;
          }
          return x2;
        };
        P2.toNumber = function() {
          return +this;
        };
        P2.toOctal = function(sd, rm) {
          return toStringBinary(this, 8, sd, rm);
        };
        P2.toPower = P2.pow = function(y2) {
          var e, k2, pr, r, rm, s, x2 = this, Ctor = x2.constructor, yn2 = +(y2 = new Ctor(y2));
          if (!x2.d || !y2.d || !x2.d[0] || !y2.d[0])
            return new Ctor(mathpow(+x2, yn2));
          x2 = new Ctor(x2);
          if (x2.eq(1))
            return x2;
          pr = Ctor.precision;
          rm = Ctor.rounding;
          if (y2.eq(1))
            return finalise(x2, pr, rm);
          e = mathfloor(y2.e / LOG_BASE);
          if (e >= y2.d.length - 1 && (k2 = yn2 < 0 ? -yn2 : yn2) <= MAX_SAFE_INTEGER) {
            r = intPow(Ctor, x2, k2, pr);
            return y2.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
          }
          s = x2.s;
          if (s < 0) {
            if (e < y2.d.length - 1)
              return new Ctor(NaN);
            if ((y2.d[e] & 1) == 0)
              s = 1;
            if (x2.e == 0 && x2.d[0] == 1 && x2.d.length == 1) {
              x2.s = s;
              return x2;
            }
          }
          k2 = mathpow(+x2, yn2);
          e = k2 == 0 || !isFinite(k2) ? mathfloor(yn2 * (Math.log("0." + digitsToString(x2.d)) / Math.LN10 + x2.e + 1)) : new Ctor(k2 + "").e;
          if (e > Ctor.maxE + 1 || e < Ctor.minE - 1)
            return new Ctor(e > 0 ? s / 0 : 0);
          external = false;
          Ctor.rounding = x2.s = 1;
          k2 = Math.min(12, (e + "").length);
          r = naturalExponential(y2.times(naturalLogarithm(x2, pr + k2)), pr);
          if (r.d) {
            r = finalise(r, pr + 5, 1);
            if (checkRoundingDigits(r.d, pr, rm)) {
              e = pr + 10;
              r = finalise(naturalExponential(y2.times(naturalLogarithm(x2, e + k2)), e), e + 5, 1);
              if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
                r = finalise(r, pr + 1, 0);
              }
            }
          }
          r.s = s;
          external = true;
          Ctor.rounding = rm;
          return finalise(r, pr, rm);
        };
        P2.toPrecision = function(sd, rm) {
          var str3, x2 = this, Ctor = x2.constructor;
          if (sd === void 0) {
            str3 = finiteToString(x2, x2.e <= Ctor.toExpNeg || x2.e >= Ctor.toExpPos);
          } else {
            checkInt32(sd, 1, MAX_DIGITS);
            if (rm === void 0)
              rm = Ctor.rounding;
            else
              checkInt32(rm, 0, 8);
            x2 = finalise(new Ctor(x2), sd, rm);
            str3 = finiteToString(x2, sd <= x2.e || x2.e <= Ctor.toExpNeg, sd);
          }
          return x2.isNeg() && !x2.isZero() ? "-" + str3 : str3;
        };
        P2.toSignificantDigits = P2.toSD = function(sd, rm) {
          var x2 = this, Ctor = x2.constructor;
          if (sd === void 0) {
            sd = Ctor.precision;
            rm = Ctor.rounding;
          } else {
            checkInt32(sd, 1, MAX_DIGITS);
            if (rm === void 0)
              rm = Ctor.rounding;
            else
              checkInt32(rm, 0, 8);
          }
          return finalise(new Ctor(x2), sd, rm);
        };
        P2.toString = function() {
          var x2 = this, Ctor = x2.constructor, str3 = finiteToString(x2, x2.e <= Ctor.toExpNeg || x2.e >= Ctor.toExpPos);
          return x2.isNeg() && !x2.isZero() ? "-" + str3 : str3;
        };
        P2.truncated = P2.trunc = function() {
          return finalise(new this.constructor(this), this.e + 1, 1);
        };
        P2.valueOf = P2.toJSON = function() {
          var x2 = this, Ctor = x2.constructor, str3 = finiteToString(x2, x2.e <= Ctor.toExpNeg || x2.e >= Ctor.toExpPos);
          return x2.isNeg() ? "-" + str3 : str3;
        };
        function digitsToString(d2) {
          var i, k2, ws, indexOfLastWord = d2.length - 1, str3 = "", w2 = d2[0];
          if (indexOfLastWord > 0) {
            str3 += w2;
            for (i = 1; i < indexOfLastWord; i++) {
              ws = d2[i] + "";
              k2 = LOG_BASE - ws.length;
              if (k2)
                str3 += getZeroString(k2);
              str3 += ws;
            }
            w2 = d2[i];
            ws = w2 + "";
            k2 = LOG_BASE - ws.length;
            if (k2)
              str3 += getZeroString(k2);
          } else if (w2 === 0) {
            return "0";
          }
          for (; w2 % 10 === 0; )
            w2 /= 10;
          return str3 + w2;
        }
        function checkInt32(i, min2, max2) {
          if (i !== ~~i || i < min2 || i > max2) {
            throw Error(invalidArgument + i);
          }
        }
        function checkRoundingDigits(d2, i, rm, repeating) {
          var di, k2, r, rd;
          for (k2 = d2[0]; k2 >= 10; k2 /= 10)
            --i;
          if (--i < 0) {
            i += LOG_BASE;
            di = 0;
          } else {
            di = Math.ceil((i + 1) / LOG_BASE);
            i %= LOG_BASE;
          }
          k2 = mathpow(10, LOG_BASE - i);
          rd = d2[di] % k2 | 0;
          if (repeating == null) {
            if (i < 3) {
              if (i == 0)
                rd = rd / 100 | 0;
              else if (i == 1)
                rd = rd / 10 | 0;
              r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 5e4 || rd == 0;
            } else {
              r = (rm < 4 && rd + 1 == k2 || rm > 3 && rd + 1 == k2 / 2) && (d2[di + 1] / k2 / 100 | 0) == mathpow(10, i - 2) - 1 || (rd == k2 / 2 || rd == 0) && (d2[di + 1] / k2 / 100 | 0) == 0;
            }
          } else {
            if (i < 4) {
              if (i == 0)
                rd = rd / 1e3 | 0;
              else if (i == 1)
                rd = rd / 100 | 0;
              else if (i == 2)
                rd = rd / 10 | 0;
              r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
            } else {
              r = ((repeating || rm < 4) && rd + 1 == k2 || !repeating && rm > 3 && rd + 1 == k2 / 2) && (d2[di + 1] / k2 / 1e3 | 0) == mathpow(10, i - 3) - 1;
            }
          }
          return r;
        }
        function convertBase(str3, baseIn, baseOut) {
          var j2, arr = [0], arrL, i = 0, strL = str3.length;
          for (; i < strL; ) {
            for (arrL = arr.length; arrL--; )
              arr[arrL] *= baseIn;
            arr[0] += NUMERALS.indexOf(str3.charAt(i++));
            for (j2 = 0; j2 < arr.length; j2++) {
              if (arr[j2] > baseOut - 1) {
                if (arr[j2 + 1] === void 0)
                  arr[j2 + 1] = 0;
                arr[j2 + 1] += arr[j2] / baseOut | 0;
                arr[j2] %= baseOut;
              }
            }
          }
          return arr.reverse();
        }
        function cosine(Ctor, x2) {
          var k2, len, y2;
          if (x2.isZero())
            return x2;
          len = x2.d.length;
          if (len < 32) {
            k2 = Math.ceil(len / 3);
            y2 = (1 / tinyPow(4, k2)).toString();
          } else {
            k2 = 16;
            y2 = "2.3283064365386962890625e-10";
          }
          Ctor.precision += k2;
          x2 = taylorSeries(Ctor, 1, x2.times(y2), new Ctor(1));
          for (var i = k2; i--; ) {
            var cos2x = x2.times(x2);
            x2 = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
          }
          Ctor.precision -= k2;
          return x2;
        }
        var divide = function() {
          function multiplyInteger(x2, k2, base) {
            var temp, carry = 0, i = x2.length;
            for (x2 = x2.slice(); i--; ) {
              temp = x2[i] * k2 + carry;
              x2[i] = temp % base | 0;
              carry = temp / base | 0;
            }
            if (carry)
              x2.unshift(carry);
            return x2;
          }
          function compare4(a, b2, aL, bL) {
            var i, r;
            if (aL != bL) {
              r = aL > bL ? 1 : -1;
            } else {
              for (i = r = 0; i < aL; i++) {
                if (a[i] != b2[i]) {
                  r = a[i] > b2[i] ? 1 : -1;
                  break;
                }
              }
            }
            return r;
          }
          function subtract(a, b2, aL, base) {
            var i = 0;
            for (; aL--; ) {
              a[aL] -= i;
              i = a[aL] < b2[aL] ? 1 : 0;
              a[aL] = i * base + a[aL] - b2[aL];
            }
            for (; !a[0] && a.length > 1; )
              a.shift();
          }
          return function(x2, y2, pr, rm, dp, base) {
            var cmp, e, i, k2, logBase, more, prod, prodL, q2, qd, rem, remL, rem0, sd, t2, xi, xL, yd0, yL, yz, Ctor = x2.constructor, sign3 = x2.s == y2.s ? 1 : -1, xd = x2.d, yd = y2.d;
            if (!xd || !xd[0] || !yd || !yd[0]) {
              return new Ctor(
                !x2.s || !y2.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : xd && xd[0] == 0 || !yd ? sign3 * 0 : sign3 / 0
              );
            }
            if (base) {
              logBase = 1;
              e = x2.e - y2.e;
            } else {
              base = BASE;
              logBase = LOG_BASE;
              e = mathfloor(x2.e / logBase) - mathfloor(y2.e / logBase);
            }
            yL = yd.length;
            xL = xd.length;
            q2 = new Ctor(sign3);
            qd = q2.d = [];
            for (i = 0; yd[i] == (xd[i] || 0); i++)
              ;
            if (yd[i] > (xd[i] || 0))
              e--;
            if (pr == null) {
              sd = pr = Ctor.precision;
              rm = Ctor.rounding;
            } else if (dp) {
              sd = pr + (x2.e - y2.e) + 1;
            } else {
              sd = pr;
            }
            if (sd < 0) {
              qd.push(1);
              more = true;
            } else {
              sd = sd / logBase + 2 | 0;
              i = 0;
              if (yL == 1) {
                k2 = 0;
                yd = yd[0];
                sd++;
                for (; (i < xL || k2) && sd--; i++) {
                  t2 = k2 * base + (xd[i] || 0);
                  qd[i] = t2 / yd | 0;
                  k2 = t2 % yd | 0;
                }
                more = k2 || i < xL;
              } else {
                k2 = base / (yd[0] + 1) | 0;
                if (k2 > 1) {
                  yd = multiplyInteger(yd, k2, base);
                  xd = multiplyInteger(xd, k2, base);
                  yL = yd.length;
                  xL = xd.length;
                }
                xi = yL;
                rem = xd.slice(0, yL);
                remL = rem.length;
                for (; remL < yL; )
                  rem[remL++] = 0;
                yz = yd.slice();
                yz.unshift(0);
                yd0 = yd[0];
                if (yd[1] >= base / 2)
                  ++yd0;
                do {
                  k2 = 0;
                  cmp = compare4(yd, rem, yL, remL);
                  if (cmp < 0) {
                    rem0 = rem[0];
                    if (yL != remL)
                      rem0 = rem0 * base + (rem[1] || 0);
                    k2 = rem0 / yd0 | 0;
                    if (k2 > 1) {
                      if (k2 >= base)
                        k2 = base - 1;
                      prod = multiplyInteger(yd, k2, base);
                      prodL = prod.length;
                      remL = rem.length;
                      cmp = compare4(prod, rem, prodL, remL);
                      if (cmp == 1) {
                        k2--;
                        subtract(prod, yL < prodL ? yz : yd, prodL, base);
                      }
                    } else {
                      if (k2 == 0)
                        cmp = k2 = 1;
                      prod = yd.slice();
                    }
                    prodL = prod.length;
                    if (prodL < remL)
                      prod.unshift(0);
                    subtract(rem, prod, remL, base);
                    if (cmp == -1) {
                      remL = rem.length;
                      cmp = compare4(yd, rem, yL, remL);
                      if (cmp < 1) {
                        k2++;
                        subtract(rem, yL < remL ? yz : yd, remL, base);
                      }
                    }
                    remL = rem.length;
                  } else if (cmp === 0) {
                    k2++;
                    rem = [0];
                  }
                  qd[i++] = k2;
                  if (cmp && rem[0]) {
                    rem[remL++] = xd[xi] || 0;
                  } else {
                    rem = [xd[xi]];
                    remL = 1;
                  }
                } while ((xi++ < xL || rem[0] !== void 0) && sd--);
                more = rem[0] !== void 0;
              }
              if (!qd[0])
                qd.shift();
            }
            if (logBase == 1) {
              q2.e = e;
              inexact = more;
            } else {
              for (i = 1, k2 = qd[0]; k2 >= 10; k2 /= 10)
                i++;
              q2.e = i + e * logBase - 1;
              finalise(q2, dp ? pr + q2.e + 1 : pr, rm, more);
            }
            return q2;
          };
        }();
        function finalise(x2, sd, rm, isTruncated) {
          var digits, i, j2, k2, rd, roundUp, w2, xd, xdi, Ctor = x2.constructor;
          out:
            if (sd != null) {
              xd = x2.d;
              if (!xd)
                return x2;
              for (digits = 1, k2 = xd[0]; k2 >= 10; k2 /= 10)
                digits++;
              i = sd - digits;
              if (i < 0) {
                i += LOG_BASE;
                j2 = sd;
                w2 = xd[xdi = 0];
                rd = w2 / mathpow(10, digits - j2 - 1) % 10 | 0;
              } else {
                xdi = Math.ceil((i + 1) / LOG_BASE);
                k2 = xd.length;
                if (xdi >= k2) {
                  if (isTruncated) {
                    for (; k2++ <= xdi; )
                      xd.push(0);
                    w2 = rd = 0;
                    digits = 1;
                    i %= LOG_BASE;
                    j2 = i - LOG_BASE + 1;
                  } else {
                    break out;
                  }
                } else {
                  w2 = k2 = xd[xdi];
                  for (digits = 1; k2 >= 10; k2 /= 10)
                    digits++;
                  i %= LOG_BASE;
                  j2 = i - LOG_BASE + digits;
                  rd = j2 < 0 ? 0 : w2 / mathpow(10, digits - j2 - 1) % 10 | 0;
                }
              }
              isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j2 < 0 ? w2 : w2 % mathpow(10, digits - j2 - 1));
              roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x2.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && (i > 0 ? j2 > 0 ? w2 / mathpow(10, digits - j2) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x2.s < 0 ? 8 : 7));
              if (sd < 1 || !xd[0]) {
                xd.length = 0;
                if (roundUp) {
                  sd -= x2.e + 1;
                  xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
                  x2.e = -sd || 0;
                } else {
                  xd[0] = x2.e = 0;
                }
                return x2;
              }
              if (i == 0) {
                xd.length = xdi;
                k2 = 1;
                xdi--;
              } else {
                xd.length = xdi + 1;
                k2 = mathpow(10, LOG_BASE - i);
                xd[xdi] = j2 > 0 ? (w2 / mathpow(10, digits - j2) % mathpow(10, j2) | 0) * k2 : 0;
              }
              if (roundUp) {
                for (; ; ) {
                  if (xdi == 0) {
                    for (i = 1, j2 = xd[0]; j2 >= 10; j2 /= 10)
                      i++;
                    j2 = xd[0] += k2;
                    for (k2 = 1; j2 >= 10; j2 /= 10)
                      k2++;
                    if (i != k2) {
                      x2.e++;
                      if (xd[0] == BASE)
                        xd[0] = 1;
                    }
                    break;
                  } else {
                    xd[xdi] += k2;
                    if (xd[xdi] != BASE)
                      break;
                    xd[xdi--] = 0;
                    k2 = 1;
                  }
                }
              }
              for (i = xd.length; xd[--i] === 0; )
                xd.pop();
            }
          if (external) {
            if (x2.e > Ctor.maxE) {
              x2.d = null;
              x2.e = NaN;
            } else if (x2.e < Ctor.minE) {
              x2.e = 0;
              x2.d = [0];
            }
          }
          return x2;
        }
        function finiteToString(x2, isExp, sd) {
          if (!x2.isFinite())
            return nonFiniteToString(x2);
          var k2, e = x2.e, str3 = digitsToString(x2.d), len = str3.length;
          if (isExp) {
            if (sd && (k2 = sd - len) > 0) {
              str3 = str3.charAt(0) + "." + str3.slice(1) + getZeroString(k2);
            } else if (len > 1) {
              str3 = str3.charAt(0) + "." + str3.slice(1);
            }
            str3 = str3 + (x2.e < 0 ? "e" : "e+") + x2.e;
          } else if (e < 0) {
            str3 = "0." + getZeroString(-e - 1) + str3;
            if (sd && (k2 = sd - len) > 0)
              str3 += getZeroString(k2);
          } else if (e >= len) {
            str3 += getZeroString(e + 1 - len);
            if (sd && (k2 = sd - e - 1) > 0)
              str3 = str3 + "." + getZeroString(k2);
          } else {
            if ((k2 = e + 1) < len)
              str3 = str3.slice(0, k2) + "." + str3.slice(k2);
            if (sd && (k2 = sd - len) > 0) {
              if (e + 1 === len)
                str3 += ".";
              str3 += getZeroString(k2);
            }
          }
          return str3;
        }
        function getBase10Exponent(digits, e) {
          var w2 = digits[0];
          for (e *= LOG_BASE; w2 >= 10; w2 /= 10)
            e++;
          return e;
        }
        function getLn10(Ctor, sd, pr) {
          if (sd > LN10_PRECISION) {
            external = true;
            if (pr)
              Ctor.precision = pr;
            throw Error(precisionLimitExceeded);
          }
          return finalise(new Ctor(LN10), sd, 1, true);
        }
        function getPi(Ctor, sd, rm) {
          if (sd > PI_PRECISION)
            throw Error(precisionLimitExceeded);
          return finalise(new Ctor(PI), sd, rm, true);
        }
        function getPrecision(digits) {
          var w2 = digits.length - 1, len = w2 * LOG_BASE + 1;
          w2 = digits[w2];
          if (w2) {
            for (; w2 % 10 == 0; w2 /= 10)
              len--;
            for (w2 = digits[0]; w2 >= 10; w2 /= 10)
              len++;
          }
          return len;
        }
        function getZeroString(k2) {
          var zs = "";
          for (; k2--; )
            zs += "0";
          return zs;
        }
        function intPow(Ctor, x2, n, pr) {
          var isTruncated, r = new Ctor(1), k2 = Math.ceil(pr / LOG_BASE + 4);
          external = false;
          for (; ; ) {
            if (n % 2) {
              r = r.times(x2);
              if (truncate2(r.d, k2))
                isTruncated = true;
            }
            n = mathfloor(n / 2);
            if (n === 0) {
              n = r.d.length - 1;
              if (isTruncated && r.d[n] === 0)
                ++r.d[n];
              break;
            }
            x2 = x2.times(x2);
            truncate2(x2.d, k2);
          }
          external = true;
          return r;
        }
        function isOdd(n) {
          return n.d[n.d.length - 1] & 1;
        }
        function maxOrMin(Ctor, args, ltgt) {
          var y2, x2 = new Ctor(args[0]), i = 0;
          for (; ++i < args.length; ) {
            y2 = new Ctor(args[i]);
            if (!y2.s) {
              x2 = y2;
              break;
            } else if (x2[ltgt](y2)) {
              x2 = y2;
            }
          }
          return x2;
        }
        function naturalExponential(x2, sd) {
          var denominator, guard, j2, pow4, sum2, t2, wpr, rep = 0, i = 0, k2 = 0, Ctor = x2.constructor, rm = Ctor.rounding, pr = Ctor.precision;
          if (!x2.d || !x2.d[0] || x2.e > 17) {
            return new Ctor(x2.d ? !x2.d[0] ? 1 : x2.s < 0 ? 0 : 1 / 0 : x2.s ? x2.s < 0 ? 0 : x2 : 0 / 0);
          }
          if (sd == null) {
            external = false;
            wpr = pr;
          } else {
            wpr = sd;
          }
          t2 = new Ctor(0.03125);
          while (x2.e > -2) {
            x2 = x2.times(t2);
            k2 += 5;
          }
          guard = Math.log(mathpow(2, k2)) / Math.LN10 * 2 + 5 | 0;
          wpr += guard;
          denominator = pow4 = sum2 = new Ctor(1);
          Ctor.precision = wpr;
          for (; ; ) {
            pow4 = finalise(pow4.times(x2), wpr, 1);
            denominator = denominator.times(++i);
            t2 = sum2.plus(divide(pow4, denominator, wpr, 1));
            if (digitsToString(t2.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
              j2 = k2;
              while (j2--)
                sum2 = finalise(sum2.times(sum2), wpr, 1);
              if (sd == null) {
                if (rep < 3 && checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
                  Ctor.precision = wpr += 10;
                  denominator = pow4 = t2 = new Ctor(1);
                  i = 0;
                  rep++;
                } else {
                  return finalise(sum2, Ctor.precision = pr, rm, external = true);
                }
              } else {
                Ctor.precision = pr;
                return sum2;
              }
            }
            sum2 = t2;
          }
        }
        function naturalLogarithm(y2, sd) {
          var c2, c0, denominator, e, numerator, rep, sum2, t2, wpr, x1, x2, n = 1, guard = 10, x3 = y2, xd = x3.d, Ctor = x3.constructor, rm = Ctor.rounding, pr = Ctor.precision;
          if (x3.s < 0 || !xd || !xd[0] || !x3.e && xd[0] == 1 && xd.length == 1) {
            return new Ctor(xd && !xd[0] ? -1 / 0 : x3.s != 1 ? NaN : xd ? 0 : x3);
          }
          if (sd == null) {
            external = false;
            wpr = pr;
          } else {
            wpr = sd;
          }
          Ctor.precision = wpr += guard;
          c2 = digitsToString(xd);
          c0 = c2.charAt(0);
          if (Math.abs(e = x3.e) < 15e14) {
            while (c0 < 7 && c0 != 1 || c0 == 1 && c2.charAt(1) > 3) {
              x3 = x3.times(y2);
              c2 = digitsToString(x3.d);
              c0 = c2.charAt(0);
              n++;
            }
            e = x3.e;
            if (c0 > 1) {
              x3 = new Ctor("0." + c2);
              e++;
            } else {
              x3 = new Ctor(c0 + "." + c2.slice(1));
            }
          } else {
            t2 = getLn10(Ctor, wpr + 2, pr).times(e + "");
            x3 = naturalLogarithm(new Ctor(c0 + "." + c2.slice(1)), wpr - guard).plus(t2);
            Ctor.precision = pr;
            return sd == null ? finalise(x3, pr, rm, external = true) : x3;
          }
          x1 = x3;
          sum2 = numerator = x3 = divide(x3.minus(1), x3.plus(1), wpr, 1);
          x2 = finalise(x3.times(x3), wpr, 1);
          denominator = 3;
          for (; ; ) {
            numerator = finalise(numerator.times(x2), wpr, 1);
            t2 = sum2.plus(divide(numerator, new Ctor(denominator), wpr, 1));
            if (digitsToString(t2.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
              sum2 = sum2.times(2);
              if (e !== 0)
                sum2 = sum2.plus(getLn10(Ctor, wpr + 2, pr).times(e + ""));
              sum2 = divide(sum2, new Ctor(n), wpr, 1);
              if (sd == null) {
                if (checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
                  Ctor.precision = wpr += guard;
                  t2 = numerator = x3 = divide(x1.minus(1), x1.plus(1), wpr, 1);
                  x2 = finalise(x3.times(x3), wpr, 1);
                  denominator = rep = 1;
                } else {
                  return finalise(sum2, Ctor.precision = pr, rm, external = true);
                }
              } else {
                Ctor.precision = pr;
                return sum2;
              }
            }
            sum2 = t2;
            denominator += 2;
          }
        }
        function nonFiniteToString(x2) {
          return String(x2.s * x2.s / 0);
        }
        function parseDecimal(x2, str3) {
          var e, i, len;
          if ((e = str3.indexOf(".")) > -1)
            str3 = str3.replace(".", "");
          if ((i = str3.search(/e/i)) > 0) {
            if (e < 0)
              e = i;
            e += +str3.slice(i + 1);
            str3 = str3.substring(0, i);
          } else if (e < 0) {
            e = str3.length;
          }
          for (i = 0; str3.charCodeAt(i) === 48; i++)
            ;
          for (len = str3.length; str3.charCodeAt(len - 1) === 48; --len)
            ;
          str3 = str3.slice(i, len);
          if (str3) {
            len -= i;
            x2.e = e = e - i - 1;
            x2.d = [];
            i = (e + 1) % LOG_BASE;
            if (e < 0)
              i += LOG_BASE;
            if (i < len) {
              if (i)
                x2.d.push(+str3.slice(0, i));
              for (len -= LOG_BASE; i < len; )
                x2.d.push(+str3.slice(i, i += LOG_BASE));
              str3 = str3.slice(i);
              i = LOG_BASE - str3.length;
            } else {
              i -= len;
            }
            for (; i--; )
              str3 += "0";
            x2.d.push(+str3);
            if (external) {
              if (x2.e > x2.constructor.maxE) {
                x2.d = null;
                x2.e = NaN;
              } else if (x2.e < x2.constructor.minE) {
                x2.e = 0;
                x2.d = [0];
              }
            }
          } else {
            x2.e = 0;
            x2.d = [0];
          }
          return x2;
        }
        function parseOther(x2, str3) {
          var base, Ctor, divisor, i, isFloat, len, p2, xd, xe2;
          if (str3.indexOf("_") > -1) {
            str3 = str3.replace(/(\d)_(?=\d)/g, "$1");
            if (isDecimal.test(str3))
              return parseDecimal(x2, str3);
          } else if (str3 === "Infinity" || str3 === "NaN") {
            if (!+str3)
              x2.s = NaN;
            x2.e = NaN;
            x2.d = null;
            return x2;
          }
          if (isHex.test(str3)) {
            base = 16;
            str3 = str3.toLowerCase();
          } else if (isBinary.test(str3)) {
            base = 2;
          } else if (isOctal.test(str3)) {
            base = 8;
          } else {
            throw Error(invalidArgument + str3);
          }
          i = str3.search(/p/i);
          if (i > 0) {
            p2 = +str3.slice(i + 1);
            str3 = str3.substring(2, i);
          } else {
            str3 = str3.slice(2);
          }
          i = str3.indexOf(".");
          isFloat = i >= 0;
          Ctor = x2.constructor;
          if (isFloat) {
            str3 = str3.replace(".", "");
            len = str3.length;
            i = len - i;
            divisor = intPow(Ctor, new Ctor(base), i, i * 2);
          }
          xd = convertBase(str3, base, BASE);
          xe2 = xd.length - 1;
          for (i = xe2; xd[i] === 0; --i)
            xd.pop();
          if (i < 0)
            return new Ctor(x2.s * 0);
          x2.e = getBase10Exponent(xd, xe2);
          x2.d = xd;
          external = false;
          if (isFloat)
            x2 = divide(x2, divisor, len * 4);
          if (p2)
            x2 = x2.times(Math.abs(p2) < 54 ? mathpow(2, p2) : Decimal.pow(2, p2));
          external = true;
          return x2;
        }
        function sine(Ctor, x2) {
          var k2, len = x2.d.length;
          if (len < 3) {
            return x2.isZero() ? x2 : taylorSeries(Ctor, 2, x2, x2);
          }
          k2 = 1.4 * Math.sqrt(len);
          k2 = k2 > 16 ? 16 : k2 | 0;
          x2 = x2.times(1 / tinyPow(5, k2));
          x2 = taylorSeries(Ctor, 2, x2, x2);
          var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
          for (; k2--; ) {
            sin2_x = x2.times(x2);
            x2 = x2.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
          }
          return x2;
        }
        function taylorSeries(Ctor, n, x2, y2, isHyperbolic) {
          var j2, t2, u2, x22, i = 1, pr = Ctor.precision, k2 = Math.ceil(pr / LOG_BASE);
          external = false;
          x22 = x2.times(x2);
          u2 = new Ctor(y2);
          for (; ; ) {
            t2 = divide(u2.times(x22), new Ctor(n++ * n++), pr, 1);
            u2 = isHyperbolic ? y2.plus(t2) : y2.minus(t2);
            y2 = divide(t2.times(x22), new Ctor(n++ * n++), pr, 1);
            t2 = u2.plus(y2);
            if (t2.d[k2] !== void 0) {
              for (j2 = k2; t2.d[j2] === u2.d[j2] && j2--; )
                ;
              if (j2 == -1)
                break;
            }
            j2 = u2;
            u2 = y2;
            y2 = t2;
            t2 = j2;
            i++;
          }
          external = true;
          t2.d.length = k2 + 1;
          return t2;
        }
        function tinyPow(b2, e) {
          var n = b2;
          while (--e)
            n *= b2;
          return n;
        }
        function toLessThanHalfPi(Ctor, x2) {
          var t2, isNeg = x2.s < 0, pi = getPi(Ctor, Ctor.precision, 1), halfPi = pi.times(0.5);
          x2 = x2.abs();
          if (x2.lte(halfPi)) {
            quadrant = isNeg ? 4 : 1;
            return x2;
          }
          t2 = x2.divToInt(pi);
          if (t2.isZero()) {
            quadrant = isNeg ? 3 : 2;
          } else {
            x2 = x2.minus(t2.times(pi));
            if (x2.lte(halfPi)) {
              quadrant = isOdd(t2) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;
              return x2;
            }
            quadrant = isOdd(t2) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;
          }
          return x2.minus(pi).abs();
        }
        function toStringBinary(x2, baseOut, sd, rm) {
          var base, e, i, k2, len, roundUp, str3, xd, y2, Ctor = x2.constructor, isExp = sd !== void 0;
          if (isExp) {
            checkInt32(sd, 1, MAX_DIGITS);
            if (rm === void 0)
              rm = Ctor.rounding;
            else
              checkInt32(rm, 0, 8);
          } else {
            sd = Ctor.precision;
            rm = Ctor.rounding;
          }
          if (!x2.isFinite()) {
            str3 = nonFiniteToString(x2);
          } else {
            str3 = finiteToString(x2);
            i = str3.indexOf(".");
            if (isExp) {
              base = 2;
              if (baseOut == 16) {
                sd = sd * 4 - 3;
              } else if (baseOut == 8) {
                sd = sd * 3 - 2;
              }
            } else {
              base = baseOut;
            }
            if (i >= 0) {
              str3 = str3.replace(".", "");
              y2 = new Ctor(1);
              y2.e = str3.length - i;
              y2.d = convertBase(finiteToString(y2), 10, base);
              y2.e = y2.d.length;
            }
            xd = convertBase(str3, 10, base);
            e = len = xd.length;
            for (; xd[--len] == 0; )
              xd.pop();
            if (!xd[0]) {
              str3 = isExp ? "0p+0" : "0";
            } else {
              if (i < 0) {
                e--;
              } else {
                x2 = new Ctor(x2);
                x2.d = xd;
                x2.e = e;
                x2 = divide(x2, y2, sd, rm, 0, base);
                xd = x2.d;
                e = x2.e;
                roundUp = inexact;
              }
              i = xd[sd];
              k2 = base / 2;
              roundUp = roundUp || xd[sd + 1] !== void 0;
              roundUp = rm < 4 ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x2.s < 0 ? 3 : 2)) : i > k2 || i === k2 && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x2.s < 0 ? 8 : 7));
              xd.length = sd;
              if (roundUp) {
                for (; ++xd[--sd] > base - 1; ) {
                  xd[sd] = 0;
                  if (!sd) {
                    ++e;
                    xd.unshift(1);
                  }
                }
              }
              for (len = xd.length; !xd[len - 1]; --len)
                ;
              for (i = 0, str3 = ""; i < len; i++)
                str3 += NUMERALS.charAt(xd[i]);
              if (isExp) {
                if (len > 1) {
                  if (baseOut == 16 || baseOut == 8) {
                    i = baseOut == 16 ? 4 : 3;
                    for (--len; len % i; len++)
                      str3 += "0";
                    xd = convertBase(str3, base, baseOut);
                    for (len = xd.length; !xd[len - 1]; --len)
                      ;
                    for (i = 1, str3 = "1."; i < len; i++)
                      str3 += NUMERALS.charAt(xd[i]);
                  } else {
                    str3 = str3.charAt(0) + "." + str3.slice(1);
                  }
                }
                str3 = str3 + (e < 0 ? "p" : "p+") + e;
              } else if (e < 0) {
                for (; ++e; )
                  str3 = "0" + str3;
                str3 = "0." + str3;
              } else {
                if (++e > len)
                  for (e -= len; e--; )
                    str3 += "0";
                else if (e < len)
                  str3 = str3.slice(0, e) + "." + str3.slice(e);
              }
            }
            str3 = (baseOut == 16 ? "0x" : baseOut == 2 ? "0b" : baseOut == 8 ? "0o" : "") + str3;
          }
          return x2.s < 0 ? "-" + str3 : str3;
        }
        function truncate2(arr, len) {
          if (arr.length > len) {
            arr.length = len;
            return true;
          }
        }
        function abs(x2) {
          return new this(x2).abs();
        }
        function acos(x2) {
          return new this(x2).acos();
        }
        function acosh(x2) {
          return new this(x2).acosh();
        }
        function add2(x2, y2) {
          return new this(x2).plus(y2);
        }
        function asin(x2) {
          return new this(x2).asin();
        }
        function asinh(x2) {
          return new this(x2).asinh();
        }
        function atan(x2) {
          return new this(x2).atan();
        }
        function atanh(x2) {
          return new this(x2).atanh();
        }
        function atan2(y2, x2) {
          y2 = new this(y2);
          x2 = new this(x2);
          var r, pr = this.precision, rm = this.rounding, wpr = pr + 4;
          if (!y2.s || !x2.s) {
            r = new this(NaN);
          } else if (!y2.d && !x2.d) {
            r = getPi(this, wpr, 1).times(x2.s > 0 ? 0.25 : 0.75);
            r.s = y2.s;
          } else if (!x2.d || y2.isZero()) {
            r = x2.s < 0 ? getPi(this, pr, rm) : new this(0);
            r.s = y2.s;
          } else if (!y2.d || x2.isZero()) {
            r = getPi(this, wpr, 1).times(0.5);
            r.s = y2.s;
          } else if (x2.s < 0) {
            this.precision = wpr;
            this.rounding = 1;
            r = this.atan(divide(y2, x2, wpr, 1));
            x2 = getPi(this, wpr, 1);
            this.precision = pr;
            this.rounding = rm;
            r = y2.s < 0 ? r.minus(x2) : r.plus(x2);
          } else {
            r = this.atan(divide(y2, x2, wpr, 1));
          }
          return r;
        }
        function cbrt(x2) {
          return new this(x2).cbrt();
        }
        function ceil(x2) {
          return finalise(x2 = new this(x2), x2.e + 1, 2);
        }
        function clamp(x2, min2, max2) {
          return new this(x2).clamp(min2, max2);
        }
        function config2(obj) {
          if (!obj || typeof obj !== "object")
            throw Error(decimalError + "Object expected");
          var i, p2, v2, useDefaults = obj.defaults === true, ps = [
            "precision",
            1,
            MAX_DIGITS,
            "rounding",
            0,
            8,
            "toExpNeg",
            -EXP_LIMIT,
            0,
            "toExpPos",
            0,
            EXP_LIMIT,
            "maxE",
            0,
            EXP_LIMIT,
            "minE",
            -EXP_LIMIT,
            0,
            "modulo",
            0,
            9
          ];
          for (i = 0; i < ps.length; i += 3) {
            if (p2 = ps[i], useDefaults)
              this[p2] = DEFAULTS[p2];
            if ((v2 = obj[p2]) !== void 0) {
              if (mathfloor(v2) === v2 && v2 >= ps[i + 1] && v2 <= ps[i + 2])
                this[p2] = v2;
              else
                throw Error(invalidArgument + p2 + ": " + v2);
            }
          }
          if (p2 = "crypto", useDefaults)
            this[p2] = DEFAULTS[p2];
          if ((v2 = obj[p2]) !== void 0) {
            if (v2 === true || v2 === false || v2 === 0 || v2 === 1) {
              if (v2) {
                if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                  this[p2] = true;
                } else {
                  throw Error(cryptoUnavailable);
                }
              } else {
                this[p2] = false;
              }
            } else {
              throw Error(invalidArgument + p2 + ": " + v2);
            }
          }
          return this;
        }
        function cos(x2) {
          return new this(x2).cos();
        }
        function cosh(x2) {
          return new this(x2).cosh();
        }
        function clone(obj) {
          var i, p2, ps;
          function Decimal2(v2) {
            var e, i2, t2, x2 = this;
            if (!(x2 instanceof Decimal2))
              return new Decimal2(v2);
            x2.constructor = Decimal2;
            if (isDecimalInstance(v2)) {
              x2.s = v2.s;
              if (external) {
                if (!v2.d || v2.e > Decimal2.maxE) {
                  x2.e = NaN;
                  x2.d = null;
                } else if (v2.e < Decimal2.minE) {
                  x2.e = 0;
                  x2.d = [0];
                } else {
                  x2.e = v2.e;
                  x2.d = v2.d.slice();
                }
              } else {
                x2.e = v2.e;
                x2.d = v2.d ? v2.d.slice() : v2.d;
              }
              return;
            }
            t2 = typeof v2;
            if (t2 === "number") {
              if (v2 === 0) {
                x2.s = 1 / v2 < 0 ? -1 : 1;
                x2.e = 0;
                x2.d = [0];
                return;
              }
              if (v2 < 0) {
                v2 = -v2;
                x2.s = -1;
              } else {
                x2.s = 1;
              }
              if (v2 === ~~v2 && v2 < 1e7) {
                for (e = 0, i2 = v2; i2 >= 10; i2 /= 10)
                  e++;
                if (external) {
                  if (e > Decimal2.maxE) {
                    x2.e = NaN;
                    x2.d = null;
                  } else if (e < Decimal2.minE) {
                    x2.e = 0;
                    x2.d = [0];
                  } else {
                    x2.e = e;
                    x2.d = [v2];
                  }
                } else {
                  x2.e = e;
                  x2.d = [v2];
                }
                return;
              } else if (v2 * 0 !== 0) {
                if (!v2)
                  x2.s = NaN;
                x2.e = NaN;
                x2.d = null;
                return;
              }
              return parseDecimal(x2, v2.toString());
            } else if (t2 !== "string") {
              throw Error(invalidArgument + v2);
            }
            if ((i2 = v2.charCodeAt(0)) === 45) {
              v2 = v2.slice(1);
              x2.s = -1;
            } else {
              if (i2 === 43)
                v2 = v2.slice(1);
              x2.s = 1;
            }
            return isDecimal.test(v2) ? parseDecimal(x2, v2) : parseOther(x2, v2);
          }
          Decimal2.prototype = P2;
          Decimal2.ROUND_UP = 0;
          Decimal2.ROUND_DOWN = 1;
          Decimal2.ROUND_CEIL = 2;
          Decimal2.ROUND_FLOOR = 3;
          Decimal2.ROUND_HALF_UP = 4;
          Decimal2.ROUND_HALF_DOWN = 5;
          Decimal2.ROUND_HALF_EVEN = 6;
          Decimal2.ROUND_HALF_CEIL = 7;
          Decimal2.ROUND_HALF_FLOOR = 8;
          Decimal2.EUCLID = 9;
          Decimal2.config = Decimal2.set = config2;
          Decimal2.clone = clone;
          Decimal2.isDecimal = isDecimalInstance;
          Decimal2.abs = abs;
          Decimal2.acos = acos;
          Decimal2.acosh = acosh;
          Decimal2.add = add2;
          Decimal2.asin = asin;
          Decimal2.asinh = asinh;
          Decimal2.atan = atan;
          Decimal2.atanh = atanh;
          Decimal2.atan2 = atan2;
          Decimal2.cbrt = cbrt;
          Decimal2.ceil = ceil;
          Decimal2.clamp = clamp;
          Decimal2.cos = cos;
          Decimal2.cosh = cosh;
          Decimal2.div = div;
          Decimal2.exp = exp;
          Decimal2.floor = floor;
          Decimal2.hypot = hypot;
          Decimal2.ln = ln2;
          Decimal2.log = log2;
          Decimal2.log10 = log10;
          Decimal2.log2 = log22;
          Decimal2.max = max;
          Decimal2.min = min;
          Decimal2.mod = mod2;
          Decimal2.mul = mul;
          Decimal2.pow = pow3;
          Decimal2.random = random;
          Decimal2.round = round;
          Decimal2.sign = sign2;
          Decimal2.sin = sin;
          Decimal2.sinh = sinh;
          Decimal2.sqrt = sqrt;
          Decimal2.sub = sub;
          Decimal2.sum = sum;
          Decimal2.tan = tan;
          Decimal2.tanh = tanh;
          Decimal2.trunc = trunc;
          if (obj === void 0)
            obj = {};
          if (obj) {
            if (obj.defaults !== true) {
              ps = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"];
              for (i = 0; i < ps.length; )
                if (!obj.hasOwnProperty(p2 = ps[i++]))
                  obj[p2] = this[p2];
            }
          }
          Decimal2.config(obj);
          return Decimal2;
        }
        function div(x2, y2) {
          return new this(x2).div(y2);
        }
        function exp(x2) {
          return new this(x2).exp();
        }
        function floor(x2) {
          return finalise(x2 = new this(x2), x2.e + 1, 3);
        }
        function hypot() {
          var i, n, t2 = new this(0);
          external = false;
          for (i = 0; i < arguments.length; ) {
            n = new this(arguments[i++]);
            if (!n.d) {
              if (n.s) {
                external = true;
                return new this(1 / 0);
              }
              t2 = n;
            } else if (t2.d) {
              t2 = t2.plus(n.times(n));
            }
          }
          external = true;
          return t2.sqrt();
        }
        function isDecimalInstance(obj) {
          return obj instanceof Decimal || obj && obj.toStringTag === tag || false;
        }
        function ln2(x2) {
          return new this(x2).ln();
        }
        function log2(x2, y2) {
          return new this(x2).log(y2);
        }
        function log22(x2) {
          return new this(x2).log(2);
        }
        function log10(x2) {
          return new this(x2).log(10);
        }
        function max() {
          return maxOrMin(this, arguments, "lt");
        }
        function min() {
          return maxOrMin(this, arguments, "gt");
        }
        function mod2(x2, y2) {
          return new this(x2).mod(y2);
        }
        function mul(x2, y2) {
          return new this(x2).mul(y2);
        }
        function pow3(x2, y2) {
          return new this(x2).pow(y2);
        }
        function random(sd) {
          var d2, e, k2, n, i = 0, r = new this(1), rd = [];
          if (sd === void 0)
            sd = this.precision;
          else
            checkInt32(sd, 1, MAX_DIGITS);
          k2 = Math.ceil(sd / LOG_BASE);
          if (!this.crypto) {
            for (; i < k2; )
              rd[i++] = Math.random() * 1e7 | 0;
          } else if (crypto.getRandomValues) {
            d2 = crypto.getRandomValues(new Uint32Array(k2));
            for (; i < k2; ) {
              n = d2[i];
              if (n >= 429e7) {
                d2[i] = crypto.getRandomValues(new Uint32Array(1))[0];
              } else {
                rd[i++] = n % 1e7;
              }
            }
          } else if (crypto.randomBytes) {
            d2 = crypto.randomBytes(k2 *= 4);
            for (; i < k2; ) {
              n = d2[i] + (d2[i + 1] << 8) + (d2[i + 2] << 16) + ((d2[i + 3] & 127) << 24);
              if (n >= 214e7) {
                crypto.randomBytes(4).copy(d2, i);
              } else {
                rd.push(n % 1e7);
                i += 4;
              }
            }
            i = k2 / 4;
          } else {
            throw Error(cryptoUnavailable);
          }
          k2 = rd[--i];
          sd %= LOG_BASE;
          if (k2 && sd) {
            n = mathpow(10, LOG_BASE - sd);
            rd[i] = (k2 / n | 0) * n;
          }
          for (; rd[i] === 0; i--)
            rd.pop();
          if (i < 0) {
            e = 0;
            rd = [0];
          } else {
            e = -1;
            for (; rd[0] === 0; e -= LOG_BASE)
              rd.shift();
            for (k2 = 1, n = rd[0]; n >= 10; n /= 10)
              k2++;
            if (k2 < LOG_BASE)
              e -= LOG_BASE - k2;
          }
          r.e = e;
          r.d = rd;
          return r;
        }
        function round(x2) {
          return finalise(x2 = new this(x2), x2.e + 1, this.rounding);
        }
        function sign2(x2) {
          x2 = new this(x2);
          return x2.d ? x2.d[0] ? x2.s : 0 * x2.s : x2.s || NaN;
        }
        function sin(x2) {
          return new this(x2).sin();
        }
        function sinh(x2) {
          return new this(x2).sinh();
        }
        function sqrt(x2) {
          return new this(x2).sqrt();
        }
        function sub(x2, y2) {
          return new this(x2).sub(y2);
        }
        function sum() {
          var i = 0, args = arguments, x2 = new this(args[i]);
          external = false;
          for (; x2.s && ++i < args.length; )
            x2 = x2.plus(args[i]);
          external = true;
          return finalise(x2, this.precision, this.rounding);
        }
        function tan(x2) {
          return new this(x2).tan();
        }
        function tanh(x2) {
          return new this(x2).tanh();
        }
        function trunc(x2) {
          return finalise(x2 = new this(x2), x2.e + 1, 1);
        }
        Decimal = clone(DEFAULTS);
        Decimal.prototype.constructor = Decimal;
        Decimal["default"] = Decimal.Decimal = Decimal;
        LN10 = new Decimal(LN10);
        PI = new Decimal(PI);
        if (typeof define == "function" && define.amd) {
          define(function() {
            return Decimal;
          });
        } else if (typeof module2 != "undefined" && module2.exports) {
          if (typeof Symbol == "function" && typeof Symbol.iterator == "symbol") {
            P2[Symbol["for"]("nodejs.util.inspect.custom")] = P2.toString;
            P2[Symbol.toStringTag] = "Decimal";
          }
          module2.exports = Decimal;
        } else {
          if (!globalScope) {
            globalScope = typeof self != "undefined" && self && self.self == self ? self : window;
          }
          noConflict = globalScope.Decimal;
          Decimal.noConflict = function() {
            globalScope.Decimal = noConflict;
            return Decimal;
          };
          globalScope.Decimal = Decimal;
        }
      })(exports2);
    }
  });

  // node_modules/camelcase/index.js
  var require_camelcase2 = __commonJS({
    "node_modules/camelcase/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var preserveCamelCase = (string4) => {
        let isLastCharLower = false;
        let isLastCharUpper = false;
        let isLastLastCharUpper = false;
        for (let i = 0; i < string4.length; i++) {
          const character = string4[i];
          if (isLastCharLower && /[a-zA-Z]/.test(character) && character.toUpperCase() === character) {
            string4 = string4.slice(0, i) + "-" + string4.slice(i);
            isLastCharLower = false;
            isLastLastCharUpper = isLastCharUpper;
            isLastCharUpper = true;
            i++;
          } else if (isLastCharUpper && isLastLastCharUpper && /[a-zA-Z]/.test(character) && character.toLowerCase() === character) {
            string4 = string4.slice(0, i - 1) + "-" + string4.slice(i - 1);
            isLastLastCharUpper = isLastCharUpper;
            isLastCharUpper = false;
            isLastCharLower = true;
          } else {
            isLastCharLower = character.toLowerCase() === character && character.toUpperCase() !== character;
            isLastLastCharUpper = isLastCharUpper;
            isLastCharUpper = character.toUpperCase() === character && character.toLowerCase() !== character;
          }
        }
        return string4;
      };
      var camelCase2 = (input, options) => {
        if (!(typeof input === "string" || Array.isArray(input))) {
          throw new TypeError("Expected the input to be `string | string[]`");
        }
        options = Object.assign({
          pascalCase: false
        }, options);
        const postProcess = (x2) => options.pascalCase ? x2.charAt(0).toUpperCase() + x2.slice(1) : x2;
        if (Array.isArray(input)) {
          input = input.map((x2) => x2.trim()).filter((x2) => x2.length).join("-");
        } else {
          input = input.trim();
        }
        if (input.length === 0) {
          return "";
        }
        if (input.length === 1) {
          return options.pascalCase ? input.toUpperCase() : input.toLowerCase();
        }
        const hasUpperCase = input !== input.toLowerCase();
        if (hasUpperCase) {
          input = preserveCamelCase(input);
        }
        input = input.replace(/^[_.\- ]+/, "").toLowerCase().replace(/[_.\- ]+(\w|$)/g, (_2, p1) => p1.toUpperCase()).replace(/\d+(\w|$)/g, (m) => m.toUpperCase());
        return postProcess(input);
      };
      module2.exports = camelCase2;
      module2.exports.default = camelCase2;
    }
  });

  // node_modules/@project-serum/borsh/dist/lib/index.js
  var require_lib2 = __commonJS({
    "node_modules/@project-serum/borsh/dist/lib/index.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.map = exports2.array = exports2.rustEnum = exports2.str = exports2.vecU8 = exports2.tagged = exports2.vec = exports2.bool = exports2.option = exports2.publicKey = exports2.i128 = exports2.u128 = exports2.i64 = exports2.u64 = exports2.struct = exports2.f64 = exports2.f32 = exports2.i32 = exports2.u32 = exports2.i16 = exports2.u16 = exports2.i8 = exports2.u8 = void 0;
      var buffer_layout_1 = require_Layout2();
      var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
      var bn_js_1 = __importDefault(require_bn());
      var buffer_layout_2 = require_Layout2();
      Object.defineProperty(exports2, "u8", { enumerable: true, get: function() {
        return buffer_layout_2.u8;
      } });
      Object.defineProperty(exports2, "i8", { enumerable: true, get: function() {
        return buffer_layout_2.s8;
      } });
      Object.defineProperty(exports2, "u16", { enumerable: true, get: function() {
        return buffer_layout_2.u16;
      } });
      Object.defineProperty(exports2, "i16", { enumerable: true, get: function() {
        return buffer_layout_2.s16;
      } });
      Object.defineProperty(exports2, "u32", { enumerable: true, get: function() {
        return buffer_layout_2.u32;
      } });
      Object.defineProperty(exports2, "i32", { enumerable: true, get: function() {
        return buffer_layout_2.s32;
      } });
      Object.defineProperty(exports2, "f32", { enumerable: true, get: function() {
        return buffer_layout_2.f32;
      } });
      Object.defineProperty(exports2, "f64", { enumerable: true, get: function() {
        return buffer_layout_2.f64;
      } });
      Object.defineProperty(exports2, "struct", { enumerable: true, get: function() {
        return buffer_layout_2.struct;
      } });
      var BNLayout = class extends buffer_layout_1.Layout {
        constructor(span, signed, property) {
          super(span, property);
          this.blob = buffer_layout_1.blob(span);
          this.signed = signed;
        }
        decode(b2, offset3 = 0) {
          const num = new bn_js_1.default(this.blob.decode(b2, offset3), 10, "le");
          if (this.signed) {
            return num.fromTwos(this.span * 8).clone();
          }
          return num;
        }
        encode(src, b2, offset3 = 0) {
          if (this.signed) {
            src = src.toTwos(this.span * 8);
          }
          return this.blob.encode(src.toArrayLike(Buffer, "le", this.span), b2, offset3);
        }
      };
      function u647(property) {
        return new BNLayout(8, false, property);
      }
      exports2.u64 = u647;
      function i643(property) {
        return new BNLayout(8, true, property);
      }
      exports2.i64 = i643;
      function u1283(property) {
        return new BNLayout(16, false, property);
      }
      exports2.u128 = u1283;
      function i1283(property) {
        return new BNLayout(16, true, property);
      }
      exports2.i128 = i1283;
      var WrappedLayout2 = class extends buffer_layout_1.Layout {
        constructor(layout, decoder, encoder, property) {
          super(layout.span, property);
          this.layout = layout;
          this.decoder = decoder;
          this.encoder = encoder;
        }
        decode(b2, offset3) {
          return this.decoder(this.layout.decode(b2, offset3));
        }
        encode(src, b2, offset3) {
          return this.layout.encode(this.encoder(src), b2, offset3);
        }
        getSpan(b2, offset3) {
          return this.layout.getSpan(b2, offset3);
        }
      };
      function publicKey6(property) {
        return new WrappedLayout2(buffer_layout_1.blob(32), (b2) => new web3_js_1.PublicKey(b2), (key) => key.toBuffer(), property);
      }
      exports2.publicKey = publicKey6;
      var OptionLayout = class extends buffer_layout_1.Layout {
        constructor(layout, property) {
          super(-1, property);
          this.layout = layout;
          this.discriminator = buffer_layout_1.u8();
        }
        encode(src, b2, offset3 = 0) {
          if (src === null || src === void 0) {
            return this.discriminator.encode(0, b2, offset3);
          }
          this.discriminator.encode(1, b2, offset3);
          return this.layout.encode(src, b2, offset3 + 1) + 1;
        }
        decode(b2, offset3 = 0) {
          const discriminator = this.discriminator.decode(b2, offset3);
          if (discriminator === 0) {
            return null;
          } else if (discriminator === 1) {
            return this.layout.decode(b2, offset3 + 1);
          }
          throw new Error("Invalid option " + this.property);
        }
        getSpan(b2, offset3 = 0) {
          const discriminator = this.discriminator.decode(b2, offset3);
          if (discriminator === 0) {
            return 1;
          } else if (discriminator === 1) {
            return this.layout.getSpan(b2, offset3 + 1) + 1;
          }
          throw new Error("Invalid option " + this.property);
        }
      };
      function option3(layout, property) {
        return new OptionLayout(layout, property);
      }
      exports2.option = option3;
      function bool4(property) {
        return new WrappedLayout2(buffer_layout_1.u8(), decodeBool, encodeBool, property);
      }
      exports2.bool = bool4;
      function decodeBool(value) {
        if (value === 0) {
          return false;
        } else if (value === 1) {
          return true;
        }
        throw new Error("Invalid bool: " + value);
      }
      function encodeBool(value) {
        return value ? 1 : 0;
      }
      function vec3(elementLayout, property) {
        const length = buffer_layout_1.u32("length");
        const layout = buffer_layout_1.struct([
          length,
          buffer_layout_1.seq(elementLayout, buffer_layout_1.offset(length, -length.span), "values")
        ]);
        return new WrappedLayout2(layout, ({ values }) => values, (values) => ({ values }), property);
      }
      exports2.vec = vec3;
      function tagged(tag, layout, property) {
        const wrappedLayout = buffer_layout_1.struct([
          u647("tag"),
          layout.replicate("data")
        ]);
        function decodeTag({ tag: receivedTag, data }) {
          if (!receivedTag.eq(tag)) {
            throw new Error("Invalid tag, expected: " + tag.toString("hex") + ", got: " + receivedTag.toString("hex"));
          }
          return data;
        }
        return new WrappedLayout2(wrappedLayout, decodeTag, (data) => ({ tag, data }), property);
      }
      exports2.tagged = tagged;
      function vecU83(property) {
        const length = buffer_layout_1.u32("length");
        const layout = buffer_layout_1.struct([
          length,
          buffer_layout_1.blob(buffer_layout_1.offset(length, -length.span), "data")
        ]);
        return new WrappedLayout2(layout, ({ data }) => data, (data) => ({ data }), property);
      }
      exports2.vecU8 = vecU83;
      function str3(property) {
        return new WrappedLayout2(vecU83(), (data) => data.toString("utf-8"), (s) => Buffer.from(s, "utf-8"), property);
      }
      exports2.str = str3;
      function rustEnum3(variants, property, discriminant) {
        const unionLayout = buffer_layout_1.union(discriminant !== null && discriminant !== void 0 ? discriminant : buffer_layout_1.u8(), property);
        variants.forEach((variant, index) => unionLayout.addVariant(index, variant, variant.property));
        return unionLayout;
      }
      exports2.rustEnum = rustEnum3;
      function array6(elementLayout, length, property) {
        const layout = buffer_layout_1.struct([
          buffer_layout_1.seq(elementLayout, length, "values")
        ]);
        return new WrappedLayout2(layout, ({ values }) => values, (values) => ({ values }), property);
      }
      exports2.array = array6;
      var MapEntryLayout = class extends buffer_layout_1.Layout {
        constructor(keyLayout, valueLayout, property) {
          super(keyLayout.span + valueLayout.span, property);
          this.keyLayout = keyLayout;
          this.valueLayout = valueLayout;
        }
        decode(b2, offset3) {
          offset3 = offset3 || 0;
          const key = this.keyLayout.decode(b2, offset3);
          const value = this.valueLayout.decode(b2, offset3 + this.keyLayout.getSpan(b2, offset3));
          return [key, value];
        }
        encode(src, b2, offset3) {
          offset3 = offset3 || 0;
          const keyBytes = this.keyLayout.encode(src[0], b2, offset3);
          const valueBytes = this.valueLayout.encode(src[1], b2, offset3 + keyBytes);
          return keyBytes + valueBytes;
        }
        getSpan(b2, offset3) {
          return this.keyLayout.getSpan(b2, offset3) + this.valueLayout.getSpan(b2, offset3);
        }
      };
      function map(keyLayout, valueLayout, property) {
        const length = buffer_layout_1.u32("length");
        const layout = buffer_layout_1.struct([
          length,
          buffer_layout_1.seq(new MapEntryLayout(keyLayout, valueLayout), buffer_layout_1.offset(length, -length.span), "values")
        ]);
        return new WrappedLayout2(layout, ({ values }) => new Map(values), (values) => ({ values: Array.from(values.entries()) }), property);
      }
      exports2.map = map;
    }
  });

  // node_modules/has-symbols/shams.js
  var require_shams = __commonJS({
    "node_modules/has-symbols/shams.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      module2.exports = function hasSymbols() {
        if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
          return false;
        }
        if (typeof Symbol.iterator === "symbol") {
          return true;
        }
        var obj = {};
        var sym = Symbol("test");
        var symObj = Object(sym);
        if (typeof sym === "string") {
          return false;
        }
        if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
          return false;
        }
        if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
          return false;
        }
        var symVal = 42;
        obj[sym] = symVal;
        for (sym in obj) {
          return false;
        }
        if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
          return false;
        }
        if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
          return false;
        }
        var syms = Object.getOwnPropertySymbols(obj);
        if (syms.length !== 1 || syms[0] !== sym) {
          return false;
        }
        if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
          return false;
        }
        if (typeof Object.getOwnPropertyDescriptor === "function") {
          var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
          if (descriptor.value !== symVal || descriptor.enumerable !== true) {
            return false;
          }
        }
        return true;
      };
    }
  });

  // node_modules/has-tostringtag/shams.js
  var require_shams2 = __commonJS({
    "node_modules/has-tostringtag/shams.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var hasSymbols = require_shams();
      module2.exports = function hasToStringTagShams() {
        return hasSymbols() && !!Symbol.toStringTag;
      };
    }
  });

  // node_modules/has-symbols/index.js
  var require_has_symbols = __commonJS({
    "node_modules/has-symbols/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var origSymbol = typeof Symbol !== "undefined" && Symbol;
      var hasSymbolSham = require_shams();
      module2.exports = function hasNativeSymbols() {
        if (typeof origSymbol !== "function") {
          return false;
        }
        if (typeof Symbol !== "function") {
          return false;
        }
        if (typeof origSymbol("foo") !== "symbol") {
          return false;
        }
        if (typeof Symbol("bar") !== "symbol") {
          return false;
        }
        return hasSymbolSham();
      };
    }
  });

  // node_modules/has-proto/index.js
  var require_has_proto = __commonJS({
    "node_modules/has-proto/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var test = {
        foo: {}
      };
      var $Object = Object;
      module2.exports = function hasProto() {
        return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
      };
    }
  });

  // node_modules/function-bind/implementation.js
  var require_implementation = __commonJS({
    "node_modules/function-bind/implementation.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
      var slice2 = Array.prototype.slice;
      var toStr = Object.prototype.toString;
      var funcType = "[object Function]";
      module2.exports = function bind(that) {
        var target = this;
        if (typeof target !== "function" || toStr.call(target) !== funcType) {
          throw new TypeError(ERROR_MESSAGE + target);
        }
        var args = slice2.call(arguments, 1);
        var bound;
        var binder = function() {
          if (this instanceof bound) {
            var result = target.apply(
              this,
              args.concat(slice2.call(arguments))
            );
            if (Object(result) === result) {
              return result;
            }
            return this;
          } else {
            return target.apply(
              that,
              args.concat(slice2.call(arguments))
            );
          }
        };
        var boundLength = Math.max(0, target.length - args.length);
        var boundArgs = [];
        for (var i = 0; i < boundLength; i++) {
          boundArgs.push("$" + i);
        }
        bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
        if (target.prototype) {
          var Empty = function Empty2() {
          };
          Empty.prototype = target.prototype;
          bound.prototype = new Empty();
          Empty.prototype = null;
        }
        return bound;
      };
    }
  });

  // node_modules/function-bind/index.js
  var require_function_bind = __commonJS({
    "node_modules/function-bind/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var implementation = require_implementation();
      module2.exports = Function.prototype.bind || implementation;
    }
  });

  // node_modules/has/src/index.js
  var require_src2 = __commonJS({
    "node_modules/has/src/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var bind = require_function_bind();
      module2.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
    }
  });

  // node_modules/get-intrinsic/index.js
  var require_get_intrinsic = __commonJS({
    "node_modules/get-intrinsic/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var undefined2;
      var $SyntaxError = SyntaxError;
      var $Function = Function;
      var $TypeError = TypeError;
      var getEvalledConstructor = function(expressionSyntax) {
        try {
          return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
        } catch (e) {
        }
      };
      var $gOPD = Object.getOwnPropertyDescriptor;
      if ($gOPD) {
        try {
          $gOPD({}, "");
        } catch (e) {
          $gOPD = null;
        }
      }
      var throwTypeError = function() {
        throw new $TypeError();
      };
      var ThrowTypeError = $gOPD ? function() {
        try {
          arguments.callee;
          return throwTypeError;
        } catch (calleeThrows) {
          try {
            return $gOPD(arguments, "callee").get;
          } catch (gOPDthrows) {
            return throwTypeError;
          }
        }
      }() : throwTypeError;
      var hasSymbols = require_has_symbols()();
      var hasProto = require_has_proto()();
      var getProto = Object.getPrototypeOf || (hasProto ? function(x2) {
        return x2.__proto__;
      } : null);
      var needsEval = {};
      var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
      var INTRINSICS = {
        "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
        "%Array%": Array,
        "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
        "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
        "%AsyncFromSyncIteratorPrototype%": undefined2,
        "%AsyncFunction%": needsEval,
        "%AsyncGenerator%": needsEval,
        "%AsyncGeneratorFunction%": needsEval,
        "%AsyncIteratorPrototype%": needsEval,
        "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
        "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
        "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
        "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
        "%Boolean%": Boolean,
        "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
        "%Date%": Date,
        "%decodeURI%": decodeURI,
        "%decodeURIComponent%": decodeURIComponent,
        "%encodeURI%": encodeURI,
        "%encodeURIComponent%": encodeURIComponent,
        "%Error%": Error,
        "%eval%": eval,
        "%EvalError%": EvalError,
        "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
        "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
        "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
        "%Function%": $Function,
        "%GeneratorFunction%": needsEval,
        "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
        "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
        "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
        "%isFinite%": isFinite,
        "%isNaN%": isNaN,
        "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
        "%JSON%": typeof JSON === "object" ? JSON : undefined2,
        "%Map%": typeof Map === "undefined" ? undefined2 : Map,
        "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
        "%Math%": Math,
        "%Number%": Number,
        "%Object%": Object,
        "%parseFloat%": parseFloat,
        "%parseInt%": parseInt,
        "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
        "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
        "%RangeError%": RangeError,
        "%ReferenceError%": ReferenceError,
        "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
        "%RegExp%": RegExp,
        "%Set%": typeof Set === "undefined" ? undefined2 : Set,
        "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
        "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
        "%String%": String,
        "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
        "%Symbol%": hasSymbols ? Symbol : undefined2,
        "%SyntaxError%": $SyntaxError,
        "%ThrowTypeError%": ThrowTypeError,
        "%TypedArray%": TypedArray,
        "%TypeError%": $TypeError,
        "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
        "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
        "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
        "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
        "%URIError%": URIError,
        "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
        "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
        "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
      };
      if (getProto) {
        try {
          null.error;
        } catch (e) {
          errorProto = getProto(getProto(e));
          INTRINSICS["%Error.prototype%"] = errorProto;
        }
      }
      var errorProto;
      var doEval = function doEval2(name2) {
        var value;
        if (name2 === "%AsyncFunction%") {
          value = getEvalledConstructor("async function () {}");
        } else if (name2 === "%GeneratorFunction%") {
          value = getEvalledConstructor("function* () {}");
        } else if (name2 === "%AsyncGeneratorFunction%") {
          value = getEvalledConstructor("async function* () {}");
        } else if (name2 === "%AsyncGenerator%") {
          var fn2 = doEval2("%AsyncGeneratorFunction%");
          if (fn2) {
            value = fn2.prototype;
          }
        } else if (name2 === "%AsyncIteratorPrototype%") {
          var gen2 = doEval2("%AsyncGenerator%");
          if (gen2 && getProto) {
            value = getProto(gen2.prototype);
          }
        }
        INTRINSICS[name2] = value;
        return value;
      };
      var LEGACY_ALIASES = {
        "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
        "%ArrayPrototype%": ["Array", "prototype"],
        "%ArrayProto_entries%": ["Array", "prototype", "entries"],
        "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
        "%ArrayProto_keys%": ["Array", "prototype", "keys"],
        "%ArrayProto_values%": ["Array", "prototype", "values"],
        "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
        "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
        "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
        "%BooleanPrototype%": ["Boolean", "prototype"],
        "%DataViewPrototype%": ["DataView", "prototype"],
        "%DatePrototype%": ["Date", "prototype"],
        "%ErrorPrototype%": ["Error", "prototype"],
        "%EvalErrorPrototype%": ["EvalError", "prototype"],
        "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
        "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
        "%FunctionPrototype%": ["Function", "prototype"],
        "%Generator%": ["GeneratorFunction", "prototype"],
        "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
        "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
        "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
        "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
        "%JSONParse%": ["JSON", "parse"],
        "%JSONStringify%": ["JSON", "stringify"],
        "%MapPrototype%": ["Map", "prototype"],
        "%NumberPrototype%": ["Number", "prototype"],
        "%ObjectPrototype%": ["Object", "prototype"],
        "%ObjProto_toString%": ["Object", "prototype", "toString"],
        "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
        "%PromisePrototype%": ["Promise", "prototype"],
        "%PromiseProto_then%": ["Promise", "prototype", "then"],
        "%Promise_all%": ["Promise", "all"],
        "%Promise_reject%": ["Promise", "reject"],
        "%Promise_resolve%": ["Promise", "resolve"],
        "%RangeErrorPrototype%": ["RangeError", "prototype"],
        "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
        "%RegExpPrototype%": ["RegExp", "prototype"],
        "%SetPrototype%": ["Set", "prototype"],
        "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
        "%StringPrototype%": ["String", "prototype"],
        "%SymbolPrototype%": ["Symbol", "prototype"],
        "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
        "%TypedArrayPrototype%": ["TypedArray", "prototype"],
        "%TypeErrorPrototype%": ["TypeError", "prototype"],
        "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
        "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
        "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
        "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
        "%URIErrorPrototype%": ["URIError", "prototype"],
        "%WeakMapPrototype%": ["WeakMap", "prototype"],
        "%WeakSetPrototype%": ["WeakSet", "prototype"]
      };
      var bind = require_function_bind();
      var hasOwn2 = require_src2();
      var $concat = bind.call(Function.call, Array.prototype.concat);
      var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
      var $replace = bind.call(Function.call, String.prototype.replace);
      var $strSlice = bind.call(Function.call, String.prototype.slice);
      var $exec = bind.call(Function.call, RegExp.prototype.exec);
      var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = function stringToPath2(string4) {
        var first = $strSlice(string4, 0, 1);
        var last = $strSlice(string4, -1);
        if (first === "%" && last !== "%") {
          throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
        } else if (last === "%" && first !== "%") {
          throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
        }
        var result = [];
        $replace(string4, rePropName, function(match, number5, quote, subString) {
          result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number5 || match;
        });
        return result;
      };
      var getBaseIntrinsic = function getBaseIntrinsic2(name2, allowMissing) {
        var intrinsicName = name2;
        var alias;
        if (hasOwn2(LEGACY_ALIASES, intrinsicName)) {
          alias = LEGACY_ALIASES[intrinsicName];
          intrinsicName = "%" + alias[0] + "%";
        }
        if (hasOwn2(INTRINSICS, intrinsicName)) {
          var value = INTRINSICS[intrinsicName];
          if (value === needsEval) {
            value = doEval(intrinsicName);
          }
          if (typeof value === "undefined" && !allowMissing) {
            throw new $TypeError("intrinsic " + name2 + " exists, but is not available. Please file an issue!");
          }
          return {
            alias,
            name: intrinsicName,
            value
          };
        }
        throw new $SyntaxError("intrinsic " + name2 + " does not exist!");
      };
      module2.exports = function GetIntrinsic(name2, allowMissing) {
        if (typeof name2 !== "string" || name2.length === 0) {
          throw new $TypeError("intrinsic name must be a non-empty string");
        }
        if (arguments.length > 1 && typeof allowMissing !== "boolean") {
          throw new $TypeError('"allowMissing" argument must be a boolean');
        }
        if ($exec(/^%?[^%]*%?$/, name2) === null) {
          throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
        }
        var parts = stringToPath(name2);
        var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
        var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
        var intrinsicRealName = intrinsic.name;
        var value = intrinsic.value;
        var skipFurtherCaching = false;
        var alias = intrinsic.alias;
        if (alias) {
          intrinsicBaseName = alias[0];
          $spliceApply(parts, $concat([0, 1], alias));
        }
        for (var i = 1, isOwn = true; i < parts.length; i += 1) {
          var part = parts[i];
          var first = $strSlice(part, 0, 1);
          var last = $strSlice(part, -1);
          if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
            throw new $SyntaxError("property names with quotes must have matching quotes");
          }
          if (part === "constructor" || !isOwn) {
            skipFurtherCaching = true;
          }
          intrinsicBaseName += "." + part;
          intrinsicRealName = "%" + intrinsicBaseName + "%";
          if (hasOwn2(INTRINSICS, intrinsicRealName)) {
            value = INTRINSICS[intrinsicRealName];
          } else if (value != null) {
            if (!(part in value)) {
              if (!allowMissing) {
                throw new $TypeError("base intrinsic for " + name2 + " exists, but the property is not available.");
              }
              return void 0;
            }
            if ($gOPD && i + 1 >= parts.length) {
              var desc = $gOPD(value, part);
              isOwn = !!desc;
              if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
                value = desc.get;
              } else {
                value = value[part];
              }
            } else {
              isOwn = hasOwn2(value, part);
              value = value[part];
            }
            if (isOwn && !skipFurtherCaching) {
              INTRINSICS[intrinsicRealName] = value;
            }
          }
        }
        return value;
      };
    }
  });

  // node_modules/call-bind/index.js
  var require_call_bind = __commonJS({
    "node_modules/call-bind/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var bind = require_function_bind();
      var GetIntrinsic = require_get_intrinsic();
      var $apply = GetIntrinsic("%Function.prototype.apply%");
      var $call = GetIntrinsic("%Function.prototype.call%");
      var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
      var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
      var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
      var $max = GetIntrinsic("%Math.max%");
      if ($defineProperty) {
        try {
          $defineProperty({}, "a", { value: 1 });
        } catch (e) {
          $defineProperty = null;
        }
      }
      module2.exports = function callBind(originalFunction) {
        var func = $reflectApply(bind, $call, arguments);
        if ($gOPD && $defineProperty) {
          var desc = $gOPD(func, "length");
          if (desc.configurable) {
            $defineProperty(
              func,
              "length",
              { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
            );
          }
        }
        return func;
      };
      var applyBind = function applyBind2() {
        return $reflectApply(bind, $apply, arguments);
      };
      if ($defineProperty) {
        $defineProperty(module2.exports, "apply", { value: applyBind });
      } else {
        module2.exports.apply = applyBind;
      }
    }
  });

  // node_modules/call-bind/callBound.js
  var require_callBound = __commonJS({
    "node_modules/call-bind/callBound.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var GetIntrinsic = require_get_intrinsic();
      var callBind = require_call_bind();
      var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
      module2.exports = function callBoundIntrinsic(name2, allowMissing) {
        var intrinsic = GetIntrinsic(name2, !!allowMissing);
        if (typeof intrinsic === "function" && $indexOf(name2, ".prototype.") > -1) {
          return callBind(intrinsic);
        }
        return intrinsic;
      };
    }
  });

  // node_modules/is-arguments/index.js
  var require_is_arguments = __commonJS({
    "node_modules/is-arguments/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var hasToStringTag = require_shams2()();
      var callBound = require_callBound();
      var $toString = callBound("Object.prototype.toString");
      var isStandardArguments = function isArguments2(value) {
        if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
          return false;
        }
        return $toString(value) === "[object Arguments]";
      };
      var isLegacyArguments = function isArguments2(value) {
        if (isStandardArguments(value)) {
          return true;
        }
        return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
      };
      var supportsStandardArguments = function() {
        return isStandardArguments(arguments);
      }();
      isStandardArguments.isLegacyArguments = isLegacyArguments;
      module2.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
    }
  });

  // node_modules/is-generator-function/index.js
  var require_is_generator_function = __commonJS({
    "node_modules/is-generator-function/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var toStr = Object.prototype.toString;
      var fnToStr = Function.prototype.toString;
      var isFnRegex = /^\s*(?:function)?\*/;
      var hasToStringTag = require_shams2()();
      var getProto = Object.getPrototypeOf;
      var getGeneratorFunc = function() {
        if (!hasToStringTag) {
          return false;
        }
        try {
          return Function("return function*() {}")();
        } catch (e) {
        }
      };
      var GeneratorFunction;
      module2.exports = function isGeneratorFunction(fn2) {
        if (typeof fn2 !== "function") {
          return false;
        }
        if (isFnRegex.test(fnToStr.call(fn2))) {
          return true;
        }
        if (!hasToStringTag) {
          var str3 = toStr.call(fn2);
          return str3 === "[object GeneratorFunction]";
        }
        if (!getProto) {
          return false;
        }
        if (typeof GeneratorFunction === "undefined") {
          var generatorFunc = getGeneratorFunc();
          GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
        }
        return getProto(fn2) === GeneratorFunction;
      };
    }
  });

  // node_modules/is-callable/index.js
  var require_is_callable = __commonJS({
    "node_modules/is-callable/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var fnToStr = Function.prototype.toString;
      var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
      var badArrayLike;
      var isCallableMarker;
      if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
        try {
          badArrayLike = Object.defineProperty({}, "length", {
            get: function() {
              throw isCallableMarker;
            }
          });
          isCallableMarker = {};
          reflectApply(function() {
            throw 42;
          }, null, badArrayLike);
        } catch (_2) {
          if (_2 !== isCallableMarker) {
            reflectApply = null;
          }
        }
      } else {
        reflectApply = null;
      }
      var constructorRegex = /^\s*class\b/;
      var isES6ClassFn = function isES6ClassFunction(value) {
        try {
          var fnStr = fnToStr.call(value);
          return constructorRegex.test(fnStr);
        } catch (e) {
          return false;
        }
      };
      var tryFunctionObject = function tryFunctionToStr(value) {
        try {
          if (isES6ClassFn(value)) {
            return false;
          }
          fnToStr.call(value);
          return true;
        } catch (e) {
          return false;
        }
      };
      var toStr = Object.prototype.toString;
      var objectClass = "[object Object]";
      var fnClass = "[object Function]";
      var genClass = "[object GeneratorFunction]";
      var ddaClass = "[object HTMLAllCollection]";
      var ddaClass2 = "[object HTML document.all class]";
      var ddaClass3 = "[object HTMLCollection]";
      var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
      var isIE68 = !(0 in [,]);
      var isDDA = function isDocumentDotAll() {
        return false;
      };
      if (typeof document === "object") {
        all = document.all;
        if (toStr.call(all) === toStr.call(document.all)) {
          isDDA = function isDocumentDotAll(value) {
            if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
              try {
                var str3 = toStr.call(value);
                return (str3 === ddaClass || str3 === ddaClass2 || str3 === ddaClass3 || str3 === objectClass) && value("") == null;
              } catch (e) {
              }
            }
            return false;
          };
        }
      }
      var all;
      module2.exports = reflectApply ? function isCallable(value) {
        if (isDDA(value)) {
          return true;
        }
        if (!value) {
          return false;
        }
        if (typeof value !== "function" && typeof value !== "object") {
          return false;
        }
        try {
          reflectApply(value, null, badArrayLike);
        } catch (e) {
          if (e !== isCallableMarker) {
            return false;
          }
        }
        return !isES6ClassFn(value) && tryFunctionObject(value);
      } : function isCallable(value) {
        if (isDDA(value)) {
          return true;
        }
        if (!value) {
          return false;
        }
        if (typeof value !== "function" && typeof value !== "object") {
          return false;
        }
        if (hasToStringTag) {
          return tryFunctionObject(value);
        }
        if (isES6ClassFn(value)) {
          return false;
        }
        var strClass = toStr.call(value);
        if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
          return false;
        }
        return tryFunctionObject(value);
      };
    }
  });

  // node_modules/for-each/index.js
  var require_for_each = __commonJS({
    "node_modules/for-each/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var isCallable = require_is_callable();
      var toStr = Object.prototype.toString;
      var hasOwnProperty2 = Object.prototype.hasOwnProperty;
      var forEachArray = function forEachArray2(array6, iterator, receiver) {
        for (var i = 0, len = array6.length; i < len; i++) {
          if (hasOwnProperty2.call(array6, i)) {
            if (receiver == null) {
              iterator(array6[i], i, array6);
            } else {
              iterator.call(receiver, array6[i], i, array6);
            }
          }
        }
      };
      var forEachString = function forEachString2(string4, iterator, receiver) {
        for (var i = 0, len = string4.length; i < len; i++) {
          if (receiver == null) {
            iterator(string4.charAt(i), i, string4);
          } else {
            iterator.call(receiver, string4.charAt(i), i, string4);
          }
        }
      };
      var forEachObject = function forEachObject2(object3, iterator, receiver) {
        for (var k2 in object3) {
          if (hasOwnProperty2.call(object3, k2)) {
            if (receiver == null) {
              iterator(object3[k2], k2, object3);
            } else {
              iterator.call(receiver, object3[k2], k2, object3);
            }
          }
        }
      };
      var forEach = function forEach2(list, iterator, thisArg) {
        if (!isCallable(iterator)) {
          throw new TypeError("iterator must be a function");
        }
        var receiver;
        if (arguments.length >= 3) {
          receiver = thisArg;
        }
        if (toStr.call(list) === "[object Array]") {
          forEachArray(list, iterator, receiver);
        } else if (typeof list === "string") {
          forEachString(list, iterator, receiver);
        } else {
          forEachObject(list, iterator, receiver);
        }
      };
      module2.exports = forEach;
    }
  });

  // node_modules/available-typed-arrays/index.js
  var require_available_typed_arrays = __commonJS({
    "node_modules/available-typed-arrays/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var possibleNames = [
        "BigInt64Array",
        "BigUint64Array",
        "Float32Array",
        "Float64Array",
        "Int16Array",
        "Int32Array",
        "Int8Array",
        "Uint16Array",
        "Uint32Array",
        "Uint8Array",
        "Uint8ClampedArray"
      ];
      var g2 = typeof globalThis === "undefined" ? window : globalThis;
      module2.exports = function availableTypedArrays() {
        var out = [];
        for (var i = 0; i < possibleNames.length; i++) {
          if (typeof g2[possibleNames[i]] === "function") {
            out[out.length] = possibleNames[i];
          }
        }
        return out;
      };
    }
  });

  // node_modules/gopd/index.js
  var require_gopd = __commonJS({
    "node_modules/gopd/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var GetIntrinsic = require_get_intrinsic();
      var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
      if ($gOPD) {
        try {
          $gOPD([], "length");
        } catch (e) {
          $gOPD = null;
        }
      }
      module2.exports = $gOPD;
    }
  });

  // node_modules/is-typed-array/index.js
  var require_is_typed_array = __commonJS({
    "node_modules/is-typed-array/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var forEach = require_for_each();
      var availableTypedArrays = require_available_typed_arrays();
      var callBound = require_callBound();
      var $toString = callBound("Object.prototype.toString");
      var hasToStringTag = require_shams2()();
      var gOPD = require_gopd();
      var g2 = typeof globalThis === "undefined" ? window : globalThis;
      var typedArrays = availableTypedArrays();
      var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf2(array6, value) {
        for (var i = 0; i < array6.length; i += 1) {
          if (array6[i] === value) {
            return i;
          }
        }
        return -1;
      };
      var $slice = callBound("String.prototype.slice");
      var toStrTags = {};
      var getPrototypeOf = Object.getPrototypeOf;
      if (hasToStringTag && gOPD && getPrototypeOf) {
        forEach(typedArrays, function(typedArray) {
          var arr = new g2[typedArray]();
          if (Symbol.toStringTag in arr) {
            var proto = getPrototypeOf(arr);
            var descriptor = gOPD(proto, Symbol.toStringTag);
            if (!descriptor) {
              var superProto = getPrototypeOf(proto);
              descriptor = gOPD(superProto, Symbol.toStringTag);
            }
            toStrTags[typedArray] = descriptor.get;
          }
        });
      }
      var tryTypedArrays = function tryAllTypedArrays(value) {
        var anyTrue = false;
        forEach(toStrTags, function(getter, typedArray) {
          if (!anyTrue) {
            try {
              anyTrue = getter.call(value) === typedArray;
            } catch (e) {
            }
          }
        });
        return anyTrue;
      };
      module2.exports = function isTypedArray(value) {
        if (!value || typeof value !== "object") {
          return false;
        }
        if (!hasToStringTag || !(Symbol.toStringTag in value)) {
          var tag = $slice($toString(value), 8, -1);
          return $indexOf(typedArrays, tag) > -1;
        }
        if (!gOPD) {
          return false;
        }
        return tryTypedArrays(value);
      };
    }
  });

  // node_modules/which-typed-array/index.js
  var require_which_typed_array = __commonJS({
    "node_modules/which-typed-array/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var forEach = require_for_each();
      var availableTypedArrays = require_available_typed_arrays();
      var callBind = require_call_bind();
      var callBound = require_callBound();
      var gOPD = require_gopd();
      var $toString = callBound("Object.prototype.toString");
      var hasToStringTag = require_shams2()();
      var g2 = typeof globalThis === "undefined" ? window : globalThis;
      var typedArrays = availableTypedArrays();
      var $slice = callBound("String.prototype.slice");
      var toStrTags = { __proto__: null };
      var getPrototypeOf = Object.getPrototypeOf;
      if (hasToStringTag && gOPD && getPrototypeOf) {
        forEach(typedArrays, function(typedArray) {
          if (typeof g2[typedArray] === "function") {
            var arr = new g2[typedArray]();
            if (Symbol.toStringTag in arr) {
              var proto = getPrototypeOf(arr);
              var descriptor = gOPD(proto, Symbol.toStringTag);
              if (!descriptor) {
                var superProto = getPrototypeOf(proto);
                descriptor = gOPD(superProto, Symbol.toStringTag);
              }
              toStrTags[typedArray] = callBind(descriptor.get);
            }
          }
        });
      }
      var tryTypedArrays = function tryAllTypedArrays(value) {
        var foundName = false;
        forEach(toStrTags, function(getter, typedArray) {
          if (!foundName) {
            try {
              var name2 = getter(value);
              if (name2 === typedArray) {
                foundName = name2;
              }
            } catch (e) {
            }
          }
        });
        return foundName;
      };
      var isTypedArray = require_is_typed_array();
      module2.exports = function whichTypedArray(value) {
        if (!isTypedArray(value)) {
          return false;
        }
        if (!hasToStringTag || !(Symbol.toStringTag in value)) {
          return $slice($toString(value), 8, -1);
        }
        return tryTypedArrays(value);
      };
    }
  });

  // node_modules/util/support/types.js
  var require_types = __commonJS({
    "node_modules/util/support/types.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var isArgumentsObject = require_is_arguments();
      var isGeneratorFunction = require_is_generator_function();
      var whichTypedArray = require_which_typed_array();
      var isTypedArray = require_is_typed_array();
      function uncurryThis(f3) {
        return f3.call.bind(f3);
      }
      var BigIntSupported = typeof BigInt !== "undefined";
      var SymbolSupported = typeof Symbol !== "undefined";
      var ObjectToString = uncurryThis(Object.prototype.toString);
      var numberValue = uncurryThis(Number.prototype.valueOf);
      var stringValue = uncurryThis(String.prototype.valueOf);
      var booleanValue = uncurryThis(Boolean.prototype.valueOf);
      if (BigIntSupported) {
        bigIntValue = uncurryThis(BigInt.prototype.valueOf);
      }
      var bigIntValue;
      if (SymbolSupported) {
        symbolValue = uncurryThis(Symbol.prototype.valueOf);
      }
      var symbolValue;
      function checkBoxedPrimitive(value, prototypeValueOf) {
        if (typeof value !== "object") {
          return false;
        }
        try {
          prototypeValueOf(value);
          return true;
        } catch (e) {
          return false;
        }
      }
      exports2.isArgumentsObject = isArgumentsObject;
      exports2.isGeneratorFunction = isGeneratorFunction;
      exports2.isTypedArray = isTypedArray;
      function isPromise(input) {
        return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
      }
      exports2.isPromise = isPromise;
      function isArrayBufferView(value) {
        if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
          return ArrayBuffer.isView(value);
        }
        return isTypedArray(value) || isDataView(value);
      }
      exports2.isArrayBufferView = isArrayBufferView;
      function isUint8Array(value) {
        return whichTypedArray(value) === "Uint8Array";
      }
      exports2.isUint8Array = isUint8Array;
      function isUint8ClampedArray(value) {
        return whichTypedArray(value) === "Uint8ClampedArray";
      }
      exports2.isUint8ClampedArray = isUint8ClampedArray;
      function isUint16Array(value) {
        return whichTypedArray(value) === "Uint16Array";
      }
      exports2.isUint16Array = isUint16Array;
      function isUint32Array(value) {
        return whichTypedArray(value) === "Uint32Array";
      }
      exports2.isUint32Array = isUint32Array;
      function isInt8Array(value) {
        return whichTypedArray(value) === "Int8Array";
      }
      exports2.isInt8Array = isInt8Array;
      function isInt16Array(value) {
        return whichTypedArray(value) === "Int16Array";
      }
      exports2.isInt16Array = isInt16Array;
      function isInt32Array(value) {
        return whichTypedArray(value) === "Int32Array";
      }
      exports2.isInt32Array = isInt32Array;
      function isFloat32Array(value) {
        return whichTypedArray(value) === "Float32Array";
      }
      exports2.isFloat32Array = isFloat32Array;
      function isFloat64Array(value) {
        return whichTypedArray(value) === "Float64Array";
      }
      exports2.isFloat64Array = isFloat64Array;
      function isBigInt64Array(value) {
        return whichTypedArray(value) === "BigInt64Array";
      }
      exports2.isBigInt64Array = isBigInt64Array;
      function isBigUint64Array(value) {
        return whichTypedArray(value) === "BigUint64Array";
      }
      exports2.isBigUint64Array = isBigUint64Array;
      function isMapToString(value) {
        return ObjectToString(value) === "[object Map]";
      }
      isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
      function isMap(value) {
        if (typeof Map === "undefined") {
          return false;
        }
        return isMapToString.working ? isMapToString(value) : value instanceof Map;
      }
      exports2.isMap = isMap;
      function isSetToString(value) {
        return ObjectToString(value) === "[object Set]";
      }
      isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
      function isSet2(value) {
        if (typeof Set === "undefined") {
          return false;
        }
        return isSetToString.working ? isSetToString(value) : value instanceof Set;
      }
      exports2.isSet = isSet2;
      function isWeakMapToString(value) {
        return ObjectToString(value) === "[object WeakMap]";
      }
      isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
      function isWeakMap(value) {
        if (typeof WeakMap === "undefined") {
          return false;
        }
        return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
      }
      exports2.isWeakMap = isWeakMap;
      function isWeakSetToString(value) {
        return ObjectToString(value) === "[object WeakSet]";
      }
      isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
      function isWeakSet(value) {
        return isWeakSetToString(value);
      }
      exports2.isWeakSet = isWeakSet;
      function isArrayBufferToString(value) {
        return ObjectToString(value) === "[object ArrayBuffer]";
      }
      isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
      function isArrayBuffer(value) {
        if (typeof ArrayBuffer === "undefined") {
          return false;
        }
        return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
      }
      exports2.isArrayBuffer = isArrayBuffer;
      function isDataViewToString(value) {
        return ObjectToString(value) === "[object DataView]";
      }
      isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
      function isDataView(value) {
        if (typeof DataView === "undefined") {
          return false;
        }
        return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
      }
      exports2.isDataView = isDataView;
      var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
      function isSharedArrayBufferToString(value) {
        return ObjectToString(value) === "[object SharedArrayBuffer]";
      }
      function isSharedArrayBuffer(value) {
        if (typeof SharedArrayBufferCopy === "undefined") {
          return false;
        }
        if (typeof isSharedArrayBufferToString.working === "undefined") {
          isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
        }
        return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
      }
      exports2.isSharedArrayBuffer = isSharedArrayBuffer;
      function isAsyncFunction(value) {
        return ObjectToString(value) === "[object AsyncFunction]";
      }
      exports2.isAsyncFunction = isAsyncFunction;
      function isMapIterator(value) {
        return ObjectToString(value) === "[object Map Iterator]";
      }
      exports2.isMapIterator = isMapIterator;
      function isSetIterator(value) {
        return ObjectToString(value) === "[object Set Iterator]";
      }
      exports2.isSetIterator = isSetIterator;
      function isGeneratorObject(value) {
        return ObjectToString(value) === "[object Generator]";
      }
      exports2.isGeneratorObject = isGeneratorObject;
      function isWebAssemblyCompiledModule(value) {
        return ObjectToString(value) === "[object WebAssembly.Module]";
      }
      exports2.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
      function isNumberObject(value) {
        return checkBoxedPrimitive(value, numberValue);
      }
      exports2.isNumberObject = isNumberObject;
      function isStringObject(value) {
        return checkBoxedPrimitive(value, stringValue);
      }
      exports2.isStringObject = isStringObject;
      function isBooleanObject(value) {
        return checkBoxedPrimitive(value, booleanValue);
      }
      exports2.isBooleanObject = isBooleanObject;
      function isBigIntObject(value) {
        return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
      }
      exports2.isBigIntObject = isBigIntObject;
      function isSymbolObject(value) {
        return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
      }
      exports2.isSymbolObject = isSymbolObject;
      function isBoxedPrimitive(value) {
        return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
      }
      exports2.isBoxedPrimitive = isBoxedPrimitive;
      function isAnyArrayBuffer(value) {
        return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
      }
      exports2.isAnyArrayBuffer = isAnyArrayBuffer;
      ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method2) {
        Object.defineProperty(exports2, method2, {
          enumerable: false,
          value: function() {
            throw new Error(method2 + " is not supported in userland");
          }
        });
      });
    }
  });

  // node_modules/util/support/isBufferBrowser.js
  var require_isBufferBrowser = __commonJS({
    "node_modules/util/support/isBufferBrowser.js"(exports2, module2) {
      init_virtual_process_polyfill();
      init_buffer();
      module2.exports = function isBuffer2(arg) {
        return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
      };
    }
  });

  // node_modules/inherits/inherits_browser.js
  var require_inherits_browser = __commonJS({
    "node_modules/inherits/inherits_browser.js"(exports2, module2) {
      init_virtual_process_polyfill();
      init_buffer();
      if (typeof Object.create === "function") {
        module2.exports = function inherits2(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          }
        };
      } else {
        module2.exports = function inherits2(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          }
        };
      }
    }
  });

  // node_modules/util/util.js
  var require_util = __commonJS({
    "node_modules/util/util.js"(exports2) {
      init_virtual_process_polyfill();
      init_buffer();
      var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
        var keys = Object.keys(obj);
        var descriptors = {};
        for (var i = 0; i < keys.length; i++) {
          descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
        }
        return descriptors;
      };
      var formatRegExp = /%[sdj%]/g;
      exports2.format = function(f3) {
        if (!isString2(f3)) {
          var objects = [];
          for (var i = 0; i < arguments.length; i++) {
            objects.push(inspect2(arguments[i]));
          }
          return objects.join(" ");
        }
        var i = 1;
        var args = arguments;
        var len = args.length;
        var str3 = String(f3).replace(formatRegExp, function(x3) {
          if (x3 === "%%")
            return "%";
          if (i >= len)
            return x3;
          switch (x3) {
            case "%s":
              return String(args[i++]);
            case "%d":
              return Number(args[i++]);
            case "%j":
              try {
                return JSON.stringify(args[i++]);
              } catch (_2) {
                return "[Circular]";
              }
            default:
              return x3;
          }
        });
        for (var x2 = args[i]; i < len; x2 = args[++i]) {
          if (isNull2(x2) || !isObject5(x2)) {
            str3 += " " + x2;
          } else {
            str3 += " " + inspect2(x2);
          }
        }
        return str3;
      };
      exports2.deprecate = function(fn2, msg) {
        if (typeof process !== "undefined" && process.noDeprecation === true) {
          return fn2;
        }
        if (typeof process === "undefined") {
          return function() {
            return exports2.deprecate(fn2, msg).apply(this, arguments);
          };
        }
        var warned = false;
        function deprecated() {
          if (!warned) {
            if (process.throwDeprecation) {
              throw new Error(msg);
            } else if (process.traceDeprecation) {
              console.trace(msg);
            } else {
              console.error(msg);
            }
            warned = true;
          }
          return fn2.apply(this, arguments);
        }
        return deprecated;
      };
      var debugs = {};
      var debugEnvRegex = /^$/;
      if (process.env.NODE_DEBUG) {
        debugEnv = process.env.NODE_DEBUG;
        debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
        debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
      }
      var debugEnv;
      exports2.debuglog = function(set) {
        set = set.toUpperCase();
        if (!debugs[set]) {
          if (debugEnvRegex.test(set)) {
            var pid = process.pid;
            debugs[set] = function() {
              var msg = exports2.format.apply(exports2, arguments);
              console.error("%s %d: %s", set, pid, msg);
            };
          } else {
            debugs[set] = function() {
            };
          }
        }
        return debugs[set];
      };
      function inspect2(obj, opts) {
        var ctx = {
          seen: [],
          stylize: stylizeNoColor2
        };
        if (arguments.length >= 3)
          ctx.depth = arguments[2];
        if (arguments.length >= 4)
          ctx.colors = arguments[3];
        if (isBoolean2(opts)) {
          ctx.showHidden = opts;
        } else if (opts) {
          exports2._extend(ctx, opts);
        }
        if (isUndefined2(ctx.showHidden))
          ctx.showHidden = false;
        if (isUndefined2(ctx.depth))
          ctx.depth = 2;
        if (isUndefined2(ctx.colors))
          ctx.colors = false;
        if (isUndefined2(ctx.customInspect))
          ctx.customInspect = true;
        if (ctx.colors)
          ctx.stylize = stylizeWithColor2;
        return formatValue2(ctx, obj, ctx.depth);
      }
      exports2.inspect = inspect2;
      inspect2.colors = {
        "bold": [1, 22],
        "italic": [3, 23],
        "underline": [4, 24],
        "inverse": [7, 27],
        "white": [37, 39],
        "grey": [90, 39],
        "black": [30, 39],
        "blue": [34, 39],
        "cyan": [36, 39],
        "green": [32, 39],
        "magenta": [35, 39],
        "red": [31, 39],
        "yellow": [33, 39]
      };
      inspect2.styles = {
        "special": "cyan",
        "number": "yellow",
        "boolean": "yellow",
        "undefined": "grey",
        "null": "bold",
        "string": "green",
        "date": "magenta",
        "regexp": "red"
      };
      function stylizeWithColor2(str3, styleType) {
        var style = inspect2.styles[styleType];
        if (style) {
          return "\x1B[" + inspect2.colors[style][0] + "m" + str3 + "\x1B[" + inspect2.colors[style][1] + "m";
        } else {
          return str3;
        }
      }
      function stylizeNoColor2(str3, styleType) {
        return str3;
      }
      function arrayToHash2(array6) {
        var hash2 = {};
        array6.forEach(function(val, idx) {
          hash2[val] = true;
        });
        return hash2;
      }
      function formatValue2(ctx, value, recurseTimes) {
        if (ctx.customInspect && value && isFunction2(value.inspect) && value.inspect !== exports2.inspect && !(value.constructor && value.constructor.prototype === value)) {
          var ret = value.inspect(recurseTimes, ctx);
          if (!isString2(ret)) {
            ret = formatValue2(ctx, ret, recurseTimes);
          }
          return ret;
        }
        var primitive = formatPrimitive2(ctx, value);
        if (primitive) {
          return primitive;
        }
        var keys = Object.keys(value);
        var visibleKeys = arrayToHash2(keys);
        if (ctx.showHidden) {
          keys = Object.getOwnPropertyNames(value);
        }
        if (isError2(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
          return formatError2(value);
        }
        if (keys.length === 0) {
          if (isFunction2(value)) {
            var name2 = value.name ? ": " + value.name : "";
            return ctx.stylize("[Function" + name2 + "]", "special");
          }
          if (isRegExp2(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
          }
          if (isDate2(value)) {
            return ctx.stylize(Date.prototype.toString.call(value), "date");
          }
          if (isError2(value)) {
            return formatError2(value);
          }
        }
        var base = "", array6 = false, braces = ["{", "}"];
        if (isArray2(value)) {
          array6 = true;
          braces = ["[", "]"];
        }
        if (isFunction2(value)) {
          var n = value.name ? ": " + value.name : "";
          base = " [Function" + n + "]";
        }
        if (isRegExp2(value)) {
          base = " " + RegExp.prototype.toString.call(value);
        }
        if (isDate2(value)) {
          base = " " + Date.prototype.toUTCString.call(value);
        }
        if (isError2(value)) {
          base = " " + formatError2(value);
        }
        if (keys.length === 0 && (!array6 || value.length == 0)) {
          return braces[0] + base + braces[1];
        }
        if (recurseTimes < 0) {
          if (isRegExp2(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
          } else {
            return ctx.stylize("[Object]", "special");
          }
        }
        ctx.seen.push(value);
        var output2;
        if (array6) {
          output2 = formatArray2(ctx, value, recurseTimes, visibleKeys, keys);
        } else {
          output2 = keys.map(function(key) {
            return formatProperty2(ctx, value, recurseTimes, visibleKeys, key, array6);
          });
        }
        ctx.seen.pop();
        return reduceToSingleString2(output2, base, braces);
      }
      function formatPrimitive2(ctx, value) {
        if (isUndefined2(value))
          return ctx.stylize("undefined", "undefined");
        if (isString2(value)) {
          var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
          return ctx.stylize(simple, "string");
        }
        if (isNumber2(value))
          return ctx.stylize("" + value, "number");
        if (isBoolean2(value))
          return ctx.stylize("" + value, "boolean");
        if (isNull2(value))
          return ctx.stylize("null", "null");
      }
      function formatError2(value) {
        return "[" + Error.prototype.toString.call(value) + "]";
      }
      function formatArray2(ctx, value, recurseTimes, visibleKeys, keys) {
        var output2 = [];
        for (var i = 0, l2 = value.length; i < l2; ++i) {
          if (hasOwnProperty2(value, String(i))) {
            output2.push(formatProperty2(
              ctx,
              value,
              recurseTimes,
              visibleKeys,
              String(i),
              true
            ));
          } else {
            output2.push("");
          }
        }
        keys.forEach(function(key) {
          if (!key.match(/^\d+$/)) {
            output2.push(formatProperty2(
              ctx,
              value,
              recurseTimes,
              visibleKeys,
              key,
              true
            ));
          }
        });
        return output2;
      }
      function formatProperty2(ctx, value, recurseTimes, visibleKeys, key, array6) {
        var name2, str3, desc;
        desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
        if (desc.get) {
          if (desc.set) {
            str3 = ctx.stylize("[Getter/Setter]", "special");
          } else {
            str3 = ctx.stylize("[Getter]", "special");
          }
        } else {
          if (desc.set) {
            str3 = ctx.stylize("[Setter]", "special");
          }
        }
        if (!hasOwnProperty2(visibleKeys, key)) {
          name2 = "[" + key + "]";
        }
        if (!str3) {
          if (ctx.seen.indexOf(desc.value) < 0) {
            if (isNull2(recurseTimes)) {
              str3 = formatValue2(ctx, desc.value, null);
            } else {
              str3 = formatValue2(ctx, desc.value, recurseTimes - 1);
            }
            if (str3.indexOf("\n") > -1) {
              if (array6) {
                str3 = str3.split("\n").map(function(line) {
                  return "  " + line;
                }).join("\n").slice(2);
              } else {
                str3 = "\n" + str3.split("\n").map(function(line) {
                  return "   " + line;
                }).join("\n");
              }
            }
          } else {
            str3 = ctx.stylize("[Circular]", "special");
          }
        }
        if (isUndefined2(name2)) {
          if (array6 && key.match(/^\d+$/)) {
            return str3;
          }
          name2 = JSON.stringify("" + key);
          if (name2.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
            name2 = name2.slice(1, -1);
            name2 = ctx.stylize(name2, "name");
          } else {
            name2 = name2.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
            name2 = ctx.stylize(name2, "string");
          }
        }
        return name2 + ": " + str3;
      }
      function reduceToSingleString2(output2, base, braces) {
        var numLinesEst = 0;
        var length = output2.reduce(function(prev, cur) {
          numLinesEst++;
          if (cur.indexOf("\n") >= 0)
            numLinesEst++;
          return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
        }, 0);
        if (length > 60) {
          return braces[0] + (base === "" ? "" : base + "\n ") + " " + output2.join(",\n  ") + " " + braces[1];
        }
        return braces[0] + base + " " + output2.join(", ") + " " + braces[1];
      }
      exports2.types = require_types();
      function isArray2(ar) {
        return Array.isArray(ar);
      }
      exports2.isArray = isArray2;
      function isBoolean2(arg) {
        return typeof arg === "boolean";
      }
      exports2.isBoolean = isBoolean2;
      function isNull2(arg) {
        return arg === null;
      }
      exports2.isNull = isNull2;
      function isNullOrUndefined(arg) {
        return arg == null;
      }
      exports2.isNullOrUndefined = isNullOrUndefined;
      function isNumber2(arg) {
        return typeof arg === "number";
      }
      exports2.isNumber = isNumber2;
      function isString2(arg) {
        return typeof arg === "string";
      }
      exports2.isString = isString2;
      function isSymbol(arg) {
        return typeof arg === "symbol";
      }
      exports2.isSymbol = isSymbol;
      function isUndefined2(arg) {
        return arg === void 0;
      }
      exports2.isUndefined = isUndefined2;
      function isRegExp2(re2) {
        return isObject5(re2) && objectToString2(re2) === "[object RegExp]";
      }
      exports2.isRegExp = isRegExp2;
      exports2.types.isRegExp = isRegExp2;
      function isObject5(arg) {
        return typeof arg === "object" && arg !== null;
      }
      exports2.isObject = isObject5;
      function isDate2(d2) {
        return isObject5(d2) && objectToString2(d2) === "[object Date]";
      }
      exports2.isDate = isDate2;
      exports2.types.isDate = isDate2;
      function isError2(e) {
        return isObject5(e) && (objectToString2(e) === "[object Error]" || e instanceof Error);
      }
      exports2.isError = isError2;
      exports2.types.isNativeError = isError2;
      function isFunction2(arg) {
        return typeof arg === "function";
      }
      exports2.isFunction = isFunction2;
      function isPrimitive2(arg) {
        return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
      }
      exports2.isPrimitive = isPrimitive2;
      exports2.isBuffer = require_isBufferBrowser();
      function objectToString2(o) {
        return Object.prototype.toString.call(o);
      }
      function pad(n) {
        return n < 10 ? "0" + n.toString(10) : n.toString(10);
      }
      var months2 = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ];
      function timestamp() {
        var d2 = new Date();
        var time = [
          pad(d2.getHours()),
          pad(d2.getMinutes()),
          pad(d2.getSeconds())
        ].join(":");
        return [d2.getDate(), months2[d2.getMonth()], time].join(" ");
      }
      exports2.log = function() {
        console.log("%s - %s", timestamp(), exports2.format.apply(exports2, arguments));
      };
      exports2.inherits = require_inherits_browser();
      exports2._extend = function(origin, add2) {
        if (!add2 || !isObject5(add2))
          return origin;
        var keys = Object.keys(add2);
        var i = keys.length;
        while (i--) {
          origin[keys[i]] = add2[keys[i]];
        }
        return origin;
      };
      function hasOwnProperty2(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }
      var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
      exports2.promisify = function promisify(original) {
        if (typeof original !== "function")
          throw new TypeError('The "original" argument must be of type Function');
        if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
          var fn2 = original[kCustomPromisifiedSymbol];
          if (typeof fn2 !== "function") {
            throw new TypeError('The "util.promisify.custom" argument must be of type Function');
          }
          Object.defineProperty(fn2, kCustomPromisifiedSymbol, {
            value: fn2,
            enumerable: false,
            writable: false,
            configurable: true
          });
          return fn2;
        }
        function fn2() {
          var promiseResolve, promiseReject;
          var promise = new Promise(function(resolve, reject) {
            promiseResolve = resolve;
            promiseReject = reject;
          });
          var args = [];
          for (var i = 0; i < arguments.length; i++) {
            args.push(arguments[i]);
          }
          args.push(function(err2, value) {
            if (err2) {
              promiseReject(err2);
            } else {
              promiseResolve(value);
            }
          });
          try {
            original.apply(this, args);
          } catch (err2) {
            promiseReject(err2);
          }
          return promise;
        }
        Object.setPrototypeOf(fn2, Object.getPrototypeOf(original));
        if (kCustomPromisifiedSymbol)
          Object.defineProperty(fn2, kCustomPromisifiedSymbol, {
            value: fn2,
            enumerable: false,
            writable: false,
            configurable: true
          });
        return Object.defineProperties(
          fn2,
          getOwnPropertyDescriptors(original)
        );
      };
      exports2.promisify.custom = kCustomPromisifiedSymbol;
      function callbackifyOnRejected(reason, cb) {
        if (!reason) {
          var newReason = new Error("Promise was rejected with a falsy value");
          newReason.reason = reason;
          reason = newReason;
        }
        return cb(reason);
      }
      function callbackify(original) {
        if (typeof original !== "function") {
          throw new TypeError('The "original" argument must be of type Function');
        }
        function callbackified() {
          var args = [];
          for (var i = 0; i < arguments.length; i++) {
            args.push(arguments[i]);
          }
          var maybeCb = args.pop();
          if (typeof maybeCb !== "function") {
            throw new TypeError("The last argument must be of type Function");
          }
          var self2 = this;
          var cb = function() {
            return maybeCb.apply(self2, arguments);
          };
          original.apply(this, args).then(
            function(ret) {
              process.nextTick(cb.bind(null, null, ret));
            },
            function(rej) {
              process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
            }
          );
        }
        Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
        Object.defineProperties(
          callbackified,
          getOwnPropertyDescriptors(original)
        );
        return callbackified;
      }
      exports2.callbackify = callbackify;
    }
  });

  // node_modules/assert/build/internal/errors.js
  var require_errors = __commonJS({
    "node_modules/assert/build/internal/errors.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      function _typeof2(obj) {
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck(instance2, Constructor) {
        if (!(instance2 instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _possibleConstructorReturn(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized(self2);
      }
      function _assertThisInitialized(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf(o);
      }
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p2) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p3) {
          o2.__proto__ = p3;
          return o2;
        };
        return _setPrototypeOf(o, p2);
      }
      var codes = {};
      var assert7;
      var util;
      function createErrorType(code2, message, Base) {
        if (!Base) {
          Base = Error;
        }
        function getMessage2(arg1, arg2, arg3) {
          if (typeof message === "string") {
            return message;
          } else {
            return message(arg1, arg2, arg3);
          }
        }
        var NodeError = /* @__PURE__ */ function(_Base) {
          _inherits(NodeError2, _Base);
          function NodeError2(arg1, arg2, arg3) {
            var _this;
            _classCallCheck(this, NodeError2);
            _this = _possibleConstructorReturn(this, _getPrototypeOf(NodeError2).call(this, getMessage2(arg1, arg2, arg3)));
            _this.code = code2;
            return _this;
          }
          return NodeError2;
        }(Base);
        codes[code2] = NodeError;
      }
      function oneOf(expected, thing) {
        if (Array.isArray(expected)) {
          var len = expected.length;
          expected = expected.map(function(i) {
            return String(i);
          });
          if (len > 2) {
            return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
          } else if (len === 2) {
            return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
          } else {
            return "of ".concat(thing, " ").concat(expected[0]);
          }
        } else {
          return "of ".concat(thing, " ").concat(String(expected));
        }
      }
      function startsWith(str3, search, pos) {
        return str3.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
      }
      function endsWith(str3, search, this_len) {
        if (this_len === void 0 || this_len > str3.length) {
          this_len = str3.length;
        }
        return str3.substring(this_len - search.length, this_len) === search;
      }
      function includes2(str3, search, start) {
        if (typeof start !== "number") {
          start = 0;
        }
        if (start + search.length > str3.length) {
          return false;
        } else {
          return str3.indexOf(search, start) !== -1;
        }
      }
      createErrorType("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError);
      createErrorType("ERR_INVALID_ARG_TYPE", function(name2, expected, actual) {
        if (assert7 === void 0)
          assert7 = require_assert();
        assert7(typeof name2 === "string", "'name' must be a string");
        var determiner;
        if (typeof expected === "string" && startsWith(expected, "not ")) {
          determiner = "must not be";
          expected = expected.replace(/^not /, "");
        } else {
          determiner = "must be";
        }
        var msg;
        if (endsWith(name2, " argument")) {
          msg = "The ".concat(name2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        } else {
          var type5 = includes2(name2, ".") ? "property" : "argument";
          msg = 'The "'.concat(name2, '" ').concat(type5, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        }
        msg += ". Received type ".concat(_typeof2(actual));
        return msg;
      }, TypeError);
      createErrorType("ERR_INVALID_ARG_VALUE", function(name2, value) {
        var reason = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "is invalid";
        if (util === void 0)
          util = require_util();
        var inspected = util.inspect(value);
        if (inspected.length > 128) {
          inspected = "".concat(inspected.slice(0, 128), "...");
        }
        return "The argument '".concat(name2, "' ").concat(reason, ". Received ").concat(inspected);
      }, TypeError, RangeError);
      createErrorType("ERR_INVALID_RETURN_VALUE", function(input, name2, value) {
        var type5;
        if (value && value.constructor && value.constructor.name) {
          type5 = "instance of ".concat(value.constructor.name);
        } else {
          type5 = "type ".concat(_typeof2(value));
        }
        return "Expected ".concat(input, ' to be returned from the "').concat(name2, '"') + " function but got ".concat(type5, ".");
      }, TypeError);
      createErrorType("ERR_MISSING_ARGS", function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if (assert7 === void 0)
          assert7 = require_assert();
        assert7(args.length > 0, "At least one arg needs to be specified");
        var msg = "The ";
        var len = args.length;
        args = args.map(function(a) {
          return '"'.concat(a, '"');
        });
        switch (len) {
          case 1:
            msg += "".concat(args[0], " argument");
            break;
          case 2:
            msg += "".concat(args[0], " and ").concat(args[1], " arguments");
            break;
          default:
            msg += args.slice(0, len - 1).join(", ");
            msg += ", and ".concat(args[len - 1], " arguments");
            break;
        }
        return "".concat(msg, " must be specified");
      }, TypeError);
      module2.exports.codes = codes;
    }
  });

  // node_modules/assert/build/internal/assert/assertion_error.js
  var require_assertion_error = __commonJS({
    "node_modules/assert/build/internal/assert/assertion_error.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};
          var ownKeys = Object.keys(source);
          if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
              return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
          }
          ownKeys.forEach(function(key) {
            _defineProperty2(target, key, source[key]);
          });
        }
        return target;
      }
      function _defineProperty2(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _classCallCheck(instance2, Constructor) {
        if (!(instance2 instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      function _possibleConstructorReturn(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized(self2);
      }
      function _assertThisInitialized(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf(subClass, superClass);
      }
      function _wrapNativeSuper(Class) {
        var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
        _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
          if (Class2 === null || !_isNativeFunction(Class2))
            return Class2;
          if (typeof Class2 !== "function") {
            throw new TypeError("Super expression must either be null or a function");
          }
          if (typeof _cache !== "undefined") {
            if (_cache.has(Class2))
              return _cache.get(Class2);
            _cache.set(Class2, Wrapper);
          }
          function Wrapper() {
            return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
          }
          Wrapper.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });
          return _setPrototypeOf(Wrapper, Class2);
        };
        return _wrapNativeSuper(Class);
      }
      function isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _construct(Parent, args, Class) {
        if (isNativeReflectConstruct()) {
          _construct = Reflect.construct;
        } else {
          _construct = function _construct2(Parent2, args2, Class2) {
            var a = [null];
            a.push.apply(a, args2);
            var Constructor = Function.bind.apply(Parent2, a);
            var instance2 = new Constructor();
            if (Class2)
              _setPrototypeOf(instance2, Class2.prototype);
            return instance2;
          };
        }
        return _construct.apply(null, arguments);
      }
      function _isNativeFunction(fn2) {
        return Function.toString.call(fn2).indexOf("[native code]") !== -1;
      }
      function _setPrototypeOf(o, p2) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p3) {
          o2.__proto__ = p3;
          return o2;
        };
        return _setPrototypeOf(o, p2);
      }
      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf(o);
      }
      function _typeof2(obj) {
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      var _require = require_util();
      var inspect2 = _require.inspect;
      var _require2 = require_errors();
      var ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE;
      function endsWith(str3, search, this_len) {
        if (this_len === void 0 || this_len > str3.length) {
          this_len = str3.length;
        }
        return str3.substring(this_len - search.length, this_len) === search;
      }
      function repeat(str3, count) {
        count = Math.floor(count);
        if (str3.length == 0 || count == 0)
          return "";
        var maxCount = str3.length * count;
        count = Math.floor(Math.log(count) / Math.log(2));
        while (count) {
          str3 += str3;
          count--;
        }
        str3 += str3.substring(0, maxCount - str3.length);
        return str3;
      }
      var blue = "";
      var green2 = "";
      var red2 = "";
      var white = "";
      var kReadableOperator = {
        deepStrictEqual: "Expected values to be strictly deep-equal:",
        strictEqual: "Expected values to be strictly equal:",
        strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
        deepEqual: "Expected values to be loosely deep-equal:",
        equal: "Expected values to be loosely equal:",
        notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
        notStrictEqual: 'Expected "actual" to be strictly unequal to:',
        notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
        notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
        notEqual: 'Expected "actual" to be loosely unequal to:',
        notIdentical: "Values identical but not reference-equal:"
      };
      var kMaxShortLength = 10;
      function copyError(source) {
        var keys = Object.keys(source);
        var target = Object.create(Object.getPrototypeOf(source));
        keys.forEach(function(key) {
          target[key] = source[key];
        });
        Object.defineProperty(target, "message", {
          value: source.message
        });
        return target;
      }
      function inspectValue(val) {
        return inspect2(val, {
          compact: false,
          customInspect: false,
          depth: 1e3,
          maxArrayLength: Infinity,
          showHidden: false,
          breakLength: Infinity,
          showProxy: false,
          sorted: true,
          getters: true
        });
      }
      function createErrDiff(actual, expected, operator) {
        var other = "";
        var res = "";
        var lastPos = 0;
        var end = "";
        var skipped = false;
        var actualInspected = inspectValue(actual);
        var actualLines = actualInspected.split("\n");
        var expectedLines = inspectValue(expected).split("\n");
        var i = 0;
        var indicator = "";
        if (operator === "strictEqual" && _typeof2(actual) === "object" && _typeof2(expected) === "object" && actual !== null && expected !== null) {
          operator = "strictEqualObject";
        }
        if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
          var inputLength = actualLines[0].length + expectedLines[0].length;
          if (inputLength <= kMaxShortLength) {
            if ((_typeof2(actual) !== "object" || actual === null) && (_typeof2(expected) !== "object" || expected === null) && (actual !== 0 || expected !== 0)) {
              return "".concat(kReadableOperator[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
            }
          } else if (operator !== "strictEqualObject") {
            var maxLength = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;
            if (inputLength < maxLength) {
              while (actualLines[0][i] === expectedLines[0][i]) {
                i++;
              }
              if (i > 2) {
                indicator = "\n  ".concat(repeat(" ", i), "^");
                i = 0;
              }
            }
          }
        }
        var a = actualLines[actualLines.length - 1];
        var b2 = expectedLines[expectedLines.length - 1];
        while (a === b2) {
          if (i++ < 2) {
            end = "\n  ".concat(a).concat(end);
          } else {
            other = a;
          }
          actualLines.pop();
          expectedLines.pop();
          if (actualLines.length === 0 || expectedLines.length === 0)
            break;
          a = actualLines[actualLines.length - 1];
          b2 = expectedLines[expectedLines.length - 1];
        }
        var maxLines = Math.max(actualLines.length, expectedLines.length);
        if (maxLines === 0) {
          var _actualLines = actualInspected.split("\n");
          if (_actualLines.length > 30) {
            _actualLines[26] = "".concat(blue, "...").concat(white);
            while (_actualLines.length > 27) {
              _actualLines.pop();
            }
          }
          return "".concat(kReadableOperator.notIdentical, "\n\n").concat(_actualLines.join("\n"), "\n");
        }
        if (i > 3) {
          end = "\n".concat(blue, "...").concat(white).concat(end);
          skipped = true;
        }
        if (other !== "") {
          end = "\n  ".concat(other).concat(end);
          other = "";
        }
        var printedLines = 0;
        var msg = kReadableOperator[operator] + "\n".concat(green2, "+ actual").concat(white, " ").concat(red2, "- expected").concat(white);
        var skippedMsg = " ".concat(blue, "...").concat(white, " Lines skipped");
        for (i = 0; i < maxLines; i++) {
          var cur = i - lastPos;
          if (actualLines.length < i + 1) {
            if (cur > 1 && i > 2) {
              if (cur > 4) {
                res += "\n".concat(blue, "...").concat(white);
                skipped = true;
              } else if (cur > 3) {
                res += "\n  ".concat(expectedLines[i - 2]);
                printedLines++;
              }
              res += "\n  ".concat(expectedLines[i - 1]);
              printedLines++;
            }
            lastPos = i;
            other += "\n".concat(red2, "-").concat(white, " ").concat(expectedLines[i]);
            printedLines++;
          } else if (expectedLines.length < i + 1) {
            if (cur > 1 && i > 2) {
              if (cur > 4) {
                res += "\n".concat(blue, "...").concat(white);
                skipped = true;
              } else if (cur > 3) {
                res += "\n  ".concat(actualLines[i - 2]);
                printedLines++;
              }
              res += "\n  ".concat(actualLines[i - 1]);
              printedLines++;
            }
            lastPos = i;
            res += "\n".concat(green2, "+").concat(white, " ").concat(actualLines[i]);
            printedLines++;
          } else {
            var expectedLine = expectedLines[i];
            var actualLine = actualLines[i];
            var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ",") || actualLine.slice(0, -1) !== expectedLine);
            if (divergingLines && endsWith(expectedLine, ",") && expectedLine.slice(0, -1) === actualLine) {
              divergingLines = false;
              actualLine += ",";
            }
            if (divergingLines) {
              if (cur > 1 && i > 2) {
                if (cur > 4) {
                  res += "\n".concat(blue, "...").concat(white);
                  skipped = true;
                } else if (cur > 3) {
                  res += "\n  ".concat(actualLines[i - 2]);
                  printedLines++;
                }
                res += "\n  ".concat(actualLines[i - 1]);
                printedLines++;
              }
              lastPos = i;
              res += "\n".concat(green2, "+").concat(white, " ").concat(actualLine);
              other += "\n".concat(red2, "-").concat(white, " ").concat(expectedLine);
              printedLines += 2;
            } else {
              res += other;
              other = "";
              if (cur === 1 || i === 0) {
                res += "\n  ".concat(actualLine);
                printedLines++;
              }
            }
          }
          if (printedLines > 20 && i < maxLines - 2) {
            return "".concat(msg).concat(skippedMsg, "\n").concat(res, "\n").concat(blue, "...").concat(white).concat(other, "\n") + "".concat(blue, "...").concat(white);
          }
        }
        return "".concat(msg).concat(skipped ? skippedMsg : "", "\n").concat(res).concat(other).concat(end).concat(indicator);
      }
      var AssertionError2 = /* @__PURE__ */ function(_Error) {
        _inherits(AssertionError3, _Error);
        function AssertionError3(options) {
          var _this;
          _classCallCheck(this, AssertionError3);
          if (_typeof2(options) !== "object" || options === null) {
            throw new ERR_INVALID_ARG_TYPE("options", "Object", options);
          }
          var message = options.message, operator = options.operator, stackStartFn = options.stackStartFn;
          var actual = options.actual, expected = options.expected;
          var limit = Error.stackTraceLimit;
          Error.stackTraceLimit = 0;
          if (message != null) {
            _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError3).call(this, String(message)));
          } else {
            if (process.stderr && process.stderr.isTTY) {
              if (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1) {
                blue = "\x1B[34m";
                green2 = "\x1B[32m";
                white = "\x1B[39m";
                red2 = "\x1B[31m";
              } else {
                blue = "";
                green2 = "";
                white = "";
                red2 = "";
              }
            }
            if (_typeof2(actual) === "object" && actual !== null && _typeof2(expected) === "object" && expected !== null && "stack" in actual && actual instanceof Error && "stack" in expected && expected instanceof Error) {
              actual = copyError(actual);
              expected = copyError(expected);
            }
            if (operator === "deepStrictEqual" || operator === "strictEqual") {
              _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError3).call(this, createErrDiff(actual, expected, operator)));
            } else if (operator === "notDeepStrictEqual" || operator === "notStrictEqual") {
              var base = kReadableOperator[operator];
              var res = inspectValue(actual).split("\n");
              if (operator === "notStrictEqual" && _typeof2(actual) === "object" && actual !== null) {
                base = kReadableOperator.notStrictEqualObject;
              }
              if (res.length > 30) {
                res[26] = "".concat(blue, "...").concat(white);
                while (res.length > 27) {
                  res.pop();
                }
              }
              if (res.length === 1) {
                _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError3).call(this, "".concat(base, " ").concat(res[0])));
              } else {
                _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError3).call(this, "".concat(base, "\n\n").concat(res.join("\n"), "\n")));
              }
            } else {
              var _res = inspectValue(actual);
              var other = "";
              var knownOperators = kReadableOperator[operator];
              if (operator === "notDeepEqual" || operator === "notEqual") {
                _res = "".concat(kReadableOperator[operator], "\n\n").concat(_res);
                if (_res.length > 1024) {
                  _res = "".concat(_res.slice(0, 1021), "...");
                }
              } else {
                other = "".concat(inspectValue(expected));
                if (_res.length > 512) {
                  _res = "".concat(_res.slice(0, 509), "...");
                }
                if (other.length > 512) {
                  other = "".concat(other.slice(0, 509), "...");
                }
                if (operator === "deepEqual" || operator === "equal") {
                  _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
                } else {
                  other = " ".concat(operator, " ").concat(other);
                }
              }
              _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError3).call(this, "".concat(_res).concat(other)));
            }
          }
          Error.stackTraceLimit = limit;
          _this.generatedMessage = !message;
          Object.defineProperty(_assertThisInitialized(_this), "name", {
            value: "AssertionError [ERR_ASSERTION]",
            enumerable: false,
            writable: true,
            configurable: true
          });
          _this.code = "ERR_ASSERTION";
          _this.actual = actual;
          _this.expected = expected;
          _this.operator = operator;
          if (Error.captureStackTrace) {
            Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);
          }
          _this.stack;
          _this.name = "AssertionError";
          return _possibleConstructorReturn(_this);
        }
        _createClass(AssertionError3, [{
          key: "toString",
          value: function toString3() {
            return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
          }
        }, {
          key: inspect2.custom,
          value: function value(recurseTimes, ctx) {
            return inspect2(this, _objectSpread({}, ctx, {
              customInspect: false,
              depth: 0
            }));
          }
        }]);
        return AssertionError3;
      }(_wrapNativeSuper(Error));
      module2.exports = AssertionError2;
    }
  });

  // node_modules/es6-object-assign/index.js
  var require_es6_object_assign = __commonJS({
    "node_modules/es6-object-assign/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      function assign2(target, firstSource) {
        if (target === void 0 || target === null) {
          throw new TypeError("Cannot convert first argument to object");
        }
        var to = Object(target);
        for (var i = 1; i < arguments.length; i++) {
          var nextSource = arguments[i];
          if (nextSource === void 0 || nextSource === null) {
            continue;
          }
          var keysArray = Object.keys(Object(nextSource));
          for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
            var nextKey = keysArray[nextIndex];
            var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
            if (desc !== void 0 && desc.enumerable) {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
        return to;
      }
      function polyfill() {
        if (!Object.assign) {
          Object.defineProperty(Object, "assign", {
            enumerable: false,
            configurable: true,
            writable: true,
            value: assign2
          });
        }
      }
      module2.exports = {
        assign: assign2,
        polyfill
      };
    }
  });

  // node_modules/object-keys/isArguments.js
  var require_isArguments = __commonJS({
    "node_modules/object-keys/isArguments.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var toStr = Object.prototype.toString;
      module2.exports = function isArguments2(value) {
        var str3 = toStr.call(value);
        var isArgs = str3 === "[object Arguments]";
        if (!isArgs) {
          isArgs = str3 !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
        }
        return isArgs;
      };
    }
  });

  // node_modules/object-keys/implementation.js
  var require_implementation2 = __commonJS({
    "node_modules/object-keys/implementation.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var keysShim;
      if (!Object.keys) {
        has = Object.prototype.hasOwnProperty;
        toStr = Object.prototype.toString;
        isArgs = require_isArguments();
        isEnumerable = Object.prototype.propertyIsEnumerable;
        hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
        hasProtoEnumBug = isEnumerable.call(function() {
        }, "prototype");
        dontEnums = [
          "toString",
          "toLocaleString",
          "valueOf",
          "hasOwnProperty",
          "isPrototypeOf",
          "propertyIsEnumerable",
          "constructor"
        ];
        equalsConstructorPrototype = function(o) {
          var ctor = o.constructor;
          return ctor && ctor.prototype === o;
        };
        excludedKeys = {
          $applicationCache: true,
          $console: true,
          $external: true,
          $frame: true,
          $frameElement: true,
          $frames: true,
          $innerHeight: true,
          $innerWidth: true,
          $onmozfullscreenchange: true,
          $onmozfullscreenerror: true,
          $outerHeight: true,
          $outerWidth: true,
          $pageXOffset: true,
          $pageYOffset: true,
          $parent: true,
          $scrollLeft: true,
          $scrollTop: true,
          $scrollX: true,
          $scrollY: true,
          $self: true,
          $webkitIndexedDB: true,
          $webkitStorageInfo: true,
          $window: true
        };
        hasAutomationEqualityBug = function() {
          if (typeof window === "undefined") {
            return false;
          }
          for (var k2 in window) {
            try {
              if (!excludedKeys["$" + k2] && has.call(window, k2) && window[k2] !== null && typeof window[k2] === "object") {
                try {
                  equalsConstructorPrototype(window[k2]);
                } catch (e) {
                  return true;
                }
              }
            } catch (e) {
              return true;
            }
          }
          return false;
        }();
        equalsConstructorPrototypeIfNotBuggy = function(o) {
          if (typeof window === "undefined" || !hasAutomationEqualityBug) {
            return equalsConstructorPrototype(o);
          }
          try {
            return equalsConstructorPrototype(o);
          } catch (e) {
            return false;
          }
        };
        keysShim = function keys(object3) {
          var isObject5 = object3 !== null && typeof object3 === "object";
          var isFunction2 = toStr.call(object3) === "[object Function]";
          var isArguments2 = isArgs(object3);
          var isString2 = isObject5 && toStr.call(object3) === "[object String]";
          var theKeys = [];
          if (!isObject5 && !isFunction2 && !isArguments2) {
            throw new TypeError("Object.keys called on a non-object");
          }
          var skipProto = hasProtoEnumBug && isFunction2;
          if (isString2 && object3.length > 0 && !has.call(object3, 0)) {
            for (var i = 0; i < object3.length; ++i) {
              theKeys.push(String(i));
            }
          }
          if (isArguments2 && object3.length > 0) {
            for (var j2 = 0; j2 < object3.length; ++j2) {
              theKeys.push(String(j2));
            }
          } else {
            for (var name2 in object3) {
              if (!(skipProto && name2 === "prototype") && has.call(object3, name2)) {
                theKeys.push(String(name2));
              }
            }
          }
          if (hasDontEnumBug) {
            var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object3);
            for (var k2 = 0; k2 < dontEnums.length; ++k2) {
              if (!(skipConstructor && dontEnums[k2] === "constructor") && has.call(object3, dontEnums[k2])) {
                theKeys.push(dontEnums[k2]);
              }
            }
          }
          return theKeys;
        };
      }
      var has;
      var toStr;
      var isArgs;
      var isEnumerable;
      var hasDontEnumBug;
      var hasProtoEnumBug;
      var dontEnums;
      var equalsConstructorPrototype;
      var excludedKeys;
      var hasAutomationEqualityBug;
      var equalsConstructorPrototypeIfNotBuggy;
      module2.exports = keysShim;
    }
  });

  // node_modules/object-keys/index.js
  var require_object_keys = __commonJS({
    "node_modules/object-keys/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var slice2 = Array.prototype.slice;
      var isArgs = require_isArguments();
      var origKeys = Object.keys;
      var keysShim = origKeys ? function keys(o) {
        return origKeys(o);
      } : require_implementation2();
      var originalKeys = Object.keys;
      keysShim.shim = function shimObjectKeys() {
        if (Object.keys) {
          var keysWorksWithArguments = function() {
            var args = Object.keys(arguments);
            return args && args.length === arguments.length;
          }(1, 2);
          if (!keysWorksWithArguments) {
            Object.keys = function keys(object3) {
              if (isArgs(object3)) {
                return originalKeys(slice2.call(object3));
              }
              return originalKeys(object3);
            };
          }
        } else {
          Object.keys = keysShim;
        }
        return Object.keys || keysShim;
      };
      module2.exports = keysShim;
    }
  });

  // node_modules/has-property-descriptors/index.js
  var require_has_property_descriptors = __commonJS({
    "node_modules/has-property-descriptors/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var GetIntrinsic = require_get_intrinsic();
      var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
      var hasPropertyDescriptors = function hasPropertyDescriptors2() {
        if ($defineProperty) {
          try {
            $defineProperty({}, "a", { value: 1 });
            return true;
          } catch (e) {
            return false;
          }
        }
        return false;
      };
      hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
        if (!hasPropertyDescriptors()) {
          return null;
        }
        try {
          return $defineProperty([], "length", { value: 1 }).length !== 1;
        } catch (e) {
          return true;
        }
      };
      module2.exports = hasPropertyDescriptors;
    }
  });

  // node_modules/define-properties/index.js
  var require_define_properties = __commonJS({
    "node_modules/define-properties/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var keys = require_object_keys();
      var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
      var toStr = Object.prototype.toString;
      var concat2 = Array.prototype.concat;
      var origDefineProperty = Object.defineProperty;
      var isFunction2 = function(fn2) {
        return typeof fn2 === "function" && toStr.call(fn2) === "[object Function]";
      };
      var hasPropertyDescriptors = require_has_property_descriptors()();
      var supportsDescriptors = origDefineProperty && hasPropertyDescriptors;
      var defineProperty = function(object3, name2, value, predicate) {
        if (name2 in object3) {
          if (predicate === true) {
            if (object3[name2] === value) {
              return;
            }
          } else if (!isFunction2(predicate) || !predicate()) {
            return;
          }
        }
        if (supportsDescriptors) {
          origDefineProperty(object3, name2, {
            configurable: true,
            enumerable: false,
            value,
            writable: true
          });
        } else {
          object3[name2] = value;
        }
      };
      var defineProperties = function(object3, map) {
        var predicates = arguments.length > 2 ? arguments[2] : {};
        var props = keys(map);
        if (hasSymbols) {
          props = concat2.call(props, Object.getOwnPropertySymbols(map));
        }
        for (var i = 0; i < props.length; i += 1) {
          defineProperty(object3, props[i], map[props[i]], predicates[props[i]]);
        }
      };
      defineProperties.supportsDescriptors = !!supportsDescriptors;
      module2.exports = defineProperties;
    }
  });

  // node_modules/object-is/implementation.js
  var require_implementation3 = __commonJS({
    "node_modules/object-is/implementation.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var numberIsNaN = function(value) {
        return value !== value;
      };
      module2.exports = function is4(a, b2) {
        if (a === 0 && b2 === 0) {
          return 1 / a === 1 / b2;
        }
        if (a === b2) {
          return true;
        }
        if (numberIsNaN(a) && numberIsNaN(b2)) {
          return true;
        }
        return false;
      };
    }
  });

  // node_modules/object-is/polyfill.js
  var require_polyfill = __commonJS({
    "node_modules/object-is/polyfill.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var implementation = require_implementation3();
      module2.exports = function getPolyfill() {
        return typeof Object.is === "function" ? Object.is : implementation;
      };
    }
  });

  // node_modules/object-is/shim.js
  var require_shim2 = __commonJS({
    "node_modules/object-is/shim.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var getPolyfill = require_polyfill();
      var define5 = require_define_properties();
      module2.exports = function shimObjectIs() {
        var polyfill = getPolyfill();
        define5(Object, { is: polyfill }, {
          is: function testObjectIs() {
            return Object.is !== polyfill;
          }
        });
        return polyfill;
      };
    }
  });

  // node_modules/object-is/index.js
  var require_object_is = __commonJS({
    "node_modules/object-is/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var define5 = require_define_properties();
      var callBind = require_call_bind();
      var implementation = require_implementation3();
      var getPolyfill = require_polyfill();
      var shim = require_shim2();
      var polyfill = callBind(getPolyfill(), Object);
      define5(polyfill, {
        getPolyfill,
        implementation,
        shim
      });
      module2.exports = polyfill;
    }
  });

  // node_modules/is-nan/implementation.js
  var require_implementation4 = __commonJS({
    "node_modules/is-nan/implementation.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      module2.exports = function isNaN2(value) {
        return value !== value;
      };
    }
  });

  // node_modules/is-nan/polyfill.js
  var require_polyfill2 = __commonJS({
    "node_modules/is-nan/polyfill.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var implementation = require_implementation4();
      module2.exports = function getPolyfill() {
        if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a")) {
          return Number.isNaN;
        }
        return implementation;
      };
    }
  });

  // node_modules/is-nan/shim.js
  var require_shim3 = __commonJS({
    "node_modules/is-nan/shim.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var define5 = require_define_properties();
      var getPolyfill = require_polyfill2();
      module2.exports = function shimNumberIsNaN() {
        var polyfill = getPolyfill();
        define5(Number, { isNaN: polyfill }, {
          isNaN: function testIsNaN() {
            return Number.isNaN !== polyfill;
          }
        });
        return polyfill;
      };
    }
  });

  // node_modules/is-nan/index.js
  var require_is_nan = __commonJS({
    "node_modules/is-nan/index.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var callBind = require_call_bind();
      var define5 = require_define_properties();
      var implementation = require_implementation4();
      var getPolyfill = require_polyfill2();
      var shim = require_shim3();
      var polyfill = callBind(getPolyfill(), Number);
      define5(polyfill, {
        getPolyfill,
        implementation,
        shim
      });
      module2.exports = polyfill;
    }
  });

  // node_modules/assert/build/internal/util/comparisons.js
  var require_comparisons = __commonJS({
    "node_modules/assert/build/internal/util/comparisons.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      function _slicedToArray(arr, i) {
        return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
      }
      function _nonIterableRest() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
      function _iterableToArrayLimit(arr, i) {
        var _arr = [];
        var _n2 = true;
        var _d = false;
        var _e2 = void 0;
        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n2 = (_s = _i.next()).done); _n2 = true) {
            _arr.push(_s.value);
            if (i && _arr.length === i)
              break;
          }
        } catch (err2) {
          _d = true;
          _e2 = err2;
        } finally {
          try {
            if (!_n2 && _i["return"] != null)
              _i["return"]();
          } finally {
            if (_d)
              throw _e2;
          }
        }
        return _arr;
      }
      function _arrayWithHoles(arr) {
        if (Array.isArray(arr))
          return arr;
      }
      function _typeof2(obj) {
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      var regexFlagsSupported = /a/g.flags !== void 0;
      var arrayFromSet = function arrayFromSet2(set) {
        var array6 = [];
        set.forEach(function(value) {
          return array6.push(value);
        });
        return array6;
      };
      var arrayFromMap = function arrayFromMap2(map) {
        var array6 = [];
        map.forEach(function(value, key) {
          return array6.push([key, value]);
        });
        return array6;
      };
      var objectIs = Object.is ? Object.is : require_object_is();
      var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
        return [];
      };
      var numberIsNaN = Number.isNaN ? Number.isNaN : require_is_nan();
      function uncurryThis(f3) {
        return f3.call.bind(f3);
      }
      var hasOwnProperty2 = uncurryThis(Object.prototype.hasOwnProperty);
      var propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
      var objectToString2 = uncurryThis(Object.prototype.toString);
      var _require$types = require_util().types;
      var isAnyArrayBuffer = _require$types.isAnyArrayBuffer;
      var isArrayBufferView = _require$types.isArrayBufferView;
      var isDate2 = _require$types.isDate;
      var isMap = _require$types.isMap;
      var isRegExp2 = _require$types.isRegExp;
      var isSet2 = _require$types.isSet;
      var isNativeError = _require$types.isNativeError;
      var isBoxedPrimitive = _require$types.isBoxedPrimitive;
      var isNumberObject = _require$types.isNumberObject;
      var isStringObject = _require$types.isStringObject;
      var isBooleanObject = _require$types.isBooleanObject;
      var isBigIntObject = _require$types.isBigIntObject;
      var isSymbolObject = _require$types.isSymbolObject;
      var isFloat32Array = _require$types.isFloat32Array;
      var isFloat64Array = _require$types.isFloat64Array;
      function isNonIndex(key) {
        if (key.length === 0 || key.length > 10)
          return true;
        for (var i = 0; i < key.length; i++) {
          var code2 = key.charCodeAt(i);
          if (code2 < 48 || code2 > 57)
            return true;
        }
        return key.length === 10 && key >= Math.pow(2, 32);
      }
      function getOwnNonIndexProperties(value) {
        return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));
      }
      function compare4(a, b2) {
        if (a === b2) {
          return 0;
        }
        var x2 = a.length;
        var y2 = b2.length;
        for (var i = 0, len = Math.min(x2, y2); i < len; ++i) {
          if (a[i] !== b2[i]) {
            x2 = a[i];
            y2 = b2[i];
            break;
          }
        }
        if (x2 < y2) {
          return -1;
        }
        if (y2 < x2) {
          return 1;
        }
        return 0;
      }
      var ONLY_ENUMERABLE = void 0;
      var kStrict = true;
      var kLoose = false;
      var kNoIterator = 0;
      var kIsArray = 1;
      var kIsSet = 2;
      var kIsMap = 3;
      function areSimilarRegExps(a, b2) {
        return regexFlagsSupported ? a.source === b2.source && a.flags === b2.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b2);
      }
      function areSimilarFloatArrays(a, b2) {
        if (a.byteLength !== b2.byteLength) {
          return false;
        }
        for (var offset3 = 0; offset3 < a.byteLength; offset3++) {
          if (a[offset3] !== b2[offset3]) {
            return false;
          }
        }
        return true;
      }
      function areSimilarTypedArrays(a, b2) {
        if (a.byteLength !== b2.byteLength) {
          return false;
        }
        return compare4(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b2.buffer, b2.byteOffset, b2.byteLength)) === 0;
      }
      function areEqualArrayBuffers(buf1, buf2) {
        return buf1.byteLength === buf2.byteLength && compare4(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
      }
      function isEqualBoxedPrimitive(val1, val2) {
        if (isNumberObject(val1)) {
          return isNumberObject(val2) && objectIs(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
        }
        if (isStringObject(val1)) {
          return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
        }
        if (isBooleanObject(val1)) {
          return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
        }
        if (isBigIntObject(val1)) {
          return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
        }
        return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
      }
      function innerDeepEqual(val1, val2, strict, memos) {
        if (val1 === val2) {
          if (val1 !== 0)
            return true;
          return strict ? objectIs(val1, val2) : true;
        }
        if (strict) {
          if (_typeof2(val1) !== "object") {
            return typeof val1 === "number" && numberIsNaN(val1) && numberIsNaN(val2);
          }
          if (_typeof2(val2) !== "object" || val1 === null || val2 === null) {
            return false;
          }
          if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
            return false;
          }
        } else {
          if (val1 === null || _typeof2(val1) !== "object") {
            if (val2 === null || _typeof2(val2) !== "object") {
              return val1 == val2;
            }
            return false;
          }
          if (val2 === null || _typeof2(val2) !== "object") {
            return false;
          }
        }
        var val1Tag = objectToString2(val1);
        var val2Tag = objectToString2(val2);
        if (val1Tag !== val2Tag) {
          return false;
        }
        if (Array.isArray(val1)) {
          if (val1.length !== val2.length) {
            return false;
          }
          var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
          var keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
          if (keys1.length !== keys2.length) {
            return false;
          }
          return keyCheck(val1, val2, strict, memos, kIsArray, keys1);
        }
        if (val1Tag === "[object Object]") {
          if (!isMap(val1) && isMap(val2) || !isSet2(val1) && isSet2(val2)) {
            return false;
          }
        }
        if (isDate2(val1)) {
          if (!isDate2(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {
            return false;
          }
        } else if (isRegExp2(val1)) {
          if (!isRegExp2(val2) || !areSimilarRegExps(val1, val2)) {
            return false;
          }
        } else if (isNativeError(val1) || val1 instanceof Error) {
          if (val1.message !== val2.message || val1.name !== val2.name) {
            return false;
          }
        } else if (isArrayBufferView(val1)) {
          if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
            if (!areSimilarFloatArrays(val1, val2)) {
              return false;
            }
          } else if (!areSimilarTypedArrays(val1, val2)) {
            return false;
          }
          var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
          var _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
          if (_keys.length !== _keys2.length) {
            return false;
          }
          return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);
        } else if (isSet2(val1)) {
          if (!isSet2(val2) || val1.size !== val2.size) {
            return false;
          }
          return keyCheck(val1, val2, strict, memos, kIsSet);
        } else if (isMap(val1)) {
          if (!isMap(val2) || val1.size !== val2.size) {
            return false;
          }
          return keyCheck(val1, val2, strict, memos, kIsMap);
        } else if (isAnyArrayBuffer(val1)) {
          if (!areEqualArrayBuffers(val1, val2)) {
            return false;
          }
        } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {
          return false;
        }
        return keyCheck(val1, val2, strict, memos, kNoIterator);
      }
      function getEnumerables(val, keys) {
        return keys.filter(function(k2) {
          return propertyIsEnumerable(val, k2);
        });
      }
      function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
        if (arguments.length === 5) {
          aKeys = Object.keys(val1);
          var bKeys = Object.keys(val2);
          if (aKeys.length !== bKeys.length) {
            return false;
          }
        }
        var i = 0;
        for (; i < aKeys.length; i++) {
          if (!hasOwnProperty2(val2, aKeys[i])) {
            return false;
          }
        }
        if (strict && arguments.length === 5) {
          var symbolKeysA = objectGetOwnPropertySymbols(val1);
          if (symbolKeysA.length !== 0) {
            var count = 0;
            for (i = 0; i < symbolKeysA.length; i++) {
              var key = symbolKeysA[i];
              if (propertyIsEnumerable(val1, key)) {
                if (!propertyIsEnumerable(val2, key)) {
                  return false;
                }
                aKeys.push(key);
                count++;
              } else if (propertyIsEnumerable(val2, key)) {
                return false;
              }
            }
            var symbolKeysB = objectGetOwnPropertySymbols(val2);
            if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
              return false;
            }
          } else {
            var _symbolKeysB = objectGetOwnPropertySymbols(val2);
            if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) {
              return false;
            }
          }
        }
        if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {
          return true;
        }
        if (memos === void 0) {
          memos = {
            val1: /* @__PURE__ */ new Map(),
            val2: /* @__PURE__ */ new Map(),
            position: 0
          };
        } else {
          var val2MemoA = memos.val1.get(val1);
          if (val2MemoA !== void 0) {
            var val2MemoB = memos.val2.get(val2);
            if (val2MemoB !== void 0) {
              return val2MemoA === val2MemoB;
            }
          }
          memos.position++;
        }
        memos.val1.set(val1, memos.position);
        memos.val2.set(val2, memos.position);
        var areEq = objEquiv2(val1, val2, strict, aKeys, memos, iterationType);
        memos.val1.delete(val1);
        memos.val2.delete(val2);
        return areEq;
      }
      function setHasEqualElement(set, val1, strict, memo) {
        var setValues = arrayFromSet(set);
        for (var i = 0; i < setValues.length; i++) {
          var val2 = setValues[i];
          if (innerDeepEqual(val1, val2, strict, memo)) {
            set.delete(val2);
            return true;
          }
        }
        return false;
      }
      function findLooseMatchingPrimitives(prim) {
        switch (_typeof2(prim)) {
          case "undefined":
            return null;
          case "object":
            return void 0;
          case "symbol":
            return false;
          case "string":
            prim = +prim;
          case "number":
            if (numberIsNaN(prim)) {
              return false;
            }
        }
        return true;
      }
      function setMightHaveLoosePrim(a, b2, prim) {
        var altValue = findLooseMatchingPrimitives(prim);
        if (altValue != null)
          return altValue;
        return b2.has(altValue) && !a.has(altValue);
      }
      function mapMightHaveLoosePrim(a, b2, prim, item, memo) {
        var altValue = findLooseMatchingPrimitives(prim);
        if (altValue != null) {
          return altValue;
        }
        var curB = b2.get(altValue);
        if (curB === void 0 && !b2.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
          return false;
        }
        return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);
      }
      function setEquiv(a, b2, strict, memo) {
        var set = null;
        var aValues = arrayFromSet(a);
        for (var i = 0; i < aValues.length; i++) {
          var val = aValues[i];
          if (_typeof2(val) === "object" && val !== null) {
            if (set === null) {
              set = /* @__PURE__ */ new Set();
            }
            set.add(val);
          } else if (!b2.has(val)) {
            if (strict)
              return false;
            if (!setMightHaveLoosePrim(a, b2, val)) {
              return false;
            }
            if (set === null) {
              set = /* @__PURE__ */ new Set();
            }
            set.add(val);
          }
        }
        if (set !== null) {
          var bValues = arrayFromSet(b2);
          for (var _i = 0; _i < bValues.length; _i++) {
            var _val = bValues[_i];
            if (_typeof2(_val) === "object" && _val !== null) {
              if (!setHasEqualElement(set, _val, strict, memo))
                return false;
            } else if (!strict && !a.has(_val) && !setHasEqualElement(set, _val, strict, memo)) {
              return false;
            }
          }
          return set.size === 0;
        }
        return true;
      }
      function mapHasEqualEntry(set, map, key1, item1, strict, memo) {
        var setValues = arrayFromSet(set);
        for (var i = 0; i < setValues.length; i++) {
          var key2 = setValues[i];
          if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map.get(key2), strict, memo)) {
            set.delete(key2);
            return true;
          }
        }
        return false;
      }
      function mapEquiv(a, b2, strict, memo) {
        var set = null;
        var aEntries = arrayFromMap(a);
        for (var i = 0; i < aEntries.length; i++) {
          var _aEntries$i = _slicedToArray(aEntries[i], 2), key = _aEntries$i[0], item1 = _aEntries$i[1];
          if (_typeof2(key) === "object" && key !== null) {
            if (set === null) {
              set = /* @__PURE__ */ new Set();
            }
            set.add(key);
          } else {
            var item2 = b2.get(key);
            if (item2 === void 0 && !b2.has(key) || !innerDeepEqual(item1, item2, strict, memo)) {
              if (strict)
                return false;
              if (!mapMightHaveLoosePrim(a, b2, key, item1, memo))
                return false;
              if (set === null) {
                set = /* @__PURE__ */ new Set();
              }
              set.add(key);
            }
          }
        }
        if (set !== null) {
          var bEntries = arrayFromMap(b2);
          for (var _i2 = 0; _i2 < bEntries.length; _i2++) {
            var _bEntries$_i = _slicedToArray(bEntries[_i2], 2), key = _bEntries$_i[0], item = _bEntries$_i[1];
            if (_typeof2(key) === "object" && key !== null) {
              if (!mapHasEqualEntry(set, a, key, item, strict, memo))
                return false;
            } else if (!strict && (!a.has(key) || !innerDeepEqual(a.get(key), item, false, memo)) && !mapHasEqualEntry(set, a, key, item, false, memo)) {
              return false;
            }
          }
          return set.size === 0;
        }
        return true;
      }
      function objEquiv2(a, b2, strict, keys, memos, iterationType) {
        var i = 0;
        if (iterationType === kIsSet) {
          if (!setEquiv(a, b2, strict, memos)) {
            return false;
          }
        } else if (iterationType === kIsMap) {
          if (!mapEquiv(a, b2, strict, memos)) {
            return false;
          }
        } else if (iterationType === kIsArray) {
          for (; i < a.length; i++) {
            if (hasOwnProperty2(a, i)) {
              if (!hasOwnProperty2(b2, i) || !innerDeepEqual(a[i], b2[i], strict, memos)) {
                return false;
              }
            } else if (hasOwnProperty2(b2, i)) {
              return false;
            } else {
              var keysA = Object.keys(a);
              for (; i < keysA.length; i++) {
                var key = keysA[i];
                if (!hasOwnProperty2(b2, key) || !innerDeepEqual(a[key], b2[key], strict, memos)) {
                  return false;
                }
              }
              if (keysA.length !== Object.keys(b2).length) {
                return false;
              }
              return true;
            }
          }
        }
        for (i = 0; i < keys.length; i++) {
          var _key = keys[i];
          if (!innerDeepEqual(a[_key], b2[_key], strict, memos)) {
            return false;
          }
        }
        return true;
      }
      function isDeepEqual(val1, val2) {
        return innerDeepEqual(val1, val2, kLoose);
      }
      function isDeepStrictEqual(val1, val2) {
        return innerDeepEqual(val1, val2, kStrict);
      }
      module2.exports = {
        isDeepEqual,
        isDeepStrictEqual
      };
    }
  });

  // node_modules/assert/build/assert.js
  var require_assert = __commonJS({
    "node_modules/assert/build/assert.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      function _typeof2(obj) {
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck(instance2, Constructor) {
        if (!(instance2 instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      var _require = require_errors();
      var _require$codes = _require.codes;
      var ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE;
      var ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE;
      var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
      var AssertionError2 = require_assertion_error();
      var _require2 = require_util();
      var inspect2 = _require2.inspect;
      var _require$types = require_util().types;
      var isPromise = _require$types.isPromise;
      var isRegExp2 = _require$types.isRegExp;
      var objectAssign = Object.assign ? Object.assign : require_es6_object_assign().assign;
      var objectIs = Object.is ? Object.is : require_object_is();
      var isDeepEqual;
      var isDeepStrictEqual;
      function lazyLoadComparison() {
        var comparison = require_comparisons();
        isDeepEqual = comparison.isDeepEqual;
        isDeepStrictEqual = comparison.isDeepStrictEqual;
      }
      var warned = false;
      var assert7 = module2.exports = ok3;
      var NO_EXCEPTION_SENTINEL = {};
      function innerFail(obj) {
        if (obj.message instanceof Error)
          throw obj.message;
        throw new AssertionError2(obj);
      }
      function fail2(actual, expected, message, operator, stackStartFn) {
        var argsLen = arguments.length;
        var internalMessage;
        if (argsLen === 0) {
          internalMessage = "Failed";
        } else if (argsLen === 1) {
          message = actual;
          actual = void 0;
        } else {
          if (warned === false) {
            warned = true;
            var warn = process.emitWarning ? process.emitWarning : console.warn.bind(console);
            warn("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
          }
          if (argsLen === 2)
            operator = "!=";
        }
        if (message instanceof Error)
          throw message;
        var errArgs = {
          actual,
          expected,
          operator: operator === void 0 ? "fail" : operator,
          stackStartFn: stackStartFn || fail2
        };
        if (message !== void 0) {
          errArgs.message = message;
        }
        var err2 = new AssertionError2(errArgs);
        if (internalMessage) {
          err2.message = internalMessage;
          err2.generatedMessage = true;
        }
        throw err2;
      }
      assert7.fail = fail2;
      assert7.AssertionError = AssertionError2;
      function innerOk(fn2, argLen, value, message) {
        if (!value) {
          var generatedMessage = false;
          if (argLen === 0) {
            generatedMessage = true;
            message = "No value argument passed to `assert.ok()`";
          } else if (message instanceof Error) {
            throw message;
          }
          var err2 = new AssertionError2({
            actual: value,
            expected: true,
            message,
            operator: "==",
            stackStartFn: fn2
          });
          err2.generatedMessage = generatedMessage;
          throw err2;
        }
      }
      function ok3() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        innerOk.apply(void 0, [ok3, args.length].concat(args));
      }
      assert7.ok = ok3;
      assert7.equal = function equal2(actual, expected, message) {
        if (arguments.length < 2) {
          throw new ERR_MISSING_ARGS("actual", "expected");
        }
        if (actual != expected) {
          innerFail({
            actual,
            expected,
            message,
            operator: "==",
            stackStartFn: equal2
          });
        }
      };
      assert7.notEqual = function notEqual2(actual, expected, message) {
        if (arguments.length < 2) {
          throw new ERR_MISSING_ARGS("actual", "expected");
        }
        if (actual == expected) {
          innerFail({
            actual,
            expected,
            message,
            operator: "!=",
            stackStartFn: notEqual2
          });
        }
      };
      assert7.deepEqual = function deepEqual2(actual, expected, message) {
        if (arguments.length < 2) {
          throw new ERR_MISSING_ARGS("actual", "expected");
        }
        if (isDeepEqual === void 0)
          lazyLoadComparison();
        if (!isDeepEqual(actual, expected)) {
          innerFail({
            actual,
            expected,
            message,
            operator: "deepEqual",
            stackStartFn: deepEqual2
          });
        }
      };
      assert7.notDeepEqual = function notDeepEqual2(actual, expected, message) {
        if (arguments.length < 2) {
          throw new ERR_MISSING_ARGS("actual", "expected");
        }
        if (isDeepEqual === void 0)
          lazyLoadComparison();
        if (isDeepEqual(actual, expected)) {
          innerFail({
            actual,
            expected,
            message,
            operator: "notDeepEqual",
            stackStartFn: notDeepEqual2
          });
        }
      };
      assert7.deepStrictEqual = function deepStrictEqual2(actual, expected, message) {
        if (arguments.length < 2) {
          throw new ERR_MISSING_ARGS("actual", "expected");
        }
        if (isDeepEqual === void 0)
          lazyLoadComparison();
        if (!isDeepStrictEqual(actual, expected)) {
          innerFail({
            actual,
            expected,
            message,
            operator: "deepStrictEqual",
            stackStartFn: deepStrictEqual2
          });
        }
      };
      assert7.notDeepStrictEqual = notDeepStrictEqual2;
      function notDeepStrictEqual2(actual, expected, message) {
        if (arguments.length < 2) {
          throw new ERR_MISSING_ARGS("actual", "expected");
        }
        if (isDeepEqual === void 0)
          lazyLoadComparison();
        if (isDeepStrictEqual(actual, expected)) {
          innerFail({
            actual,
            expected,
            message,
            operator: "notDeepStrictEqual",
            stackStartFn: notDeepStrictEqual2
          });
        }
      }
      assert7.strictEqual = function strictEqual2(actual, expected, message) {
        if (arguments.length < 2) {
          throw new ERR_MISSING_ARGS("actual", "expected");
        }
        if (!objectIs(actual, expected)) {
          innerFail({
            actual,
            expected,
            message,
            operator: "strictEqual",
            stackStartFn: strictEqual2
          });
        }
      };
      assert7.notStrictEqual = function notStrictEqual2(actual, expected, message) {
        if (arguments.length < 2) {
          throw new ERR_MISSING_ARGS("actual", "expected");
        }
        if (objectIs(actual, expected)) {
          innerFail({
            actual,
            expected,
            message,
            operator: "notStrictEqual",
            stackStartFn: notStrictEqual2
          });
        }
      };
      var Comparison = function Comparison2(obj, keys, actual) {
        var _this = this;
        _classCallCheck(this, Comparison2);
        keys.forEach(function(key) {
          if (key in obj) {
            if (actual !== void 0 && typeof actual[key] === "string" && isRegExp2(obj[key]) && obj[key].test(actual[key])) {
              _this[key] = actual[key];
            } else {
              _this[key] = obj[key];
            }
          }
        });
      };
      function compareExceptionKey(actual, expected, key, message, keys, fn2) {
        if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {
          if (!message) {
            var a = new Comparison(actual, keys);
            var b2 = new Comparison(expected, keys, actual);
            var err2 = new AssertionError2({
              actual: a,
              expected: b2,
              operator: "deepStrictEqual",
              stackStartFn: fn2
            });
            err2.actual = actual;
            err2.expected = expected;
            err2.operator = fn2.name;
            throw err2;
          }
          innerFail({
            actual,
            expected,
            message,
            operator: fn2.name,
            stackStartFn: fn2
          });
        }
      }
      function expectedException2(actual, expected, msg, fn2) {
        if (typeof expected !== "function") {
          if (isRegExp2(expected))
            return expected.test(actual);
          if (arguments.length === 2) {
            throw new ERR_INVALID_ARG_TYPE("expected", ["Function", "RegExp"], expected);
          }
          if (_typeof2(actual) !== "object" || actual === null) {
            var err2 = new AssertionError2({
              actual,
              expected,
              message: msg,
              operator: "deepStrictEqual",
              stackStartFn: fn2
            });
            err2.operator = fn2.name;
            throw err2;
          }
          var keys = Object.keys(expected);
          if (expected instanceof Error) {
            keys.push("name", "message");
          } else if (keys.length === 0) {
            throw new ERR_INVALID_ARG_VALUE("error", expected, "may not be an empty object");
          }
          if (isDeepEqual === void 0)
            lazyLoadComparison();
          keys.forEach(function(key) {
            if (typeof actual[key] === "string" && isRegExp2(expected[key]) && expected[key].test(actual[key])) {
              return;
            }
            compareExceptionKey(actual, expected, key, msg, keys, fn2);
          });
          return true;
        }
        if (expected.prototype !== void 0 && actual instanceof expected) {
          return true;
        }
        if (Error.isPrototypeOf(expected)) {
          return false;
        }
        return expected.call({}, actual) === true;
      }
      function getActual(fn2) {
        if (typeof fn2 !== "function") {
          throw new ERR_INVALID_ARG_TYPE("fn", "Function", fn2);
        }
        try {
          fn2();
        } catch (e) {
          return e;
        }
        return NO_EXCEPTION_SENTINEL;
      }
      function checkIsPromise(obj) {
        return isPromise(obj) || obj !== null && _typeof2(obj) === "object" && typeof obj.then === "function" && typeof obj.catch === "function";
      }
      function waitForActual(promiseFn) {
        return Promise.resolve().then(function() {
          var resultPromise;
          if (typeof promiseFn === "function") {
            resultPromise = promiseFn();
            if (!checkIsPromise(resultPromise)) {
              throw new ERR_INVALID_RETURN_VALUE("instance of Promise", "promiseFn", resultPromise);
            }
          } else if (checkIsPromise(promiseFn)) {
            resultPromise = promiseFn;
          } else {
            throw new ERR_INVALID_ARG_TYPE("promiseFn", ["Function", "Promise"], promiseFn);
          }
          return Promise.resolve().then(function() {
            return resultPromise;
          }).then(function() {
            return NO_EXCEPTION_SENTINEL;
          }).catch(function(e) {
            return e;
          });
        });
      }
      function expectsError(stackStartFn, actual, error2, message) {
        if (typeof error2 === "string") {
          if (arguments.length === 4) {
            throw new ERR_INVALID_ARG_TYPE("error", ["Object", "Error", "Function", "RegExp"], error2);
          }
          if (_typeof2(actual) === "object" && actual !== null) {
            if (actual.message === error2) {
              throw new ERR_AMBIGUOUS_ARGUMENT("error/message", 'The error message "'.concat(actual.message, '" is identical to the message.'));
            }
          } else if (actual === error2) {
            throw new ERR_AMBIGUOUS_ARGUMENT("error/message", 'The error "'.concat(actual, '" is identical to the message.'));
          }
          message = error2;
          error2 = void 0;
        } else if (error2 != null && _typeof2(error2) !== "object" && typeof error2 !== "function") {
          throw new ERR_INVALID_ARG_TYPE("error", ["Object", "Error", "Function", "RegExp"], error2);
        }
        if (actual === NO_EXCEPTION_SENTINEL) {
          var details = "";
          if (error2 && error2.name) {
            details += " (".concat(error2.name, ")");
          }
          details += message ? ": ".concat(message) : ".";
          var fnType = stackStartFn.name === "rejects" ? "rejection" : "exception";
          innerFail({
            actual: void 0,
            expected: error2,
            operator: stackStartFn.name,
            message: "Missing expected ".concat(fnType).concat(details),
            stackStartFn
          });
        }
        if (error2 && !expectedException2(actual, error2, message, stackStartFn)) {
          throw actual;
        }
      }
      function expectsNoError(stackStartFn, actual, error2, message) {
        if (actual === NO_EXCEPTION_SENTINEL)
          return;
        if (typeof error2 === "string") {
          message = error2;
          error2 = void 0;
        }
        if (!error2 || expectedException2(actual, error2)) {
          var details = message ? ": ".concat(message) : ".";
          var fnType = stackStartFn.name === "doesNotReject" ? "rejection" : "exception";
          innerFail({
            actual,
            expected: error2,
            operator: stackStartFn.name,
            message: "Got unwanted ".concat(fnType).concat(details, "\n") + 'Actual message: "'.concat(actual && actual.message, '"'),
            stackStartFn
          });
        }
        throw actual;
      }
      assert7.throws = function throws2(promiseFn) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        expectsError.apply(void 0, [throws2, getActual(promiseFn)].concat(args));
      };
      assert7.rejects = function rejects(promiseFn) {
        for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          args[_key3 - 1] = arguments[_key3];
        }
        return waitForActual(promiseFn).then(function(result) {
          return expectsError.apply(void 0, [rejects, result].concat(args));
        });
      };
      assert7.doesNotThrow = function doesNotThrow2(fn2) {
        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
          args[_key4 - 1] = arguments[_key4];
        }
        expectsNoError.apply(void 0, [doesNotThrow2, getActual(fn2)].concat(args));
      };
      assert7.doesNotReject = function doesNotReject(fn2) {
        for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
          args[_key5 - 1] = arguments[_key5];
        }
        return waitForActual(fn2).then(function(result) {
          return expectsNoError.apply(void 0, [doesNotReject, result].concat(args));
        });
      };
      assert7.ifError = function ifError2(err2) {
        if (err2 !== null && err2 !== void 0) {
          var message = "ifError got unwanted exception: ";
          if (_typeof2(err2) === "object" && typeof err2.message === "string") {
            if (err2.message.length === 0 && err2.constructor) {
              message += err2.constructor.name;
            } else {
              message += err2.message;
            }
          } else {
            message += inspect2(err2);
          }
          var newErr = new AssertionError2({
            actual: err2,
            expected: null,
            operator: "ifError",
            message,
            stackStartFn: ifError2
          });
          var origStack = err2.stack;
          if (typeof origStack === "string") {
            var tmp2 = origStack.split("\n");
            tmp2.shift();
            var tmp1 = newErr.stack.split("\n");
            for (var i = 0; i < tmp2.length; i++) {
              var pos = tmp1.indexOf(tmp2[i]);
              if (pos !== -1) {
                tmp1 = tmp1.slice(0, pos);
                break;
              }
            }
            newErr.stack = "".concat(tmp1.join("\n"), "\n").concat(tmp2.join("\n"));
          }
          throw newErr;
        }
      };
      function strict() {
        for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
          args[_key6] = arguments[_key6];
        }
        innerOk.apply(void 0, [strict, args.length].concat(args));
      }
      assert7.strict = objectAssign(strict, assert7, {
        equal: assert7.strictEqual,
        deepEqual: assert7.deepStrictEqual,
        notEqual: assert7.notStrictEqual,
        notDeepEqual: assert7.notDeepStrictEqual
      });
      assert7.strict.strict = assert7.strict;
    }
  });

  // node_modules/@project-serum/anchor/dist/browser/index.js
  var browser_exports = {};
  __export(browser_exports, {
    ACCOUNT_DISCRIMINATOR_SIZE: () => Dt,
    AccountClient: () => En,
    AnchorError: () => vt,
    AnchorProvider: () => st,
    BN: () => import_bn5.default,
    BorshAccountsCoder: () => Nt,
    BorshCoder: () => Kt,
    BorshEventCoder: () => Rt,
    BorshInstructionCoder: () => Tt,
    BorshStateCoder: () => Ut,
    EventManager: () => xn,
    EventParser: () => Pn,
    IdlError: () => gt,
    LangErrorCode: () => _t,
    LangErrorMessage: () => St,
    MethodsBuilderFactory: () => Nn,
    Native: () => Yn,
    Program: () => Vn,
    ProgramError: () => bt,
    ProgramErrorStack: () => wt,
    Spl: () => Jn,
    SplTokenCoder: () => Ne,
    StateClient: () => _n,
    SystemCoder: () => Qe,
    eventDiscriminator: () => Vt,
    getProvider: () => lt,
    parseIdlErrors: () => M,
    setProvider: () => dt,
    splitArgsAndCtx: () => wn,
    stateDiscriminator: () => jt,
    toInstruction: () => x,
    translateAddress: () => L,
    translateError: () => At,
    utils: () => yn,
    validateAccounts: () => P,
    web3: () => index_browser_esm_exports
  });
  function v(t2) {
    return new TextDecoder("utf-8").decode(t2);
  }
  function b(t2) {
    return new TextEncoder().encode(t2);
  }
  function _(t2) {
    return import_bs583.default.encode(t2);
  }
  function E(e) {
    return import_buffer91.Buffer.from(l.toByteArray(e));
  }
  function M(t2) {
    const e = /* @__PURE__ */ new Map();
    return t2.errors && t2.errors.forEach((t3) => {
      var n;
      let r = null !== (n = t3.msg) && void 0 !== n ? n : t3.name;
      e.set(t3.code, r);
    }), e;
  }
  function x(t2, ...e) {
    if (t2.args.length != e.length)
      throw new Error("Invalid argument length");
    const n = {};
    let r = 0;
    return t2.args.forEach((t3) => {
      n[t3.name] = e[r], r += 1;
    }), n;
  }
  function P(t2, e = {}) {
    t2.forEach((t3) => {
      if ("accounts" in t3)
        P(t3.accounts, e[t3.name]);
      else if (void 0 === e[t3.name])
        throw new Error(`Invalid arguments: ${t3.name} not provided.`);
    });
  }
  function L(t2) {
    return t2 instanceof PublicKey ? t2 : new PublicKey(t2);
  }
  function C(t2) {
    return "object" == typeof t2 && null != t2;
  }
  function z(t2) {
    return "string" == typeof t2 ? JSON.stringify(t2) : "" + t2;
  }
  function B(t2, e, n, r) {
    if (true === t2)
      return;
    false === t2 ? t2 = {} : "string" == typeof t2 && (t2 = { message: t2 });
    const { path: o, branch: i } = e, { type: s } = n, { refinement: a, message: c2 = "Expected a value of type `" + s + "`" + (a ? " with refinement `" + a + "`" : "") + ", but received: `" + z(r) + "`" } = t2;
    return { value: r, type: s, refinement: a, key: o[o.length - 1], path: o, branch: i, ...t2, message: c2 };
  }
  function* O(t2, e, n, r) {
    var o;
    C(o = t2) && "function" == typeof o[Symbol.iterator] || (t2 = [t2]);
    for (const o2 of t2) {
      const t3 = B(o2, e, n, r);
      t3 && (yield t3);
    }
  }
  function* D(t2, e, n) {
    void 0 === n && (n = {});
    const { path: r = [], branch: o = [t2], coerce: i = false, mask: s = false } = n, a = { path: r, branch: o };
    if (i && (t2 = e.coercer(t2, a), s && "type" !== e.type && C(e.schema) && C(t2) && !Array.isArray(t2)))
      for (const n2 in t2)
        void 0 === e.schema[n2] && delete t2[n2];
    let c2 = true;
    for (const n2 of e.validator(t2, a))
      c2 = false, yield [n2, void 0];
    for (let [n2, u2, d2] of e.entries(t2, a)) {
      const e2 = D(u2, d2, { path: void 0 === n2 ? r : [...r, n2], branch: void 0 === n2 ? o : [...o, u2], coerce: i, mask: s });
      for (const r2 of e2)
        r2[0] ? (c2 = false, yield [r2[0], void 0]) : i && (u2 = r2[1], void 0 === n2 ? t2 = u2 : t2 instanceof Map ? t2.set(n2, u2) : t2 instanceof Set ? t2.add(u2) : C(t2) && (t2[n2] = u2));
    }
    if (c2)
      for (const n2 of e.refiner(t2, a))
        c2 = false, yield [n2, void 0];
    c2 && (yield [void 0, t2]);
  }
  function R(t2, e) {
    const n = U(t2, e, { coerce: true });
    if (n[0])
      throw n[0];
    return n[1];
  }
  function V(t2, e) {
    return !U(t2, e)[0];
  }
  function U(t2, e, n) {
    void 0 === n && (n = {});
    const r = D(t2, e, n), o = function(t3) {
      const { done: e2, value: n2 } = t3.next();
      return e2 ? void 0 : n2;
    }(r);
    if (o[0]) {
      return [new T(o[0], function* () {
        for (const t3 of r)
          t3[0] && (yield t3[0]);
      }), void 0];
    }
    return [void 0, o[1]];
  }
  function j(t2, e) {
    return new N({ type: t2, schema: null, validator: e });
  }
  function $(t2) {
    return new N({ type: "array", schema: t2, *entries(e) {
      if (t2 && Array.isArray(e))
        for (const [n, r] of e.entries())
          yield [n, r, t2];
    }, coercer: (t3) => Array.isArray(t3) ? t3.slice() : t3, validator: (t3) => Array.isArray(t3) || "Expected an array value, but received: " + z(t3) });
  }
  function K2(t2) {
    const e = z(t2), n = typeof t2;
    return new N({ type: "literal", schema: "string" === n || "number" === n || "boolean" === n ? t2 : null, validator: (n2) => n2 === t2 || "Expected the literal `" + e + "`, but received: " + z(n2) });
  }
  function q(t2) {
    return new N({ ...t2, validator: (e, n) => null === e || t2.validator(e, n), refiner: (e, n) => null === e || t2.refiner(e, n) });
  }
  function F() {
    return j("number", (t2) => "number" == typeof t2 && !isNaN(t2) || "Expected a number, but received: " + z(t2));
  }
  function W(t2) {
    return new N({ ...t2, validator: (e, n) => void 0 === e || t2.validator(e, n), refiner: (e, n) => void 0 === e || t2.refiner(e, n) });
  }
  function G() {
    return j("string", (t2) => "string" == typeof t2 || "Expected a string, but received: " + z(t2));
  }
  function H(t2) {
    const e = Object.keys(t2);
    return new N({ type: "type", schema: t2, *entries(n) {
      if (C(n))
        for (const r of e)
          yield [r, n[r], t2[r]];
    }, validator: (t3) => C(t3) || "Expected an object, but received: " + z(t3) });
  }
  function J(t2) {
    const e = t2.map((t3) => t3.type).join(" | ");
    return new N({ type: "union", schema: null, coercer: (e2, n) => (t2.find((t3) => {
      const [n2] = t3.validate(e2, { coerce: true });
      return !n2;
    }) || Z()).coercer(e2, n), validator(n, r) {
      const o = [];
      for (const e2 of t2) {
        const [...t3] = D(n, e2, r), [i] = t3;
        if (!i[0])
          return [];
        for (const [e3] of t3)
          e3 && o.push(e3);
      }
      return ["Expected the value to satisfy a union of `" + e + "`, but received: " + z(n), ...o];
    } });
  }
  function Z() {
    return j("unknown", () => true);
  }
  async function X(t2, e, n) {
    if (e.length <= 99)
      return await Q(t2, e, n);
    {
      const r = function(t3, e2) {
        return Array.apply(0, new Array(Math.ceil(t3.length / e2))).map((n2, r2) => t3.slice(r2 * e2, (r2 + 1) * e2));
      }(e, 99);
      return (await Promise.all(r.map((e2) => Q(t2, e2, n)))).flat();
    }
  }
  async function Q(t2, e, n) {
    const r = null != n ? n : t2.commitment;
    return (await t2.getMultipleAccountsInfo(e, r)).map((t3, n2) => null === t3 ? null : { publicKey: e[n2], account: t3 });
  }
  async function Y(t2, e, n, r, i) {
    n && n.length > 0 && e.sign(...n);
    const s = e._compile(), a = s.serialize(), c2 = e._serialize(a).toString("base64"), u2 = { encoding: "base64", commitment: null != r ? r : t2.commitment };
    if (i) {
      const t3 = (Array.isArray(i) ? i : s.nonProgramIds()).map((t4) => t4.toBase58());
      u2.accounts = { encoding: "base64", addresses: t3 };
    }
    n && (u2.sigVerify = true);
    const d2 = [c2, u2], l2 = R(await t2._rpcRequest("simulateTransaction", d2), rt);
    if ("error" in l2) {
      let t3;
      if ("data" in l2.error && (t3 = l2.error.data.logs, t3 && Array.isArray(t3))) {
        const e2 = "\n    ", n2 = e2 + t3.join(e2);
        console.error(l2.error.message, n2);
      }
      throw new SendTransactionError("failed to simulate transaction: " + l2.error.message, t3);
    }
    return l2.result;
  }
  function tt(t2) {
    return function(t3, e, n) {
      return new N({ ...t3, coercer: (r, o) => V(r, e) ? t3.coercer(n(r, o), o) : t3.coercer(r, o) });
    }(nt(t2), et, (e) => "error" in e ? e : { ...e, result: R(e.result, t2) });
  }
  function nt(t2) {
    return J([H({ jsonrpc: K2("2.0"), id: G(), result: t2 }), H({ jsonrpc: K2("2.0"), id: G(), error: H({ code: Z(), message: G(), data: W(j("any", () => true)) }) })]);
  }
  async function ct(t2, e, n) {
    const r = n && { skipPreflight: n.skipPreflight, preflightCommitment: n.preflightCommitment || n.commitment }, o = await t2.sendRawTransaction(e, r), i = (await t2.confirmTransaction(o, n && n.commitment)).value;
    if (i.err)
      throw new ut(`Raw transaction ${o} failed (${JSON.stringify(i)})`);
    return o;
  }
  function dt(t2) {
    ht = t2;
  }
  function lt() {
    return null === ht ? st.local() : ht;
  }
  function mt(t2) {
    return void 0 !== ft.get(t2);
  }
  function At(t2, e) {
    mt("debug-logs") && console.log("Translating error:", t2);
    const n = vt.parse(t2.logs);
    if (n)
      return n;
    const r = bt.parse(t2, e);
    if (r)
      return r;
    if (t2.logs) {
      const e2 = { get: function(e3, n2) {
        return "programErrorStack" === n2 ? e3.programErrorStack.stack : "program" === n2 ? e3.programErrorStack.stack[t2.programErrorStack.stack.length - 1] : Reflect.get(...arguments);
      } };
      return t2.programErrorStack = wt.parse(t2.logs), new Proxy(t2, e2);
    }
    return t2;
  }
  function It(t2) {
    return t2.toLowerCase();
  }
  function xt(t2, e, n) {
    return e instanceof RegExp ? t2.replace(e, n) : e.reduce(function(t3, e2) {
      return t3.replace(e2, n);
    }, t2);
  }
  function Pt(t2, e) {
    return void 0 === e && (e = {}), function(t3, e2) {
      void 0 === e2 && (e2 = {});
      for (var n = e2.splitRegexp, r = void 0 === n ? kt : n, o = e2.stripRegexp, i = void 0 === o ? Mt : o, s = e2.transform, a = void 0 === s ? It : s, c2 = e2.delimiter, u2 = void 0 === c2 ? " " : c2, d2 = xt(xt(t3, r, "$1\0$2"), i, "\0"), l2 = 0, h2 = d2.length; "\0" === d2.charAt(l2); )
        l2++;
      for (; "\0" === d2.charAt(h2 - 1); )
        h2--;
      return d2.slice(l2, h2).split("\0").map(a).join(u2);
    }(t2, Et({ delimiter: "." }, e));
  }
  function zt(e, n) {
    var r;
    let o = `${e}:${void 0 === r && (r = {}), Pt(n, Et({ delimiter: "_" }, r))}`;
    return import_buffer91.Buffer.from(import_js_sha2562.sha256.digest(o)).slice(0, 8);
  }
  function Bt(t2, e) {
    if ("enum" === e.type.kind) {
      let n = e.type.variants.map((e2) => void 0 === e2.fields ? 0 : e2.fields.map((e3) => {
        if ("object" != typeof e3 || !("name" in e3))
          throw new Error("Tuple enum variants not yet implemented.");
        return Ot(t2, e3.type);
      }).reduce((t3, e3) => t3 + e3));
      return Math.max(...n) + 1;
    }
    return void 0 === e.type.fields ? 0 : e.type.fields.map((e2) => Ot(t2, e2.type)).reduce((t3, e2) => t3 + e2, 0);
  }
  function Ot(t2, e) {
    var n, r;
    switch (e) {
      case "bool":
      case "u8":
      case "i8":
      case "bytes":
      case "string":
        return 1;
      case "i16":
      case "u16":
        return 2;
      case "u32":
      case "i32":
      case "f32":
        return 4;
      case "u64":
      case "i64":
      case "f64":
        return 8;
      case "u128":
      case "i128":
        return 16;
      case "publicKey":
        return 32;
      default:
        if ("vec" in e)
          return 1;
        if ("option" in e)
          return 1 + Ot(t2, e.option);
        if ("coption" in e)
          return 4 + Ot(t2, e.coption);
        if ("defined" in e) {
          const o = null !== (r = null === (n = t2.types) || void 0 === n ? void 0 : n.filter((t3) => t3.name === e.defined)) && void 0 !== r ? r : [];
          if (1 !== o.length)
            throw new gt(`Type not found: ${JSON.stringify(e)}`);
          return Bt(t2, o[0]);
        }
        if ("array" in e) {
          let n2 = e.array[0], r2 = e.array[1];
          return Ot(t2, n2) * r2;
        }
        throw new Error(`Invalid type ${JSON.stringify(e)}`);
    }
  }
  function Vt(e) {
    return import_buffer91.Buffer.from(import_js_sha2562.sha256.digest(`event:${e}`)).slice(0, 8);
  }
  async function jt(e) {
    let n = mt("anchor-deprecated-state") ? "account" : "state";
    return import_buffer91.Buffer.from(import_js_sha2562.sha256.digest(`${n}:${e}`)).slice(0, 8);
  }
  function Ft(t2) {
    return t2 && t2.__esModule && Object.prototype.hasOwnProperty.call(t2, "default") ? t2.default : t2;
  }
  function Yt(t2) {
    const e = Math.floor(t2 / Qt);
    return { hi32: e, lo32: t2 - e * Qt };
  }
  function te(t2, e) {
    return t2 * Qt + e;
  }
  function ve(t2) {
    return ye(32, t2);
  }
  function be(t2) {
    let e = Buffer.alloc(Ae), n = we.encode(t2, e);
    return e.slice(0, n);
  }
  function Se(t2) {
    return new ke(ye(8), (t3) => Le.fromBuffer(t3), (t3) => t3.toBuffer(), t2);
  }
  function Ee(t2) {
    return new ke(ye(32), (t3) => new PublicKey(t3), (t3) => t3.toBuffer(), t2);
  }
  function Ie(t2, e) {
    return new Me(t2, e);
  }
  function xe(t2) {
    if (0 === t2)
      return false;
    if (1 === t2)
      return true;
    throw new Error("Invalid bool: " + t2);
  }
  function Pe(t2) {
    return t2 ? 1 : 0;
  }
  function Ue(t2) {
    return new Ve(t2);
  }
  function je(t2) {
    return ye(32, t2);
  }
  function Ke(t2, e) {
    const n = Buffer.alloc(null != e ? e : qe), r = $e.encode(t2, n);
    return void 0 === e ? n.slice(0, r) : n;
  }
  function He(t2) {
    return new Ge(ye(32), (t3) => new PublicKey(t3), (t3) => t3.toBuffer(), t2);
  }
  function tn(n, r, o) {
    const i = import_buffer91.Buffer.concat([n.toBuffer(), import_buffer91.Buffer.from(r), o.toBuffer()]), s = import_js_sha2562.sha256.digest(i);
    return new PublicKey(import_buffer91.Buffer.from(s));
  }
  function en(n, r) {
    let o = import_buffer91.Buffer.alloc(0);
    n.forEach(function(e) {
      if (e.length > 32)
        throw new TypeError("Max seed length exceeded");
      o = import_buffer91.Buffer.concat([o, rn(e)]);
    }), o = import_buffer91.Buffer.concat([o, r.toBuffer(), import_buffer91.Buffer.from("ProgramDerivedAddress")]);
    let i = (0, import_js_sha2562.sha256)(new Uint8Array(o)), s = new import_bn4.default(i, 16).toArray(void 0, 32);
    if (PublicKey.isOnCurve(new Uint8Array(s)))
      throw new Error("Invalid seeds, address must fall off the curve");
    return new PublicKey(s);
  }
  function nn(e, n) {
    let r, o = 255;
    for (; 0 != o; ) {
      try {
        r = en(e.concat(import_buffer91.Buffer.from([o])), n);
      } catch (t2) {
        if (t2 instanceof TypeError)
          throw t2;
        o--;
        continue;
      }
      return [r, o];
    }
    throw new Error("Unable to find a viable program address nonce");
  }
  async function on2(n, ...r) {
    let o = [import_buffer91.Buffer.from([97, 110, 99, 104, 111, 114])];
    r.forEach((e) => {
      o.push(e instanceof import_buffer91.Buffer ? e : L(e).toBuffer());
    });
    const [i] = await PublicKey.findProgramAddress(o, L(n));
    return i;
  }
  async function hn(t2, e) {
    const n = await t2.getAccountInfo(e);
    if (null === n)
      throw new Error("program account not found");
    const { program: r } = fn(n.data), o = await t2.getAccountInfo(r.programdataAddress);
    if (null === o)
      throw new Error("program data account not found");
    const { programData: i } = fn(o.data);
    return i;
  }
  function fn(t2) {
    return pn.decode(t2);
  }
  function wn(t2, e) {
    var n, r;
    let o = {};
    const i = t2.args ? t2.args.length : 0;
    if (e.length > i) {
      if (e.length !== i + 1)
        throw new Error(`provided too many arguments ${e} to instruction ${null == t2 ? void 0 : t2.name} expecting: ${null !== (r = null === (n = t2.args) || void 0 === n ? void 0 : n.map((t3) => t3.name)) && void 0 !== r ? r : []}`);
      o = e.pop();
    }
    return [e, o];
  }
  function Sn(t2) {
    let [e] = nn([], t2);
    return tn(e, "unversioned", t2);
  }
  function zn() {
    return new Ne(Bn);
  }
  function Gn(t2) {
    return new Vn(Hn, Wn, t2, new Fn(Hn));
  }
  function Xn(t2) {
    return new Vn(Qn, Zn, t2, new Qe(Qn));
  }
  var import_buffer91, import_bn4, import_bn5, import_bs583, l, import_camelcase2, import_js_sha2562, f2, import_eventemitter33, g, w, A, S, I, k, T, N, et, rt, ot, it, st, at, ut, ht, pt, ft, yt, gt, wt, vt, bt, _t, St, Et, kt, Mt, Lt, Tt, Ct, Dt, Nt, Rt, Ut, $t, Kt, qt, Wt, Gt, Ht, Jt, Zt, Xt, Qt, ee, ne, re, oe, ie, se, ae, ce, ue, de, le, he, pe, fe, me, ye, ge, we, Ae, _e, ke, Me, Le, Te, Ce, ze, Be, Oe, De, Ne, Re, Ve, $e, qe, Fe, We, Ge, Je, Ze, Xe, Qe, Ye, rn, sn, an, cn, un, dn, ln, pn, mn, yn, gn, vn, bn, An, _n, En, In, kn, Mn, xn, Pn, Ln, Tn, Cn, Bn, On, Dn, Nn, Rn, Vn, Un, jn, $n, Kn, qn, Fn, Wn, Hn, Jn, Zn, Qn, Yn;
  var init_browser = __esm({
    "node_modules/@project-serum/anchor/dist/browser/index.js"() {
      init_virtual_process_polyfill();
      init_buffer();
      import_buffer91 = __toESM(require_buffer());
      init_index_browser_esm();
      init_index_browser_esm();
      import_bn4 = __toESM(require_bn());
      import_bn5 = __toESM(require_bn());
      import_bs583 = __toESM(require_bs58());
      l = __toESM(require_base64_js());
      import_camelcase2 = __toESM(require_camelcase2());
      import_js_sha2562 = __toESM(require_sha256());
      f2 = __toESM(require_lib2());
      init_pako_esm();
      import_eventemitter33 = __toESM(require_eventemitter3());
      g = __toESM(require_assert());
      w = Object.freeze({ __proto__: null, encode: function(t2) {
        return t2.reduce((t3, e) => t3 + e.toString(16).padStart(2, "0"), "0x");
      }, decode: function(e) {
        0 === e.indexOf("0x") && (e = e.substr(2)), e.length % 2 == 1 && (e = "0" + e);
        let n = e.match(/.{2}/g);
        return null === n ? import_buffer91.Buffer.from([]) : import_buffer91.Buffer.from(n.map((t2) => parseInt(t2, 16)));
      } });
      A = Object.freeze({ __proto__: null, decode: v, encode: b });
      S = Object.freeze({ __proto__: null, encode: _, decode: function(t2) {
        return import_bs583.default.decode(t2);
      } });
      I = Object.freeze({ __proto__: null, encode: function(t2) {
        return l.fromByteArray(t2);
      }, decode: E });
      k = Object.freeze({ __proto__: null, hex: w, utf8: A, bs58: S, base64: I });
      T = class extends TypeError {
        constructor(t2, e) {
          let n;
          const { message: r, ...o } = t2, { path: i } = t2;
          super(0 === i.length ? r : "At path: " + i.join(".") + " -- " + r), this.value = void 0, this.key = void 0, this.type = void 0, this.refinement = void 0, this.path = void 0, this.branch = void 0, this.failures = void 0, Object.assign(this, o), this.name = this.constructor.name, this.failures = () => {
            var r2;
            return null != (r2 = n) ? r2 : n = [t2, ...e()];
          };
        }
      };
      N = class {
        constructor(t2) {
          this.TYPE = void 0, this.type = void 0, this.schema = void 0, this.coercer = void 0, this.validator = void 0, this.refiner = void 0, this.entries = void 0;
          const { type: e, schema: n, validator: r, refiner: o, coercer: i = (t3) => t3, entries: s = function* () {
          } } = t2;
          this.type = e, this.schema = n, this.entries = s, this.coercer = i, this.validator = r ? (t3, e2) => O(r(t3, e2), e2, this, t3) : () => [], this.refiner = o ? (t3, e2) => O(o(t3, e2), e2, this, t3) : () => [];
        }
        assert(t2) {
          return function(t3, e) {
            const n = U(t3, e);
            if (n[0])
              throw n[0];
          }(t2, this);
        }
        create(t2) {
          return R(t2, this);
        }
        is(t2) {
          return V(t2, this);
        }
        mask(t2) {
          return function(t3, e) {
            const n = U(t3, e, { coerce: true, mask: true });
            if (n[0])
              throw n[0];
            return n[1];
          }(t2, this);
        }
        validate(t2, e) {
          return void 0 === e && (e = {}), U(t2, this, e);
        }
      };
      et = nt(Z());
      rt = (ot = H({ err: q(J([H({}), G()])), logs: q($(G())), accounts: W(q($(q(H({ executable: j("boolean", (t2) => "boolean" == typeof t2), owner: G(), lamports: F(), data: $(G()), rentEpoch: W(F()) }))))), unitsConsumed: W(F()) }), tt(H({ context: H({ slot: F() }), value: ot })));
      it = Object.freeze({ __proto__: null, invoke: async function(t2, e, o, i) {
        t2 = L(t2), i || (i = lt());
        const s = new Transaction();
        if (s.add(new TransactionInstruction({ programId: t2, keys: null != e ? e : [], data: o })), void 0 === i.sendAndConfirm)
          throw new Error("This function requires 'Provider.sendAndConfirm' to be implemented.");
        return await i.sendAndConfirm(s, []);
      }, getMultipleAccounts: X, simulateTransaction: Y });
      st = class {
        constructor(t2, e, n) {
          this.connection = t2, this.wallet = e, this.opts = n, this.publicKey = e.publicKey;
        }
        static defaultOptions() {
          return { preflightCommitment: "processed", commitment: "processed" };
        }
        static local(t2, e) {
          throw new Error("Provider local is not available on browser.");
        }
        static env() {
          throw new Error("Provider env is not available on browser.");
        }
        async sendAndConfirm(t2, e, n) {
          var r;
          void 0 === n && (n = this.opts), t2.feePayer = this.wallet.publicKey, t2.recentBlockhash = (await this.connection.getRecentBlockhash(n.preflightCommitment)).blockhash, t2 = await this.wallet.signTransaction(t2), (null != e ? e : []).forEach((e2) => {
            t2.partialSign(e2);
          });
          const i = t2.serialize();
          try {
            return await ct(this.connection, i, n);
          } catch (e2) {
            if (e2 instanceof ut) {
              const n2 = await this.connection.getTransaction(_(t2.signature), { commitment: "confirmed" });
              if (n2) {
                const t3 = null === (r = n2.meta) || void 0 === r ? void 0 : r.logMessages;
                throw t3 ? new SendTransactionError(e2.message, t3) : e2;
              }
              throw e2;
            }
            throw e2;
          }
        }
        async sendAll(t2, e) {
          void 0 === e && (e = this.opts);
          const n = await this.connection.getRecentBlockhash(e.preflightCommitment);
          let r = t2.map((t3) => {
            var e2;
            let r2 = t3.tx, o2 = null !== (e2 = t3.signers) && void 0 !== e2 ? e2 : [];
            return r2.feePayer = this.wallet.publicKey, r2.recentBlockhash = n.blockhash, o2.forEach((t4) => {
              r2.partialSign(t4);
            }), r2;
          });
          const o = await this.wallet.signAllTransactions(r), i = [];
          for (let t3 = 0; t3 < r.length; t3 += 1) {
            const n2 = o[t3].serialize();
            i.push(await ct(this.connection, n2, e));
          }
          return i;
        }
        async simulate(t2, e, n, r) {
          t2.feePayer = this.wallet.publicKey, t2.recentBlockhash = (await this.connection.getLatestBlockhash(null != n ? n : this.connection.commitment)).blockhash, t2 = await this.wallet.signTransaction(t2);
          const o = await Y(this.connection, t2, e, n, r);
          if (o.value.err)
            throw new at(o.value);
          return o.value;
        }
      };
      at = class extends Error {
        constructor(t2, e) {
          super(e), this.simulationResponse = t2;
        }
      };
      ut = class extends Error {
        constructor(t2) {
          super(t2);
        }
      };
      ht = null;
      pt = /* @__PURE__ */ new Set(["anchor-deprecated-state", "debug-logs"]);
      ft = /* @__PURE__ */ new Map();
      yt = Object.freeze({ __proto__: null, set: function(t2) {
        if (!pt.has(t2))
          throw new Error("Invalid feature");
        ft.set(t2, true);
      }, isSet: mt });
      gt = class extends Error {
        constructor(t2) {
          super(t2), this.name = "IdlError";
        }
      };
      wt = class {
        constructor(t2) {
          this.stack = t2;
        }
        static parse(t2) {
          var n;
          const r = /^Program (\w*) invoke/, o = /^Program \w* success/, i = [];
          for (let s = 0; s < t2.length; s++) {
            if (o.exec(t2[s])) {
              i.pop();
              continue;
            }
            const a = null === (n = r.exec(t2[s])) || void 0 === n ? void 0 : n[1];
            a && i.push(new PublicKey(a));
          }
          return new wt(i);
        }
      };
      vt = class extends Error {
        constructor(t2, e, n, r, o, i) {
          super(n.join("\n").replace("Program log: ", "")), this.errorLogs = n, this.logs = r, this.error = { errorCode: t2, errorMessage: e, comparedValues: i, origin: o }, this._programErrorStack = wt.parse(r);
        }
        static parse(t2) {
          if (!t2)
            return null;
          const n = t2.findIndex((t3) => t3.startsWith("Program log: AnchorError"));
          if (-1 === n)
            return null;
          const r = t2[n], o = [r];
          let i;
          if (n + 1 < t2.length) {
            if ("Program log: Left:" === t2[n + 1]) {
              const r2 = /^Program log: (.*)$/, s2 = r2.exec(t2[n + 2])[1], a2 = r2.exec(t2[n + 4])[1];
              i = [new PublicKey(s2), new PublicKey(a2)], o.push(...t2.slice(n + 1, n + 5));
            } else if (t2[n + 1].startsWith("Program log: Left:")) {
              const e = /^Program log: (Left|Right): (.*)$/, r2 = e.exec(t2[n + 1])[2], s2 = e.exec(t2[n + 2])[2];
              o.push(...t2.slice(n + 1, n + 3)), i = [r2, s2];
            }
          }
          const s = /^Program log: AnchorError occurred\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./.exec(r), a = /^Program log: AnchorError thrown in (.*):(\d*)\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./.exec(r), c2 = /^Program log: AnchorError caused by account: (.*)\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./.exec(r);
          if (s) {
            const [e, n2, r2] = s.slice(1, 4), a2 = { code: e, number: parseInt(n2) };
            return new vt(a2, r2, o, t2, void 0, i);
          }
          if (a) {
            const [e, n2, r2, s2, c3] = a.slice(1, 6), u2 = { code: r2, number: parseInt(s2) }, d2 = { file: e, line: parseInt(n2) };
            return new vt(u2, c3, o, t2, d2, i);
          }
          if (c2) {
            const [e, n2, r2, s2] = c2.slice(1, 5), a2 = e, u2 = { code: n2, number: parseInt(r2) };
            return new vt(u2, s2, o, t2, a2, i);
          }
          return null;
        }
        get program() {
          return this._programErrorStack.stack[this._programErrorStack.stack.length - 1];
        }
        get programErrorStack() {
          return this._programErrorStack.stack;
        }
        toString() {
          return this.message;
        }
      };
      bt = class extends Error {
        constructor(t2, e, n) {
          super(), this.code = t2, this.msg = e, this.logs = n, n && (this._programErrorStack = wt.parse(n));
        }
        static parse(t2, e) {
          const n = t2.toString();
          let r, o;
          if (n.includes("custom program error:")) {
            let t3 = n.split("custom program error: ");
            if (2 !== t3.length)
              return null;
            r = t3[1];
          } else {
            const t3 = n.match(/"Custom":([0-9]+)}/g);
            if (!t3 || t3.length > 1)
              return null;
            r = t3[0].match(/([0-9]+)/g)[0];
          }
          try {
            o = parseInt(r);
          } catch (t3) {
            return null;
          }
          let i = e.get(o);
          return void 0 !== i ? new bt(o, i, t2.logs) : (i = St.get(o), void 0 !== i ? new bt(o, i, t2.logs) : null);
        }
        get program() {
          var t2;
          return null === (t2 = this._programErrorStack) || void 0 === t2 ? void 0 : t2.stack[this._programErrorStack.stack.length - 1];
        }
        get programErrorStack() {
          var t2;
          return null === (t2 = this._programErrorStack) || void 0 === t2 ? void 0 : t2.stack;
        }
        toString() {
          return this.msg;
        }
      };
      _t = { InstructionMissing: 100, InstructionFallbackNotFound: 101, InstructionDidNotDeserialize: 102, InstructionDidNotSerialize: 103, IdlInstructionStub: 1e3, IdlInstructionInvalidProgram: 1001, ConstraintMut: 2e3, ConstraintHasOne: 2001, ConstraintSigner: 2002, ConstraintRaw: 2003, ConstraintOwner: 2004, ConstraintRentExempt: 2005, ConstraintSeeds: 2006, ConstraintExecutable: 2007, ConstraintState: 2008, ConstraintAssociated: 2009, ConstraintAssociatedInit: 2010, ConstraintClose: 2011, ConstraintAddress: 2012, ConstraintZero: 2013, ConstraintTokenMint: 2014, ConstraintTokenOwner: 2015, ConstraintMintMintAuthority: 2016, ConstraintMintFreezeAuthority: 2017, ConstraintMintDecimals: 2018, ConstraintSpace: 2019, RequireViolated: 2500, RequireEqViolated: 2501, RequireKeysEqViolated: 2502, RequireNeqViolated: 2503, RequireKeysNeqViolated: 2504, RequireGtViolated: 2505, RequireGteViolated: 2506, AccountDiscriminatorAlreadySet: 3e3, AccountDiscriminatorNotFound: 3001, AccountDiscriminatorMismatch: 3002, AccountDidNotDeserialize: 3003, AccountDidNotSerialize: 3004, AccountNotEnoughKeys: 3005, AccountNotMutable: 3006, AccountOwnedByWrongProgram: 3007, InvalidProgramId: 3008, InvalidProgramExecutable: 3009, AccountNotSigner: 3010, AccountNotSystemOwned: 3011, AccountNotInitialized: 3012, AccountNotProgramData: 3013, AccountNotAssociatedTokenAccount: 3014, AccountSysvarMismatch: 3015, AccountReallocExceedsLimit: 3016, AccountDuplicateReallocs: 3017, StateInvalidAddress: 4e3, DeclaredProgramIdMismatch: 4100, Deprecated: 5e3 };
      St = /* @__PURE__ */ new Map([[_t.InstructionMissing, "8 byte instruction identifier not provided"], [_t.InstructionFallbackNotFound, "Fallback functions are not supported"], [_t.InstructionDidNotDeserialize, "The program could not deserialize the given instruction"], [_t.InstructionDidNotSerialize, "The program could not serialize the given instruction"], [_t.IdlInstructionStub, "The program was compiled without idl instructions"], [_t.IdlInstructionInvalidProgram, "The transaction was given an invalid program for the IDL instruction"], [_t.ConstraintMut, "A mut constraint was violated"], [_t.ConstraintHasOne, "A has_one constraint was violated"], [_t.ConstraintSigner, "A signer constraint was violated"], [_t.ConstraintRaw, "A raw constraint was violated"], [_t.ConstraintOwner, "An owner constraint was violated"], [_t.ConstraintRentExempt, "A rent exemption constraint was violated"], [_t.ConstraintSeeds, "A seeds constraint was violated"], [_t.ConstraintExecutable, "An executable constraint was violated"], [_t.ConstraintState, "A state constraint was violated"], [_t.ConstraintAssociated, "An associated constraint was violated"], [_t.ConstraintAssociatedInit, "An associated init constraint was violated"], [_t.ConstraintClose, "A close constraint was violated"], [_t.ConstraintAddress, "An address constraint was violated"], [_t.ConstraintZero, "Expected zero account discriminant"], [_t.ConstraintTokenMint, "A token mint constraint was violated"], [_t.ConstraintTokenOwner, "A token owner constraint was violated"], [_t.ConstraintMintMintAuthority, "A mint mint authority constraint was violated"], [_t.ConstraintMintFreezeAuthority, "A mint freeze authority constraint was violated"], [_t.ConstraintMintDecimals, "A mint decimals constraint was violated"], [_t.ConstraintSpace, "A space constraint was violated"], [_t.RequireViolated, "A require expression was violated"], [_t.RequireEqViolated, "A require_eq expression was violated"], [_t.RequireKeysEqViolated, "A require_keys_eq expression was violated"], [_t.RequireNeqViolated, "A require_neq expression was violated"], [_t.RequireKeysNeqViolated, "A require_keys_neq expression was violated"], [_t.RequireGtViolated, "A require_gt expression was violated"], [_t.RequireGteViolated, "A require_gte expression was violated"], [_t.AccountDiscriminatorAlreadySet, "The account discriminator was already set on this account"], [_t.AccountDiscriminatorNotFound, "No 8 byte discriminator was found on the account"], [_t.AccountDiscriminatorMismatch, "8 byte discriminator did not match what was expected"], [_t.AccountDidNotDeserialize, "Failed to deserialize the account"], [_t.AccountDidNotSerialize, "Failed to serialize the account"], [_t.AccountNotEnoughKeys, "Not enough account keys given to the instruction"], [_t.AccountNotMutable, "The given account is not mutable"], [_t.AccountOwnedByWrongProgram, "The given account is owned by a different program than expected"], [_t.InvalidProgramId, "Program ID was not as expected"], [_t.InvalidProgramExecutable, "Program account is not executable"], [_t.AccountNotSigner, "The given account did not sign"], [_t.AccountNotSystemOwned, "The given account is not owned by the system program"], [_t.AccountNotInitialized, "The program expected this account to be already initialized"], [_t.AccountNotProgramData, "The given account is not a program data account"], [_t.AccountNotAssociatedTokenAccount, "The given account is not the associated token account"], [_t.AccountSysvarMismatch, "The given public key does not match the required sysvar"], [_t.AccountReallocExceedsLimit, "The account reallocation exceeds the MAX_PERMITTED_DATA_INCREASE limit"], [_t.AccountDuplicateReallocs, "The account was duplicated for more than one reallocation"], [_t.StateInvalidAddress, "The given state account does not have the correct address"], [_t.DeclaredProgramIdMismatch, "The declared program id does not match the actual program id"], [_t.Deprecated, "The API being used is deprecated and should no longer be used"]]);
      Et = function() {
        return Et = Object.assign || function(t2) {
          for (var e, n = 1, r = arguments.length; n < r; n++)
            for (var o in e = arguments[n])
              Object.prototype.hasOwnProperty.call(e, o) && (t2[o] = e[o]);
          return t2;
        }, Et.apply(this, arguments);
      };
      kt = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g];
      Mt = /[^A-Z0-9]+/gi;
      Lt = class {
        static fieldLayout(t2, e) {
          const n = void 0 !== t2.name ? (0, import_camelcase2.default)(t2.name) : void 0;
          switch (t2.type) {
            case "bool":
              return f2.bool(n);
            case "u8":
              return f2.u8(n);
            case "i8":
              return f2.i8(n);
            case "u16":
              return f2.u16(n);
            case "i16":
              return f2.i16(n);
            case "u32":
              return f2.u32(n);
            case "i32":
              return f2.i32(n);
            case "f32":
              return f2.f32(n);
            case "u64":
              return f2.u64(n);
            case "i64":
              return f2.i64(n);
            case "f64":
              return f2.f64(n);
            case "u128":
              return f2.u128(n);
            case "i128":
              return f2.i128(n);
            case "bytes":
              return f2.vecU8(n);
            case "string":
              return f2.str(n);
            case "publicKey":
              return f2.publicKey(n);
            default:
              if ("vec" in t2.type)
                return f2.vec(Lt.fieldLayout({ name: void 0, type: t2.type.vec }, e), n);
              if ("option" in t2.type)
                return f2.option(Lt.fieldLayout({ name: void 0, type: t2.type.option }, e), n);
              if ("defined" in t2.type) {
                const r = t2.type.defined;
                if (void 0 === e)
                  throw new gt("User defined types not provided");
                const o = e.filter((t3) => t3.name === r);
                if (1 !== o.length)
                  throw new gt(`Type not found: ${JSON.stringify(t2)}`);
                return Lt.typeDefLayout(o[0], e, n);
              }
              if ("array" in t2.type) {
                let r = t2.type.array[0], o = t2.type.array[1], i = Lt.fieldLayout({ name: void 0, type: r }, e);
                return f2.array(i, o, n);
              }
              throw new Error(`Not yet implemented: ${t2}`);
          }
        }
        static typeDefLayout(t2, e = [], n) {
          if ("struct" === t2.type.kind) {
            const r = t2.type.fields.map((t3) => Lt.fieldLayout(t3, e));
            return f2.struct(r, n);
          }
          if ("enum" === t2.type.kind) {
            let r = t2.type.variants.map((t3) => {
              const n2 = (0, import_camelcase2.default)(t3.name);
              if (void 0 === t3.fields)
                return f2.struct([], n2);
              const r2 = t3.fields.map((t4) => {
                if (!t4.hasOwnProperty("name"))
                  throw new Error("Tuple enum variants not yet implemented.");
                return Lt.fieldLayout(t4, e);
              });
              return f2.struct(r2, n2);
            });
            return void 0 !== n ? f2.rustEnum(r).replicate(n) : f2.rustEnum(r, n);
          }
          throw new Error(`Unknown type kint: ${t2}`);
        }
      };
      Tt = class {
        constructor(t2) {
          this.idl = t2, this.ixLayout = Tt.parseIxLayout(t2);
          const e = /* @__PURE__ */ new Map();
          t2.instructions.forEach((t3) => {
            const n = zt("global", t3.name);
            e.set(import_bs583.default.encode(n), { layout: this.ixLayout.get(t3.name), name: t3.name });
          }), t2.state && t2.state.methods.map((t3) => {
            const n = zt("state", t3.name);
            e.set(import_bs583.default.encode(n), { layout: this.ixLayout.get(t3.name), name: t3.name });
          }), this.sighashLayouts = e;
        }
        encode(t2, e) {
          return this._encode("global", t2, e);
        }
        encodeState(t2, e) {
          return this._encode("state", t2, e);
        }
        _encode(e, n, r) {
          const o = import_buffer91.Buffer.alloc(1e3), i = (0, import_camelcase2.default)(n), s = this.ixLayout.get(i);
          if (!s)
            throw new Error(`Unknown method: ${i}`);
          const a = s.encode(r, o), c2 = o.slice(0, a);
          return import_buffer91.Buffer.concat([zt(e, n), c2]);
        }
        static parseIxLayout(t2) {
          const e = (t2.state ? t2.state.methods : []).map((e2) => {
            let n = e2.args.map((e3) => {
              var n2, r2;
              return Lt.fieldLayout(e3, Array.from([...null !== (n2 = t2.accounts) && void 0 !== n2 ? n2 : [], ...null !== (r2 = t2.types) && void 0 !== r2 ? r2 : []]));
            });
            const r = (0, import_camelcase2.default)(e2.name);
            return [r, f2.struct(n, r)];
          }).concat(t2.instructions.map((e2) => {
            let n = e2.args.map((e3) => {
              var n2, r2;
              return Lt.fieldLayout(e3, Array.from([...null !== (n2 = t2.accounts) && void 0 !== n2 ? n2 : [], ...null !== (r2 = t2.types) && void 0 !== r2 ? r2 : []]));
            });
            const r = (0, import_camelcase2.default)(e2.name);
            return [r, f2.struct(n, r)];
          }));
          return new Map(e);
        }
        decode(e, n = "hex") {
          "string" == typeof e && (e = "hex" === n ? import_buffer91.Buffer.from(e, "hex") : import_bs583.default.decode(e));
          let r = import_bs583.default.encode(e.slice(0, 8)), o = e.slice(8);
          const i = this.sighashLayouts.get(r);
          return i ? { data: i.layout.decode(o), name: i.name } : null;
        }
        format(t2, e) {
          return Ct.format(t2, e, this.idl);
        }
      };
      Ct = class {
        static format(t2, e, n) {
          const r = n.instructions.filter((e2) => t2.name === e2.name)[0];
          if (void 0 === r)
            return console.error("Invalid instruction given"), null;
          const o = r.args.map((e2) => ({ name: e2.name, type: Ct.formatIdlType(e2.type), data: Ct.formatIdlData(e2, t2.data[e2.name], n.types) })), i = Ct.flattenIdlAccounts(r.accounts);
          return { args: o, accounts: e.map((t3, e2) => e2 < i.length ? { name: i[e2].name, ...t3 } : { name: void 0, ...t3 }) };
        }
        static formatIdlType(t2) {
          if ("string" == typeof t2)
            return t2;
          if ("vec" in t2)
            return `Vec<${this.formatIdlType(t2.vec)}>`;
          if ("option" in t2)
            return `Option<${this.formatIdlType(t2.option)}>`;
          if ("defined" in t2)
            return t2.defined;
          if ("array" in t2)
            return `Array<${t2.array[0]}; ${t2.array[1]}>`;
          throw new Error(`Unknown IDL type: ${t2}`);
        }
        static formatIdlData(t2, e, n) {
          if ("string" == typeof t2.type)
            return e.toString();
          if (t2.type.hasOwnProperty("vec"))
            return "[" + e.map((e2) => this.formatIdlData({ name: "", type: t2.type.vec }, e2)).join(", ") + "]";
          if (t2.type.hasOwnProperty("option"))
            return null === e ? "null" : this.formatIdlData({ name: "", type: t2.type.option }, e, n);
          if (t2.type.hasOwnProperty("defined")) {
            if (void 0 === n)
              throw new Error("User defined types not provided");
            const r = n.filter((e2) => e2.name === t2.type.defined);
            if (1 !== r.length)
              throw new Error(`Type not found: ${t2.type.defined}`);
            return Ct.formatIdlDataDefined(r[0], e, n);
          }
          return "unknown";
        }
        static formatIdlDataDefined(t2, e, n) {
          if ("struct" === t2.type.kind) {
            const r = t2.type;
            return "{ " + Object.keys(e).map((t3) => {
              const o = r.fields.filter((e2) => e2.name === t3)[0];
              if (void 0 === o)
                throw new Error("Unable to find type");
              return t3 + ": " + Ct.formatIdlData(o, e[t3], n);
            }).join(", ") + " }";
          }
          if (0 === t2.type.variants.length)
            return "{}";
          if (t2.type.variants[0].name) {
            const r = t2.type.variants, o = Object.keys(e)[0], i = e[o], s = Object.keys(i).map((t3) => {
              var e2;
              const s2 = i[t3], a2 = null === (e2 = r[o]) || void 0 === e2 ? void 0 : e2.filter((e3) => e3.name === t3)[0];
              if (void 0 === a2)
                throw new Error("Unable to find variant");
              return t3 + ": " + Ct.formatIdlData(a2, s2, n);
            }).join(", "), a = (0, import_camelcase2.default)(o, { pascalCase: true });
            return 0 === s.length ? a : `${a} { ${s} }`;
          }
          return "Tuple formatting not yet implemented";
        }
        static flattenIdlAccounts(t2, e) {
          return t2.map((t3) => {
            const n = function(t4) {
              const e2 = t4.replace(/([A-Z])/g, " $1");
              return e2.charAt(0).toUpperCase() + e2.slice(1);
            }(t3.name);
            if (t3.hasOwnProperty("accounts")) {
              const r = e ? `${e} > ${n}` : n;
              return Ct.flattenIdlAccounts(t3.accounts, r);
            }
            return { ...t3, name: e ? `${e} > ${n}` : n };
          }).flat();
        }
      };
      Dt = 8;
      Nt = class {
        constructor(t2) {
          if (void 0 === t2.accounts)
            return void (this.accountLayouts = /* @__PURE__ */ new Map());
          const e = t2.accounts.map((e2) => [e2.name, Lt.typeDefLayout(e2, t2.types)]);
          this.accountLayouts = new Map(e), this.idl = t2;
        }
        async encode(e, n) {
          const r = import_buffer91.Buffer.alloc(1e3), o = this.accountLayouts.get(e);
          if (!o)
            throw new Error(`Unknown account: ${e}`);
          const i = o.encode(n, r);
          let s = r.slice(0, i), a = Nt.accountDiscriminator(e);
          return import_buffer91.Buffer.concat([a, s]);
        }
        decode(t2, e) {
          if (Nt.accountDiscriminator(t2).compare(e.slice(0, 8)))
            throw new Error("Invalid account discriminator");
          return this.decodeUnchecked(t2, e);
        }
        decodeUnchecked(t2, e) {
          const n = e.slice(8), r = this.accountLayouts.get(t2);
          if (!r)
            throw new Error(`Unknown account: ${t2}`);
          return r.decode(n);
        }
        memcmp(e, n) {
          const r = Nt.accountDiscriminator(e);
          return { offset: 0, bytes: import_bs583.default.encode(n ? import_buffer91.Buffer.concat([r, n]) : r) };
        }
        size(t2) {
          var e;
          return 8 + (null !== (e = Bt(this.idl, t2)) && void 0 !== e ? e : 0);
        }
        static accountDiscriminator(e) {
          return import_buffer91.Buffer.from(import_js_sha2562.sha256.digest(`account:${(0, import_camelcase2.default)(e, { pascalCase: true })}`)).slice(0, 8);
        }
      };
      Rt = class {
        constructor(t2) {
          if (void 0 === t2.events)
            return void (this.layouts = /* @__PURE__ */ new Map());
          const e = t2.events.map((e2) => {
            let n = { name: e2.name, type: { kind: "struct", fields: e2.fields.map((t3) => ({ name: t3.name, type: t3.type })) } };
            return [e2.name, Lt.typeDefLayout(n, t2.types)];
          });
          this.layouts = new Map(e), this.discriminators = new Map(void 0 === t2.events ? [] : t2.events.map((t3) => [l.fromByteArray(Vt(t3.name)), t3.name]));
        }
        decode(e) {
          let n;
          try {
            n = import_buffer91.Buffer.from(l.toByteArray(e));
          } catch (t2) {
            return null;
          }
          const r = l.fromByteArray(n.slice(0, 8)), o = this.discriminators.get(r);
          if (void 0 === o)
            return null;
          const i = this.layouts.get(o);
          if (!i)
            throw new Error(`Unknown event: ${o}`);
          return { data: i.decode(n.slice(8)), name: o };
        }
      };
      Ut = class {
        constructor(t2) {
          if (void 0 === t2.state)
            throw new Error("Idl state not defined.");
          this.layout = Lt.typeDefLayout(t2.state.struct, t2.types);
        }
        async encode(e, n) {
          const r = import_buffer91.Buffer.alloc(1e3), o = this.layout.encode(n, r), i = await jt(e), s = r.slice(0, o);
          return import_buffer91.Buffer.concat([i, s]);
        }
        decode(t2) {
          const e = t2.slice(8);
          return this.layout.decode(e);
        }
      };
      $t = class {
        constructor(t2) {
          if (void 0 === t2.types)
            return void (this.typeLayouts = /* @__PURE__ */ new Map());
          const e = t2.types.map((e2) => [e2.name, Lt.typeDefLayout(e2, t2.types)]);
          this.typeLayouts = new Map(e), this.idl = t2;
        }
        encode(e, n) {
          const r = import_buffer91.Buffer.alloc(1e3), o = this.typeLayouts.get(e);
          if (!o)
            throw new Error(`Unknown type: ${e}`);
          const i = o.encode(n, r);
          return r.slice(0, i);
        }
        decode(t2, e) {
          const n = this.typeLayouts.get(t2);
          if (!n)
            throw new Error(`Unknown type: ${t2}`);
          return n.decode(e);
        }
      };
      Kt = class {
        constructor(t2) {
          this.instruction = new Tt(t2), this.accounts = new Nt(t2), this.events = new Rt(t2), t2.state && (this.state = new Ut(t2)), this.types = new $t(t2);
        }
      };
      qt = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof window ? window : "undefined" != typeof self ? self : {};
      Wt = class {
        constructor(t2, e) {
          if (!Number.isInteger(t2))
            throw new TypeError("span must be an integer");
          this.span = t2, this.property = e;
        }
        makeDestinationObject() {
          return {};
        }
        decode(t2, e) {
          throw new Error("Layout is abstract");
        }
        encode(t2, e, n) {
          throw new Error("Layout is abstract");
        }
        getSpan(t2, e) {
          if (0 > this.span)
            throw new RangeError("indeterminate span");
          return this.span;
        }
        replicate(t2) {
          const e = Object.create(this.constructor.prototype);
          return Object.assign(e, this), e.property = t2, e;
        }
        fromArray(t2) {
        }
      };
      Gt = Wt;
      Ht = class extends Wt {
        isCount() {
          throw new Error("ExternalLayout is abstract");
        }
      };
      Jt = class extends Ht {
        constructor(t2, e, n) {
          if (!(t2 instanceof Wt))
            throw new TypeError("layout must be a Layout");
          if (void 0 === e)
            e = 0;
          else if (!Number.isInteger(e))
            throw new TypeError("offset must be integer or undefined");
          super(t2.span, n || t2.property), this.layout = t2, this.offset = e;
        }
        isCount() {
          return this.layout instanceof Zt || this.layout instanceof Xt;
        }
        decode(t2, e) {
          return void 0 === e && (e = 0), this.layout.decode(t2, e + this.offset);
        }
        encode(t2, e, n) {
          return void 0 === n && (n = 0), this.layout.encode(t2, e, n + this.offset);
        }
      };
      Zt = class extends Wt {
        constructor(t2, e) {
          if (super(t2, e), 6 < this.span)
            throw new RangeError("span must not exceed 6 bytes");
        }
        decode(t2, e) {
          return void 0 === e && (e = 0), t2.readUIntLE(e, this.span);
        }
        encode(t2, e, n) {
          return void 0 === n && (n = 0), e.writeUIntLE(t2, n, this.span), this.span;
        }
      };
      Xt = class extends Wt {
        constructor(t2, e) {
          if (super(t2, e), 6 < this.span)
            throw new RangeError("span must not exceed 6 bytes");
        }
        decode(t2, e) {
          return void 0 === e && (e = 0), t2.readUIntBE(e, this.span);
        }
        encode(t2, e, n) {
          return void 0 === n && (n = 0), e.writeUIntBE(t2, n, this.span), this.span;
        }
      };
      Qt = Math.pow(2, 32);
      ee = class extends Wt {
        constructor(t2) {
          super(8, t2);
        }
        decode(t2, e) {
          void 0 === e && (e = 0);
          const n = t2.readUInt32LE(e);
          return te(t2.readUInt32LE(e + 4), n);
        }
        encode(t2, e, n) {
          void 0 === n && (n = 0);
          const r = Yt(t2);
          return e.writeUInt32LE(r.lo32, n), e.writeUInt32LE(r.hi32, n + 4), 8;
        }
      };
      ne = class extends Wt {
        constructor(t2) {
          super(8, t2);
        }
        decode(t2, e) {
          void 0 === e && (e = 0);
          const n = t2.readUInt32LE(e);
          return te(t2.readInt32LE(e + 4), n);
        }
        encode(t2, e, n) {
          void 0 === n && (n = 0);
          const r = Yt(t2);
          return e.writeUInt32LE(r.lo32, n), e.writeInt32LE(r.hi32, n + 4), 8;
        }
      };
      re = class extends Wt {
        constructor(t2, e, n) {
          if (!Array.isArray(t2) || !t2.reduce((t3, e2) => t3 && e2 instanceof Wt, true))
            throw new TypeError("fields must be array of Layout instances");
          "boolean" == typeof e && void 0 === n && (n = e, e = void 0);
          for (const e2 of t2)
            if (0 > e2.span && void 0 === e2.property)
              throw new Error("fields cannot contain unnamed variable-length layout");
          let r = -1;
          try {
            r = t2.reduce((t3, e2) => t3 + e2.getSpan(), 0);
          } catch (t3) {
          }
          super(r, e), this.fields = t2, this.decodePrefixes = !!n;
        }
        getSpan(t2, e) {
          if (0 <= this.span)
            return this.span;
          void 0 === e && (e = 0);
          let n = 0;
          try {
            n = this.fields.reduce((n2, r) => {
              const o = r.getSpan(t2, e);
              return e += o, n2 + o;
            }, 0);
          } catch (t3) {
            throw new RangeError("indeterminate span");
          }
          return n;
        }
        decode(t2, e) {
          void 0 === e && (e = 0);
          const n = this.makeDestinationObject();
          for (const r of this.fields)
            if (void 0 !== r.property && (n[r.property] = r.decode(t2, e)), e += r.getSpan(t2, e), this.decodePrefixes && t2.length === e)
              break;
          return n;
        }
        encode(t2, e, n) {
          void 0 === n && (n = 0);
          const r = n;
          let o = 0, i = 0;
          for (const r2 of this.fields) {
            let s = r2.span;
            if (i = 0 < s ? s : 0, void 0 !== r2.property) {
              const o2 = t2[r2.property];
              void 0 !== o2 && (i = r2.encode(o2, e, n), 0 > s && (s = r2.getSpan(e, n)));
            }
            o = n, n += s;
          }
          return o + i - r;
        }
        fromArray(t2) {
          const e = this.makeDestinationObject();
          for (const n of this.fields)
            void 0 !== n.property && 0 < t2.length && (e[n.property] = t2.shift());
          return e;
        }
        layoutFor(t2) {
          if ("string" != typeof t2)
            throw new TypeError("property must be string");
          for (const e of this.fields)
            if (e.property === t2)
              return e;
        }
        offsetOf(t2) {
          if ("string" != typeof t2)
            throw new TypeError("property must be string");
          let e = 0;
          for (const n of this.fields) {
            if (n.property === t2)
              return e;
            0 > n.span ? e = -1 : 0 <= e && (e += n.span);
          }
        }
      };
      oe = class {
        constructor(t2) {
          this.property = t2;
        }
        decode() {
          throw new Error("UnionDiscriminator is abstract");
        }
        encode() {
          throw new Error("UnionDiscriminator is abstract");
        }
      };
      ie = class extends oe {
        constructor(t2, e) {
          if (!(t2 instanceof Ht && t2.isCount()))
            throw new TypeError("layout must be an unsigned integer ExternalLayout");
          super(e || t2.property || "variant"), this.layout = t2;
        }
        decode(t2, e) {
          return this.layout.decode(t2, e);
        }
        encode(t2, e, n) {
          return this.layout.encode(t2, e, n);
        }
      };
      se = class extends Wt {
        constructor(t2, e, n) {
          const r = t2 instanceof Zt || t2 instanceof Xt;
          if (r)
            t2 = new ie(new Jt(t2));
          else if (t2 instanceof Ht && t2.isCount())
            t2 = new ie(t2);
          else if (!(t2 instanceof oe))
            throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
          if (void 0 === e && (e = null), !(null === e || e instanceof Wt))
            throw new TypeError("defaultLayout must be null or a Layout");
          if (null !== e) {
            if (0 > e.span)
              throw new Error("defaultLayout must have constant span");
            void 0 === e.property && (e = e.replicate("content"));
          }
          let o = -1;
          e && (o = e.span, 0 <= o && r && (o += t2.layout.span)), super(o, n), this.discriminator = t2, this.usesPrefixDiscriminator = r, this.defaultLayout = e, this.registry = {};
          let i = this.defaultGetSourceVariant.bind(this);
          this.getSourceVariant = function(t3) {
            return i(t3);
          }, this.configGetSourceVariant = function(t3) {
            i = t3.bind(this);
          };
        }
        getSpan(t2, e) {
          if (0 <= this.span)
            return this.span;
          void 0 === e && (e = 0);
          const n = this.getVariant(t2, e);
          if (!n)
            throw new Error("unable to determine span for unrecognized variant");
          return n.getSpan(t2, e);
        }
        defaultGetSourceVariant(t2) {
          if (t2.hasOwnProperty(this.discriminator.property)) {
            if (this.defaultLayout && t2.hasOwnProperty(this.defaultLayout.property))
              return;
            const e = this.registry[t2[this.discriminator.property]];
            if (e && (!e.layout || t2.hasOwnProperty(e.property)))
              return e;
          } else
            for (const e in this.registry) {
              const n = this.registry[e];
              if (t2.hasOwnProperty(n.property))
                return n;
            }
          throw new Error("unable to infer src variant");
        }
        decode(t2, e) {
          let n;
          void 0 === e && (e = 0);
          const r = this.discriminator, o = r.decode(t2, e);
          let i = this.registry[o];
          if (void 0 === i) {
            let s = 0;
            i = this.defaultLayout, this.usesPrefixDiscriminator && (s = r.layout.span), n = this.makeDestinationObject(), n[r.property] = o, n[i.property] = this.defaultLayout.decode(t2, e + s);
          } else
            n = i.decode(t2, e);
          return n;
        }
        encode(t2, e, n) {
          void 0 === n && (n = 0);
          const r = this.getSourceVariant(t2);
          if (void 0 === r) {
            const r2 = this.discriminator, o = this.defaultLayout;
            let i = 0;
            return this.usesPrefixDiscriminator && (i = r2.layout.span), r2.encode(t2[r2.property], e, n), i + o.encode(t2[o.property], e, n + i);
          }
          return r.encode(t2, e, n);
        }
        addVariant(t2, e, n) {
          const r = new ae(this, t2, e, n);
          return this.registry[t2] = r, r;
        }
        getVariant(t2, e) {
          let n = t2;
          return Buffer.isBuffer(t2) && (void 0 === e && (e = 0), n = this.discriminator.decode(t2, e)), this.registry[n];
        }
      };
      ae = class extends Wt {
        constructor(t2, e, n, r) {
          if (!(t2 instanceof se))
            throw new TypeError("union must be a Union");
          if (!Number.isInteger(e) || 0 > e)
            throw new TypeError("variant must be a (non-negative) integer");
          if ("string" == typeof n && void 0 === r && (r = n, n = null), n) {
            if (!(n instanceof Wt))
              throw new TypeError("layout must be a Layout");
            if (null !== t2.defaultLayout && 0 <= n.span && n.span > t2.defaultLayout.span)
              throw new Error("variant span exceeds span of containing union");
            if ("string" != typeof r)
              throw new TypeError("variant must have a String property");
          }
          let o = t2.span;
          0 > t2.span && (o = n ? n.span : 0, 0 <= o && t2.usesPrefixDiscriminator && (o += t2.discriminator.layout.span)), super(o, r), this.union = t2, this.variant = e, this.layout = n || null;
        }
        getSpan(t2, e) {
          if (0 <= this.span)
            return this.span;
          void 0 === e && (e = 0);
          let n = 0;
          return this.union.usesPrefixDiscriminator && (n = this.union.discriminator.layout.span), n + this.layout.getSpan(t2, e + n);
        }
        decode(t2, e) {
          const n = this.makeDestinationObject();
          if (void 0 === e && (e = 0), this !== this.union.getVariant(t2, e))
            throw new Error("variant mismatch");
          let r = 0;
          return this.union.usesPrefixDiscriminator && (r = this.union.discriminator.layout.span), this.layout ? n[this.property] = this.layout.decode(t2, e + r) : this.property ? n[this.property] = true : this.union.usesPrefixDiscriminator && (n[this.union.discriminator.property] = this.variant), n;
        }
        encode(t2, e, n) {
          void 0 === n && (n = 0);
          let r = 0;
          if (this.union.usesPrefixDiscriminator && (r = this.union.discriminator.layout.span), this.layout && !t2.hasOwnProperty(this.property))
            throw new TypeError("variant lacks property " + this.property);
          this.union.discriminator.encode(this.variant, e, n);
          let o = r;
          if (this.layout && (this.layout.encode(t2[this.property], e, n + r), o += this.layout.getSpan(e, n + r), 0 <= this.union.span && o > this.union.span))
            throw new Error("encoded variant overruns containing union");
          return o;
        }
        fromArray(t2) {
          if (this.layout)
            return this.layout.fromArray(t2);
        }
      };
      ce = class extends Wt {
        constructor(t2, e) {
          if (!(t2 instanceof Ht && t2.isCount() || Number.isInteger(t2) && 0 <= t2))
            throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
          let n = -1;
          t2 instanceof Ht || (n = t2), super(n, e), this.length = t2;
        }
        getSpan(t2, e) {
          let n = this.span;
          return 0 > n && (n = this.length.decode(t2, e)), n;
        }
        decode(t2, e) {
          void 0 === e && (e = 0);
          let n = this.span;
          return 0 > n && (n = this.length.decode(t2, e)), t2.slice(e, e + n);
        }
        encode(t2, e, n) {
          let r = this.length;
          if (this.length instanceof Ht && (r = t2.length), !Buffer.isBuffer(t2) || r !== t2.length)
            throw new TypeError((o = "Blob.encode", ((i = this).property ? o + "[" + i.property + "]" : o) + " requires (length " + r + ") Buffer as src"));
          var o, i;
          if (n + r > e.length)
            throw new RangeError("encoding overruns Buffer");
          return e.write(t2.toString("hex"), n, r, "hex"), this.length instanceof Ht && this.length.encode(r, e, n), r;
        }
      };
      ue = (t2, e, n) => new Jt(t2, e, n);
      de = (t2) => new Zt(1, t2);
      le = (t2) => new Zt(4, t2);
      he = (t2) => new ee(t2);
      pe = (t2) => new ne(t2);
      fe = (t2, e, n) => new re(t2, e, n);
      me = (t2, e, n) => new se(t2, e, n);
      ye = (t2, e) => new ce(t2, e);
      ge = class {
        constructor(t2) {
        }
        encode(t2, n) {
          switch ((0, import_camelcase2.default)(t2)) {
            case "initializeMint":
              return function({ decimals: t3, mintAuthority: n2, freezeAuthority: r }) {
                return be({ initializeMint: { decimals: t3, mintAuthority: n2.toBuffer(), freezeAuthorityOption: !!r, freezeAuthority: (r || PublicKey.default).toBuffer() } });
              }(n);
            case "initializeAccount":
              return be({ initializeAccount: {} });
            case "initializeMultisig":
              return function({ m: t3 }) {
                return be({ initializeMultisig: { m: t3 } });
              }(n);
            case "transfer":
              return function({ amount: t3 }) {
                return be({ transfer: { amount: t3 } });
              }(n);
            case "approve":
              return function({ amount: t3 }) {
                return be({ approve: { amount: t3 } });
              }(n);
            case "revoke":
              return be({ revoke: {} });
            case "setAuthority":
              return function({ authorityType: t3, newAuthority: e }) {
                return be({ setAuthority: { authorityType: t3, newAuthority: e } });
              }(n);
            case "mintTo":
              return function({ amount: t3 }) {
                return be({ mintTo: { amount: t3 } });
              }(n);
            case "burn":
              return function({ amount: t3 }) {
                return be({ burn: { amount: t3 } });
              }(n);
            case "closeAccount":
              return be({ closeAccount: {} });
            case "freezeAccount":
              return be({ freezeAccount: {} });
            case "thawAccount":
              return be({ thawAccount: {} });
            case "transferChecked":
              return function({ amount: t3, decimals: e }) {
                return be({ transferChecked: { amount: t3, decimals: e } });
              }(n);
            case "approvedChecked":
              return function({ amount: t3, decimals: e }) {
                return be({ approveChecked: { amount: t3, decimals: e } });
              }(n);
            case "mintToChecked":
              return function({ amount: t3, decimals: e }) {
                return be({ mintToChecked: { amount: t3, decimals: e } });
              }(n);
            case "burnChecked":
              return function({ amount: t3, decimals: e }) {
                return be({ burnChecked: { amount: t3, decimals: e } });
              }(n);
            case "intializeAccount2":
              return function({ authority: t3 }) {
                return be({ initilaizeAccount2: { authority: t3 } });
              }(n);
            case "syncNative":
              return be({ syncNative: {} });
            case "initializeAccount3":
              return function({ authority: t3 }) {
                return be({ initializeAccount3: { authority: t3 } });
              }(n);
            case "initializeMultisig2":
              return function({ m: t3 }) {
                return be({ initializeMultisig2: { m: t3 } });
              }(n);
            case "initializeMint2":
              return function({ decimals: t3, mintAuthority: e, freezeAuthority: n2 }) {
                return be({ encodeInitializeMint2: { decimals: t3, mintAuthority: e, freezeAuthority: n2 } });
              }(n);
            default:
              throw new Error(`Invalid instruction: ${t2}`);
          }
        }
        encodeState(t2, e) {
          throw new Error("SPL token does not have state");
        }
      };
      we = me(de("instruction"));
      we.addVariant(0, fe([de("decimals"), ye(32, "mintAuthority"), de("freezeAuthorityOption"), ve("freezeAuthority")]), "initializeMint"), we.addVariant(1, fe([]), "initializeAccount"), we.addVariant(2, fe([de("m")]), "initializeMultisig"), we.addVariant(3, fe([he("amount")]), "transfer"), we.addVariant(4, fe([he("amount")]), "approve"), we.addVariant(5, fe([]), "revoke"), we.addVariant(6, fe([de("authorityType"), de("newAuthorityOption"), ve("newAuthority")]), "setAuthority"), we.addVariant(7, fe([he("amount")]), "mintTo"), we.addVariant(8, fe([he("amount")]), "burn"), we.addVariant(9, fe([]), "closeAccount"), we.addVariant(10, fe([]), "freezeAccount"), we.addVariant(11, fe([]), "thawAccount"), we.addVariant(12, fe([he("amount"), de("decimals")]), "transferChecked"), we.addVariant(13, fe([he("amount"), de("decimals")]), "approvedChecked"), we.addVariant(14, fe([he("amount"), de("decimals")]), "mintToChecked"), we.addVariant(15, fe([he("amount"), de("decimals")]), "burnedChecked"), we.addVariant(16, fe([ve("authority")]), "InitializeAccount2"), we.addVariant(17, fe([]), "syncNative"), we.addVariant(18, fe([ve("authority")]), "initializeAccount3"), we.addVariant(19, fe([de("m")]), "initializeMultisig2"), we.addVariant(20, fe([de("decimals"), ve("mintAuthority"), de("freezeAuthorityOption"), ve("freezeAuthority")]), "initializeMint2");
      Ae = Math.max(...Object.values(we.registry).map((t2) => t2.span));
      _e = class {
        constructor(t2) {
        }
        encode(t2, e) {
          throw new Error("SPL token does not have state");
        }
        decode(t2) {
          throw new Error("SPL token does not have state");
        }
      };
      ke = class extends Gt {
        constructor(t2, e, n, r) {
          super(t2.span, r), this.layout = t2, this.decoder = e, this.encoder = n;
        }
        decode(t2, e) {
          return this.decoder(this.layout.decode(t2, e));
        }
        encode(t2, e, n) {
          return this.layout.encode(this.encoder(t2), e, n);
        }
        getSpan(t2, e) {
          return this.layout.getSpan(t2, e);
        }
      };
      Me = class extends Gt {
        constructor(t2, e) {
          super(-1, e), this.layout = t2, this.discriminator = le();
        }
        encode(t2, e, n = 0) {
          return null == t2 ? this.layout.span + this.discriminator.encode(0, e, n) : (this.discriminator.encode(1, e, n), this.layout.encode(t2, e, n + 4) + 4);
        }
        decode(t2, e = 0) {
          const n = this.discriminator.decode(t2, e);
          if (0 === n)
            return null;
          if (1 === n)
            return this.layout.decode(t2, e + 4);
          throw new Error("Invalid coption " + this.layout.property);
        }
        getSpan(t2, e = 0) {
          return this.layout.getSpan(t2, e + 4) + 4;
        }
      };
      Le = class extends import_bn4.default {
        toBuffer() {
          const t2 = super.toArray().reverse(), e = Buffer.from(t2);
          if (8 === e.length)
            return e;
          if (e.length >= 8)
            throw new Error("u64 too large");
          const n = Buffer.alloc(8);
          return e.copy(n), n;
        }
        static fromBuffer(t2) {
          if (8 !== t2.length)
            throw new Error(`Invalid buffer length: ${t2.length}`);
          return new Le([...t2].reverse().map((t3) => `00${t3.toString(16)}`.slice(-2)).join(""), 16);
        }
      };
      Te = class {
        constructor(t2) {
          this.idl = t2;
        }
        async encode(t2, e) {
          switch (t2) {
            case "token": {
              const t3 = Buffer.alloc(165), n = Be.encode(e, t3);
              return t3.slice(0, n);
            }
            case "mint": {
              const t3 = Buffer.alloc(82), n = Ce.encode(e, t3);
              return t3.slice(0, n);
            }
            default:
              throw new Error(`Invalid account name: ${t2}`);
          }
        }
        decode(t2, e) {
          return this.decodeUnchecked(t2, e);
        }
        decodeUnchecked(t2, e) {
          switch (t2) {
            case "token":
              return function(t3) {
                return Be.decode(t3);
              }(e);
            case "mint":
              return function(t3) {
                return Ce.decode(t3);
              }(e);
            default:
              throw new Error(`Invalid account name: ${t2}`);
          }
        }
        memcmp(t2, e) {
          switch (t2) {
            case "token":
              return { dataSize: 165 };
            case "mint":
              return { dataSize: 82 };
            default:
              throw new Error(`Invalid account name: ${t2}`);
          }
        }
        size(t2) {
          var e;
          return null !== (e = Bt(this.idl, t2)) && void 0 !== e ? e : 0;
        }
      };
      Ce = fe([Ie(Ee(), "mintAuthority"), Se("supply"), de("decimals"), (ze = "isInitialized", new ke(de(), xe, Pe, ze)), Ie(Ee(), "freezeAuthority")]);
      Be = fe([Ee("mint"), Ee("authority"), Se("amount"), Ie(Ee(), "delegate"), de("state"), Ie(Se(), "isNative"), Se("delegatedAmount"), Ie(Ee(), "closeAuthority")]);
      Oe = class {
        constructor(t2) {
        }
        decode(t2) {
          throw new Error("SPL token program does not have events");
        }
      };
      De = class {
        constructor(t2) {
        }
        encode(t2, e) {
          throw new Error("SPL token does not have user-defined types");
        }
        decode(t2, e) {
          throw new Error("SPL token does not have user-defined types");
        }
      };
      Ne = class {
        constructor(t2) {
          this.instruction = new ge(t2), this.accounts = new Te(t2), this.events = new Oe(t2), this.state = new _e(t2), this.types = new De(t2);
        }
      };
      Re = class {
        constructor(t2) {
        }
        encode(t2, e) {
          switch ((0, import_camelcase2.default)(t2)) {
            case "createAccount":
              return function({ lamports: t3, space: e2, owner: n }) {
                return Ke({ createAccount: { lamports: t3, space: e2, owner: n.toBuffer() } });
              }(e);
            case "assign":
              return function({ owner: t3 }) {
                return Ke({ assign: { owner: t3.toBuffer() } });
              }(e);
            case "transfer":
              return function({ lamports: t3 }) {
                return Ke({ transfer: { lamports: t3 } });
              }(e);
            case "createAccountWithSeed":
              return function({ base: t3, seed: e2, lamports: n, space: r, owner: o }) {
                return Ke({ createAccountWithSeed: { base: t3.toBuffer(), seed: e2, lamports: n, space: r, owner: o.toBuffer() } }, $e.getVariant(3).span + e2.length);
              }(e);
            case "advanceNonceAccount":
              return function({ authorized: t3 }) {
                return Ke({ advanceNonceAccount: { authorized: t3.toBuffer() } });
              }(e);
            case "withdrawNonceAccount":
              return function({ lamports: t3 }) {
                return Ke({ withdrawNonceAccount: { lamports: t3 } });
              }(e);
            case "initializeNonceAccount":
              return function({ authorized: t3 }) {
                return Ke({ initializeNonceAccount: { authorized: t3.toBuffer() } });
              }(e);
            case "authorizeNonceAccount":
              return function({ authorized: t3 }) {
                return Ke({ authorizeNonceAccount: { authorized: t3.toBuffer() } });
              }(e);
            case "allocate":
              return function({ space: t3 }) {
                return Ke({ allocate: { space: t3 } });
              }(e);
            case "allocateWithSeed":
              return function({ base: t3, seed: e2, space: n, owner: r }) {
                return Ke({ allocateWithSeed: { base: t3.toBuffer(), seed: e2, space: n, owner: r.toBuffer() } }, $e.getVariant(9).span + e2.length);
              }(e);
            case "assignWithSeed":
              return function({ base: t3, seed: e2, owner: n }) {
                return Ke({ assignWithSeed: { base: t3.toBuffer(), seed: e2, owner: n.toBuffer() } }, $e.getVariant(10).span + e2.length);
              }(e);
            case "transferWithSeed":
              return function({ lamports: t3, seed: e2, owner: n }) {
                return Ke({ transferWithSeed: { lamports: t3, seed: e2, owner: n.toBuffer() } }, $e.getVariant(11).span + e2.length);
              }(e);
            default:
              throw new Error(`Invalid instruction: ${t2}`);
          }
        }
        encodeState(t2, e) {
          throw new Error("System does not have state");
        }
      };
      Ve = class extends Gt {
        constructor(t2) {
          super(-1, t2), this.property = t2, this.layout = fe([le("length"), le("lengthPadding"), ye(ue(le(), -8), "chars")], this.property);
        }
        encode(t2, e, n = 0) {
          if (null == t2)
            return this.layout.span;
          const r = { chars: Buffer.from(t2, "utf8") };
          return this.layout.encode(r, e, n);
        }
        decode(t2, e = 0) {
          return this.layout.decode(t2, e).chars.toString();
        }
        getSpan(t2, e = 0) {
          return le().span + le().span + new import_bn4.default(new Uint8Array(t2).slice(e, e + 4), 10, "le").toNumber();
        }
      };
      $e = me(le("instruction"));
      $e.addVariant(0, fe([pe("lamports"), pe("space"), je("owner")]), "createAccount"), $e.addVariant(1, fe([je("owner")]), "assign"), $e.addVariant(2, fe([pe("lamports")]), "transfer"), $e.addVariant(3, fe([je("base"), Ue("seed"), pe("lamports"), pe("space"), je("owner")]), "createAccountWithSeed"), $e.addVariant(4, fe([je("authorized")]), "advanceNonceAccount"), $e.addVariant(5, fe([pe("lamports")]), "withdrawNonceAccount"), $e.addVariant(6, fe([je("authorized")]), "initializeNonceAccount"), $e.addVariant(7, fe([je("authorized")]), "authorizeNonceAccount"), $e.addVariant(8, fe([pe("space")]), "allocate"), $e.addVariant(9, fe([je("base"), Ue("seed"), pe("space"), je("owner")]), "allocateWithSeed"), $e.addVariant(10, fe([je("base"), Ue("seed"), je("owner")]), "assignWithSeed"), $e.addVariant(11, fe([pe("lamports"), Ue("seed"), je("owner")]), "transferWithSeed");
      qe = Math.max(...Object.values($e.registry).map((t2) => t2.span));
      Fe = class {
        constructor(t2) {
        }
        encode(t2, e) {
          throw new Error("System does not have state");
        }
        decode(t2) {
          throw new Error("System does not have state");
        }
      };
      We = class {
        constructor(t2) {
          this.idl = t2;
        }
        async encode(t2, e) {
          if ("nonce" === t2) {
            const t3 = Buffer.alloc(NONCE_ACCOUNT_LENGTH), n = Je.encode(e, t3);
            return t3.slice(0, n);
          }
          throw new Error(`Invalid account name: ${t2}`);
        }
        decode(t2, e) {
          return this.decodeUnchecked(t2, e);
        }
        decodeUnchecked(t2, e) {
          if ("nonce" === t2)
            return function(t3) {
              return Je.decode(t3);
            }(e);
          throw new Error(`Invalid account name: ${t2}`);
        }
        memcmp(t2, e) {
          if ("nonce" === t2)
            return { dataSize: NONCE_ACCOUNT_LENGTH };
          throw new Error(`Invalid account name: ${t2}`);
        }
        size(t2) {
          var e;
          return null !== (e = Bt(this.idl, t2)) && void 0 !== e ? e : 0;
        }
      };
      Ge = class extends Gt {
        constructor(t2, e, n, r) {
          super(t2.span, r), this.layout = t2, this.decoder = e, this.encoder = n;
        }
        decode(t2, e) {
          return this.decoder(this.layout.decode(t2, e));
        }
        encode(t2, e, n) {
          return this.layout.encode(this.encoder(t2), e, n);
        }
        getSpan(t2, e) {
          return this.layout.getSpan(t2, e);
        }
      };
      Je = fe([le("version"), le("state"), He("authorizedPubkey"), He("nonce"), fe([he("lamportsPerSignature")], "feeCalculator")]);
      Ze = class {
        constructor(t2) {
        }
        decode(t2) {
          throw new Error("System program does not have events");
        }
      };
      Xe = class {
        constructor(t2) {
        }
        encode(t2, e) {
          throw new Error("System does not have user-defined types");
        }
        decode(t2, e) {
          throw new Error("System does not have user-defined types");
        }
      };
      Qe = class {
        constructor(t2) {
          this.instruction = new Re(t2), this.accounts = new We(t2), this.events = new Ze(t2), this.state = new Fe(t2), this.types = new Xe(t2);
        }
      };
      Ye = Object.freeze({ __proto__: null, hash: function(t2) {
        return (0, import_js_sha2562.sha256)(t2);
      } });
      rn = (e) => e instanceof import_buffer91.Buffer ? e : e instanceof Uint8Array ? import_buffer91.Buffer.from(e.buffer, e.byteOffset, e.byteLength) : import_buffer91.Buffer.from(e);
      sn = Object.freeze({ __proto__: null, createWithSeedSync: tn, createProgramAddressSync: en, findProgramAddressSync: nn, associated: on2 });
      an = new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
      cn = new PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
      un = Object.freeze({ __proto__: null, TOKEN_PROGRAM_ID: an, ASSOCIATED_PROGRAM_ID: cn, associatedAddress: async function({ mint: t2, owner: n }) {
        return (await PublicKey.findProgramAddress([n.toBuffer(), an.toBuffer(), t2.toBuffer()], cn))[0];
      } });
      dn = { exports: {} };
      !function(t2, e) {
        var n = "undefined" != typeof self ? self : qt, r = function() {
          function t3() {
            this.fetch = false, this.DOMException = n.DOMException;
          }
          return t3.prototype = n, new t3();
        }();
        !function(t3) {
          !function(e2) {
            var n2 = "URLSearchParams" in t3, r2 = "Symbol" in t3 && "iterator" in Symbol, o2 = "FileReader" in t3 && "Blob" in t3 && function() {
              try {
                return new Blob(), true;
              } catch (t4) {
                return false;
              }
            }(), i = "FormData" in t3, s = "ArrayBuffer" in t3;
            if (s)
              var a = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"], c2 = ArrayBuffer.isView || function(t4) {
                return t4 && a.indexOf(Object.prototype.toString.call(t4)) > -1;
              };
            function u2(t4) {
              if ("string" != typeof t4 && (t4 = String(t4)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(t4))
                throw new TypeError("Invalid character in header field name");
              return t4.toLowerCase();
            }
            function d2(t4) {
              return "string" != typeof t4 && (t4 = String(t4)), t4;
            }
            function l2(t4) {
              var e3 = { next: function() {
                var e4 = t4.shift();
                return { done: void 0 === e4, value: e4 };
              } };
              return r2 && (e3[Symbol.iterator] = function() {
                return e3;
              }), e3;
            }
            function h2(t4) {
              this.map = {}, t4 instanceof h2 ? t4.forEach(function(t5, e3) {
                this.append(e3, t5);
              }, this) : Array.isArray(t4) ? t4.forEach(function(t5) {
                this.append(t5[0], t5[1]);
              }, this) : t4 && Object.getOwnPropertyNames(t4).forEach(function(e3) {
                this.append(e3, t4[e3]);
              }, this);
            }
            function p2(t4) {
              if (t4.bodyUsed)
                return Promise.reject(new TypeError("Already read"));
              t4.bodyUsed = true;
            }
            function f3(t4) {
              return new Promise(function(e3, n3) {
                t4.onload = function() {
                  e3(t4.result);
                }, t4.onerror = function() {
                  n3(t4.error);
                };
              });
            }
            function m(t4) {
              var e3 = new FileReader(), n3 = f3(e3);
              return e3.readAsArrayBuffer(t4), n3;
            }
            function y2(t4) {
              if (t4.slice)
                return t4.slice(0);
              var e3 = new Uint8Array(t4.byteLength);
              return e3.set(new Uint8Array(t4)), e3.buffer;
            }
            function g2() {
              return this.bodyUsed = false, this._initBody = function(t4) {
                var e3;
                this._bodyInit = t4, t4 ? "string" == typeof t4 ? this._bodyText = t4 : o2 && Blob.prototype.isPrototypeOf(t4) ? this._bodyBlob = t4 : i && FormData.prototype.isPrototypeOf(t4) ? this._bodyFormData = t4 : n2 && URLSearchParams.prototype.isPrototypeOf(t4) ? this._bodyText = t4.toString() : s && o2 && ((e3 = t4) && DataView.prototype.isPrototypeOf(e3)) ? (this._bodyArrayBuffer = y2(t4.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : s && (ArrayBuffer.prototype.isPrototypeOf(t4) || c2(t4)) ? this._bodyArrayBuffer = y2(t4) : this._bodyText = t4 = Object.prototype.toString.call(t4) : this._bodyText = "", this.headers.get("content-type") || ("string" == typeof t4 ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : n2 && URLSearchParams.prototype.isPrototypeOf(t4) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
              }, o2 && (this.blob = function() {
                var t4 = p2(this);
                if (t4)
                  return t4;
                if (this._bodyBlob)
                  return Promise.resolve(this._bodyBlob);
                if (this._bodyArrayBuffer)
                  return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                if (this._bodyFormData)
                  throw new Error("could not read FormData body as blob");
                return Promise.resolve(new Blob([this._bodyText]));
              }, this.arrayBuffer = function() {
                return this._bodyArrayBuffer ? p2(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(m);
              }), this.text = function() {
                var t4 = p2(this);
                if (t4)
                  return t4;
                if (this._bodyBlob)
                  return function(t5) {
                    var e3 = new FileReader(), n3 = f3(e3);
                    return e3.readAsText(t5), n3;
                  }(this._bodyBlob);
                if (this._bodyArrayBuffer)
                  return Promise.resolve(function(t5) {
                    for (var e3 = new Uint8Array(t5), n3 = new Array(e3.length), r3 = 0; r3 < e3.length; r3++)
                      n3[r3] = String.fromCharCode(e3[r3]);
                    return n3.join("");
                  }(this._bodyArrayBuffer));
                if (this._bodyFormData)
                  throw new Error("could not read FormData body as text");
                return Promise.resolve(this._bodyText);
              }, i && (this.formData = function() {
                return this.text().then(b2);
              }), this.json = function() {
                return this.text().then(JSON.parse);
              }, this;
            }
            h2.prototype.append = function(t4, e3) {
              t4 = u2(t4), e3 = d2(e3);
              var n3 = this.map[t4];
              this.map[t4] = n3 ? n3 + ", " + e3 : e3;
            }, h2.prototype.delete = function(t4) {
              delete this.map[u2(t4)];
            }, h2.prototype.get = function(t4) {
              return t4 = u2(t4), this.has(t4) ? this.map[t4] : null;
            }, h2.prototype.has = function(t4) {
              return this.map.hasOwnProperty(u2(t4));
            }, h2.prototype.set = function(t4, e3) {
              this.map[u2(t4)] = d2(e3);
            }, h2.prototype.forEach = function(t4, e3) {
              for (var n3 in this.map)
                this.map.hasOwnProperty(n3) && t4.call(e3, this.map[n3], n3, this);
            }, h2.prototype.keys = function() {
              var t4 = [];
              return this.forEach(function(e3, n3) {
                t4.push(n3);
              }), l2(t4);
            }, h2.prototype.values = function() {
              var t4 = [];
              return this.forEach(function(e3) {
                t4.push(e3);
              }), l2(t4);
            }, h2.prototype.entries = function() {
              var t4 = [];
              return this.forEach(function(e3, n3) {
                t4.push([n3, e3]);
              }), l2(t4);
            }, r2 && (h2.prototype[Symbol.iterator] = h2.prototype.entries);
            var w2 = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
            function v2(t4, e3) {
              var n3, r3, o3 = (e3 = e3 || {}).body;
              if (t4 instanceof v2) {
                if (t4.bodyUsed)
                  throw new TypeError("Already read");
                this.url = t4.url, this.credentials = t4.credentials, e3.headers || (this.headers = new h2(t4.headers)), this.method = t4.method, this.mode = t4.mode, this.signal = t4.signal, o3 || null == t4._bodyInit || (o3 = t4._bodyInit, t4.bodyUsed = true);
              } else
                this.url = String(t4);
              if (this.credentials = e3.credentials || this.credentials || "same-origin", !e3.headers && this.headers || (this.headers = new h2(e3.headers)), this.method = (n3 = e3.method || this.method || "GET", r3 = n3.toUpperCase(), w2.indexOf(r3) > -1 ? r3 : n3), this.mode = e3.mode || this.mode || null, this.signal = e3.signal || this.signal, this.referrer = null, ("GET" === this.method || "HEAD" === this.method) && o3)
                throw new TypeError("Body not allowed for GET or HEAD requests");
              this._initBody(o3);
            }
            function b2(t4) {
              var e3 = new FormData();
              return t4.trim().split("&").forEach(function(t5) {
                if (t5) {
                  var n3 = t5.split("="), r3 = n3.shift().replace(/\+/g, " "), o3 = n3.join("=").replace(/\+/g, " ");
                  e3.append(decodeURIComponent(r3), decodeURIComponent(o3));
                }
              }), e3;
            }
            function A2(t4, e3) {
              e3 || (e3 = {}), this.type = "default", this.status = void 0 === e3.status ? 200 : e3.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in e3 ? e3.statusText : "OK", this.headers = new h2(e3.headers), this.url = e3.url || "", this._initBody(t4);
            }
            v2.prototype.clone = function() {
              return new v2(this, { body: this._bodyInit });
            }, g2.call(v2.prototype), g2.call(A2.prototype), A2.prototype.clone = function() {
              return new A2(this._bodyInit, { status: this.status, statusText: this.statusText, headers: new h2(this.headers), url: this.url });
            }, A2.error = function() {
              var t4 = new A2(null, { status: 0, statusText: "" });
              return t4.type = "error", t4;
            };
            var _2 = [301, 302, 303, 307, 308];
            A2.redirect = function(t4, e3) {
              if (-1 === _2.indexOf(e3))
                throw new RangeError("Invalid status code");
              return new A2(null, { status: e3, headers: { location: t4 } });
            }, e2.DOMException = t3.DOMException;
            try {
              new e2.DOMException();
            } catch (t4) {
              e2.DOMException = function(t5, e3) {
                this.message = t5, this.name = e3;
                var n3 = Error(t5);
                this.stack = n3.stack;
              }, e2.DOMException.prototype = Object.create(Error.prototype), e2.DOMException.prototype.constructor = e2.DOMException;
            }
            function S2(t4, n3) {
              return new Promise(function(r3, i2) {
                var s2 = new v2(t4, n3);
                if (s2.signal && s2.signal.aborted)
                  return i2(new e2.DOMException("Aborted", "AbortError"));
                var a2 = new XMLHttpRequest();
                function c3() {
                  a2.abort();
                }
                a2.onload = function() {
                  var t5, e3, n4 = { status: a2.status, statusText: a2.statusText, headers: (t5 = a2.getAllResponseHeaders() || "", e3 = new h2(), t5.replace(/\r?\n[\t ]+/g, " ").split(/\r?\n/).forEach(function(t6) {
                    var n5 = t6.split(":"), r4 = n5.shift().trim();
                    if (r4) {
                      var o4 = n5.join(":").trim();
                      e3.append(r4, o4);
                    }
                  }), e3) };
                  n4.url = "responseURL" in a2 ? a2.responseURL : n4.headers.get("X-Request-URL");
                  var o3 = "response" in a2 ? a2.response : a2.responseText;
                  r3(new A2(o3, n4));
                }, a2.onerror = function() {
                  i2(new TypeError("Network request failed"));
                }, a2.ontimeout = function() {
                  i2(new TypeError("Network request failed"));
                }, a2.onabort = function() {
                  i2(new e2.DOMException("Aborted", "AbortError"));
                }, a2.open(s2.method, s2.url, true), "include" === s2.credentials ? a2.withCredentials = true : "omit" === s2.credentials && (a2.withCredentials = false), "responseType" in a2 && o2 && (a2.responseType = "blob"), s2.headers.forEach(function(t5, e3) {
                  a2.setRequestHeader(e3, t5);
                }), s2.signal && (s2.signal.addEventListener("abort", c3), a2.onreadystatechange = function() {
                  4 === a2.readyState && s2.signal.removeEventListener("abort", c3);
                }), a2.send(void 0 === s2._bodyInit ? null : s2._bodyInit);
              });
            }
            S2.polyfill = true, t3.fetch || (t3.fetch = S2, t3.Headers = h2, t3.Request = v2, t3.Response = A2), e2.Headers = h2, e2.Request = v2, e2.Response = A2, e2.fetch = S2, Object.defineProperty(e2, "__esModule", { value: true });
          }({});
        }(r), r.fetch.ponyfill = true, delete r.fetch.polyfill;
        var o = r;
        (e = o.fetch).default = o.fetch, e.fetch = o.fetch, e.Headers = o.Headers, e.Request = o.Request, e.Response = o.Response, t2.exports = e;
      }(dn, dn.exports);
      ln = Ft(dn.exports);
      pn = f2.rustEnum([f2.struct([], "uninitialized"), f2.struct([f2.option(f2.publicKey(), "authorityAddress")], "buffer"), f2.struct([f2.publicKey("programdataAddress")], "program"), f2.struct([f2.u64("slot"), f2.option(f2.publicKey(), "upgradeAuthorityAddress")], "programData")], void 0, f2.u32());
      mn = Object.freeze({ __proto__: null, verifiedBuild: async function(t2, e, n = 5) {
        const r = `https://api.apr.dev/api/v0/program/${e.toString()}/latest?limit=${n}`, [o, i] = await Promise.all([hn(t2, e), ln(r)]), s = (await i.json()).filter((t3) => !t3.aborted && "Built" === t3.state && "Verified" === t3.verified);
        if (0 === s.length)
          return null;
        const a = s[0];
        return o.slot.toNumber() !== a.verified_slot ? null : a;
      }, fetchData: hn, decodeUpgradeableLoaderState: fn });
      yn = Object.freeze({ __proto__: null, sha256: Ye, rpc: it, publicKey: sn, bytes: k, token: un, features: yt, registry: mn });
      gn = f2.struct([f2.publicKey("authority"), f2.vecU8("data")]);
      vn = class {
        static build(t2, e, n) {
          if ("_inner" === t2.name)
            throw new gt("the _inner name is reserved");
          const o = (...i) => {
            const [s, a] = wn(t2, [...i]);
            P(t2.accounts, a.accounts);
            const c2 = o.accounts(a.accounts);
            return void 0 !== a.remainingAccounts && c2.push(...a.remainingAccounts), mt("debug-logs") && console.log("Outgoing account metas:", c2), new TransactionInstruction({ keys: c2, programId: n, data: e(t2.name, x(t2, ...s)) });
          };
          return o.accounts = (e2) => vn.accountsArray(e2, t2.accounts, t2.name), o;
        }
        static accountsArray(t2, e, n) {
          return t2 ? e.map((e2) => {
            if (void 0 !== ("accounts" in e2 ? e2.accounts : void 0)) {
              const r = t2[e2.name];
              return vn.accountsArray(r, e2.accounts, n).flat();
            }
            {
              const r = e2;
              let o;
              try {
                o = L(t2[e2.name]);
              } catch (t3) {
                throw new Error(`Wrong input type for account "${e2.name}" in the instruction accounts object${void 0 !== n ? ' for instruction "' + n + '"' : ""}. Expected PublicKey or string.`);
              }
              return { pubkey: o, isWritable: r.isMut, isSigner: r.isSigner };
            }
          }).flat() : [];
        }
      };
      bn = class {
        static build(t2, e, n, r) {
          return async (...o) => {
            var i;
            const s = e(...o), [, a] = wn(t2, [...o]);
            if (void 0 === r.sendAndConfirm)
              throw new Error("This function requires 'Provider.sendAndConfirm' to be implemented.");
            try {
              return await r.sendAndConfirm(s, null !== (i = a.signers) && void 0 !== i ? i : [], a.options);
            } catch (t3) {
              throw At(t3, n);
            }
          };
        }
      };
      An = class {
        static build(t2, e) {
          return (...r) => {
            var o, i, s;
            const [, a] = wn(t2, [...r]), c2 = new Transaction();
            if (a.preInstructions && a.instructions)
              throw new Error("instructions is deprecated, use preInstructions");
            return null === (o = a.preInstructions) || void 0 === o || o.forEach((t3) => c2.add(t3)), null === (i = a.instructions) || void 0 === i || i.forEach((t3) => c2.add(t3)), c2.add(e(...r)), null === (s = a.postInstructions) || void 0 === s || s.forEach((t3) => c2.add(t3)), c2;
          };
        }
      };
      _n = class {
        constructor(t2, e, n = lt(), r = new Kt(t2)) {
          this.provider = n, this.coder = r, this._idl = t2, this._programId = e, this._address = Sn(e), this._sub = null;
          const [o, i, a] = (() => {
            var o2;
            let i2 = {}, a2 = {}, c2 = {};
            return null === (o2 = t2.state) || void 0 === o2 || o2.methods.forEach((o3) => {
              const u2 = vn.build(o3, (t3, e2) => r.instruction.encodeState(t3, e2), e);
              u2.accounts = (t3) => {
                const r2 = function(t4, e2, n2, r3) {
                  if ("new" === n2.name) {
                    const [n3] = nn([], t4);
                    if (void 0 === e2.wallet)
                      throw new Error("This function requires the Provider interface implementor to have a 'wallet' field.");
                    return [{ pubkey: e2.wallet.publicKey, isWritable: false, isSigner: true }, { pubkey: Sn(t4), isWritable: true, isSigner: false }, { pubkey: n3, isWritable: false, isSigner: false }, { pubkey: SystemProgram.programId, isWritable: false, isSigner: false }, { pubkey: t4, isWritable: false, isSigner: false }];
                  }
                  return P(n2.accounts, r3), [{ pubkey: Sn(t4), isWritable: true, isSigner: false }];
                }(e, n, o3, t3);
                return r2.concat(vn.accountsArray(t3, o3.accounts, o3.name));
              };
              const d2 = An.build(o3, u2), l2 = bn.build(o3, d2, M(t2), n), p2 = (0, import_camelcase2.default)(o3.name);
              i2[p2] = u2, a2[p2] = d2, c2[p2] = l2;
            }), [i2, a2, c2];
          })();
          this.instruction = o, this.transaction = i, this.rpc = a;
        }
        get programId() {
          return this._programId;
        }
        async fetch() {
          const t2 = this.address(), e = await this.provider.connection.getAccountInfo(t2);
          if (null === e)
            throw new Error(`Account does not exist ${t2.toString()}`);
          const n = this._idl.state;
          if (!n)
            throw new Error("State is not specified in IDL.");
          if ((await jt(n.struct.name)).compare(e.data.slice(0, 8)))
            throw new Error("Invalid account discriminator");
          return this.coder.state.decode(e.data);
        }
        address() {
          return this._address;
        }
        subscribe(t2) {
          if (null !== this._sub)
            return this._sub.ee;
          const e = new import_eventemitter33.default(), n = this.provider.connection.onAccountChange(this.address(), (t3) => {
            const n2 = this.coder.state.decode(t3.data);
            e.emit("change", n2);
          }, t2);
          return this._sub = { ee: e, listener: n }, e;
        }
        unsubscribe() {
          null !== this._sub && this.provider.connection.removeAccountChangeListener(this._sub.listener).then(async () => {
            this._sub = null;
          }).catch(console.error);
        }
      };
      En = class {
        constructor(t2, e, n, r, o) {
          this._idlAccount = e, this._programId = n, this._provider = null != r ? r : lt(), this._coder = null != o ? o : new Kt(t2), this._size = this._coder.accounts.size(e);
        }
        get size() {
          return this._size;
        }
        get programId() {
          return this._programId;
        }
        get provider() {
          return this._provider;
        }
        get coder() {
          return this._coder;
        }
        async fetchNullable(t2, e) {
          const n = await this.getAccountInfo(t2, e);
          return null === n ? null : this._coder.accounts.decode(this._idlAccount.name, n.data);
        }
        async fetch(t2, e) {
          const n = await this.fetchNullable(t2, e);
          if (null === n)
            throw new Error(`Account does not exist ${t2.toString()}`);
          return n;
        }
        async fetchMultiple(t2, e) {
          return (await X(this._provider.connection, t2.map((t3) => L(t3)), e)).map((t3) => null == t3 ? null : this._coder.accounts.decode(this._idlAccount.name, null == t3 ? void 0 : t3.account.data));
        }
        async all(t2) {
          return (await this._provider.connection.getProgramAccounts(this._programId, { commitment: this._provider.connection.commitment, filters: [{ memcmp: this.coder.accounts.memcmp(this._idlAccount.name, t2 instanceof Buffer ? t2 : void 0) }, ...Array.isArray(t2) ? t2 : []] })).map(({ pubkey: t3, account: e }) => ({ publicKey: t3, account: this._coder.accounts.decode(this._idlAccount.name, e.data) }));
        }
        subscribe(t2, e) {
          const n = In.get(t2.toString());
          if (n)
            return n.ee;
          const r = new import_eventemitter33.default();
          t2 = L(t2);
          const o = this._provider.connection.onAccountChange(t2, (t3) => {
            const e2 = this._coder.accounts.decode(this._idlAccount.name, t3.data);
            r.emit("change", e2);
          }, e);
          return In.set(t2.toString(), { ee: r, listener: o }), r;
        }
        async unsubscribe(t2) {
          let e = In.get(t2.toString());
          e ? In && await this._provider.connection.removeAccountChangeListener(e.listener).then(() => {
            In.delete(t2.toString());
          }).catch(console.error) : console.warn("Address is not subscribed");
        }
        async createInstruction(t2, e) {
          const n = this.size;
          if (void 0 === this._provider.wallet)
            throw new Error("This function requires the Provider interface implementor to have a 'wallet' field.");
          return SystemProgram.createAccount({ fromPubkey: this._provider.wallet.publicKey, newAccountPubkey: t2.publicKey, space: null != e ? e : n, lamports: await this._provider.connection.getMinimumBalanceForRentExemption(null != e ? e : n), programId: this._programId });
        }
        async associated(...t2) {
          const e = await this.associatedAddress(...t2);
          return await this.fetch(e);
        }
        async associatedAddress(...t2) {
          return await on2(this._programId, ...t2);
        }
        async getAccountInfo(t2, e) {
          return await this._provider.connection.getAccountInfo(L(t2), e);
        }
      };
      In = /* @__PURE__ */ new Map();
      kn = "Program log: ".length;
      Mn = "Program data: ".length;
      xn = class {
        constructor(t2, e, n) {
          this._programId = t2, this._provider = e, this._eventParser = new Pn(t2, n), this._eventCallbacks = /* @__PURE__ */ new Map(), this._eventListeners = /* @__PURE__ */ new Map(), this._listenerIdCount = 0;
        }
        addEventListener(t2, e) {
          var n;
          let r = this._listenerIdCount;
          return this._listenerIdCount += 1, t2 in this._eventCallbacks || this._eventListeners.set(t2, []), this._eventListeners.set(t2, (null !== (n = this._eventListeners.get(t2)) && void 0 !== n ? n : []).concat(r)), this._eventCallbacks.set(r, [t2, e]), void 0 !== this._onLogsSubscriptionId || (this._onLogsSubscriptionId = this._provider.connection.onLogs(this._programId, (t3, e2) => {
            if (!t3.err)
              for (const n2 of this._eventParser.parseLogs(t3.logs)) {
                const r2 = this._eventListeners.get(n2.name);
                r2 && r2.forEach((r3) => {
                  const o = this._eventCallbacks.get(r3);
                  if (o) {
                    const [, r4] = o;
                    r4(n2.data, e2.slot, t3.signature);
                  }
                });
              }
          })), r;
        }
        async removeEventListener(t2) {
          const e = this._eventCallbacks.get(t2);
          if (!e)
            throw new Error(`Event listener ${t2} doesn't exist!`);
          const [n] = e;
          let r = this._eventListeners.get(n);
          if (!r)
            throw new Error(`Event listeners don't exist for ${n}!`);
          this._eventCallbacks.delete(t2), r = r.filter((e2) => e2 !== t2), 0 === r.length && this._eventListeners.delete(n), 0 == this._eventCallbacks.size && (g.ok(0 === this._eventListeners.size), void 0 !== this._onLogsSubscriptionId && (await this._provider.connection.removeOnLogsListener(this._onLogsSubscriptionId), this._onLogsSubscriptionId = void 0));
        }
      };
      Pn = class {
        constructor(t2, e) {
          this.coder = e, this.programId = t2;
        }
        *parseLogs(t2) {
          const e = new Tn(t2), n = new Ln();
          let r = e.next();
          for (; null !== r; ) {
            let [t3, o, i] = this.handleLog(n, r);
            t3 && (yield t3), o && n.push(o), i && n.pop(), r = e.next();
          }
        }
        handleLog(t2, e) {
          return t2.stack.length > 0 && t2.program() === this.programId.toString() ? this.handleProgramLog(e) : [null, ...this.handleSystemLog(e)];
        }
        handleProgramLog(t2) {
          if (t2.startsWith("Program log: ") || t2.startsWith("Program data: ")) {
            const e = t2.startsWith("Program log: ") ? t2.slice(kn) : t2.slice(Mn);
            return [this.coder.events.decode(e), null, false];
          }
          return [null, ...this.handleSystemLog(t2)];
        }
        handleSystemLog(t2) {
          const e = t2.split(":")[0];
          return null !== e.match(/^Program (.*) success/g) ? [null, true] : e.startsWith(`Program ${this.programId.toString()} invoke`) ? [this.programId.toString(), false] : e.includes("invoke") ? ["cpi", false] : [null, false];
        }
      };
      Ln = class {
        constructor() {
          this.stack = [];
        }
        program() {
          return g.ok(this.stack.length > 0), this.stack[this.stack.length - 1];
        }
        push(t2) {
          this.stack.push(t2);
        }
        pop() {
          g.ok(this.stack.length > 0), this.stack.pop();
        }
      };
      Tn = class {
        constructor(t2) {
          this.logs = t2;
        }
        next() {
          if (0 === this.logs.length)
            return null;
          let t2 = this.logs[0];
          return this.logs = this.logs.slice(1), t2;
        }
      };
      Cn = new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
      Bn = { version: "0.1.0", name: "spl_token", instructions: [{ name: "initializeMint", accounts: [{ name: "mint", isMut: true, isSigner: false }, { name: "rent", isMut: false, isSigner: false }], args: [{ name: "decimals", type: "u8" }, { name: "mintAuthority", type: "publicKey" }, { name: "freezeAuthority", type: { coption: "publicKey" } }] }, { name: "initializeAccount", accounts: [{ name: "account", isMut: true, isSigner: false }, { name: "mint", isMut: false, isSigner: false }, { name: "authority", isMut: false, isSigner: false }, { name: "rent", isMut: false, isSigner: false }], args: [] }, { name: "initializeMultisig", accounts: [{ name: "account", isMut: true, isSigner: false }, { name: "rent", isMut: false, isSigner: false }], args: [{ name: "m", type: "u8" }] }, { name: "transfer", accounts: [{ name: "source", isMut: true, isSigner: false }, { name: "destination", isMut: true, isSigner: false }, { name: "authority", isMut: false, isSigner: true }], args: [{ name: "amount", type: "u64" }] }, { name: "approve", accounts: [{ name: "source", isMut: true, isSigner: false }, { name: "delegate", isMut: false, isSigner: false }, { name: "authority", isMut: false, isSigner: true }], args: [{ name: "amount", type: "u64" }] }, { name: "revoke", accounts: [{ name: "source", isMut: true, isSigner: false }, { name: "authority", isMut: false, isSigner: true }], args: [] }, { name: "setAuthority", accounts: [{ name: "mint", isMut: true, isSigner: false }, { name: "authority", isMut: false, isSigner: true }], args: [{ name: "authorityType", type: "u8" }, { name: "newAuthority", type: { coption: "publicKey" } }] }, { name: "mintTo", accounts: [{ name: "mint", isMut: true, isSigner: false }, { name: "to", isMut: true, isSigner: false }, { name: "authority", isMut: false, isSigner: true }], args: [{ name: "amount", type: "u64" }] }, { name: "burn", accounts: [{ name: "source", isMut: true, isSigner: false }, { name: "mint", isMut: true, isSigner: false }, { name: "authority", isMut: false, isSigner: true }], args: [{ name: "amount", type: "u64" }] }, { name: "closeAccount", accounts: [{ name: "account", isMut: true, isSigner: false }, { name: "destination", isMut: true, isSigner: false }, { name: "authority", isMut: false, isSigner: false }], args: [] }, { name: "freezeAccount", accounts: [{ name: "account", isMut: true, isSigner: false }, { name: "mint", isMut: false, isSigner: false }, { name: "authority", isMut: false, isSigner: true }], args: [] }, { name: "thawAccount", accounts: [{ name: "account", isMut: true, isSigner: false }, { name: "mint", isMut: false, isSigner: false }, { name: "authority", isMut: false, isSigner: true }], args: [] }, { name: "transferChecked", accounts: [{ name: "source", isMut: true, isSigner: false }, { name: "mint", isMut: false, isSigner: false }, { name: "destination", isMut: true, isSigner: false }, { name: "authority", isMut: false, isSigner: true }], args: [{ name: "amount", type: "u64" }, { name: "decimals", type: "u8" }] }, { name: "approveChecked", accounts: [{ name: "source", isMut: true, isSigner: false }, { name: "mint", isMut: false, isSigner: false }, { name: "delegate", isMut: false, isSigner: false }, { name: "authority", isMut: false, isSigner: true }], args: [{ name: "amount", type: "u64" }, { name: "decimals", type: "u8" }] }, { name: "mintToChecked", accounts: [{ name: "mint", isMut: true, isSigner: false }, { name: "to", isMut: true, isSigner: false }, { name: "authority", isMut: false, isSigner: true }], args: [{ name: "amount", type: "u64" }, { name: "decimals", type: "u8" }] }, { name: "burnChecked", accounts: [{ name: "source", isMut: true, isSigner: false }, { name: "mint", isMut: true, isSigner: false }, { name: "authority", isMut: false, isSigner: true }], args: [{ name: "amount", type: "u64" }, { name: "decimals", type: "u8" }] }, { name: "initializeAccount2", accounts: [{ name: "account", isMut: true, isSigner: false }, { name: "mint", isMut: false, isSigner: false }, { name: "rent", isMut: false, isSigner: false }], args: [{ name: "authority", type: "publicKey" }] }, { name: "syncNative", accounts: [{ name: "account", isMut: true, isSigner: false }], args: [] }, { name: "initializeAccount3", accounts: [{ name: "account", isMut: true, isSigner: false }, { name: "mint", isMut: false, isSigner: false }], args: [{ name: "authority", type: "publicKey" }] }, { name: "initializeMultisig2", accounts: [{ name: "account", isMut: true, isSigner: false }], args: [{ name: "m", type: "u8" }] }, { name: "initializeMint2", accounts: [{ name: "mint", isMut: true, isSigner: false }], args: [{ name: "decimals", type: "u8" }, { name: "mintAuthority", type: "publicKey" }, { name: "freezeAuthority", type: { coption: "publicKey" } }] }], accounts: [{ name: "mint", type: { kind: "struct", fields: [{ name: "mintAuthority", type: { coption: "publicKey" } }, { name: "supply", type: "u64" }, { name: "decimals", type: "u8" }, { name: "isInitialized", type: "bool" }, { name: "freezeAuthority", type: { coption: "publicKey" } }] } }, { name: "token", type: { kind: "struct", fields: [{ name: "mint", type: "publicKey" }, { name: "authority", type: "publicKey" }, { name: "amount", type: "u64" }, { name: "delegate", type: { coption: "publicKey" } }, { name: "state", type: "u8" }, { name: "isNative", type: { coption: "u64" } }, { name: "delegatedAmount", type: "u64" }, { name: "closeAuthority", type: { coption: "publicKey" } }] } }] };
      On = class {
        constructor(t2, e, n, r, o, i) {
          this._args = t2, this._accounts = e, this._provider = n, this._programId = r, this._idlIx = o, this._accountStore = new Dn(n, i);
        }
        async resolve() {
          for (let t2 = 0; t2 < this._idlIx.accounts.length; t2 += 1) {
            const e = this._idlIx.accounts[t2], n = (0, import_camelcase2.default)(e.name);
            if (!e.isSigner || this._accounts[n])
              Reflect.has(On.CONST_ACCOUNTS, n) && !this._accounts[n] && (this._accounts[n] = On.CONST_ACCOUNTS[n]);
            else {
              if (void 0 === this._provider.wallet)
                throw new Error("This function requires the Provider interface implementor to have a 'wallet' field.");
              this._accounts[n] = this._provider.wallet.publicKey;
            }
          }
          for (let t2 = 0; t2 < this._idlIx.accounts.length; t2 += 1) {
            const e = this._idlIx.accounts[t2], n = (0, import_camelcase2.default)(e.name);
            e.pda && e.pda.seeds.length > 0 && !this._accounts[n] && await this.autoPopulatePda(e);
          }
        }
        async autoPopulatePda(t2) {
          if (!t2.pda || !t2.pda.seeds)
            throw new Error("Must have seeds");
          const n = await Promise.all(t2.pda.seeds.map((t3) => this.toBuffer(t3))), r = await this.parseProgramId(t2), [o] = await PublicKey.findProgramAddress(n, r);
          this._accounts[(0, import_camelcase2.default)(t2.name)] = o;
        }
        async parseProgramId(t2) {
          var n;
          if (!(null === (n = t2.pda) || void 0 === n ? void 0 : n.programId))
            return this._programId;
          switch (t2.pda.programId.kind) {
            case "const":
              return new PublicKey(this.toBufferConst(t2.pda.programId.value));
            case "arg":
              return this.argValue(t2.pda.programId);
            case "account":
              return await this.accountValue(t2.pda.programId);
            default:
              throw new Error(`Unexpected program seed kind: ${t2.pda.programId.kind}`);
          }
        }
        async toBuffer(t2) {
          switch (t2.kind) {
            case "const":
              return this.toBufferConst(t2);
            case "arg":
              return await this.toBufferArg(t2);
            case "account":
              return await this.toBufferAccount(t2);
            default:
              throw new Error(`Unexpected seed kind: ${t2.kind}`);
          }
        }
        toBufferConst(t2) {
          return this.toBufferValue(t2.type, t2.value);
        }
        async toBufferArg(t2) {
          const e = this.argValue(t2);
          return this.toBufferValue(t2.type, e);
        }
        argValue(t2) {
          const e = (0, import_camelcase2.default)(t2.path.split(".")[0]), n = this._idlIx.args.findIndex((t3) => t3.name === e);
          if (-1 === n)
            throw new Error(`Unable to find argument for seed: ${e}`);
          return this._args[n];
        }
        async toBufferAccount(t2) {
          const e = await this.accountValue(t2);
          return this.toBufferValue(t2.type, e);
        }
        async accountValue(t2) {
          const e = t2.path.split("."), n = e[0], r = this._accounts[(0, import_camelcase2.default)(n)];
          if (1 === e.length)
            return r;
          const o = await this._accountStore.fetchAccount(t2.account, r);
          return this.parseAccountValue(o, e.slice(1));
        }
        parseAccountValue(t2, e) {
          let n;
          for (; e.length > 0; )
            n = t2[(0, import_camelcase2.default)(e[0])], e = e.slice(1);
          return n;
        }
        toBufferValue(t2, e) {
          switch (t2) {
            case "u8":
              return Buffer.from([e]);
            case "u16":
              let n = Buffer.alloc(2);
              return n.writeUInt16LE(e), n;
            case "u32":
              let r = Buffer.alloc(4);
              return r.writeUInt32LE(e), r;
            case "u64":
              let o = Buffer.alloc(8);
              return o.writeBigUInt64LE(BigInt(e)), o;
            case "string":
              return Buffer.from(b(e));
            case "publicKey":
              return e.toBuffer();
            default:
              if (t2.array)
                return Buffer.from(e);
              throw new Error(`Unexpected seed type: ${t2}`);
          }
        }
      };
      On.CONST_ACCOUNTS = { associatedTokenProgram: cn, rent: SYSVAR_RENT_PUBKEY, systemProgram: SystemProgram.programId, tokenProgram: an };
      Dn = class {
        constructor(t2, e) {
          this._provider = t2, this._accounts = e, this._cache = /* @__PURE__ */ new Map();
        }
        async fetchAccount(t2, e) {
          const n = e.toString();
          if (!this._cache.has(n))
            if ("TokenAccount" === t2) {
              const t3 = await this._provider.connection.getAccountInfo(e);
              if (null === t3)
                throw new Error(`invalid account info for ${n}`);
              const r = zn().accounts.decode("token", t3.data);
              this._cache.set(n, r);
            } else {
              const r = this._accounts[(0, import_camelcase2.default)(t2)].fetch(e);
              this._cache.set(n, r);
            }
          return this._cache.get(n);
        }
      };
      Nn = class {
        static build(t2, e, n, r, o, i, s, a, c2) {
          return (...u2) => new Rn(u2, r, o, i, s, a, t2, e, n, c2);
        }
      };
      Rn = class {
        constructor(t2, e, n, r, o, i, s, a, c2, u2) {
          this._args = t2, this._ixFn = e, this._txFn = n, this._rpcFn = r, this._simulateFn = o, this._viewFn = i, this._accounts = {}, this._remainingAccounts = [], this._signers = [], this._preInstructions = [], this._postInstructions = [], this._autoResolveAccounts = true, this._accountsResolver = new On(t2, this._accounts, s, a, c2, u2);
        }
        async pubkeys() {
          return this._autoResolveAccounts && await this._accountsResolver.resolve(), this._accounts;
        }
        accounts(t2) {
          return this._autoResolveAccounts = true, Object.assign(this._accounts, t2), this;
        }
        accountsStrict(t2) {
          return this._autoResolveAccounts = false, Object.assign(this._accounts, t2), this;
        }
        signers(t2) {
          return this._signers = this._signers.concat(t2), this;
        }
        remainingAccounts(t2) {
          return this._remainingAccounts = this._remainingAccounts.concat(t2), this;
        }
        preInstructions(t2) {
          return this._preInstructions = this._preInstructions.concat(t2), this;
        }
        postInstructions(t2) {
          return this._postInstructions = this._postInstructions.concat(t2), this;
        }
        async rpc(t2) {
          return this._autoResolveAccounts && await this._accountsResolver.resolve(), this._rpcFn(...this._args, { accounts: this._accounts, signers: this._signers, remainingAccounts: this._remainingAccounts, preInstructions: this._preInstructions, postInstructions: this._postInstructions, options: t2 });
        }
        async view(t2) {
          if (this._autoResolveAccounts && await this._accountsResolver.resolve(), !this._viewFn)
            throw new Error("Method does not support views");
          return this._viewFn(...this._args, { accounts: this._accounts, signers: this._signers, remainingAccounts: this._remainingAccounts, preInstructions: this._preInstructions, postInstructions: this._postInstructions, options: t2 });
        }
        async simulate(t2) {
          return this._autoResolveAccounts && await this._accountsResolver.resolve(), this._simulateFn(...this._args, { accounts: this._accounts, signers: this._signers, remainingAccounts: this._remainingAccounts, preInstructions: this._preInstructions, postInstructions: this._postInstructions, options: t2 });
        }
        async instruction() {
          return this._autoResolveAccounts && await this._accountsResolver.resolve(), this._ixFn(...this._args, { accounts: this._accounts, signers: this._signers, remainingAccounts: this._remainingAccounts, preInstructions: this._preInstructions, postInstructions: this._postInstructions });
        }
        async transaction() {
          return this._autoResolveAccounts && await this._accountsResolver.resolve(), this._txFn(...this._args, { accounts: this._accounts, signers: this._signers, remainingAccounts: this._remainingAccounts, preInstructions: this._preInstructions, postInstructions: this._postInstructions });
        }
      };
      Vn = class {
        constructor(t2, e, n, r) {
          e = L(e), n || (n = lt()), this._idl = t2, this._provider = n, this._programId = e, this._coder = null != r ? r : new Kt(t2), this._events = new xn(this._programId, n, this._coder);
          const [o, i, s, a, c2, u2, d2, l2] = class {
            static build(t3, e2, n2, r2) {
              const o2 = {}, i2 = {}, s2 = {}, a2 = {}, c3 = {}, u3 = {}, d3 = M(t3), l3 = t3.accounts ? class {
                static build(t4, e3, n3, r3) {
                  var o3;
                  const i3 = {};
                  return null === (o3 = t4.accounts) || void 0 === o3 || o3.forEach((o4) => {
                    const s3 = (0, import_camelcase2.default)(o4.name);
                    i3[s3] = new En(t4, o4, n3, r3, e3);
                  }), i3;
                }
              }.build(t3, e2, n2, r2) : {}, p2 = class {
                static build(t4, e3, n3, r3) {
                  if (void 0 !== t4.state)
                    return new _n(t4, n3, r3, e3);
                }
              }.build(t3, e2, n2, r2);
              return t3.instructions.forEach((p3) => {
                const f3 = vn.build(p3, (t4, n3) => e2.instruction.encode(t4, n3), n2), m = An.build(p3, f3), y2 = bn.build(p3, m, d3, r2), g2 = class {
                  static build(t4, e3, n3, r3, o3, i3, s3) {
                    return async (...a3) => {
                      var c4;
                      const u4 = e3(...a3), [, d4] = wn(t4, [...a3]);
                      let l4;
                      if (void 0 === r3.simulate)
                        throw new Error("This function requires 'Provider.simulate' to be implemented.");
                      try {
                        l4 = await r3.simulate(u4, d4.signers, null === (c4 = d4.options) || void 0 === c4 ? void 0 : c4.commitment);
                      } catch (t5) {
                        throw At(t5, n3);
                      }
                      if (void 0 === l4)
                        throw new Error("Unable to simulate transaction");
                      const h2 = l4.logs;
                      if (!h2)
                        throw new Error("Simulated logs not found");
                      const p4 = [];
                      if (s3.events) {
                        let t5 = new Pn(i3, o3);
                        for (const e4 of t5.parseLogs(h2))
                          p4.push(e4);
                      }
                      return { events: p4, raw: h2 };
                    };
                  }
                }.build(p3, m, d3, r2, e2, n2, t3), w2 = class {
                  static build(t4, e3, n3, r3) {
                    const o3 = e3.accounts.find((t5) => t5.isMut), i3 = !!e3.returns;
                    if (!o3 && i3)
                      return async (...o4) => {
                        var i4, s3;
                        let a3 = await n3(...o4);
                        const c4 = `Program return: ${t4} `;
                        let u4 = a3.raw.find((t5) => t5.startsWith(c4));
                        if (!u4)
                          throw new Error("View expected return log");
                        let d4 = E(u4.slice(c4.length)), l4 = e3.returns;
                        if (!l4)
                          throw new Error("View expected return type");
                        return Lt.fieldLayout({ type: l4 }, Array.from([...null !== (i4 = r3.accounts) && void 0 !== i4 ? i4 : [], ...null !== (s3 = r3.types) && void 0 !== s3 ? s3 : []])).decode(d4);
                      };
                  }
                }.build(n2, p3, g2, t3), v2 = Nn.build(r2, n2, p3, f3, m, y2, g2, w2, l3), b2 = (0, import_camelcase2.default)(p3.name);
                i2[b2] = f3, s2[b2] = m, o2[b2] = y2, a2[b2] = g2, c3[b2] = v2, w2 && (u3[b2] = w2);
              }), [o2, i2, s2, l3, a2, c3, p2, u3];
            }
          }.build(t2, this._coder, e, n);
          this.rpc = o, this.instruction = i, this.transaction = s, this.account = a, this.simulate = c2, this.methods = u2, this.state = d2, this.views = l2;
        }
        get programId() {
          return this._programId;
        }
        get idl() {
          return this._idl;
        }
        get coder() {
          return this._coder;
        }
        get provider() {
          return this._provider;
        }
        static async at(t2, e) {
          const n = L(t2), r = await Vn.fetchIdl(n, e);
          if (!r)
            throw new Error(`IDL not found for program: ${t2.toString()}`);
          return new Vn(r, n, e);
        }
        static async fetchIdl(t2, n) {
          n = null != n ? n : lt();
          const r = L(t2), o = await async function(t3) {
            const n2 = (await PublicKey.findProgramAddress([], t3))[0];
            return await PublicKey.createWithSeed(n2, "anchor:idl", t3);
          }(r), i = await n.connection.getAccountInfo(o);
          if (!i)
            return null;
          let s = (a = i.data.slice(8), gn.decode(a));
          var a;
          const c2 = inflate_1(s.data);
          return JSON.parse(v(c2));
        }
        addEventListener(t2, e) {
          return this._events.addEventListener(t2, e);
        }
        async removeEventListener(t2) {
          return await this._events.removeEventListener(t2);
        }
      };
      Un = class {
        constructor(t2) {
        }
        encode(t2, e) {
          if ("create" === (0, import_camelcase2.default)(t2))
            return Buffer.alloc(0);
          throw new Error(`Invalid instruction: ${t2}`);
        }
        encodeState(t2, e) {
          throw new Error("SPL associated token does not have state");
        }
      };
      jn = class {
        constructor(t2) {
        }
        encode(t2, e) {
          throw new Error("SPL associated token does not have state");
        }
        decode(t2) {
          throw new Error("SPL associated token does not have state");
        }
      };
      $n = class {
        constructor(t2) {
          this.idl = t2;
        }
        async encode(t2, e) {
          throw new Error(`Invalid account name: ${t2}`);
        }
        decode(t2, e) {
          return this.decodeUnchecked(t2, e);
        }
        decodeUnchecked(t2, e) {
          throw new Error(`Invalid account name: ${t2}`);
        }
        memcmp(t2, e) {
          throw new Error(`Invalid account name: ${t2}`);
        }
        size(t2) {
          var e;
          return null !== (e = Bt(this.idl, t2)) && void 0 !== e ? e : 0;
        }
      };
      Kn = class {
        constructor(t2) {
        }
        decode(t2) {
          throw new Error("SPL associated token program does not have events");
        }
      };
      qn = class {
        constructor(t2) {
        }
        encode(t2, e) {
          throw new Error("SPL associated token does not have user-defined types");
        }
        decode(t2, e) {
          throw new Error("SPL associated token does not have user-defined types");
        }
      };
      Fn = class {
        constructor(t2) {
          this.instruction = new Un(t2), this.accounts = new $n(t2), this.events = new Kn(t2), this.state = new jn(t2), this.types = new qn(t2);
        }
      };
      Wn = new PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
      Hn = { version: "0.1.0", name: "spl_associated_token", instructions: [{ name: "create", accounts: [{ name: "authority", isMut: true, isSigner: true }, { name: "associatedAccount", isMut: true, isSigner: false }, { name: "owner", isMut: false, isSigner: false }, { name: "mint", isMut: false, isSigner: false }, { name: "systemProgram", isMut: false, isSigner: false }, { name: "tokenProgram", isMut: false, isSigner: false }, { name: "rent", isMut: false, isSigner: false }], args: [] }] };
      Jn = class {
        static token(t2) {
          return function(t3) {
            return new Vn(Bn, Cn, t3, zn());
          }(t2);
        }
        static associatedToken(t2) {
          return Gn(t2);
        }
      };
      Zn = new PublicKey("11111111111111111111111111111111");
      Qn = { version: "0.1.0", name: "system_program", instructions: [{ name: "createAccount", accounts: [{ name: "from", isMut: true, isSigner: true }, { name: "to", isMut: true, isSigner: true }], args: [{ name: "lamports", type: "u64" }, { name: "space", type: "u64" }, { name: "owner", type: "publicKey" }] }, { name: "assign", accounts: [{ name: "pubkey", isMut: true, isSigner: true }], args: [{ name: "owner", type: "publicKey" }] }, { name: "transfer", accounts: [{ name: "from", isMut: true, isSigner: true }, { name: "to", isMut: true, isSigner: false }], args: [{ name: "lamports", type: "u64" }] }, { name: "createAccountWithSeed", accounts: [{ name: "from", isMut: true, isSigner: true }, { name: "to", isMut: true, isSigner: false }, { name: "base", isMut: false, isSigner: true }], args: [{ name: "base", type: "publicKey" }, { name: "seed", type: "string" }, { name: "lamports", type: "u64" }, { name: "space", type: "u64" }, { name: "owner", type: "publicKey" }] }, { name: "advanceNonceAccount", accounts: [{ name: "nonce", isMut: true, isSigner: false }, { name: "recentBlockhashes", isMut: false, isSigner: false }, { name: "authorized", isMut: false, isSigner: true }], args: [{ name: "authorized", type: "publicKey" }] }, { name: "withdrawNonceAccount", accounts: [{ name: "nonce", isMut: true, isSigner: false }, { name: "to", isMut: true, isSigner: false }, { name: "recentBlockhashes", isMut: false, isSigner: false }, { name: "rent", isMut: false, isSigner: false }, { name: "authorized", isMut: false, isSigner: true }], args: [{ name: "lamports", type: "u64" }] }, { name: "initializeNonceAccount", accounts: [{ name: "nonce", isMut: true, isSigner: true }, { name: "recentBlockhashes", isMut: false, isSigner: false }, { name: "rent", isMut: false, isSigner: false }], args: [{ name: "authorized", type: "publicKey" }] }, { name: "authorizeNonceAccount", accounts: [{ name: "nonce", isMut: true, isSigner: false }, { name: "authorized", isMut: false, isSigner: true }], args: [{ name: "authorized", type: "publicKey" }] }, { name: "allocate", accounts: [{ name: "pubkey", isMut: true, isSigner: true }], args: [{ name: "space", type: "u64" }] }, { name: "allocateWithSeed", accounts: [{ name: "account", isMut: true, isSigner: false }, { name: "base", isMut: false, isSigner: true }], args: [{ name: "base", type: "publicKey" }, { name: "seed", type: "string" }, { name: "space", type: "u64" }, { name: "owner", type: "publicKey" }] }, { name: "assignWithSeed", accounts: [{ name: "account", isMut: true, isSigner: false }, { name: "base", isMut: false, isSigner: true }], args: [{ name: "base", type: "publicKey" }, { name: "seed", type: "string" }, { name: "owner", type: "publicKey" }] }, { name: "transferWithSeed", accounts: [{ name: "from", isMut: true, isSigner: false }, { name: "base", isMut: false, isSigner: true }, { name: "to", isMut: true, isSigner: false }], args: [{ name: "lamports", type: "u64" }, { name: "seed", type: "string" }, { name: "owner", type: "publicKey" }] }], accounts: [{ name: "nonce", type: { kind: "struct", fields: [{ name: "version", type: "u32" }, { name: "state", type: "u32" }, { name: "authorizedPubkey", type: "publicKey" }, { name: "nonce", type: "publicKey" }, { name: "feeCalculator", type: { defined: "FeeCalculator" } }] } }], types: [{ name: "FeeCalculator", type: { kind: "struct", fields: [{ name: "lamportsPerSignature", type: "u64" }] } }] };
      Yn = class {
        static system(t2) {
          return Xn(t2);
        }
      };
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/artifacts/whirlpool.json
  var require_whirlpool = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/artifacts/whirlpool.json"(exports2, module2) {
      module2.exports = {
        version: "0.1.0",
        name: "whirlpool",
        instructions: [
          {
            name: "initializeConfig",
            accounts: [
              {
                name: "config",
                isMut: true,
                isSigner: true
              },
              {
                name: "funder",
                isMut: true,
                isSigner: true
              },
              {
                name: "systemProgram",
                isMut: false,
                isSigner: false
              }
            ],
            args: [
              {
                name: "feeAuthority",
                type: "publicKey"
              },
              {
                name: "collectProtocolFeesAuthority",
                type: "publicKey"
              },
              {
                name: "rewardEmissionsSuperAuthority",
                type: "publicKey"
              },
              {
                name: "defaultProtocolFeeRate",
                type: "u16"
              }
            ]
          },
          {
            name: "initializePool",
            accounts: [
              {
                name: "whirlpoolsConfig",
                isMut: false,
                isSigner: false
              },
              {
                name: "tokenMintA",
                isMut: false,
                isSigner: false
              },
              {
                name: "tokenMintB",
                isMut: false,
                isSigner: false
              },
              {
                name: "funder",
                isMut: true,
                isSigner: true
              },
              {
                name: "whirlpool",
                isMut: true,
                isSigner: false
              },
              {
                name: "tokenVaultA",
                isMut: true,
                isSigner: true
              },
              {
                name: "tokenVaultB",
                isMut: true,
                isSigner: true
              },
              {
                name: "feeTier",
                isMut: false,
                isSigner: false
              },
              {
                name: "tokenProgram",
                isMut: false,
                isSigner: false
              },
              {
                name: "systemProgram",
                isMut: false,
                isSigner: false
              },
              {
                name: "rent",
                isMut: false,
                isSigner: false
              }
            ],
            args: [
              {
                name: "bumps",
                type: {
                  defined: "WhirlpoolBumps"
                }
              },
              {
                name: "tickSpacing",
                type: "u16"
              },
              {
                name: "initialSqrtPrice",
                type: "u128"
              }
            ]
          },
          {
            name: "initializeTickArray",
            accounts: [
              {
                name: "whirlpool",
                isMut: false,
                isSigner: false
              },
              {
                name: "funder",
                isMut: true,
                isSigner: true
              },
              {
                name: "tickArray",
                isMut: true,
                isSigner: false
              },
              {
                name: "systemProgram",
                isMut: false,
                isSigner: false
              }
            ],
            args: [
              {
                name: "startTickIndex",
                type: "i32"
              }
            ]
          },
          {
            name: "initializeFeeTier",
            accounts: [
              {
                name: "config",
                isMut: false,
                isSigner: false
              },
              {
                name: "feeTier",
                isMut: true,
                isSigner: false
              },
              {
                name: "funder",
                isMut: true,
                isSigner: true
              },
              {
                name: "feeAuthority",
                isMut: false,
                isSigner: true
              },
              {
                name: "systemProgram",
                isMut: false,
                isSigner: false
              }
            ],
            args: [
              {
                name: "tickSpacing",
                type: "u16"
              },
              {
                name: "defaultFeeRate",
                type: "u16"
              }
            ]
          },
          {
            name: "initializeReward",
            accounts: [
              {
                name: "rewardAuthority",
                isMut: false,
                isSigner: true
              },
              {
                name: "funder",
                isMut: true,
                isSigner: true
              },
              {
                name: "whirlpool",
                isMut: true,
                isSigner: false
              },
              {
                name: "rewardMint",
                isMut: false,
                isSigner: false
              },
              {
                name: "rewardVault",
                isMut: true,
                isSigner: true
              },
              {
                name: "tokenProgram",
                isMut: false,
                isSigner: false
              },
              {
                name: "systemProgram",
                isMut: false,
                isSigner: false
              },
              {
                name: "rent",
                isMut: false,
                isSigner: false
              }
            ],
            args: [
              {
                name: "rewardIndex",
                type: "u8"
              }
            ]
          },
          {
            name: "setRewardEmissions",
            accounts: [
              {
                name: "whirlpool",
                isMut: true,
                isSigner: false
              },
              {
                name: "rewardAuthority",
                isMut: false,
                isSigner: true
              },
              {
                name: "rewardVault",
                isMut: false,
                isSigner: false
              }
            ],
            args: [
              {
                name: "rewardIndex",
                type: "u8"
              },
              {
                name: "emissionsPerSecondX64",
                type: "u128"
              }
            ]
          },
          {
            name: "openPosition",
            accounts: [
              {
                name: "funder",
                isMut: true,
                isSigner: true
              },
              {
                name: "owner",
                isMut: false,
                isSigner: false
              },
              {
                name: "position",
                isMut: true,
                isSigner: false
              },
              {
                name: "positionMint",
                isMut: true,
                isSigner: true
              },
              {
                name: "positionTokenAccount",
                isMut: true,
                isSigner: false
              },
              {
                name: "whirlpool",
                isMut: false,
                isSigner: false
              },
              {
                name: "tokenProgram",
                isMut: false,
                isSigner: false
              },
              {
                name: "systemProgram",
                isMut: false,
                isSigner: false
              },
              {
                name: "rent",
                isMut: false,
                isSigner: false
              },
              {
                name: "associatedTokenProgram",
                isMut: false,
                isSigner: false
              }
            ],
            args: [
              {
                name: "bumps",
                type: {
                  defined: "OpenPositionBumps"
                }
              },
              {
                name: "tickLowerIndex",
                type: "i32"
              },
              {
                name: "tickUpperIndex",
                type: "i32"
              }
            ]
          },
          {
            name: "openPositionWithMetadata",
            accounts: [
              {
                name: "funder",
                isMut: true,
                isSigner: true
              },
              {
                name: "owner",
                isMut: false,
                isSigner: false
              },
              {
                name: "position",
                isMut: true,
                isSigner: false
              },
              {
                name: "positionMint",
                isMut: true,
                isSigner: true
              },
              {
                name: "positionMetadataAccount",
                isMut: true,
                isSigner: false
              },
              {
                name: "positionTokenAccount",
                isMut: true,
                isSigner: false
              },
              {
                name: "whirlpool",
                isMut: false,
                isSigner: false
              },
              {
                name: "tokenProgram",
                isMut: false,
                isSigner: false
              },
              {
                name: "systemProgram",
                isMut: false,
                isSigner: false
              },
              {
                name: "rent",
                isMut: false,
                isSigner: false
              },
              {
                name: "associatedTokenProgram",
                isMut: false,
                isSigner: false
              },
              {
                name: "metadataProgram",
                isMut: false,
                isSigner: false
              },
              {
                name: "metadataUpdateAuth",
                isMut: false,
                isSigner: false
              }
            ],
            args: [
              {
                name: "bumps",
                type: {
                  defined: "OpenPositionWithMetadataBumps"
                }
              },
              {
                name: "tickLowerIndex",
                type: "i32"
              },
              {
                name: "tickUpperIndex",
                type: "i32"
              }
            ]
          },
          {
            name: "increaseLiquidity",
            accounts: [
              {
                name: "whirlpool",
                isMut: true,
                isSigner: false
              },
              {
                name: "tokenProgram",
                isMut: false,
                isSigner: false
              },
              {
                name: "positionAuthority",
                isMut: false,
                isSigner: true
              },
              {
                name: "position",
                isMut: true,
                isSigner: false
              },
              {
                name: "positionTokenAccount",
                isMut: false,
                isSigner: false
              },
              {
                name: "tokenOwnerAccountA",
                isMut: true,
                isSigner: false
              },
              {
                name: "tokenOwnerAccountB",
                isMut: true,
                isSigner: false
              },
              {
                name: "tokenVaultA",
                isMut: true,
                isSigner: false
              },
              {
                name: "tokenVaultB",
                isMut: true,
                isSigner: false
              },
              {
                name: "tickArrayLower",
                isMut: true,
                isSigner: false
              },
              {
                name: "tickArrayUpper",
                isMut: true,
                isSigner: false
              }
            ],
            args: [
              {
                name: "liquidityAmount",
                type: "u128"
              },
              {
                name: "tokenMaxA",
                type: "u64"
              },
              {
                name: "tokenMaxB",
                type: "u64"
              }
            ]
          },
          {
            name: "decreaseLiquidity",
            accounts: [
              {
                name: "whirlpool",
                isMut: true,
                isSigner: false
              },
              {
                name: "tokenProgram",
                isMut: false,
                isSigner: false
              },
              {
                name: "positionAuthority",
                isMut: false,
                isSigner: true
              },
              {
                name: "position",
                isMut: true,
                isSigner: false
              },
              {
                name: "positionTokenAccount",
                isMut: false,
                isSigner: false
              },
              {
                name: "tokenOwnerAccountA",
                isMut: true,
                isSigner: false
              },
              {
                name: "tokenOwnerAccountB",
                isMut: true,
                isSigner: false
              },
              {
                name: "tokenVaultA",
                isMut: true,
                isSigner: false
              },
              {
                name: "tokenVaultB",
                isMut: true,
                isSigner: false
              },
              {
                name: "tickArrayLower",
                isMut: true,
                isSigner: false
              },
              {
                name: "tickArrayUpper",
                isMut: true,
                isSigner: false
              }
            ],
            args: [
              {
                name: "liquidityAmount",
                type: "u128"
              },
              {
                name: "tokenMinA",
                type: "u64"
              },
              {
                name: "tokenMinB",
                type: "u64"
              }
            ]
          },
          {
            name: "updateFeesAndRewards",
            accounts: [
              {
                name: "whirlpool",
                isMut: true,
                isSigner: false
              },
              {
                name: "position",
                isMut: true,
                isSigner: false
              },
              {
                name: "tickArrayLower",
                isMut: false,
                isSigner: false
              },
              {
                name: "tickArrayUpper",
                isMut: false,
                isSigner: false
              }
            ],
            args: []
          },
          {
            name: "collectFees",
            accounts: [
              {
                name: "whirlpool",
                isMut: false,
                isSigner: false
              },
              {
                name: "positionAuthority",
                isMut: false,
                isSigner: true
              },
              {
                name: "position",
                isMut: true,
                isSigner: false
              },
              {
                name: "positionTokenAccount",
                isMut: false,
                isSigner: false
              },
              {
                name: "tokenOwnerAccountA",
                isMut: true,
                isSigner: false
              },
              {
                name: "tokenVaultA",
                isMut: true,
                isSigner: false
              },
              {
                name: "tokenOwnerAccountB",
                isMut: true,
                isSigner: false
              },
              {
                name: "tokenVaultB",
                isMut: true,
                isSigner: false
              },
              {
                name: "tokenProgram",
                isMut: false,
                isSigner: false
              }
            ],
            args: []
          },
          {
            name: "collectReward",
            accounts: [
              {
                name: "whirlpool",
                isMut: false,
                isSigner: false
              },
              {
                name: "positionAuthority",
                isMut: false,
                isSigner: true
              },
              {
                name: "position",
                isMut: true,
                isSigner: false
              },
              {
                name: "positionTokenAccount",
                isMut: false,
                isSigner: false
              },
              {
                name: "rewardOwnerAccount",
                isMut: true,
                isSigner: false
              },
              {
                name: "rewardVault",
                isMut: true,
                isSigner: false
              },
              {
                name: "tokenProgram",
                isMut: false,
                isSigner: false
              }
            ],
            args: [
              {
                name: "rewardIndex",
                type: "u8"
              }
            ]
          },
          {
            name: "collectProtocolFees",
            accounts: [
              {
                name: "whirlpoolsConfig",
                isMut: false,
                isSigner: false
              },
              {
                name: "whirlpool",
                isMut: true,
                isSigner: false
              },
              {
                name: "collectProtocolFeesAuthority",
                isMut: false,
                isSigner: true
              },
              {
                name: "tokenVaultA",
                isMut: true,
                isSigner: false
              },
              {
                name: "tokenVaultB",
                isMut: true,
                isSigner: false
              },
              {
                name: "tokenDestinationA",
                isMut: true,
                isSigner: false
              },
              {
                name: "tokenDestinationB",
                isMut: true,
                isSigner: false
              },
              {
                name: "tokenProgram",
                isMut: false,
                isSigner: false
              }
            ],
            args: []
          },
          {
            name: "swap",
            accounts: [
              {
                name: "tokenProgram",
                isMut: false,
                isSigner: false
              },
              {
                name: "tokenAuthority",
                isMut: false,
                isSigner: true
              },
              {
                name: "whirlpool",
                isMut: true,
                isSigner: false
              },
              {
                name: "tokenOwnerAccountA",
                isMut: true,
                isSigner: false
              },
              {
                name: "tokenVaultA",
                isMut: true,
                isSigner: false
              },
              {
                name: "tokenOwnerAccountB",
                isMut: true,
                isSigner: false
              },
              {
                name: "tokenVaultB",
                isMut: true,
                isSigner: false
              },
              {
                name: "tickArray0",
                isMut: true,
                isSigner: false
              },
              {
                name: "tickArray1",
                isMut: true,
                isSigner: false
              },
              {
                name: "tickArray2",
                isMut: true,
                isSigner: false
              },
              {
                name: "oracle",
                isMut: false,
                isSigner: false
              }
            ],
            args: [
              {
                name: "amount",
                type: "u64"
              },
              {
                name: "otherAmountThreshold",
                type: "u64"
              },
              {
                name: "sqrtPriceLimit",
                type: "u128"
              },
              {
                name: "amountSpecifiedIsInput",
                type: "bool"
              },
              {
                name: "aToB",
                type: "bool"
              }
            ]
          },
          {
            name: "closePosition",
            accounts: [
              {
                name: "positionAuthority",
                isMut: false,
                isSigner: true
              },
              {
                name: "receiver",
                isMut: true,
                isSigner: false
              },
              {
                name: "position",
                isMut: true,
                isSigner: false
              },
              {
                name: "positionMint",
                isMut: true,
                isSigner: false
              },
              {
                name: "positionTokenAccount",
                isMut: true,
                isSigner: false
              },
              {
                name: "tokenProgram",
                isMut: false,
                isSigner: false
              }
            ],
            args: []
          },
          {
            name: "setDefaultFeeRate",
            accounts: [
              {
                name: "whirlpoolsConfig",
                isMut: false,
                isSigner: false
              },
              {
                name: "feeTier",
                isMut: true,
                isSigner: false
              },
              {
                name: "feeAuthority",
                isMut: false,
                isSigner: true
              }
            ],
            args: [
              {
                name: "defaultFeeRate",
                type: "u16"
              }
            ]
          },
          {
            name: "setDefaultProtocolFeeRate",
            accounts: [
              {
                name: "whirlpoolsConfig",
                isMut: true,
                isSigner: false
              },
              {
                name: "feeAuthority",
                isMut: false,
                isSigner: true
              }
            ],
            args: [
              {
                name: "defaultProtocolFeeRate",
                type: "u16"
              }
            ]
          },
          {
            name: "setFeeRate",
            accounts: [
              {
                name: "whirlpoolsConfig",
                isMut: false,
                isSigner: false
              },
              {
                name: "whirlpool",
                isMut: true,
                isSigner: false
              },
              {
                name: "feeAuthority",
                isMut: false,
                isSigner: true
              }
            ],
            args: [
              {
                name: "feeRate",
                type: "u16"
              }
            ]
          },
          {
            name: "setProtocolFeeRate",
            accounts: [
              {
                name: "whirlpoolsConfig",
                isMut: false,
                isSigner: false
              },
              {
                name: "whirlpool",
                isMut: true,
                isSigner: false
              },
              {
                name: "feeAuthority",
                isMut: false,
                isSigner: true
              }
            ],
            args: [
              {
                name: "protocolFeeRate",
                type: "u16"
              }
            ]
          },
          {
            name: "setFeeAuthority",
            accounts: [
              {
                name: "whirlpoolsConfig",
                isMut: true,
                isSigner: false
              },
              {
                name: "feeAuthority",
                isMut: false,
                isSigner: true
              },
              {
                name: "newFeeAuthority",
                isMut: false,
                isSigner: false
              }
            ],
            args: []
          },
          {
            name: "setCollectProtocolFeesAuthority",
            accounts: [
              {
                name: "whirlpoolsConfig",
                isMut: true,
                isSigner: false
              },
              {
                name: "collectProtocolFeesAuthority",
                isMut: false,
                isSigner: true
              },
              {
                name: "newCollectProtocolFeesAuthority",
                isMut: false,
                isSigner: false
              }
            ],
            args: []
          },
          {
            name: "setRewardAuthority",
            accounts: [
              {
                name: "whirlpool",
                isMut: true,
                isSigner: false
              },
              {
                name: "rewardAuthority",
                isMut: false,
                isSigner: true
              },
              {
                name: "newRewardAuthority",
                isMut: false,
                isSigner: false
              }
            ],
            args: [
              {
                name: "rewardIndex",
                type: "u8"
              }
            ]
          },
          {
            name: "setRewardAuthorityBySuperAuthority",
            accounts: [
              {
                name: "whirlpoolsConfig",
                isMut: false,
                isSigner: false
              },
              {
                name: "whirlpool",
                isMut: true,
                isSigner: false
              },
              {
                name: "rewardEmissionsSuperAuthority",
                isMut: false,
                isSigner: true
              },
              {
                name: "newRewardAuthority",
                isMut: false,
                isSigner: false
              }
            ],
            args: [
              {
                name: "rewardIndex",
                type: "u8"
              }
            ]
          },
          {
            name: "setRewardEmissionsSuperAuthority",
            accounts: [
              {
                name: "whirlpoolsConfig",
                isMut: true,
                isSigner: false
              },
              {
                name: "rewardEmissionsSuperAuthority",
                isMut: false,
                isSigner: true
              },
              {
                name: "newRewardEmissionsSuperAuthority",
                isMut: false,
                isSigner: false
              }
            ],
            args: []
          }
        ],
        accounts: [
          {
            name: "WhirlpoolsConfig",
            type: {
              kind: "struct",
              fields: [
                {
                  name: "feeAuthority",
                  type: "publicKey"
                },
                {
                  name: "collectProtocolFeesAuthority",
                  type: "publicKey"
                },
                {
                  name: "rewardEmissionsSuperAuthority",
                  type: "publicKey"
                },
                {
                  name: "defaultProtocolFeeRate",
                  type: "u16"
                }
              ]
            }
          },
          {
            name: "FeeTier",
            type: {
              kind: "struct",
              fields: [
                {
                  name: "whirlpoolsConfig",
                  type: "publicKey"
                },
                {
                  name: "tickSpacing",
                  type: "u16"
                },
                {
                  name: "defaultFeeRate",
                  type: "u16"
                }
              ]
            }
          },
          {
            name: "Position",
            type: {
              kind: "struct",
              fields: [
                {
                  name: "whirlpool",
                  type: "publicKey"
                },
                {
                  name: "positionMint",
                  type: "publicKey"
                },
                {
                  name: "liquidity",
                  type: "u128"
                },
                {
                  name: "tickLowerIndex",
                  type: "i32"
                },
                {
                  name: "tickUpperIndex",
                  type: "i32"
                },
                {
                  name: "feeGrowthCheckpointA",
                  type: "u128"
                },
                {
                  name: "feeOwedA",
                  type: "u64"
                },
                {
                  name: "feeGrowthCheckpointB",
                  type: "u128"
                },
                {
                  name: "feeOwedB",
                  type: "u64"
                },
                {
                  name: "rewardInfos",
                  type: {
                    array: [
                      {
                        defined: "PositionRewardInfo"
                      },
                      3
                    ]
                  }
                }
              ]
            }
          },
          {
            name: "TickArray",
            type: {
              kind: "struct",
              fields: [
                {
                  name: "startTickIndex",
                  type: "i32"
                },
                {
                  name: "ticks",
                  type: {
                    array: [
                      {
                        defined: "Tick"
                      },
                      88
                    ]
                  }
                },
                {
                  name: "whirlpool",
                  type: "publicKey"
                }
              ]
            }
          },
          {
            name: "Whirlpool",
            type: {
              kind: "struct",
              fields: [
                {
                  name: "whirlpoolsConfig",
                  type: "publicKey"
                },
                {
                  name: "whirlpoolBump",
                  type: {
                    array: [
                      "u8",
                      1
                    ]
                  }
                },
                {
                  name: "tickSpacing",
                  type: "u16"
                },
                {
                  name: "tickSpacingSeed",
                  type: {
                    array: [
                      "u8",
                      2
                    ]
                  }
                },
                {
                  name: "feeRate",
                  type: "u16"
                },
                {
                  name: "protocolFeeRate",
                  type: "u16"
                },
                {
                  name: "liquidity",
                  type: "u128"
                },
                {
                  name: "sqrtPrice",
                  type: "u128"
                },
                {
                  name: "tickCurrentIndex",
                  type: "i32"
                },
                {
                  name: "protocolFeeOwedA",
                  type: "u64"
                },
                {
                  name: "protocolFeeOwedB",
                  type: "u64"
                },
                {
                  name: "tokenMintA",
                  type: "publicKey"
                },
                {
                  name: "tokenVaultA",
                  type: "publicKey"
                },
                {
                  name: "feeGrowthGlobalA",
                  type: "u128"
                },
                {
                  name: "tokenMintB",
                  type: "publicKey"
                },
                {
                  name: "tokenVaultB",
                  type: "publicKey"
                },
                {
                  name: "feeGrowthGlobalB",
                  type: "u128"
                },
                {
                  name: "rewardLastUpdatedTimestamp",
                  type: "u64"
                },
                {
                  name: "rewardInfos",
                  type: {
                    array: [
                      {
                        defined: "WhirlpoolRewardInfo"
                      },
                      3
                    ]
                  }
                }
              ]
            }
          }
        ],
        types: [
          {
            name: "OpenPositionBumps",
            type: {
              kind: "struct",
              fields: [
                {
                  name: "positionBump",
                  type: "u8"
                }
              ]
            }
          },
          {
            name: "OpenPositionWithMetadataBumps",
            type: {
              kind: "struct",
              fields: [
                {
                  name: "positionBump",
                  type: "u8"
                },
                {
                  name: "metadataBump",
                  type: "u8"
                }
              ]
            }
          },
          {
            name: "PositionRewardInfo",
            type: {
              kind: "struct",
              fields: [
                {
                  name: "growthInsideCheckpoint",
                  type: "u128"
                },
                {
                  name: "amountOwed",
                  type: "u64"
                }
              ]
            }
          },
          {
            name: "Tick",
            type: {
              kind: "struct",
              fields: [
                {
                  name: "initialized",
                  type: "bool"
                },
                {
                  name: "liquidityNet",
                  type: "i128"
                },
                {
                  name: "liquidityGross",
                  type: "u128"
                },
                {
                  name: "feeGrowthOutsideA",
                  type: "u128"
                },
                {
                  name: "feeGrowthOutsideB",
                  type: "u128"
                },
                {
                  name: "rewardGrowthsOutside",
                  type: {
                    array: [
                      "u128",
                      3
                    ]
                  }
                }
              ]
            }
          },
          {
            name: "WhirlpoolRewardInfo",
            type: {
              kind: "struct",
              fields: [
                {
                  name: "mint",
                  type: "publicKey"
                },
                {
                  name: "vault",
                  type: "publicKey"
                },
                {
                  name: "authority",
                  type: "publicKey"
                },
                {
                  name: "emissionsPerSecondX64",
                  type: "u128"
                },
                {
                  name: "growthGlobalX64",
                  type: "u128"
                }
              ]
            }
          },
          {
            name: "WhirlpoolBumps",
            type: {
              kind: "struct",
              fields: [
                {
                  name: "whirlpoolBump",
                  type: "u8"
                }
              ]
            }
          },
          {
            name: "CurrIndex",
            type: {
              kind: "enum",
              variants: [
                {
                  name: "Below"
                },
                {
                  name: "Inside"
                },
                {
                  name: "Above"
                }
              ]
            }
          },
          {
            name: "TickLabel",
            type: {
              kind: "enum",
              variants: [
                {
                  name: "Upper"
                },
                {
                  name: "Lower"
                }
              ]
            }
          },
          {
            name: "Direction",
            type: {
              kind: "enum",
              variants: [
                {
                  name: "Left"
                },
                {
                  name: "Right"
                }
              ]
            }
          }
        ],
        errors: [
          {
            code: 6e3,
            name: "InvalidEnum",
            msg: "Enum value could not be converted"
          },
          {
            code: 6001,
            name: "InvalidStartTick",
            msg: "Invalid start tick index provided."
          },
          {
            code: 6002,
            name: "TickArrayExistInPool",
            msg: "Tick-array already exists in this whirlpool"
          },
          {
            code: 6003,
            name: "TickArrayIndexOutofBounds",
            msg: "Attempt to search for a tick-array failed"
          },
          {
            code: 6004,
            name: "InvalidTickSpacing",
            msg: "Tick-spacing is not supported"
          },
          {
            code: 6005,
            name: "ClosePositionNotEmpty",
            msg: "Position is not empty It cannot be closed"
          },
          {
            code: 6006,
            name: "DivideByZero",
            msg: "Unable to divide by zero"
          },
          {
            code: 6007,
            name: "NumberCastError",
            msg: "Unable to cast number into BigInt"
          },
          {
            code: 6008,
            name: "NumberDownCastError",
            msg: "Unable to down cast number"
          },
          {
            code: 6009,
            name: "TickNotFound",
            msg: "Tick not found within tick array"
          },
          {
            code: 6010,
            name: "InvalidTickIndex",
            msg: "Provided tick index is either out of bounds or uninitializable"
          },
          {
            code: 6011,
            name: "SqrtPriceOutOfBounds",
            msg: "Provided sqrt price out of bounds"
          },
          {
            code: 6012,
            name: "LiquidityZero",
            msg: "Liquidity amount must be greater than zero"
          },
          {
            code: 6013,
            name: "LiquidityTooHigh",
            msg: "Liquidity amount must be less than i64::MAX"
          },
          {
            code: 6014,
            name: "LiquidityOverflow",
            msg: "Liquidity overflow"
          },
          {
            code: 6015,
            name: "LiquidityUnderflow",
            msg: "Liquidity underflow"
          },
          {
            code: 6016,
            name: "LiquidityNetError",
            msg: "Tick liquidity net underflowed or overflowed"
          },
          {
            code: 6017,
            name: "TokenMaxExceeded",
            msg: "Exceeded token max"
          },
          {
            code: 6018,
            name: "TokenMinSubceeded",
            msg: "Did not meet token min"
          },
          {
            code: 6019,
            name: "MissingOrInvalidDelegate",
            msg: "Position token account has a missing or invalid delegate"
          },
          {
            code: 6020,
            name: "InvalidPositionTokenAmount",
            msg: "Position token amount must be 1"
          },
          {
            code: 6021,
            name: "InvalidTimestampConversion",
            msg: "Timestamp should be convertible from i64 to u64"
          },
          {
            code: 6022,
            name: "InvalidTimestamp",
            msg: "Timestamp should be greater than the last updated timestamp"
          },
          {
            code: 6023,
            name: "InvalidTickArraySequence",
            msg: "Invalid tick array sequence provided for instruction."
          },
          {
            code: 6024,
            name: "InvalidTokenMintOrder",
            msg: "Token Mint in wrong order"
          },
          {
            code: 6025,
            name: "RewardNotInitialized",
            msg: "Reward not initialized"
          },
          {
            code: 6026,
            name: "InvalidRewardIndex",
            msg: "Invalid reward index"
          },
          {
            code: 6027,
            name: "RewardVaultAmountInsufficient",
            msg: "Reward vault requires amount to support emissions for at least one day"
          },
          {
            code: 6028,
            name: "FeeRateMaxExceeded",
            msg: "Exceeded max fee rate"
          },
          {
            code: 6029,
            name: "ProtocolFeeRateMaxExceeded",
            msg: "Exceeded max protocol fee rate"
          },
          {
            code: 6030,
            name: "MultiplicationShiftRightOverflow",
            msg: "Multiplication with shift right overflow"
          },
          {
            code: 6031,
            name: "MulDivOverflow",
            msg: "Muldiv overflow"
          },
          {
            code: 6032,
            name: "MulDivInvalidInput",
            msg: "Invalid div_u256 input"
          },
          {
            code: 6033,
            name: "MultiplicationOverflow",
            msg: "Multiplication overflow"
          },
          {
            code: 6034,
            name: "InvalidSqrtPriceLimitDirection",
            msg: "Provided SqrtPriceLimit not in the same direction as the swap."
          },
          {
            code: 6035,
            name: "ZeroTradableAmount",
            msg: "There are no tradable amount to swap."
          },
          {
            code: 6036,
            name: "AmountOutBelowMinimum",
            msg: "Amount out below minimum threshold"
          },
          {
            code: 6037,
            name: "AmountInAboveMaximum",
            msg: "Amount in above maximum threshold"
          },
          {
            code: 6038,
            name: "TickArraySequenceInvalidIndex",
            msg: "Invalid index for tick array sequence"
          },
          {
            code: 6039,
            name: "AmountCalcOverflow",
            msg: "Amount calculated overflows"
          },
          {
            code: 6040,
            name: "AmountRemainingOverflow",
            msg: "Amount remaining overflows"
          }
        ]
      };
    }
  });

  // node_modules/tiny-invariant/dist/tiny-invariant.cjs.js
  var require_tiny_invariant_cjs = __commonJS({
    "node_modules/tiny-invariant/dist/tiny-invariant.cjs.js"(exports2, module2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var isProduction = false;
      var prefix = "Invariant failed";
      function invariant(condition, message) {
        if (condition) {
          return;
        }
        if (isProduction) {
          throw new Error(prefix);
        }
        var provided = typeof message === "function" ? message() : message;
        var value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
        throw new Error(value);
      }
      module2.exports = invariant;
    }
  });

  // node_modules/@babel/runtime/helpers/esm/defineProperty.js
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var init_defineProperty = __esm({
    "node_modules/@babel/runtime/helpers/esm/defineProperty.js"() {
      init_virtual_process_polyfill();
      init_buffer();
      init_toPropertyKey();
    }
  });

  // node_modules/@solana/spl-token/lib/index.browser.esm.js
  var index_browser_esm_exports2 = {};
  __export(index_browser_esm_exports2, {
    ASSOCIATED_TOKEN_PROGRAM_ID: () => ASSOCIATED_TOKEN_PROGRAM_ID,
    AccountLayout: () => AccountLayout,
    MintLayout: () => MintLayout,
    NATIVE_MINT: () => NATIVE_MINT,
    TOKEN_PROGRAM_ID: () => TOKEN_PROGRAM_ID2,
    Token: () => Token,
    u64: () => u646
  });
  function getLens(b64) {
    var len = b64.length;
    if (len % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var validLen = b64.indexOf("=");
    if (validLen === -1)
      validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }
  function byteLength2(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray3(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr2(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;
    for (i = 0; i < len; i += 4) {
      tmp = revLookup2[b64.charCodeAt(i)] << 18 | revLookup2[b64.charCodeAt(i + 1)] << 12 | revLookup2[b64.charCodeAt(i + 2)] << 6 | revLookup2[b64.charCodeAt(i + 3)];
      arr[curByte++] = tmp >> 16 & 255;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup2[b64.charCodeAt(i)] << 2 | revLookup2[b64.charCodeAt(i + 1)] >> 4;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup2[b64.charCodeAt(i)] << 10 | revLookup2[b64.charCodeAt(i + 1)] << 4 | revLookup2[b64.charCodeAt(i + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase642(num) {
    return lookup2[num >> 18 & 63] + lookup2[num >> 12 & 63] + lookup2[num >> 6 & 63] + lookup2[num & 63];
  }
  function encodeChunk2(uint8, start, end) {
    var tmp;
    var output2 = [];
    for (var i = start; i < end; i += 3) {
      tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);
      output2.push(tripletToBase642(tmp));
    }
    return output2.join("");
  }
  function fromByteArray3(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk2(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      parts.push(
        lookup2[tmp >> 2] + lookup2[tmp << 4 & 63] + "=="
      );
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + uint8[len - 1];
      parts.push(
        lookup2[tmp >> 10] + lookup2[tmp >> 4 & 63] + lookup2[tmp << 2 & 63] + "="
      );
    }
    return parts.join("");
  }
  function inspect$1(obj, opts) {
    var ctx = {
      seen: [],
      stylize: stylizeNoColor
    };
    if (arguments.length >= 3)
      ctx.depth = arguments[2];
    if (arguments.length >= 4)
      ctx.colors = arguments[3];
    if (isBoolean(opts)) {
      ctx.showHidden = opts;
    } else if (opts) {
      _extend(ctx, opts);
    }
    if (isUndefined(ctx.showHidden))
      ctx.showHidden = false;
    if (isUndefined(ctx.depth))
      ctx.depth = 2;
    if (isUndefined(ctx.colors))
      ctx.colors = false;
    if (isUndefined(ctx.customInspect))
      ctx.customInspect = true;
    if (ctx.colors)
      ctx.stylize = stylizeWithColor;
    return formatValue(ctx, obj, ctx.depth);
  }
  function stylizeWithColor(str3, styleType) {
    var style = inspect$1.styles[styleType];
    if (style) {
      return "\x1B[" + inspect$1.colors[style][0] + "m" + str3 + "\x1B[" + inspect$1.colors[style][1] + "m";
    } else {
      return str3;
    }
  }
  function stylizeNoColor(str3, styleType) {
    return str3;
  }
  function arrayToHash(array6) {
    var hash2 = {};
    array6.forEach(function(val, idx) {
      hash2[val] = true;
    });
    return hash2;
  }
  function formatValue(ctx, value, recurseTimes) {
    if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== inspect$1 && !(value.constructor && value.constructor.prototype === value)) {
      var ret = value.inspect(recurseTimes, ctx);
      if (!isString(ret)) {
        ret = formatValue(ctx, ret, recurseTimes);
      }
      return ret;
    }
    var primitive = formatPrimitive(ctx, value);
    if (primitive) {
      return primitive;
    }
    var keys = Object.keys(value);
    var visibleKeys = arrayToHash(keys);
    if (ctx.showHidden) {
      keys = Object.getOwnPropertyNames(value);
    }
    if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
      return formatError(value);
    }
    if (keys.length === 0) {
      if (isFunction(value)) {
        var name2 = value.name ? ": " + value.name : "";
        return ctx.stylize("[Function" + name2 + "]", "special");
      }
      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
      }
      if (isDate(value)) {
        return ctx.stylize(Date.prototype.toString.call(value), "date");
      }
      if (isError(value)) {
        return formatError(value);
      }
    }
    var base = "", array6 = false, braces = ["{", "}"];
    if (isArray(value)) {
      array6 = true;
      braces = ["[", "]"];
    }
    if (isFunction(value)) {
      var n = value.name ? ": " + value.name : "";
      base = " [Function" + n + "]";
    }
    if (isRegExp(value)) {
      base = " " + RegExp.prototype.toString.call(value);
    }
    if (isDate(value)) {
      base = " " + Date.prototype.toUTCString.call(value);
    }
    if (isError(value)) {
      base = " " + formatError(value);
    }
    if (keys.length === 0 && (!array6 || value.length == 0)) {
      return braces[0] + base + braces[1];
    }
    if (recurseTimes < 0) {
      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
      } else {
        return ctx.stylize("[Object]", "special");
      }
    }
    ctx.seen.push(value);
    var output2;
    if (array6) {
      output2 = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
    } else {
      output2 = keys.map(function(key) {
        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array6);
      });
    }
    ctx.seen.pop();
    return reduceToSingleString(output2, base, braces);
  }
  function formatPrimitive(ctx, value) {
    if (isUndefined(value))
      return ctx.stylize("undefined", "undefined");
    if (isString(value)) {
      var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return ctx.stylize(simple, "string");
    }
    if (isNumber(value))
      return ctx.stylize("" + value, "number");
    if (isBoolean(value))
      return ctx.stylize("" + value, "boolean");
    if (isNull(value))
      return ctx.stylize("null", "null");
  }
  function formatError(value) {
    return "[" + Error.prototype.toString.call(value) + "]";
  }
  function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
    var output2 = [];
    for (var i = 0, l2 = value.length; i < l2; ++i) {
      if (hasOwnProperty(value, String(i))) {
        output2.push(formatProperty(
          ctx,
          value,
          recurseTimes,
          visibleKeys,
          String(i),
          true
        ));
      } else {
        output2.push("");
      }
    }
    keys.forEach(function(key) {
      if (!key.match(/^\d+$/)) {
        output2.push(formatProperty(
          ctx,
          value,
          recurseTimes,
          visibleKeys,
          key,
          true
        ));
      }
    });
    return output2;
  }
  function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array6) {
    var name2, str3, desc;
    desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
    if (desc.get) {
      if (desc.set) {
        str3 = ctx.stylize("[Getter/Setter]", "special");
      } else {
        str3 = ctx.stylize("[Getter]", "special");
      }
    } else {
      if (desc.set) {
        str3 = ctx.stylize("[Setter]", "special");
      }
    }
    if (!hasOwnProperty(visibleKeys, key)) {
      name2 = "[" + key + "]";
    }
    if (!str3) {
      if (ctx.seen.indexOf(desc.value) < 0) {
        if (isNull(recurseTimes)) {
          str3 = formatValue(ctx, desc.value, null);
        } else {
          str3 = formatValue(ctx, desc.value, recurseTimes - 1);
        }
        if (str3.indexOf("\n") > -1) {
          if (array6) {
            str3 = str3.split("\n").map(function(line) {
              return "  " + line;
            }).join("\n").substr(2);
          } else {
            str3 = "\n" + str3.split("\n").map(function(line) {
              return "   " + line;
            }).join("\n");
          }
        }
      } else {
        str3 = ctx.stylize("[Circular]", "special");
      }
    }
    if (isUndefined(name2)) {
      if (array6 && key.match(/^\d+$/)) {
        return str3;
      }
      name2 = JSON.stringify("" + key);
      if (name2.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
        name2 = name2.substr(1, name2.length - 2);
        name2 = ctx.stylize(name2, "name");
      } else {
        name2 = name2.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
        name2 = ctx.stylize(name2, "string");
      }
    }
    return name2 + ": " + str3;
  }
  function reduceToSingleString(output2, base, braces) {
    var length = output2.reduce(function(prev, cur) {
      if (cur.indexOf("\n") >= 0)
        ;
      return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    if (length > 60) {
      return braces[0] + (base === "" ? "" : base + "\n ") + " " + output2.join(",\n  ") + " " + braces[1];
    }
    return braces[0] + base + " " + output2.join(", ") + " " + braces[1];
  }
  function isArray(ar) {
    return Array.isArray(ar);
  }
  function isBoolean(arg) {
    return typeof arg === "boolean";
  }
  function isNull(arg) {
    return arg === null;
  }
  function isNumber(arg) {
    return typeof arg === "number";
  }
  function isString(arg) {
    return typeof arg === "string";
  }
  function isUndefined(arg) {
    return arg === void 0;
  }
  function isRegExp(re2) {
    return isObject4(re2) && objectToString(re2) === "[object RegExp]";
  }
  function isObject4(arg) {
    return typeof arg === "object" && arg !== null;
  }
  function isDate(d2) {
    return isObject4(d2) && objectToString(d2) === "[object Date]";
  }
  function isError(e) {
    return isObject4(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
  }
  function isFunction(arg) {
    return typeof arg === "function";
  }
  function isPrimitive(arg) {
    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
  }
  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }
  function _extend(origin, add2) {
    if (!add2 || !isObject4(add2))
      return origin;
    var keys = Object.keys(add2);
    var i = keys.length;
    while (i--) {
      origin[keys[i]] = add2[keys[i]];
    }
    return origin;
  }
  function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }
  function compare3(a, b2) {
    if (a === b2) {
      return 0;
    }
    var x2 = a.length;
    var y2 = b2.length;
    for (var i = 0, len = Math.min(x2, y2); i < len; ++i) {
      if (a[i] !== b2[i]) {
        x2 = a[i];
        y2 = b2[i];
        break;
      }
    }
    if (x2 < y2) {
      return -1;
    }
    if (y2 < x2) {
      return 1;
    }
    return 0;
  }
  function functionsHaveNames() {
    if (typeof _functionsHaveNames !== "undefined") {
      return _functionsHaveNames;
    }
    return _functionsHaveNames = function() {
      return function foo() {
      }.name === "foo";
    }();
  }
  function pToString(obj) {
    return Object.prototype.toString.call(obj);
  }
  function isView(arrbuf) {
    if (buffer.isBuffer(arrbuf)) {
      return false;
    }
    if (typeof global$1.ArrayBuffer !== "function") {
      return false;
    }
    if (typeof ArrayBuffer.isView === "function") {
      return ArrayBuffer.isView(arrbuf);
    }
    if (!arrbuf) {
      return false;
    }
    if (arrbuf instanceof DataView) {
      return true;
    }
    if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
      return true;
    }
    return false;
  }
  function assert6(value, message) {
    if (!value)
      fail(value, true, message, "==", ok2);
  }
  function getName(func) {
    if (!isFunction(func)) {
      return;
    }
    if (functionsHaveNames()) {
      return func.name;
    }
    var str3 = func.toString();
    var match = str3.match(regex);
    return match && match[1];
  }
  function AssertionError(options) {
    this.name = "AssertionError";
    this.actual = options.actual;
    this.expected = options.expected;
    this.operator = options.operator;
    if (options.message) {
      this.message = options.message;
      this.generatedMessage = false;
    } else {
      this.message = getMessage(this);
      this.generatedMessage = true;
    }
    var stackStartFunction = options.stackStartFunction || fail;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, stackStartFunction);
    } else {
      var err2 = new Error();
      if (err2.stack) {
        var out = err2.stack;
        var fn_name = getName(stackStartFunction);
        var idx = out.indexOf("\n" + fn_name);
        if (idx >= 0) {
          var next_line = out.indexOf("\n", idx + 1);
          out = out.substring(next_line + 1);
        }
        this.stack = out;
      }
    }
  }
  function truncate(s, n) {
    if (typeof s === "string") {
      return s.length < n ? s : s.slice(0, n);
    } else {
      return s;
    }
  }
  function inspect(something) {
    if (functionsHaveNames() || !isFunction(something)) {
      return inspect$1(something);
    }
    var rawname = getName(something);
    var name2 = rawname ? ": " + rawname : "";
    return "[Function" + name2 + "]";
  }
  function getMessage(self2) {
    return truncate(inspect(self2.actual), 128) + " " + self2.operator + " " + truncate(inspect(self2.expected), 128);
  }
  function fail(actual, expected, message, operator, stackStartFunction) {
    throw new AssertionError({
      message,
      actual,
      expected,
      operator,
      stackStartFunction
    });
  }
  function ok2(value, message) {
    if (!value)
      fail(value, true, message, "==", ok2);
  }
  function equal(actual, expected, message) {
    if (actual != expected)
      fail(actual, expected, message, "==", equal);
  }
  function notEqual(actual, expected, message) {
    if (actual == expected) {
      fail(actual, expected, message, "!=", notEqual);
    }
  }
  function deepEqual(actual, expected, message) {
    if (!_deepEqual(actual, expected, false)) {
      fail(actual, expected, message, "deepEqual", deepEqual);
    }
  }
  function deepStrictEqual(actual, expected, message) {
    if (!_deepEqual(actual, expected, true)) {
      fail(actual, expected, message, "deepStrictEqual", deepStrictEqual);
    }
  }
  function _deepEqual(actual, expected, strict, memos) {
    if (actual === expected) {
      return true;
    } else if (buffer.isBuffer(actual) && buffer.isBuffer(expected)) {
      return compare3(actual, expected) === 0;
    } else if (isDate(actual) && isDate(expected)) {
      return actual.getTime() === expected.getTime();
    } else if (isRegExp(actual) && isRegExp(expected)) {
      return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
    } else if ((actual === null || typeof actual !== "object") && (expected === null || typeof expected !== "object")) {
      return strict ? actual === expected : actual == expected;
    } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
      return compare3(
        new Uint8Array(actual.buffer),
        new Uint8Array(expected.buffer)
      ) === 0;
    } else if (buffer.isBuffer(actual) !== buffer.isBuffer(expected)) {
      return false;
    } else {
      memos = memos || { actual: [], expected: [] };
      var actualIndex = memos.actual.indexOf(actual);
      if (actualIndex !== -1) {
        if (actualIndex === memos.expected.indexOf(expected)) {
          return true;
        }
      }
      memos.actual.push(actual);
      memos.expected.push(expected);
      return objEquiv(actual, expected, strict, memos);
    }
  }
  function isArguments(object3) {
    return Object.prototype.toString.call(object3) == "[object Arguments]";
  }
  function objEquiv(a, b2, strict, actualVisitedObjects) {
    if (a === null || a === void 0 || b2 === null || b2 === void 0)
      return false;
    if (isPrimitive(a) || isPrimitive(b2))
      return a === b2;
    if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b2))
      return false;
    var aIsArgs = isArguments(a);
    var bIsArgs = isArguments(b2);
    if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs)
      return false;
    if (aIsArgs) {
      a = pSlice.call(a);
      b2 = pSlice.call(b2);
      return _deepEqual(a, b2, strict);
    }
    var ka = objectKeys(a);
    var kb = objectKeys(b2);
    var key, i;
    if (ka.length !== kb.length)
      return false;
    ka.sort();
    kb.sort();
    for (i = ka.length - 1; i >= 0; i--) {
      if (ka[i] !== kb[i])
        return false;
    }
    for (i = ka.length - 1; i >= 0; i--) {
      key = ka[i];
      if (!_deepEqual(a[key], b2[key], strict, actualVisitedObjects))
        return false;
    }
    return true;
  }
  function notDeepEqual(actual, expected, message) {
    if (_deepEqual(actual, expected, false)) {
      fail(actual, expected, message, "notDeepEqual", notDeepEqual);
    }
  }
  function notDeepStrictEqual(actual, expected, message) {
    if (_deepEqual(actual, expected, true)) {
      fail(actual, expected, message, "notDeepStrictEqual", notDeepStrictEqual);
    }
  }
  function strictEqual(actual, expected, message) {
    if (actual !== expected) {
      fail(actual, expected, message, "===", strictEqual);
    }
  }
  function notStrictEqual(actual, expected, message) {
    if (actual === expected) {
      fail(actual, expected, message, "!==", notStrictEqual);
    }
  }
  function expectedException(actual, expected) {
    if (!actual || !expected) {
      return false;
    }
    if (Object.prototype.toString.call(expected) == "[object RegExp]") {
      return expected.test(actual);
    }
    try {
      if (actual instanceof expected) {
        return true;
      }
    } catch (e) {
    }
    if (Error.isPrototypeOf(expected)) {
      return false;
    }
    return expected.call({}, actual) === true;
  }
  function _tryBlock(block) {
    var error2;
    try {
      block();
    } catch (e) {
      error2 = e;
    }
    return error2;
  }
  function _throws(shouldThrow, block, expected, message) {
    var actual;
    if (typeof block !== "function") {
      throw new TypeError('"block" argument must be a function');
    }
    if (typeof expected === "string") {
      message = expected;
      expected = null;
    }
    actual = _tryBlock(block);
    message = (expected && expected.name ? " (" + expected.name + ")." : ".") + (message ? " " + message : ".");
    if (shouldThrow && !actual) {
      fail(actual, expected, "Missing expected exception" + message);
    }
    var userProvidedMessage = typeof message === "string";
    var isUnwantedException = !shouldThrow && isError(actual);
    var isUnexpectedException = !shouldThrow && actual && !expected;
    if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
      fail(actual, expected, "Got unwanted exception" + message);
    }
    if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
      throw actual;
    }
  }
  function throws(block, error2, message) {
    _throws(true, block, error2, message);
  }
  function doesNotThrow(block, error2, message) {
    _throws(false, block, error2, message);
  }
  function ifError(err2) {
    if (err2)
      throw err2;
  }
  function nameWithProperty2(name2, lo) {
    if (lo.property) {
      return name2 + "[" + lo.property + "]";
    }
    return name2;
  }
  function bindConstructorLayout(Class, layout) {
    if ("function" !== typeof Class) {
      throw new TypeError("Class must be constructor");
    }
    if (Class.hasOwnProperty("layout_")) {
      throw new Error("Class is already bound to a layout");
    }
    if (!(layout && layout instanceof Layout2)) {
      throw new TypeError("layout must be a Layout");
    }
    if (layout.hasOwnProperty("boundConstructor_")) {
      throw new Error("layout is already bound to a constructor");
    }
    Class.layout_ = layout;
    layout.boundConstructor_ = Class;
    layout.makeDestinationObject = () => new Class();
    Object.defineProperty(Class.prototype, "encode", {
      value: function(b2, offset3) {
        return layout.encode(this, b2, offset3);
      },
      writable: true
    });
    Object.defineProperty(Class, "decode", {
      value: function(b2, offset3) {
        return layout.decode(b2, offset3);
      },
      writable: true
    });
  }
  function divmodInt642(src) {
    const hi32 = Math.floor(src / V2E322);
    const lo32 = src - hi32 * V2E322;
    return { hi32, lo32 };
  }
  function roundedInt642(hi32, lo32) {
    return hi32 * V2E322 + lo32;
  }
  function fixBitwiseResult(v2) {
    if (0 > v2) {
      v2 += 4294967296;
    }
    return v2;
  }
  function sendAndConfirmTransaction2(title2, connection, transaction, ...signers) {
    return sendAndConfirmTransaction(connection, transaction, signers, {
      skipPreflight: false
    });
  }
  function pubkeyToBuffer(publicKey6) {
    return buffer.Buffer.from(publicKey6.toBuffer());
  }
  function isAccount(accountOrPublicKey) {
    return "publicKey" in accountOrPublicKey;
  }
  var import_bn6, buffer, base64Js, lookup2, revLookup2, Arr2, code, i, len, ieee754, global$1, inherits, inherits$1, hasOwn, objectKeys, pSlice, _functionsHaveNames, regex, Layout$1, Layout2, ExternalLayout2, GreedyCount, OffsetLayout2, UInt2, UIntBE2, Int, IntBE, V2E322, NearUInt642, NearUInt64BE, NearInt642, NearInt64BE, Float, FloatBE, Double, DoubleBE, Sequence, Structure2, UnionDiscriminator2, UnionLayoutDiscriminator2, Union2, VariantLayout2, BitStructure, BitField, Boolean2, Blob2, CString, UTF8, Constant, u85, u326, struct5, blob4, publicKey5, uint642, TOKEN_PROGRAM_ID2, ASSOCIATED_TOKEN_PROGRAM_ID, FAILED_TO_FIND_ACCOUNT, INVALID_ACCOUNT_OWNER, u646, AuthorityTypeCodes, NATIVE_MINT, MintLayout, AccountLayout, MultisigLayout, Token;
  var init_index_browser_esm2 = __esm({
    "node_modules/@solana/spl-token/lib/index.browser.esm.js"() {
      init_virtual_process_polyfill();
      init_buffer();
      init_defineProperty();
      import_bn6 = __toESM(require_bn());
      init_index_browser_esm();
      buffer = {};
      base64Js = {};
      base64Js.byteLength = byteLength2;
      base64Js.toByteArray = toByteArray3;
      base64Js.fromByteArray = fromByteArray3;
      lookup2 = [];
      revLookup2 = [];
      Arr2 = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      for (i = 0, len = code.length; i < len; ++i) {
        lookup2[i] = code[i];
        revLookup2[code.charCodeAt(i)] = i;
      }
      revLookup2["-".charCodeAt(0)] = 62;
      revLookup2["_".charCodeAt(0)] = 63;
      ieee754 = {};
      ieee754.read = function(buffer2, offset3, isLE2, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE2 ? nBytes - 1 : 0;
        var d2 = isLE2 ? -1 : 1;
        var s = buffer2[offset3 + i];
        i += d2;
        e = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer2[offset3 + i], i += d2, nBits -= 8) {
        }
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer2[offset3 + i], i += d2, nBits -= 8) {
        }
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
      };
      ieee754.write = function(buffer2, value, offset3, isLE2, mLen, nBytes) {
        var e, m, c2;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt2 = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE2 ? 0 : nBytes - 1;
        var d2 = isLE2 ? 1 : -1;
        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c2 = Math.pow(2, -e)) < 1) {
            e--;
            c2 *= 2;
          }
          if (e + eBias >= 1) {
            value += rt2 / c2;
          } else {
            value += rt2 * Math.pow(2, 1 - eBias);
          }
          if (value * c2 >= 2) {
            e++;
            c2 /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c2 - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer2[offset3 + i] = m & 255, i += d2, m /= 256, mLen -= 8) {
        }
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer2[offset3 + i] = e & 255, i += d2, e /= 256, eLen -= 8) {
        }
        buffer2[offset3 + i - d2] |= s * 128;
      };
      (function(exports2) {
        const base64 = base64Js;
        const ieee754$1 = ieee754;
        const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
        exports2.Buffer = Buffer3;
        exports2.SlowBuffer = SlowBuffer;
        exports2.INSPECT_MAX_BYTES = 50;
        const K_MAX_LENGTH = 2147483647;
        exports2.kMaxLength = K_MAX_LENGTH;
        Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
        if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
          console.error(
            "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
          );
        }
        function typedArraySupport() {
          try {
            const arr = new Uint8Array(1);
            const proto = { foo: function() {
              return 42;
            } };
            Object.setPrototypeOf(proto, Uint8Array.prototype);
            Object.setPrototypeOf(arr, proto);
            return arr.foo() === 42;
          } catch (e) {
            return false;
          }
        }
        Object.defineProperty(Buffer3.prototype, "parent", {
          enumerable: true,
          get: function() {
            if (!Buffer3.isBuffer(this))
              return void 0;
            return this.buffer;
          }
        });
        Object.defineProperty(Buffer3.prototype, "offset", {
          enumerable: true,
          get: function() {
            if (!Buffer3.isBuffer(this))
              return void 0;
            return this.byteOffset;
          }
        });
        function createBuffer2(length) {
          if (length > K_MAX_LENGTH) {
            throw new RangeError('The value "' + length + '" is invalid for option "size"');
          }
          const buf = new Uint8Array(length);
          Object.setPrototypeOf(buf, Buffer3.prototype);
          return buf;
        }
        function Buffer3(arg, encodingOrOffset, length) {
          if (typeof arg === "number") {
            if (typeof encodingOrOffset === "string") {
              throw new TypeError(
                'The "string" argument must be of type string. Received type number'
              );
            }
            return allocUnsafe2(arg);
          }
          return from2(arg, encodingOrOffset, length);
        }
        Buffer3.poolSize = 8192;
        function from2(value, encodingOrOffset, length) {
          if (typeof value === "string") {
            return fromString2(value, encodingOrOffset);
          }
          if (ArrayBuffer.isView(value)) {
            return fromArrayView(value);
          }
          if (value == null) {
            throw new TypeError(
              "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
            );
          }
          if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
            return fromArrayBuffer2(value, encodingOrOffset, length);
          }
          if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
            return fromArrayBuffer2(value, encodingOrOffset, length);
          }
          if (typeof value === "number") {
            throw new TypeError(
              'The "value" argument must not be of type number. Received type number'
            );
          }
          const valueOf = value.valueOf && value.valueOf();
          if (valueOf != null && valueOf !== value) {
            return Buffer3.from(valueOf, encodingOrOffset, length);
          }
          const b2 = fromObject2(value);
          if (b2)
            return b2;
          if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
            return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
          }
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
          );
        }
        Buffer3.from = function(value, encodingOrOffset, length) {
          return from2(value, encodingOrOffset, length);
        };
        Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
        Object.setPrototypeOf(Buffer3, Uint8Array);
        function assertSize2(size) {
          if (typeof size !== "number") {
            throw new TypeError('"size" argument must be of type number');
          } else if (size < 0) {
            throw new RangeError('The value "' + size + '" is invalid for option "size"');
          }
        }
        function alloc2(size, fill2, encoding) {
          assertSize2(size);
          if (size <= 0) {
            return createBuffer2(size);
          }
          if (fill2 !== void 0) {
            return typeof encoding === "string" ? createBuffer2(size).fill(fill2, encoding) : createBuffer2(size).fill(fill2);
          }
          return createBuffer2(size);
        }
        Buffer3.alloc = function(size, fill2, encoding) {
          return alloc2(size, fill2, encoding);
        };
        function allocUnsafe2(size) {
          assertSize2(size);
          return createBuffer2(size < 0 ? 0 : checked2(size) | 0);
        }
        Buffer3.allocUnsafe = function(size) {
          return allocUnsafe2(size);
        };
        Buffer3.allocUnsafeSlow = function(size) {
          return allocUnsafe2(size);
        };
        function fromString2(string4, encoding) {
          if (typeof encoding !== "string" || encoding === "") {
            encoding = "utf8";
          }
          if (!Buffer3.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
          const length = byteLength3(string4, encoding) | 0;
          let buf = createBuffer2(length);
          const actual = buf.write(string4, encoding);
          if (actual !== length) {
            buf = buf.slice(0, actual);
          }
          return buf;
        }
        function fromArrayLike2(array6) {
          const length = array6.length < 0 ? 0 : checked2(array6.length) | 0;
          const buf = createBuffer2(length);
          for (let i = 0; i < length; i += 1) {
            buf[i] = array6[i] & 255;
          }
          return buf;
        }
        function fromArrayView(arrayView) {
          if (isInstance(arrayView, Uint8Array)) {
            const copy2 = new Uint8Array(arrayView);
            return fromArrayBuffer2(copy2.buffer, copy2.byteOffset, copy2.byteLength);
          }
          return fromArrayLike2(arrayView);
        }
        function fromArrayBuffer2(array6, byteOffset, length) {
          if (byteOffset < 0 || array6.byteLength < byteOffset) {
            throw new RangeError('"offset" is outside of buffer bounds');
          }
          if (array6.byteLength < byteOffset + (length || 0)) {
            throw new RangeError('"length" is outside of buffer bounds');
          }
          let buf;
          if (byteOffset === void 0 && length === void 0) {
            buf = new Uint8Array(array6);
          } else if (length === void 0) {
            buf = new Uint8Array(array6, byteOffset);
          } else {
            buf = new Uint8Array(array6, byteOffset, length);
          }
          Object.setPrototypeOf(buf, Buffer3.prototype);
          return buf;
        }
        function fromObject2(obj) {
          if (Buffer3.isBuffer(obj)) {
            const len = checked2(obj.length) | 0;
            const buf = createBuffer2(len);
            if (buf.length === 0) {
              return buf;
            }
            obj.copy(buf, 0, 0, len);
            return buf;
          }
          if (obj.length !== void 0) {
            if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
              return createBuffer2(0);
            }
            return fromArrayLike2(obj);
          }
          if (obj.type === "Buffer" && Array.isArray(obj.data)) {
            return fromArrayLike2(obj.data);
          }
        }
        function checked2(length) {
          if (length >= K_MAX_LENGTH) {
            throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
          }
          return length | 0;
        }
        function SlowBuffer(length) {
          if (+length != length) {
            length = 0;
          }
          return Buffer3.alloc(+length);
        }
        Buffer3.isBuffer = function isBuffer2(b2) {
          return b2 != null && b2._isBuffer === true && b2 !== Buffer3.prototype;
        };
        Buffer3.compare = function compare4(a, b2) {
          if (isInstance(a, Uint8Array))
            a = Buffer3.from(a, a.offset, a.byteLength);
          if (isInstance(b2, Uint8Array))
            b2 = Buffer3.from(b2, b2.offset, b2.byteLength);
          if (!Buffer3.isBuffer(a) || !Buffer3.isBuffer(b2)) {
            throw new TypeError(
              'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
            );
          }
          if (a === b2)
            return 0;
          let x2 = a.length;
          let y2 = b2.length;
          for (let i = 0, len = Math.min(x2, y2); i < len; ++i) {
            if (a[i] !== b2[i]) {
              x2 = a[i];
              y2 = b2[i];
              break;
            }
          }
          if (x2 < y2)
            return -1;
          if (y2 < x2)
            return 1;
          return 0;
        };
        Buffer3.isEncoding = function isEncoding2(encoding) {
          switch (String(encoding).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return true;
            default:
              return false;
          }
        };
        Buffer3.concat = function concat2(list, length) {
          if (!Array.isArray(list)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          }
          if (list.length === 0) {
            return Buffer3.alloc(0);
          }
          let i;
          if (length === void 0) {
            length = 0;
            for (i = 0; i < list.length; ++i) {
              length += list[i].length;
            }
          }
          const buffer2 = Buffer3.allocUnsafe(length);
          let pos = 0;
          for (i = 0; i < list.length; ++i) {
            let buf = list[i];
            if (isInstance(buf, Uint8Array)) {
              if (pos + buf.length > buffer2.length) {
                if (!Buffer3.isBuffer(buf))
                  buf = Buffer3.from(buf);
                buf.copy(buffer2, pos);
              } else {
                Uint8Array.prototype.set.call(
                  buffer2,
                  buf,
                  pos
                );
              }
            } else if (!Buffer3.isBuffer(buf)) {
              throw new TypeError('"list" argument must be an Array of Buffers');
            } else {
              buf.copy(buffer2, pos);
            }
            pos += buf.length;
          }
          return buffer2;
        };
        function byteLength3(string4, encoding) {
          if (Buffer3.isBuffer(string4)) {
            return string4.length;
          }
          if (ArrayBuffer.isView(string4) || isInstance(string4, ArrayBuffer)) {
            return string4.byteLength;
          }
          if (typeof string4 !== "string") {
            throw new TypeError(
              'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string4
            );
          }
          const len = string4.length;
          const mustMatch = arguments.length > 2 && arguments[2] === true;
          if (!mustMatch && len === 0)
            return 0;
          let loweredCase = false;
          for (; ; ) {
            switch (encoding) {
              case "ascii":
              case "latin1":
              case "binary":
                return len;
              case "utf8":
              case "utf-8":
                return utf8ToBytes4(string4).length;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return len * 2;
              case "hex":
                return len >>> 1;
              case "base64":
                return base64ToBytes2(string4).length;
              default:
                if (loweredCase) {
                  return mustMatch ? -1 : utf8ToBytes4(string4).length;
                }
                encoding = ("" + encoding).toLowerCase();
                loweredCase = true;
            }
          }
        }
        Buffer3.byteLength = byteLength3;
        function slowToString2(encoding, start, end) {
          let loweredCase = false;
          if (start === void 0 || start < 0) {
            start = 0;
          }
          if (start > this.length) {
            return "";
          }
          if (end === void 0 || end > this.length) {
            end = this.length;
          }
          if (end <= 0) {
            return "";
          }
          end >>>= 0;
          start >>>= 0;
          if (end <= start) {
            return "";
          }
          if (!encoding)
            encoding = "utf8";
          while (true) {
            switch (encoding) {
              case "hex":
                return hexSlice2(this, start, end);
              case "utf8":
              case "utf-8":
                return utf8Slice2(this, start, end);
              case "ascii":
                return asciiSlice2(this, start, end);
              case "latin1":
              case "binary":
                return latin1Slice2(this, start, end);
              case "base64":
                return base64Slice2(this, start, end);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return utf16leSlice2(this, start, end);
              default:
                if (loweredCase)
                  throw new TypeError("Unknown encoding: " + encoding);
                encoding = (encoding + "").toLowerCase();
                loweredCase = true;
            }
          }
        }
        Buffer3.prototype._isBuffer = true;
        function swap2(b2, n, m) {
          const i = b2[n];
          b2[n] = b2[m];
          b2[m] = i;
        }
        Buffer3.prototype.swap16 = function swap162() {
          const len = this.length;
          if (len % 2 !== 0) {
            throw new RangeError("Buffer size must be a multiple of 16-bits");
          }
          for (let i = 0; i < len; i += 2) {
            swap2(this, i, i + 1);
          }
          return this;
        };
        Buffer3.prototype.swap32 = function swap322() {
          const len = this.length;
          if (len % 4 !== 0) {
            throw new RangeError("Buffer size must be a multiple of 32-bits");
          }
          for (let i = 0; i < len; i += 4) {
            swap2(this, i, i + 3);
            swap2(this, i + 1, i + 2);
          }
          return this;
        };
        Buffer3.prototype.swap64 = function swap642() {
          const len = this.length;
          if (len % 8 !== 0) {
            throw new RangeError("Buffer size must be a multiple of 64-bits");
          }
          for (let i = 0; i < len; i += 8) {
            swap2(this, i, i + 7);
            swap2(this, i + 1, i + 6);
            swap2(this, i + 2, i + 5);
            swap2(this, i + 3, i + 4);
          }
          return this;
        };
        Buffer3.prototype.toString = function toString3() {
          const length = this.length;
          if (length === 0)
            return "";
          if (arguments.length === 0)
            return utf8Slice2(this, 0, length);
          return slowToString2.apply(this, arguments);
        };
        Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
        Buffer3.prototype.equals = function equals2(b2) {
          if (!Buffer3.isBuffer(b2))
            throw new TypeError("Argument must be a Buffer");
          if (this === b2)
            return true;
          return Buffer3.compare(this, b2) === 0;
        };
        Buffer3.prototype.inspect = function inspect2() {
          let str3 = "";
          const max = exports2.INSPECT_MAX_BYTES;
          str3 = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
          if (this.length > max)
            str3 += " ... ";
          return "<Buffer " + str3 + ">";
        };
        if (customInspectSymbol) {
          Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
        }
        Buffer3.prototype.compare = function compare4(target, start, end, thisStart, thisEnd) {
          if (isInstance(target, Uint8Array)) {
            target = Buffer3.from(target, target.offset, target.byteLength);
          }
          if (!Buffer3.isBuffer(target)) {
            throw new TypeError(
              'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
            );
          }
          if (start === void 0) {
            start = 0;
          }
          if (end === void 0) {
            end = target ? target.length : 0;
          }
          if (thisStart === void 0) {
            thisStart = 0;
          }
          if (thisEnd === void 0) {
            thisEnd = this.length;
          }
          if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
            throw new RangeError("out of range index");
          }
          if (thisStart >= thisEnd && start >= end) {
            return 0;
          }
          if (thisStart >= thisEnd) {
            return -1;
          }
          if (start >= end) {
            return 1;
          }
          start >>>= 0;
          end >>>= 0;
          thisStart >>>= 0;
          thisEnd >>>= 0;
          if (this === target)
            return 0;
          let x2 = thisEnd - thisStart;
          let y2 = end - start;
          const len = Math.min(x2, y2);
          const thisCopy = this.slice(thisStart, thisEnd);
          const targetCopy = target.slice(start, end);
          for (let i = 0; i < len; ++i) {
            if (thisCopy[i] !== targetCopy[i]) {
              x2 = thisCopy[i];
              y2 = targetCopy[i];
              break;
            }
          }
          if (x2 < y2)
            return -1;
          if (y2 < x2)
            return 1;
          return 0;
        };
        function bidirectionalIndexOf2(buffer2, val, byteOffset, encoding, dir) {
          if (buffer2.length === 0)
            return -1;
          if (typeof byteOffset === "string") {
            encoding = byteOffset;
            byteOffset = 0;
          } else if (byteOffset > 2147483647) {
            byteOffset = 2147483647;
          } else if (byteOffset < -2147483648) {
            byteOffset = -2147483648;
          }
          byteOffset = +byteOffset;
          if (numberIsNaN(byteOffset)) {
            byteOffset = dir ? 0 : buffer2.length - 1;
          }
          if (byteOffset < 0)
            byteOffset = buffer2.length + byteOffset;
          if (byteOffset >= buffer2.length) {
            if (dir)
              return -1;
            else
              byteOffset = buffer2.length - 1;
          } else if (byteOffset < 0) {
            if (dir)
              byteOffset = 0;
            else
              return -1;
          }
          if (typeof val === "string") {
            val = Buffer3.from(val, encoding);
          }
          if (Buffer3.isBuffer(val)) {
            if (val.length === 0) {
              return -1;
            }
            return arrayIndexOf2(buffer2, val, byteOffset, encoding, dir);
          } else if (typeof val === "number") {
            val = val & 255;
            if (typeof Uint8Array.prototype.indexOf === "function") {
              if (dir) {
                return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
              } else {
                return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
              }
            }
            return arrayIndexOf2(buffer2, [val], byteOffset, encoding, dir);
          }
          throw new TypeError("val must be string, number or Buffer");
        }
        function arrayIndexOf2(arr, val, byteOffset, encoding, dir) {
          let indexSize = 1;
          let arrLength = arr.length;
          let valLength = val.length;
          if (encoding !== void 0) {
            encoding = String(encoding).toLowerCase();
            if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
              if (arr.length < 2 || val.length < 2) {
                return -1;
              }
              indexSize = 2;
              arrLength /= 2;
              valLength /= 2;
              byteOffset /= 2;
            }
          }
          function read(buf, i2) {
            if (indexSize === 1) {
              return buf[i2];
            } else {
              return buf.readUInt16BE(i2 * indexSize);
            }
          }
          let i;
          if (dir) {
            let foundIndex = -1;
            for (i = byteOffset; i < arrLength; i++) {
              if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                if (foundIndex === -1)
                  foundIndex = i;
                if (i - foundIndex + 1 === valLength)
                  return foundIndex * indexSize;
              } else {
                if (foundIndex !== -1)
                  i -= i - foundIndex;
                foundIndex = -1;
              }
            }
          } else {
            if (byteOffset + valLength > arrLength)
              byteOffset = arrLength - valLength;
            for (i = byteOffset; i >= 0; i--) {
              let found = true;
              for (let j2 = 0; j2 < valLength; j2++) {
                if (read(arr, i + j2) !== read(val, j2)) {
                  found = false;
                  break;
                }
              }
              if (found)
                return i;
            }
          }
          return -1;
        }
        Buffer3.prototype.includes = function includes2(val, byteOffset, encoding) {
          return this.indexOf(val, byteOffset, encoding) !== -1;
        };
        Buffer3.prototype.indexOf = function indexOf2(val, byteOffset, encoding) {
          return bidirectionalIndexOf2(this, val, byteOffset, encoding, true);
        };
        Buffer3.prototype.lastIndexOf = function lastIndexOf2(val, byteOffset, encoding) {
          return bidirectionalIndexOf2(this, val, byteOffset, encoding, false);
        };
        function hexWrite2(buf, string4, offset3, length) {
          offset3 = Number(offset3) || 0;
          const remaining = buf.length - offset3;
          if (!length) {
            length = remaining;
          } else {
            length = Number(length);
            if (length > remaining) {
              length = remaining;
            }
          }
          const strLen = string4.length;
          if (length > strLen / 2) {
            length = strLen / 2;
          }
          let i;
          for (i = 0; i < length; ++i) {
            const parsed = parseInt(string4.substr(i * 2, 2), 16);
            if (numberIsNaN(parsed))
              return i;
            buf[offset3 + i] = parsed;
          }
          return i;
        }
        function utf8Write2(buf, string4, offset3, length) {
          return blitBuffer2(utf8ToBytes4(string4, buf.length - offset3), buf, offset3, length);
        }
        function asciiWrite2(buf, string4, offset3, length) {
          return blitBuffer2(asciiToBytes2(string4), buf, offset3, length);
        }
        function base64Write2(buf, string4, offset3, length) {
          return blitBuffer2(base64ToBytes2(string4), buf, offset3, length);
        }
        function ucs2Write2(buf, string4, offset3, length) {
          return blitBuffer2(utf16leToBytes2(string4, buf.length - offset3), buf, offset3, length);
        }
        Buffer3.prototype.write = function write2(string4, offset3, length, encoding) {
          if (offset3 === void 0) {
            encoding = "utf8";
            length = this.length;
            offset3 = 0;
          } else if (length === void 0 && typeof offset3 === "string") {
            encoding = offset3;
            length = this.length;
            offset3 = 0;
          } else if (isFinite(offset3)) {
            offset3 = offset3 >>> 0;
            if (isFinite(length)) {
              length = length >>> 0;
              if (encoding === void 0)
                encoding = "utf8";
            } else {
              encoding = length;
              length = void 0;
            }
          } else {
            throw new Error(
              "Buffer.write(string, encoding, offset[, length]) is no longer supported"
            );
          }
          const remaining = this.length - offset3;
          if (length === void 0 || length > remaining)
            length = remaining;
          if (string4.length > 0 && (length < 0 || offset3 < 0) || offset3 > this.length) {
            throw new RangeError("Attempt to write outside buffer bounds");
          }
          if (!encoding)
            encoding = "utf8";
          let loweredCase = false;
          for (; ; ) {
            switch (encoding) {
              case "hex":
                return hexWrite2(this, string4, offset3, length);
              case "utf8":
              case "utf-8":
                return utf8Write2(this, string4, offset3, length);
              case "ascii":
              case "latin1":
              case "binary":
                return asciiWrite2(this, string4, offset3, length);
              case "base64":
                return base64Write2(this, string4, offset3, length);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return ucs2Write2(this, string4, offset3, length);
              default:
                if (loweredCase)
                  throw new TypeError("Unknown encoding: " + encoding);
                encoding = ("" + encoding).toLowerCase();
                loweredCase = true;
            }
          }
        };
        Buffer3.prototype.toJSON = function toJSON2() {
          return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
          };
        };
        function base64Slice2(buf, start, end) {
          if (start === 0 && end === buf.length) {
            return base64.fromByteArray(buf);
          } else {
            return base64.fromByteArray(buf.slice(start, end));
          }
        }
        function utf8Slice2(buf, start, end) {
          end = Math.min(buf.length, end);
          const res = [];
          let i = start;
          while (i < end) {
            const firstByte = buf[i];
            let codePoint = null;
            let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
            if (i + bytesPerSequence <= end) {
              let secondByte, thirdByte, fourthByte, tempCodePoint;
              switch (bytesPerSequence) {
                case 1:
                  if (firstByte < 128) {
                    codePoint = firstByte;
                  }
                  break;
                case 2:
                  secondByte = buf[i + 1];
                  if ((secondByte & 192) === 128) {
                    tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                    if (tempCodePoint > 127) {
                      codePoint = tempCodePoint;
                    }
                  }
                  break;
                case 3:
                  secondByte = buf[i + 1];
                  thirdByte = buf[i + 2];
                  if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                    tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                    if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                      codePoint = tempCodePoint;
                    }
                  }
                  break;
                case 4:
                  secondByte = buf[i + 1];
                  thirdByte = buf[i + 2];
                  fourthByte = buf[i + 3];
                  if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                    tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                    if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                      codePoint = tempCodePoint;
                    }
                  }
              }
            }
            if (codePoint === null) {
              codePoint = 65533;
              bytesPerSequence = 1;
            } else if (codePoint > 65535) {
              codePoint -= 65536;
              res.push(codePoint >>> 10 & 1023 | 55296);
              codePoint = 56320 | codePoint & 1023;
            }
            res.push(codePoint);
            i += bytesPerSequence;
          }
          return decodeCodePointsArray2(res);
        }
        const MAX_ARGUMENTS_LENGTH2 = 4096;
        function decodeCodePointsArray2(codePoints) {
          const len = codePoints.length;
          if (len <= MAX_ARGUMENTS_LENGTH2) {
            return String.fromCharCode.apply(String, codePoints);
          }
          let res = "";
          let i = 0;
          while (i < len) {
            res += String.fromCharCode.apply(
              String,
              codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH2)
            );
          }
          return res;
        }
        function asciiSlice2(buf, start, end) {
          let ret = "";
          end = Math.min(buf.length, end);
          for (let i = start; i < end; ++i) {
            ret += String.fromCharCode(buf[i] & 127);
          }
          return ret;
        }
        function latin1Slice2(buf, start, end) {
          let ret = "";
          end = Math.min(buf.length, end);
          for (let i = start; i < end; ++i) {
            ret += String.fromCharCode(buf[i]);
          }
          return ret;
        }
        function hexSlice2(buf, start, end) {
          const len = buf.length;
          if (!start || start < 0)
            start = 0;
          if (!end || end < 0 || end > len)
            end = len;
          let out = "";
          for (let i = start; i < end; ++i) {
            out += hexSliceLookupTable[buf[i]];
          }
          return out;
        }
        function utf16leSlice2(buf, start, end) {
          const bytes2 = buf.slice(start, end);
          let res = "";
          for (let i = 0; i < bytes2.length - 1; i += 2) {
            res += String.fromCharCode(bytes2[i] + bytes2[i + 1] * 256);
          }
          return res;
        }
        Buffer3.prototype.slice = function slice2(start, end) {
          const len = this.length;
          start = ~~start;
          end = end === void 0 ? len : ~~end;
          if (start < 0) {
            start += len;
            if (start < 0)
              start = 0;
          } else if (start > len) {
            start = len;
          }
          if (end < 0) {
            end += len;
            if (end < 0)
              end = 0;
          } else if (end > len) {
            end = len;
          }
          if (end < start)
            end = start;
          const newBuf = this.subarray(start, end);
          Object.setPrototypeOf(newBuf, Buffer3.prototype);
          return newBuf;
        };
        function checkOffset2(offset3, ext, length) {
          if (offset3 % 1 !== 0 || offset3 < 0)
            throw new RangeError("offset is not uint");
          if (offset3 + ext > length)
            throw new RangeError("Trying to access beyond buffer length");
        }
        Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE2(offset3, byteLength4, noAssert) {
          offset3 = offset3 >>> 0;
          byteLength4 = byteLength4 >>> 0;
          if (!noAssert)
            checkOffset2(offset3, byteLength4, this.length);
          let val = this[offset3];
          let mul = 1;
          let i = 0;
          while (++i < byteLength4 && (mul *= 256)) {
            val += this[offset3 + i] * mul;
          }
          return val;
        };
        Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE2(offset3, byteLength4, noAssert) {
          offset3 = offset3 >>> 0;
          byteLength4 = byteLength4 >>> 0;
          if (!noAssert) {
            checkOffset2(offset3, byteLength4, this.length);
          }
          let val = this[offset3 + --byteLength4];
          let mul = 1;
          while (byteLength4 > 0 && (mul *= 256)) {
            val += this[offset3 + --byteLength4] * mul;
          }
          return val;
        };
        Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt82(offset3, noAssert) {
          offset3 = offset3 >>> 0;
          if (!noAssert)
            checkOffset2(offset3, 1, this.length);
          return this[offset3];
        };
        Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE2(offset3, noAssert) {
          offset3 = offset3 >>> 0;
          if (!noAssert)
            checkOffset2(offset3, 2, this.length);
          return this[offset3] | this[offset3 + 1] << 8;
        };
        Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE2(offset3, noAssert) {
          offset3 = offset3 >>> 0;
          if (!noAssert)
            checkOffset2(offset3, 2, this.length);
          return this[offset3] << 8 | this[offset3 + 1];
        };
        Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE2(offset3, noAssert) {
          offset3 = offset3 >>> 0;
          if (!noAssert)
            checkOffset2(offset3, 4, this.length);
          return (this[offset3] | this[offset3 + 1] << 8 | this[offset3 + 2] << 16) + this[offset3 + 3] * 16777216;
        };
        Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE2(offset3, noAssert) {
          offset3 = offset3 >>> 0;
          if (!noAssert)
            checkOffset2(offset3, 4, this.length);
          return this[offset3] * 16777216 + (this[offset3 + 1] << 16 | this[offset3 + 2] << 8 | this[offset3 + 3]);
        };
        Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset3) {
          offset3 = offset3 >>> 0;
          validateNumber(offset3, "offset");
          const first = this[offset3];
          const last = this[offset3 + 7];
          if (first === void 0 || last === void 0) {
            boundsError(offset3, this.length - 8);
          }
          const lo = first + this[++offset3] * 2 ** 8 + this[++offset3] * 2 ** 16 + this[++offset3] * 2 ** 24;
          const hi = this[++offset3] + this[++offset3] * 2 ** 8 + this[++offset3] * 2 ** 16 + last * 2 ** 24;
          return BigInt(lo) + (BigInt(hi) << BigInt(32));
        });
        Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset3) {
          offset3 = offset3 >>> 0;
          validateNumber(offset3, "offset");
          const first = this[offset3];
          const last = this[offset3 + 7];
          if (first === void 0 || last === void 0) {
            boundsError(offset3, this.length - 8);
          }
          const hi = first * 2 ** 24 + this[++offset3] * 2 ** 16 + this[++offset3] * 2 ** 8 + this[++offset3];
          const lo = this[++offset3] * 2 ** 24 + this[++offset3] * 2 ** 16 + this[++offset3] * 2 ** 8 + last;
          return (BigInt(hi) << BigInt(32)) + BigInt(lo);
        });
        Buffer3.prototype.readIntLE = function readIntLE2(offset3, byteLength4, noAssert) {
          offset3 = offset3 >>> 0;
          byteLength4 = byteLength4 >>> 0;
          if (!noAssert)
            checkOffset2(offset3, byteLength4, this.length);
          let val = this[offset3];
          let mul = 1;
          let i = 0;
          while (++i < byteLength4 && (mul *= 256)) {
            val += this[offset3 + i] * mul;
          }
          mul *= 128;
          if (val >= mul)
            val -= Math.pow(2, 8 * byteLength4);
          return val;
        };
        Buffer3.prototype.readIntBE = function readIntBE2(offset3, byteLength4, noAssert) {
          offset3 = offset3 >>> 0;
          byteLength4 = byteLength4 >>> 0;
          if (!noAssert)
            checkOffset2(offset3, byteLength4, this.length);
          let i = byteLength4;
          let mul = 1;
          let val = this[offset3 + --i];
          while (i > 0 && (mul *= 256)) {
            val += this[offset3 + --i] * mul;
          }
          mul *= 128;
          if (val >= mul)
            val -= Math.pow(2, 8 * byteLength4);
          return val;
        };
        Buffer3.prototype.readInt8 = function readInt82(offset3, noAssert) {
          offset3 = offset3 >>> 0;
          if (!noAssert)
            checkOffset2(offset3, 1, this.length);
          if (!(this[offset3] & 128))
            return this[offset3];
          return (255 - this[offset3] + 1) * -1;
        };
        Buffer3.prototype.readInt16LE = function readInt16LE2(offset3, noAssert) {
          offset3 = offset3 >>> 0;
          if (!noAssert)
            checkOffset2(offset3, 2, this.length);
          const val = this[offset3] | this[offset3 + 1] << 8;
          return val & 32768 ? val | 4294901760 : val;
        };
        Buffer3.prototype.readInt16BE = function readInt16BE2(offset3, noAssert) {
          offset3 = offset3 >>> 0;
          if (!noAssert)
            checkOffset2(offset3, 2, this.length);
          const val = this[offset3 + 1] | this[offset3] << 8;
          return val & 32768 ? val | 4294901760 : val;
        };
        Buffer3.prototype.readInt32LE = function readInt32LE2(offset3, noAssert) {
          offset3 = offset3 >>> 0;
          if (!noAssert)
            checkOffset2(offset3, 4, this.length);
          return this[offset3] | this[offset3 + 1] << 8 | this[offset3 + 2] << 16 | this[offset3 + 3] << 24;
        };
        Buffer3.prototype.readInt32BE = function readInt32BE2(offset3, noAssert) {
          offset3 = offset3 >>> 0;
          if (!noAssert)
            checkOffset2(offset3, 4, this.length);
          return this[offset3] << 24 | this[offset3 + 1] << 16 | this[offset3 + 2] << 8 | this[offset3 + 3];
        };
        Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset3) {
          offset3 = offset3 >>> 0;
          validateNumber(offset3, "offset");
          const first = this[offset3];
          const last = this[offset3 + 7];
          if (first === void 0 || last === void 0) {
            boundsError(offset3, this.length - 8);
          }
          const val = this[offset3 + 4] + this[offset3 + 5] * 2 ** 8 + this[offset3 + 6] * 2 ** 16 + (last << 24);
          return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset3] * 2 ** 8 + this[++offset3] * 2 ** 16 + this[++offset3] * 2 ** 24);
        });
        Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset3) {
          offset3 = offset3 >>> 0;
          validateNumber(offset3, "offset");
          const first = this[offset3];
          const last = this[offset3 + 7];
          if (first === void 0 || last === void 0) {
            boundsError(offset3, this.length - 8);
          }
          const val = (first << 24) + this[++offset3] * 2 ** 16 + this[++offset3] * 2 ** 8 + this[++offset3];
          return (BigInt(val) << BigInt(32)) + BigInt(this[++offset3] * 2 ** 24 + this[++offset3] * 2 ** 16 + this[++offset3] * 2 ** 8 + last);
        });
        Buffer3.prototype.readFloatLE = function readFloatLE2(offset3, noAssert) {
          offset3 = offset3 >>> 0;
          if (!noAssert)
            checkOffset2(offset3, 4, this.length);
          return ieee754$1.read(this, offset3, true, 23, 4);
        };
        Buffer3.prototype.readFloatBE = function readFloatBE2(offset3, noAssert) {
          offset3 = offset3 >>> 0;
          if (!noAssert)
            checkOffset2(offset3, 4, this.length);
          return ieee754$1.read(this, offset3, false, 23, 4);
        };
        Buffer3.prototype.readDoubleLE = function readDoubleLE2(offset3, noAssert) {
          offset3 = offset3 >>> 0;
          if (!noAssert)
            checkOffset2(offset3, 8, this.length);
          return ieee754$1.read(this, offset3, true, 52, 8);
        };
        Buffer3.prototype.readDoubleBE = function readDoubleBE2(offset3, noAssert) {
          offset3 = offset3 >>> 0;
          if (!noAssert)
            checkOffset2(offset3, 8, this.length);
          return ieee754$1.read(this, offset3, false, 52, 8);
        };
        function checkInt2(buf, value, offset3, ext, max, min) {
          if (!Buffer3.isBuffer(buf))
            throw new TypeError('"buffer" argument must be a Buffer instance');
          if (value > max || value < min)
            throw new RangeError('"value" argument is out of bounds');
          if (offset3 + ext > buf.length)
            throw new RangeError("Index out of range");
        }
        Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE2(value, offset3, byteLength4, noAssert) {
          value = +value;
          offset3 = offset3 >>> 0;
          byteLength4 = byteLength4 >>> 0;
          if (!noAssert) {
            const maxBytes = Math.pow(2, 8 * byteLength4) - 1;
            checkInt2(this, value, offset3, byteLength4, maxBytes, 0);
          }
          let mul = 1;
          let i = 0;
          this[offset3] = value & 255;
          while (++i < byteLength4 && (mul *= 256)) {
            this[offset3 + i] = value / mul & 255;
          }
          return offset3 + byteLength4;
        };
        Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE2(value, offset3, byteLength4, noAssert) {
          value = +value;
          offset3 = offset3 >>> 0;
          byteLength4 = byteLength4 >>> 0;
          if (!noAssert) {
            const maxBytes = Math.pow(2, 8 * byteLength4) - 1;
            checkInt2(this, value, offset3, byteLength4, maxBytes, 0);
          }
          let i = byteLength4 - 1;
          let mul = 1;
          this[offset3 + i] = value & 255;
          while (--i >= 0 && (mul *= 256)) {
            this[offset3 + i] = value / mul & 255;
          }
          return offset3 + byteLength4;
        };
        Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt82(value, offset3, noAssert) {
          value = +value;
          offset3 = offset3 >>> 0;
          if (!noAssert)
            checkInt2(this, value, offset3, 1, 255, 0);
          this[offset3] = value & 255;
          return offset3 + 1;
        };
        Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE2(value, offset3, noAssert) {
          value = +value;
          offset3 = offset3 >>> 0;
          if (!noAssert)
            checkInt2(this, value, offset3, 2, 65535, 0);
          this[offset3] = value & 255;
          this[offset3 + 1] = value >>> 8;
          return offset3 + 2;
        };
        Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE2(value, offset3, noAssert) {
          value = +value;
          offset3 = offset3 >>> 0;
          if (!noAssert)
            checkInt2(this, value, offset3, 2, 65535, 0);
          this[offset3] = value >>> 8;
          this[offset3 + 1] = value & 255;
          return offset3 + 2;
        };
        Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE2(value, offset3, noAssert) {
          value = +value;
          offset3 = offset3 >>> 0;
          if (!noAssert)
            checkInt2(this, value, offset3, 4, 4294967295, 0);
          this[offset3 + 3] = value >>> 24;
          this[offset3 + 2] = value >>> 16;
          this[offset3 + 1] = value >>> 8;
          this[offset3] = value & 255;
          return offset3 + 4;
        };
        Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE2(value, offset3, noAssert) {
          value = +value;
          offset3 = offset3 >>> 0;
          if (!noAssert)
            checkInt2(this, value, offset3, 4, 4294967295, 0);
          this[offset3] = value >>> 24;
          this[offset3 + 1] = value >>> 16;
          this[offset3 + 2] = value >>> 8;
          this[offset3 + 3] = value & 255;
          return offset3 + 4;
        };
        function wrtBigUInt64LE(buf, value, offset3, min, max) {
          checkIntBI(value, min, max, buf, offset3, 7);
          let lo = Number(value & BigInt(4294967295));
          buf[offset3++] = lo;
          lo = lo >> 8;
          buf[offset3++] = lo;
          lo = lo >> 8;
          buf[offset3++] = lo;
          lo = lo >> 8;
          buf[offset3++] = lo;
          let hi = Number(value >> BigInt(32) & BigInt(4294967295));
          buf[offset3++] = hi;
          hi = hi >> 8;
          buf[offset3++] = hi;
          hi = hi >> 8;
          buf[offset3++] = hi;
          hi = hi >> 8;
          buf[offset3++] = hi;
          return offset3;
        }
        function wrtBigUInt64BE(buf, value, offset3, min, max) {
          checkIntBI(value, min, max, buf, offset3, 7);
          let lo = Number(value & BigInt(4294967295));
          buf[offset3 + 7] = lo;
          lo = lo >> 8;
          buf[offset3 + 6] = lo;
          lo = lo >> 8;
          buf[offset3 + 5] = lo;
          lo = lo >> 8;
          buf[offset3 + 4] = lo;
          let hi = Number(value >> BigInt(32) & BigInt(4294967295));
          buf[offset3 + 3] = hi;
          hi = hi >> 8;
          buf[offset3 + 2] = hi;
          hi = hi >> 8;
          buf[offset3 + 1] = hi;
          hi = hi >> 8;
          buf[offset3] = hi;
          return offset3 + 8;
        }
        Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset3 = 0) {
          return wrtBigUInt64LE(this, value, offset3, BigInt(0), BigInt("0xffffffffffffffff"));
        });
        Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset3 = 0) {
          return wrtBigUInt64BE(this, value, offset3, BigInt(0), BigInt("0xffffffffffffffff"));
        });
        Buffer3.prototype.writeIntLE = function writeIntLE2(value, offset3, byteLength4, noAssert) {
          value = +value;
          offset3 = offset3 >>> 0;
          if (!noAssert) {
            const limit = Math.pow(2, 8 * byteLength4 - 1);
            checkInt2(this, value, offset3, byteLength4, limit - 1, -limit);
          }
          let i = 0;
          let mul = 1;
          let sub = 0;
          this[offset3] = value & 255;
          while (++i < byteLength4 && (mul *= 256)) {
            if (value < 0 && sub === 0 && this[offset3 + i - 1] !== 0) {
              sub = 1;
            }
            this[offset3 + i] = (value / mul >> 0) - sub & 255;
          }
          return offset3 + byteLength4;
        };
        Buffer3.prototype.writeIntBE = function writeIntBE2(value, offset3, byteLength4, noAssert) {
          value = +value;
          offset3 = offset3 >>> 0;
          if (!noAssert) {
            const limit = Math.pow(2, 8 * byteLength4 - 1);
            checkInt2(this, value, offset3, byteLength4, limit - 1, -limit);
          }
          let i = byteLength4 - 1;
          let mul = 1;
          let sub = 0;
          this[offset3 + i] = value & 255;
          while (--i >= 0 && (mul *= 256)) {
            if (value < 0 && sub === 0 && this[offset3 + i + 1] !== 0) {
              sub = 1;
            }
            this[offset3 + i] = (value / mul >> 0) - sub & 255;
          }
          return offset3 + byteLength4;
        };
        Buffer3.prototype.writeInt8 = function writeInt82(value, offset3, noAssert) {
          value = +value;
          offset3 = offset3 >>> 0;
          if (!noAssert)
            checkInt2(this, value, offset3, 1, 127, -128);
          if (value < 0)
            value = 255 + value + 1;
          this[offset3] = value & 255;
          return offset3 + 1;
        };
        Buffer3.prototype.writeInt16LE = function writeInt16LE2(value, offset3, noAssert) {
          value = +value;
          offset3 = offset3 >>> 0;
          if (!noAssert)
            checkInt2(this, value, offset3, 2, 32767, -32768);
          this[offset3] = value & 255;
          this[offset3 + 1] = value >>> 8;
          return offset3 + 2;
        };
        Buffer3.prototype.writeInt16BE = function writeInt16BE2(value, offset3, noAssert) {
          value = +value;
          offset3 = offset3 >>> 0;
          if (!noAssert)
            checkInt2(this, value, offset3, 2, 32767, -32768);
          this[offset3] = value >>> 8;
          this[offset3 + 1] = value & 255;
          return offset3 + 2;
        };
        Buffer3.prototype.writeInt32LE = function writeInt32LE2(value, offset3, noAssert) {
          value = +value;
          offset3 = offset3 >>> 0;
          if (!noAssert)
            checkInt2(this, value, offset3, 4, 2147483647, -2147483648);
          this[offset3] = value & 255;
          this[offset3 + 1] = value >>> 8;
          this[offset3 + 2] = value >>> 16;
          this[offset3 + 3] = value >>> 24;
          return offset3 + 4;
        };
        Buffer3.prototype.writeInt32BE = function writeInt32BE2(value, offset3, noAssert) {
          value = +value;
          offset3 = offset3 >>> 0;
          if (!noAssert)
            checkInt2(this, value, offset3, 4, 2147483647, -2147483648);
          if (value < 0)
            value = 4294967295 + value + 1;
          this[offset3] = value >>> 24;
          this[offset3 + 1] = value >>> 16;
          this[offset3 + 2] = value >>> 8;
          this[offset3 + 3] = value & 255;
          return offset3 + 4;
        };
        Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset3 = 0) {
          return wrtBigUInt64LE(this, value, offset3, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
        });
        Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset3 = 0) {
          return wrtBigUInt64BE(this, value, offset3, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
        });
        function checkIEEE7542(buf, value, offset3, ext, max, min) {
          if (offset3 + ext > buf.length)
            throw new RangeError("Index out of range");
          if (offset3 < 0)
            throw new RangeError("Index out of range");
        }
        function writeFloat2(buf, value, offset3, littleEndian, noAssert) {
          value = +value;
          offset3 = offset3 >>> 0;
          if (!noAssert) {
            checkIEEE7542(buf, value, offset3, 4);
          }
          ieee754$1.write(buf, value, offset3, littleEndian, 23, 4);
          return offset3 + 4;
        }
        Buffer3.prototype.writeFloatLE = function writeFloatLE2(value, offset3, noAssert) {
          return writeFloat2(this, value, offset3, true, noAssert);
        };
        Buffer3.prototype.writeFloatBE = function writeFloatBE2(value, offset3, noAssert) {
          return writeFloat2(this, value, offset3, false, noAssert);
        };
        function writeDouble2(buf, value, offset3, littleEndian, noAssert) {
          value = +value;
          offset3 = offset3 >>> 0;
          if (!noAssert) {
            checkIEEE7542(buf, value, offset3, 8);
          }
          ieee754$1.write(buf, value, offset3, littleEndian, 52, 8);
          return offset3 + 8;
        }
        Buffer3.prototype.writeDoubleLE = function writeDoubleLE2(value, offset3, noAssert) {
          return writeDouble2(this, value, offset3, true, noAssert);
        };
        Buffer3.prototype.writeDoubleBE = function writeDoubleBE2(value, offset3, noAssert) {
          return writeDouble2(this, value, offset3, false, noAssert);
        };
        Buffer3.prototype.copy = function copy2(target, targetStart, start, end) {
          if (!Buffer3.isBuffer(target))
            throw new TypeError("argument should be a Buffer");
          if (!start)
            start = 0;
          if (!end && end !== 0)
            end = this.length;
          if (targetStart >= target.length)
            targetStart = target.length;
          if (!targetStart)
            targetStart = 0;
          if (end > 0 && end < start)
            end = start;
          if (end === start)
            return 0;
          if (target.length === 0 || this.length === 0)
            return 0;
          if (targetStart < 0) {
            throw new RangeError("targetStart out of bounds");
          }
          if (start < 0 || start >= this.length)
            throw new RangeError("Index out of range");
          if (end < 0)
            throw new RangeError("sourceEnd out of bounds");
          if (end > this.length)
            end = this.length;
          if (target.length - targetStart < end - start) {
            end = target.length - targetStart + start;
          }
          const len = end - start;
          if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
            this.copyWithin(targetStart, start, end);
          } else {
            Uint8Array.prototype.set.call(
              target,
              this.subarray(start, end),
              targetStart
            );
          }
          return len;
        };
        Buffer3.prototype.fill = function fill2(val, start, end, encoding) {
          if (typeof val === "string") {
            if (typeof start === "string") {
              encoding = start;
              start = 0;
              end = this.length;
            } else if (typeof end === "string") {
              encoding = end;
              end = this.length;
            }
            if (encoding !== void 0 && typeof encoding !== "string") {
              throw new TypeError("encoding must be a string");
            }
            if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
              throw new TypeError("Unknown encoding: " + encoding);
            }
            if (val.length === 1) {
              const code2 = val.charCodeAt(0);
              if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
                val = code2;
              }
            }
          } else if (typeof val === "number") {
            val = val & 255;
          } else if (typeof val === "boolean") {
            val = Number(val);
          }
          if (start < 0 || this.length < start || this.length < end) {
            throw new RangeError("Out of range index");
          }
          if (end <= start) {
            return this;
          }
          start = start >>> 0;
          end = end === void 0 ? this.length : end >>> 0;
          if (!val)
            val = 0;
          let i;
          if (typeof val === "number") {
            for (i = start; i < end; ++i) {
              this[i] = val;
            }
          } else {
            const bytes2 = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
            const len = bytes2.length;
            if (len === 0) {
              throw new TypeError('The value "' + val + '" is invalid for argument "value"');
            }
            for (i = 0; i < end - start; ++i) {
              this[i + start] = bytes2[i % len];
            }
          }
          return this;
        };
        const errors = {};
        function E2(sym, getMessage2, Base) {
          errors[sym] = class NodeError extends Base {
            constructor() {
              super();
              Object.defineProperty(this, "message", {
                value: getMessage2.apply(this, arguments),
                writable: true,
                configurable: true
              });
              this.name = `${this.name} [${sym}]`;
              this.stack;
              delete this.name;
            }
            get code() {
              return sym;
            }
            set code(value) {
              Object.defineProperty(this, "code", {
                configurable: true,
                enumerable: true,
                value,
                writable: true
              });
            }
            toString() {
              return `${this.name} [${sym}]: ${this.message}`;
            }
          };
        }
        E2(
          "ERR_BUFFER_OUT_OF_BOUNDS",
          function(name2) {
            if (name2) {
              return `${name2} is outside of buffer bounds`;
            }
            return "Attempt to access memory outside buffer bounds";
          },
          RangeError
        );
        E2(
          "ERR_INVALID_ARG_TYPE",
          function(name2, actual) {
            return `The "${name2}" argument must be of type number. Received type ${typeof actual}`;
          },
          TypeError
        );
        E2(
          "ERR_OUT_OF_RANGE",
          function(str3, range, input) {
            let msg = `The value of "${str3}" is out of range.`;
            let received = input;
            if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
              received = addNumericalSeparator(String(input));
            } else if (typeof input === "bigint") {
              received = String(input);
              if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
                received = addNumericalSeparator(received);
              }
              received += "n";
            }
            msg += ` It must be ${range}. Received ${received}`;
            return msg;
          },
          RangeError
        );
        function addNumericalSeparator(val) {
          let res = "";
          let i = val.length;
          const start = val[0] === "-" ? 1 : 0;
          for (; i >= start + 4; i -= 3) {
            res = `_${val.slice(i - 3, i)}${res}`;
          }
          return `${val.slice(0, i)}${res}`;
        }
        function checkBounds(buf, offset3, byteLength4) {
          validateNumber(offset3, "offset");
          if (buf[offset3] === void 0 || buf[offset3 + byteLength4] === void 0) {
            boundsError(offset3, buf.length - (byteLength4 + 1));
          }
        }
        function checkIntBI(value, min, max, buf, offset3, byteLength4) {
          if (value > max || value < min) {
            const n = typeof min === "bigint" ? "n" : "";
            let range;
            if (byteLength4 > 3) {
              if (min === 0 || min === BigInt(0)) {
                range = `>= 0${n} and < 2${n} ** ${(byteLength4 + 1) * 8}${n}`;
              } else {
                range = `>= -(2${n} ** ${(byteLength4 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength4 + 1) * 8 - 1}${n}`;
              }
            } else {
              range = `>= ${min}${n} and <= ${max}${n}`;
            }
            throw new errors.ERR_OUT_OF_RANGE("value", range, value);
          }
          checkBounds(buf, offset3, byteLength4);
        }
        function validateNumber(value, name2) {
          if (typeof value !== "number") {
            throw new errors.ERR_INVALID_ARG_TYPE(name2, "number", value);
          }
        }
        function boundsError(value, length, type5) {
          if (Math.floor(value) !== value) {
            validateNumber(value, type5);
            throw new errors.ERR_OUT_OF_RANGE(type5 || "offset", "an integer", value);
          }
          if (length < 0) {
            throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
          }
          throw new errors.ERR_OUT_OF_RANGE(
            type5 || "offset",
            `>= ${type5 ? 1 : 0} and <= ${length}`,
            value
          );
        }
        const INVALID_BASE64_RE2 = /[^+/0-9A-Za-z-_]/g;
        function base64clean2(str3) {
          str3 = str3.split("=")[0];
          str3 = str3.trim().replace(INVALID_BASE64_RE2, "");
          if (str3.length < 2)
            return "";
          while (str3.length % 4 !== 0) {
            str3 = str3 + "=";
          }
          return str3;
        }
        function utf8ToBytes4(string4, units) {
          units = units || Infinity;
          let codePoint;
          const length = string4.length;
          let leadSurrogate = null;
          const bytes2 = [];
          for (let i = 0; i < length; ++i) {
            codePoint = string4.charCodeAt(i);
            if (codePoint > 55295 && codePoint < 57344) {
              if (!leadSurrogate) {
                if (codePoint > 56319) {
                  if ((units -= 3) > -1)
                    bytes2.push(239, 191, 189);
                  continue;
                } else if (i + 1 === length) {
                  if ((units -= 3) > -1)
                    bytes2.push(239, 191, 189);
                  continue;
                }
                leadSurrogate = codePoint;
                continue;
              }
              if (codePoint < 56320) {
                if ((units -= 3) > -1)
                  bytes2.push(239, 191, 189);
                leadSurrogate = codePoint;
                continue;
              }
              codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
            } else if (leadSurrogate) {
              if ((units -= 3) > -1)
                bytes2.push(239, 191, 189);
            }
            leadSurrogate = null;
            if (codePoint < 128) {
              if ((units -= 1) < 0)
                break;
              bytes2.push(codePoint);
            } else if (codePoint < 2048) {
              if ((units -= 2) < 0)
                break;
              bytes2.push(
                codePoint >> 6 | 192,
                codePoint & 63 | 128
              );
            } else if (codePoint < 65536) {
              if ((units -= 3) < 0)
                break;
              bytes2.push(
                codePoint >> 12 | 224,
                codePoint >> 6 & 63 | 128,
                codePoint & 63 | 128
              );
            } else if (codePoint < 1114112) {
              if ((units -= 4) < 0)
                break;
              bytes2.push(
                codePoint >> 18 | 240,
                codePoint >> 12 & 63 | 128,
                codePoint >> 6 & 63 | 128,
                codePoint & 63 | 128
              );
            } else {
              throw new Error("Invalid code point");
            }
          }
          return bytes2;
        }
        function asciiToBytes2(str3) {
          const byteArray = [];
          for (let i = 0; i < str3.length; ++i) {
            byteArray.push(str3.charCodeAt(i) & 255);
          }
          return byteArray;
        }
        function utf16leToBytes2(str3, units) {
          let c2, hi, lo;
          const byteArray = [];
          for (let i = 0; i < str3.length; ++i) {
            if ((units -= 2) < 0)
              break;
            c2 = str3.charCodeAt(i);
            hi = c2 >> 8;
            lo = c2 % 256;
            byteArray.push(lo);
            byteArray.push(hi);
          }
          return byteArray;
        }
        function base64ToBytes2(str3) {
          return base64.toByteArray(base64clean2(str3));
        }
        function blitBuffer2(src, dst, offset3, length) {
          let i;
          for (i = 0; i < length; ++i) {
            if (i + offset3 >= dst.length || i >= src.length)
              break;
            dst[i + offset3] = src[i];
          }
          return i;
        }
        function isInstance(obj, type5) {
          return obj instanceof type5 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type5.name;
        }
        function numberIsNaN(obj) {
          return obj !== obj;
        }
        const hexSliceLookupTable = function() {
          const alphabet = "0123456789abcdef";
          const table = new Array(256);
          for (let i = 0; i < 16; ++i) {
            const i163 = i * 16;
            for (let j2 = 0; j2 < 16; ++j2) {
              table[i163 + j2] = alphabet[i] + alphabet[j2];
            }
          }
          return table;
        }();
        function defineBigIntMethod(fn2) {
          return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn2;
        }
        function BufferBigIntNotDefined() {
          throw new Error("BigInt not supported");
        }
      })(buffer);
      global$1 = typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
      if (typeof Object.create === "function") {
        inherits = function inherits2(ctor, superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        };
      } else {
        inherits = function inherits2(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        };
      }
      inherits$1 = inherits;
      inspect$1.colors = {
        "bold": [1, 22],
        "italic": [3, 23],
        "underline": [4, 24],
        "inverse": [7, 27],
        "white": [37, 39],
        "grey": [90, 39],
        "black": [30, 39],
        "blue": [34, 39],
        "cyan": [36, 39],
        "green": [32, 39],
        "magenta": [35, 39],
        "red": [31, 39],
        "yellow": [33, 39]
      };
      inspect$1.styles = {
        "special": "cyan",
        "number": "yellow",
        "boolean": "yellow",
        "undefined": "grey",
        "null": "bold",
        "string": "green",
        "date": "magenta",
        "regexp": "red"
      };
      hasOwn = Object.prototype.hasOwnProperty;
      objectKeys = Object.keys || function(obj) {
        var keys = [];
        for (var key in obj) {
          if (hasOwn.call(obj, key))
            keys.push(key);
        }
        return keys;
      };
      pSlice = Array.prototype.slice;
      regex = /\s*function\s+([^\(\s]*)\s*/;
      assert6.AssertionError = AssertionError;
      inherits$1(AssertionError, Error);
      assert6.fail = fail;
      assert6.ok = ok2;
      assert6.equal = equal;
      assert6.notEqual = notEqual;
      assert6.deepEqual = deepEqual;
      assert6.deepStrictEqual = deepStrictEqual;
      assert6.notDeepEqual = notDeepEqual;
      assert6.notDeepStrictEqual = notDeepStrictEqual;
      assert6.strictEqual = strictEqual;
      assert6.notStrictEqual = notStrictEqual;
      assert6.throws = throws;
      assert6.doesNotThrow = doesNotThrow;
      assert6.ifError = ifError;
      Layout$1 = {};
      Layout2 = class {
        constructor(span, property) {
          if (!Number.isInteger(span)) {
            throw new TypeError("span must be an integer");
          }
          this.span = span;
          this.property = property;
        }
        makeDestinationObject() {
          return {};
        }
        decode(b2, offset3) {
          throw new Error("Layout is abstract");
        }
        encode(src, b2, offset3) {
          throw new Error("Layout is abstract");
        }
        getSpan(b2, offset3) {
          if (0 > this.span) {
            throw new RangeError("indeterminate span");
          }
          return this.span;
        }
        replicate(property) {
          const rv = Object.create(this.constructor.prototype);
          Object.assign(rv, this);
          rv.property = property;
          return rv;
        }
        fromArray(values) {
          return void 0;
        }
      };
      Layout$1.Layout = Layout2;
      Layout$1.nameWithProperty = nameWithProperty2;
      Layout$1.bindConstructorLayout = bindConstructorLayout;
      ExternalLayout2 = class extends Layout2 {
        isCount() {
          throw new Error("ExternalLayout is abstract");
        }
      };
      GreedyCount = class extends ExternalLayout2 {
        constructor(elementSpan, property) {
          if (void 0 === elementSpan) {
            elementSpan = 1;
          }
          if (!Number.isInteger(elementSpan) || 0 >= elementSpan) {
            throw new TypeError("elementSpan must be a (positive) integer");
          }
          super(-1, property);
          this.elementSpan = elementSpan;
        }
        isCount() {
          return true;
        }
        decode(b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          const rem = b2.length - offset3;
          return Math.floor(rem / this.elementSpan);
        }
        encode(src, b2, offset3) {
          return 0;
        }
      };
      OffsetLayout2 = class extends ExternalLayout2 {
        constructor(layout, offset3, property) {
          if (!(layout instanceof Layout2)) {
            throw new TypeError("layout must be a Layout");
          }
          if (void 0 === offset3) {
            offset3 = 0;
          } else if (!Number.isInteger(offset3)) {
            throw new TypeError("offset must be integer or undefined");
          }
          super(layout.span, property || layout.property);
          this.layout = layout;
          this.offset = offset3;
        }
        isCount() {
          return this.layout instanceof UInt2 || this.layout instanceof UIntBE2;
        }
        decode(b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          return this.layout.decode(b2, offset3 + this.offset);
        }
        encode(src, b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          return this.layout.encode(src, b2, offset3 + this.offset);
        }
      };
      UInt2 = class extends Layout2 {
        constructor(span, property) {
          super(span, property);
          if (6 < this.span) {
            throw new RangeError("span must not exceed 6 bytes");
          }
        }
        decode(b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          return b2.readUIntLE(offset3, this.span);
        }
        encode(src, b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          b2.writeUIntLE(src, offset3, this.span);
          return this.span;
        }
      };
      UIntBE2 = class extends Layout2 {
        constructor(span, property) {
          super(span, property);
          if (6 < this.span) {
            throw new RangeError("span must not exceed 6 bytes");
          }
        }
        decode(b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          return b2.readUIntBE(offset3, this.span);
        }
        encode(src, b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          b2.writeUIntBE(src, offset3, this.span);
          return this.span;
        }
      };
      Int = class extends Layout2 {
        constructor(span, property) {
          super(span, property);
          if (6 < this.span) {
            throw new RangeError("span must not exceed 6 bytes");
          }
        }
        decode(b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          return b2.readIntLE(offset3, this.span);
        }
        encode(src, b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          b2.writeIntLE(src, offset3, this.span);
          return this.span;
        }
      };
      IntBE = class extends Layout2 {
        constructor(span, property) {
          super(span, property);
          if (6 < this.span) {
            throw new RangeError("span must not exceed 6 bytes");
          }
        }
        decode(b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          return b2.readIntBE(offset3, this.span);
        }
        encode(src, b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          b2.writeIntBE(src, offset3, this.span);
          return this.span;
        }
      };
      V2E322 = Math.pow(2, 32);
      NearUInt642 = class extends Layout2 {
        constructor(property) {
          super(8, property);
        }
        decode(b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          const lo32 = b2.readUInt32LE(offset3);
          const hi32 = b2.readUInt32LE(offset3 + 4);
          return roundedInt642(hi32, lo32);
        }
        encode(src, b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          const split2 = divmodInt642(src);
          b2.writeUInt32LE(split2.lo32, offset3);
          b2.writeUInt32LE(split2.hi32, offset3 + 4);
          return 8;
        }
      };
      NearUInt64BE = class extends Layout2 {
        constructor(property) {
          super(8, property);
        }
        decode(b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          const hi32 = b2.readUInt32BE(offset3);
          const lo32 = b2.readUInt32BE(offset3 + 4);
          return roundedInt642(hi32, lo32);
        }
        encode(src, b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          const split2 = divmodInt642(src);
          b2.writeUInt32BE(split2.hi32, offset3);
          b2.writeUInt32BE(split2.lo32, offset3 + 4);
          return 8;
        }
      };
      NearInt642 = class extends Layout2 {
        constructor(property) {
          super(8, property);
        }
        decode(b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          const lo32 = b2.readUInt32LE(offset3);
          const hi32 = b2.readInt32LE(offset3 + 4);
          return roundedInt642(hi32, lo32);
        }
        encode(src, b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          const split2 = divmodInt642(src);
          b2.writeUInt32LE(split2.lo32, offset3);
          b2.writeInt32LE(split2.hi32, offset3 + 4);
          return 8;
        }
      };
      NearInt64BE = class extends Layout2 {
        constructor(property) {
          super(8, property);
        }
        decode(b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          const hi32 = b2.readInt32BE(offset3);
          const lo32 = b2.readUInt32BE(offset3 + 4);
          return roundedInt642(hi32, lo32);
        }
        encode(src, b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          const split2 = divmodInt642(src);
          b2.writeInt32BE(split2.hi32, offset3);
          b2.writeUInt32BE(split2.lo32, offset3 + 4);
          return 8;
        }
      };
      Float = class extends Layout2 {
        constructor(property) {
          super(4, property);
        }
        decode(b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          return b2.readFloatLE(offset3);
        }
        encode(src, b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          b2.writeFloatLE(src, offset3);
          return 4;
        }
      };
      FloatBE = class extends Layout2 {
        constructor(property) {
          super(4, property);
        }
        decode(b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          return b2.readFloatBE(offset3);
        }
        encode(src, b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          b2.writeFloatBE(src, offset3);
          return 4;
        }
      };
      Double = class extends Layout2 {
        constructor(property) {
          super(8, property);
        }
        decode(b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          return b2.readDoubleLE(offset3);
        }
        encode(src, b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          b2.writeDoubleLE(src, offset3);
          return 8;
        }
      };
      DoubleBE = class extends Layout2 {
        constructor(property) {
          super(8, property);
        }
        decode(b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          return b2.readDoubleBE(offset3);
        }
        encode(src, b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          b2.writeDoubleBE(src, offset3);
          return 8;
        }
      };
      Sequence = class extends Layout2 {
        constructor(elementLayout, count, property) {
          if (!(elementLayout instanceof Layout2)) {
            throw new TypeError("elementLayout must be a Layout");
          }
          if (!(count instanceof ExternalLayout2 && count.isCount() || Number.isInteger(count) && 0 <= count)) {
            throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
          }
          let span = -1;
          if (!(count instanceof ExternalLayout2) && 0 < elementLayout.span) {
            span = count * elementLayout.span;
          }
          super(span, property);
          this.elementLayout = elementLayout;
          this.count = count;
        }
        getSpan(b2, offset3) {
          if (0 <= this.span) {
            return this.span;
          }
          if (void 0 === offset3) {
            offset3 = 0;
          }
          let span = 0;
          let count = this.count;
          if (count instanceof ExternalLayout2) {
            count = count.decode(b2, offset3);
          }
          if (0 < this.elementLayout.span) {
            span = count * this.elementLayout.span;
          } else {
            let idx = 0;
            while (idx < count) {
              span += this.elementLayout.getSpan(b2, offset3 + span);
              ++idx;
            }
          }
          return span;
        }
        decode(b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          const rv = [];
          let i = 0;
          let count = this.count;
          if (count instanceof ExternalLayout2) {
            count = count.decode(b2, offset3);
          }
          while (i < count) {
            rv.push(this.elementLayout.decode(b2, offset3));
            offset3 += this.elementLayout.getSpan(b2, offset3);
            i += 1;
          }
          return rv;
        }
        encode(src, b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          const elo = this.elementLayout;
          const span = src.reduce((span2, v2) => {
            return span2 + elo.encode(v2, b2, offset3 + span2);
          }, 0);
          if (this.count instanceof ExternalLayout2) {
            this.count.encode(src.length, b2, offset3);
          }
          return span;
        }
      };
      Structure2 = class extends Layout2 {
        constructor(fields, property, decodePrefixes) {
          if (!(Array.isArray(fields) && fields.reduce((acc, v2) => acc && v2 instanceof Layout2, true))) {
            throw new TypeError("fields must be array of Layout instances");
          }
          if ("boolean" === typeof property && void 0 === decodePrefixes) {
            decodePrefixes = property;
            property = void 0;
          }
          for (const fd of fields) {
            if (0 > fd.span && void 0 === fd.property) {
              throw new Error("fields cannot contain unnamed variable-length layout");
            }
          }
          let span = -1;
          try {
            span = fields.reduce((span2, fd) => span2 + fd.getSpan(), 0);
          } catch (e) {
          }
          super(span, property);
          this.fields = fields;
          this.decodePrefixes = !!decodePrefixes;
        }
        getSpan(b2, offset3) {
          if (0 <= this.span) {
            return this.span;
          }
          if (void 0 === offset3) {
            offset3 = 0;
          }
          let span = 0;
          try {
            span = this.fields.reduce((span2, fd) => {
              const fsp = fd.getSpan(b2, offset3);
              offset3 += fsp;
              return span2 + fsp;
            }, 0);
          } catch (e) {
            throw new RangeError("indeterminate span");
          }
          return span;
        }
        decode(b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          const dest = this.makeDestinationObject();
          for (const fd of this.fields) {
            if (void 0 !== fd.property) {
              dest[fd.property] = fd.decode(b2, offset3);
            }
            offset3 += fd.getSpan(b2, offset3);
            if (this.decodePrefixes && b2.length === offset3) {
              break;
            }
          }
          return dest;
        }
        encode(src, b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          const firstOffset = offset3;
          let lastOffset = 0;
          let lastWrote = 0;
          for (const fd of this.fields) {
            let span = fd.span;
            lastWrote = 0 < span ? span : 0;
            if (void 0 !== fd.property) {
              const fv = src[fd.property];
              if (void 0 !== fv) {
                lastWrote = fd.encode(fv, b2, offset3);
                if (0 > span) {
                  span = fd.getSpan(b2, offset3);
                }
              }
            }
            lastOffset = offset3;
            offset3 += span;
          }
          return lastOffset + lastWrote - firstOffset;
        }
        fromArray(values) {
          const dest = this.makeDestinationObject();
          for (const fd of this.fields) {
            if (void 0 !== fd.property && 0 < values.length) {
              dest[fd.property] = values.shift();
            }
          }
          return dest;
        }
        layoutFor(property) {
          if ("string" !== typeof property) {
            throw new TypeError("property must be string");
          }
          for (const fd of this.fields) {
            if (fd.property === property) {
              return fd;
            }
          }
        }
        offsetOf(property) {
          if ("string" !== typeof property) {
            throw new TypeError("property must be string");
          }
          let offset3 = 0;
          for (const fd of this.fields) {
            if (fd.property === property) {
              return offset3;
            }
            if (0 > fd.span) {
              offset3 = -1;
            } else if (0 <= offset3) {
              offset3 += fd.span;
            }
          }
        }
      };
      UnionDiscriminator2 = class {
        constructor(property) {
          this.property = property;
        }
        decode() {
          throw new Error("UnionDiscriminator is abstract");
        }
        encode() {
          throw new Error("UnionDiscriminator is abstract");
        }
      };
      UnionLayoutDiscriminator2 = class extends UnionDiscriminator2 {
        constructor(layout, property) {
          if (!(layout instanceof ExternalLayout2 && layout.isCount())) {
            throw new TypeError("layout must be an unsigned integer ExternalLayout");
          }
          super(property || layout.property || "variant");
          this.layout = layout;
        }
        decode(b2, offset3) {
          return this.layout.decode(b2, offset3);
        }
        encode(src, b2, offset3) {
          return this.layout.encode(src, b2, offset3);
        }
      };
      Union2 = class extends Layout2 {
        constructor(discr, defaultLayout, property) {
          const upv = discr instanceof UInt2 || discr instanceof UIntBE2;
          if (upv) {
            discr = new UnionLayoutDiscriminator2(new OffsetLayout2(discr));
          } else if (discr instanceof ExternalLayout2 && discr.isCount()) {
            discr = new UnionLayoutDiscriminator2(discr);
          } else if (!(discr instanceof UnionDiscriminator2)) {
            throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
          }
          if (void 0 === defaultLayout) {
            defaultLayout = null;
          }
          if (!(null === defaultLayout || defaultLayout instanceof Layout2)) {
            throw new TypeError("defaultLayout must be null or a Layout");
          }
          if (null !== defaultLayout) {
            if (0 > defaultLayout.span) {
              throw new Error("defaultLayout must have constant span");
            }
            if (void 0 === defaultLayout.property) {
              defaultLayout = defaultLayout.replicate("content");
            }
          }
          let span = -1;
          if (defaultLayout) {
            span = defaultLayout.span;
            if (0 <= span && upv) {
              span += discr.layout.span;
            }
          }
          super(span, property);
          this.discriminator = discr;
          this.usesPrefixDiscriminator = upv;
          this.defaultLayout = defaultLayout;
          this.registry = {};
          let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);
          this.getSourceVariant = function(src) {
            return boundGetSourceVariant(src);
          };
          this.configGetSourceVariant = function(gsv) {
            boundGetSourceVariant = gsv.bind(this);
          };
        }
        getSpan(b2, offset3) {
          if (0 <= this.span) {
            return this.span;
          }
          if (void 0 === offset3) {
            offset3 = 0;
          }
          const vlo = this.getVariant(b2, offset3);
          if (!vlo) {
            throw new Error("unable to determine span for unrecognized variant");
          }
          return vlo.getSpan(b2, offset3);
        }
        defaultGetSourceVariant(src) {
          if (src.hasOwnProperty(this.discriminator.property)) {
            if (this.defaultLayout && src.hasOwnProperty(this.defaultLayout.property)) {
              return void 0;
            }
            const vlo = this.registry[src[this.discriminator.property]];
            if (vlo && (!vlo.layout || src.hasOwnProperty(vlo.property))) {
              return vlo;
            }
          } else {
            for (const tag in this.registry) {
              const vlo = this.registry[tag];
              if (src.hasOwnProperty(vlo.property)) {
                return vlo;
              }
            }
          }
          throw new Error("unable to infer src variant");
        }
        decode(b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          let dest;
          const dlo = this.discriminator;
          const discr = dlo.decode(b2, offset3);
          let clo = this.registry[discr];
          if (void 0 === clo) {
            let contentOffset = 0;
            clo = this.defaultLayout;
            if (this.usesPrefixDiscriminator) {
              contentOffset = dlo.layout.span;
            }
            dest = this.makeDestinationObject();
            dest[dlo.property] = discr;
            dest[clo.property] = this.defaultLayout.decode(b2, offset3 + contentOffset);
          } else {
            dest = clo.decode(b2, offset3);
          }
          return dest;
        }
        encode(src, b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          const vlo = this.getSourceVariant(src);
          if (void 0 === vlo) {
            const dlo = this.discriminator;
            const clo = this.defaultLayout;
            let contentOffset = 0;
            if (this.usesPrefixDiscriminator) {
              contentOffset = dlo.layout.span;
            }
            dlo.encode(src[dlo.property], b2, offset3);
            return contentOffset + clo.encode(
              src[clo.property],
              b2,
              offset3 + contentOffset
            );
          }
          return vlo.encode(src, b2, offset3);
        }
        addVariant(variant, layout, property) {
          const rv = new VariantLayout2(this, variant, layout, property);
          this.registry[variant] = rv;
          return rv;
        }
        getVariant(vb, offset3) {
          let variant = vb;
          if (buffer.Buffer.isBuffer(vb)) {
            if (void 0 === offset3) {
              offset3 = 0;
            }
            variant = this.discriminator.decode(vb, offset3);
          }
          return this.registry[variant];
        }
      };
      VariantLayout2 = class extends Layout2 {
        constructor(union4, variant, layout, property) {
          if (!(union4 instanceof Union2)) {
            throw new TypeError("union must be a Union");
          }
          if (!Number.isInteger(variant) || 0 > variant) {
            throw new TypeError("variant must be a (non-negative) integer");
          }
          if ("string" === typeof layout && void 0 === property) {
            property = layout;
            layout = null;
          }
          if (layout) {
            if (!(layout instanceof Layout2)) {
              throw new TypeError("layout must be a Layout");
            }
            if (null !== union4.defaultLayout && 0 <= layout.span && layout.span > union4.defaultLayout.span) {
              throw new Error("variant span exceeds span of containing union");
            }
            if ("string" !== typeof property) {
              throw new TypeError("variant must have a String property");
            }
          }
          let span = union4.span;
          if (0 > union4.span) {
            span = layout ? layout.span : 0;
            if (0 <= span && union4.usesPrefixDiscriminator) {
              span += union4.discriminator.layout.span;
            }
          }
          super(span, property);
          this.union = union4;
          this.variant = variant;
          this.layout = layout || null;
        }
        getSpan(b2, offset3) {
          if (0 <= this.span) {
            return this.span;
          }
          if (void 0 === offset3) {
            offset3 = 0;
          }
          let contentOffset = 0;
          if (this.union.usesPrefixDiscriminator) {
            contentOffset = this.union.discriminator.layout.span;
          }
          return contentOffset + this.layout.getSpan(b2, offset3 + contentOffset);
        }
        decode(b2, offset3) {
          const dest = this.makeDestinationObject();
          if (void 0 === offset3) {
            offset3 = 0;
          }
          if (this !== this.union.getVariant(b2, offset3)) {
            throw new Error("variant mismatch");
          }
          let contentOffset = 0;
          if (this.union.usesPrefixDiscriminator) {
            contentOffset = this.union.discriminator.layout.span;
          }
          if (this.layout) {
            dest[this.property] = this.layout.decode(b2, offset3 + contentOffset);
          } else if (this.property) {
            dest[this.property] = true;
          } else if (this.union.usesPrefixDiscriminator) {
            dest[this.union.discriminator.property] = this.variant;
          }
          return dest;
        }
        encode(src, b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          let contentOffset = 0;
          if (this.union.usesPrefixDiscriminator) {
            contentOffset = this.union.discriminator.layout.span;
          }
          if (this.layout && !src.hasOwnProperty(this.property)) {
            throw new TypeError("variant lacks property " + this.property);
          }
          this.union.discriminator.encode(this.variant, b2, offset3);
          let span = contentOffset;
          if (this.layout) {
            this.layout.encode(src[this.property], b2, offset3 + contentOffset);
            span += this.layout.getSpan(b2, offset3 + contentOffset);
            if (0 <= this.union.span && span > this.union.span) {
              throw new Error("encoded variant overruns containing union");
            }
          }
          return span;
        }
        fromArray(values) {
          if (this.layout) {
            return this.layout.fromArray(values);
          }
        }
      };
      BitStructure = class extends Layout2 {
        constructor(word, msb, property) {
          if (!(word instanceof UInt2 || word instanceof UIntBE2)) {
            throw new TypeError("word must be a UInt or UIntBE layout");
          }
          if ("string" === typeof msb && void 0 === property) {
            property = msb;
            msb = void 0;
          }
          if (4 < word.span) {
            throw new RangeError("word cannot exceed 32 bits");
          }
          super(word.span, property);
          this.word = word;
          this.msb = !!msb;
          this.fields = [];
          let value = 0;
          this._packedSetValue = function(v2) {
            value = fixBitwiseResult(v2);
            return this;
          };
          this._packedGetValue = function() {
            return value;
          };
        }
        decode(b2, offset3) {
          const dest = this.makeDestinationObject();
          if (void 0 === offset3) {
            offset3 = 0;
          }
          const value = this.word.decode(b2, offset3);
          this._packedSetValue(value);
          for (const fd of this.fields) {
            if (void 0 !== fd.property) {
              dest[fd.property] = fd.decode(value);
            }
          }
          return dest;
        }
        encode(src, b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          const value = this.word.decode(b2, offset3);
          this._packedSetValue(value);
          for (const fd of this.fields) {
            if (void 0 !== fd.property) {
              const fv = src[fd.property];
              if (void 0 !== fv) {
                fd.encode(fv);
              }
            }
          }
          return this.word.encode(this._packedGetValue(), b2, offset3);
        }
        addField(bits, property) {
          const bf = new BitField(this, bits, property);
          this.fields.push(bf);
          return bf;
        }
        addBoolean(property) {
          const bf = new Boolean2(this, property);
          this.fields.push(bf);
          return bf;
        }
        fieldFor(property) {
          if ("string" !== typeof property) {
            throw new TypeError("property must be string");
          }
          for (const fd of this.fields) {
            if (fd.property === property) {
              return fd;
            }
          }
        }
      };
      BitField = class {
        constructor(container, bits, property) {
          if (!(container instanceof BitStructure)) {
            throw new TypeError("container must be a BitStructure");
          }
          if (!Number.isInteger(bits) || 0 >= bits) {
            throw new TypeError("bits must be positive integer");
          }
          const totalBits = 8 * container.span;
          const usedBits = container.fields.reduce((sum, fd) => sum + fd.bits, 0);
          if (bits + usedBits > totalBits) {
            throw new Error("bits too long for span remainder (" + (totalBits - usedBits) + " of " + totalBits + " remain)");
          }
          this.container = container;
          this.bits = bits;
          this.valueMask = (1 << bits) - 1;
          if (32 === bits) {
            this.valueMask = 4294967295;
          }
          this.start = usedBits;
          if (this.container.msb) {
            this.start = totalBits - usedBits - bits;
          }
          this.wordMask = fixBitwiseResult(this.valueMask << this.start);
          this.property = property;
        }
        decode() {
          const word = this.container._packedGetValue();
          const wordValue = fixBitwiseResult(word & this.wordMask);
          const value = wordValue >>> this.start;
          return value;
        }
        encode(value) {
          if (!Number.isInteger(value) || value !== fixBitwiseResult(value & this.valueMask)) {
            throw new TypeError(nameWithProperty2("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
          }
          const word = this.container._packedGetValue();
          const wordValue = fixBitwiseResult(value << this.start);
          this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask) | wordValue);
        }
      };
      Boolean2 = class extends BitField {
        constructor(container, property) {
          super(container, 1, property);
        }
        decode(b2, offset3) {
          return !!BitField.prototype.decode.call(this, b2, offset3);
        }
        encode(value) {
          if ("boolean" === typeof value) {
            value = +value;
          }
          return BitField.prototype.encode.call(this, value);
        }
      };
      Blob2 = class extends Layout2 {
        constructor(length, property) {
          if (!(length instanceof ExternalLayout2 && length.isCount() || Number.isInteger(length) && 0 <= length)) {
            throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
          }
          let span = -1;
          if (!(length instanceof ExternalLayout2)) {
            span = length;
          }
          super(span, property);
          this.length = length;
        }
        getSpan(b2, offset3) {
          let span = this.span;
          if (0 > span) {
            span = this.length.decode(b2, offset3);
          }
          return span;
        }
        decode(b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          let span = this.span;
          if (0 > span) {
            span = this.length.decode(b2, offset3);
          }
          return b2.slice(offset3, offset3 + span);
        }
        encode(src, b2, offset3) {
          let span = this.length;
          if (this.length instanceof ExternalLayout2) {
            span = src.length;
          }
          if (!(buffer.Buffer.isBuffer(src) && span === src.length)) {
            throw new TypeError(nameWithProperty2("Blob.encode", this) + " requires (length " + span + ") Buffer as src");
          }
          if (offset3 + span > b2.length) {
            throw new RangeError("encoding overruns Buffer");
          }
          b2.write(src.toString("hex"), offset3, span, "hex");
          if (this.length instanceof ExternalLayout2) {
            this.length.encode(span, b2, offset3);
          }
          return span;
        }
      };
      CString = class extends Layout2 {
        constructor(property) {
          super(-1, property);
        }
        getSpan(b2, offset3) {
          if (!buffer.Buffer.isBuffer(b2)) {
            throw new TypeError("b must be a Buffer");
          }
          if (void 0 === offset3) {
            offset3 = 0;
          }
          let idx = offset3;
          while (idx < b2.length && 0 !== b2[idx]) {
            idx += 1;
          }
          return 1 + idx - offset3;
        }
        decode(b2, offset3, dest) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          let span = this.getSpan(b2, offset3);
          return b2.slice(offset3, offset3 + span - 1).toString("utf-8");
        }
        encode(src, b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          if ("string" !== typeof src) {
            src = src.toString();
          }
          const srcb = new buffer.Buffer(src, "utf8");
          const span = srcb.length;
          if (offset3 + span > b2.length) {
            throw new RangeError("encoding overruns Buffer");
          }
          srcb.copy(b2, offset3);
          b2[offset3 + span] = 0;
          return span + 1;
        }
      };
      UTF8 = class extends Layout2 {
        constructor(maxSpan, property) {
          if ("string" === typeof maxSpan && void 0 === property) {
            property = maxSpan;
            maxSpan = void 0;
          }
          if (void 0 === maxSpan) {
            maxSpan = -1;
          } else if (!Number.isInteger(maxSpan)) {
            throw new TypeError("maxSpan must be an integer");
          }
          super(-1, property);
          this.maxSpan = maxSpan;
        }
        getSpan(b2, offset3) {
          if (!buffer.Buffer.isBuffer(b2)) {
            throw new TypeError("b must be a Buffer");
          }
          if (void 0 === offset3) {
            offset3 = 0;
          }
          return b2.length - offset3;
        }
        decode(b2, offset3, dest) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          let span = this.getSpan(b2, offset3);
          if (0 <= this.maxSpan && this.maxSpan < span) {
            throw new RangeError("text length exceeds maxSpan");
          }
          return b2.slice(offset3, offset3 + span).toString("utf-8");
        }
        encode(src, b2, offset3) {
          if (void 0 === offset3) {
            offset3 = 0;
          }
          if ("string" !== typeof src) {
            src = src.toString();
          }
          const srcb = new buffer.Buffer(src, "utf8");
          const span = srcb.length;
          if (0 <= this.maxSpan && this.maxSpan < span) {
            throw new RangeError("text length exceeds maxSpan");
          }
          if (offset3 + span > b2.length) {
            throw new RangeError("encoding overruns Buffer");
          }
          srcb.copy(b2, offset3);
          return span;
        }
      };
      Constant = class extends Layout2 {
        constructor(value, property) {
          super(0, property);
          this.value = value;
        }
        decode(b2, offset3, dest) {
          return this.value;
        }
        encode(src, b2, offset3) {
          return 0;
        }
      };
      Layout$1.ExternalLayout = ExternalLayout2;
      Layout$1.GreedyCount = GreedyCount;
      Layout$1.OffsetLayout = OffsetLayout2;
      Layout$1.UInt = UInt2;
      Layout$1.UIntBE = UIntBE2;
      Layout$1.Int = Int;
      Layout$1.IntBE = IntBE;
      Layout$1.Float = Float;
      Layout$1.FloatBE = FloatBE;
      Layout$1.Double = Double;
      Layout$1.DoubleBE = DoubleBE;
      Layout$1.Sequence = Sequence;
      Layout$1.Structure = Structure2;
      Layout$1.UnionDiscriminator = UnionDiscriminator2;
      Layout$1.UnionLayoutDiscriminator = UnionLayoutDiscriminator2;
      Layout$1.Union = Union2;
      Layout$1.VariantLayout = VariantLayout2;
      Layout$1.BitStructure = BitStructure;
      Layout$1.BitField = BitField;
      Layout$1.Boolean = Boolean2;
      Layout$1.Blob = Blob2;
      Layout$1.CString = CString;
      Layout$1.UTF8 = UTF8;
      Layout$1.Constant = Constant;
      Layout$1.greedy = (elementSpan, property) => new GreedyCount(elementSpan, property);
      Layout$1.offset = (layout, offset3, property) => new OffsetLayout2(layout, offset3, property);
      u85 = Layout$1.u8 = (property) => new UInt2(1, property);
      Layout$1.u16 = (property) => new UInt2(2, property);
      Layout$1.u24 = (property) => new UInt2(3, property);
      u326 = Layout$1.u32 = (property) => new UInt2(4, property);
      Layout$1.u40 = (property) => new UInt2(5, property);
      Layout$1.u48 = (property) => new UInt2(6, property);
      Layout$1.nu64 = (property) => new NearUInt642(property);
      Layout$1.u16be = (property) => new UIntBE2(2, property);
      Layout$1.u24be = (property) => new UIntBE2(3, property);
      Layout$1.u32be = (property) => new UIntBE2(4, property);
      Layout$1.u40be = (property) => new UIntBE2(5, property);
      Layout$1.u48be = (property) => new UIntBE2(6, property);
      Layout$1.nu64be = (property) => new NearUInt64BE(property);
      Layout$1.s8 = (property) => new Int(1, property);
      Layout$1.s16 = (property) => new Int(2, property);
      Layout$1.s24 = (property) => new Int(3, property);
      Layout$1.s32 = (property) => new Int(4, property);
      Layout$1.s40 = (property) => new Int(5, property);
      Layout$1.s48 = (property) => new Int(6, property);
      Layout$1.ns64 = (property) => new NearInt642(property);
      Layout$1.s16be = (property) => new IntBE(2, property);
      Layout$1.s24be = (property) => new IntBE(3, property);
      Layout$1.s32be = (property) => new IntBE(4, property);
      Layout$1.s40be = (property) => new IntBE(5, property);
      Layout$1.s48be = (property) => new IntBE(6, property);
      Layout$1.ns64be = (property) => new NearInt64BE(property);
      Layout$1.f32 = (property) => new Float(property);
      Layout$1.f32be = (property) => new FloatBE(property);
      Layout$1.f64 = (property) => new Double(property);
      Layout$1.f64be = (property) => new DoubleBE(property);
      struct5 = Layout$1.struct = (fields, property, decodePrefixes) => new Structure2(fields, property, decodePrefixes);
      Layout$1.bits = (word, msb, property) => new BitStructure(word, msb, property);
      Layout$1.seq = (elementLayout, count, property) => new Sequence(elementLayout, count, property);
      Layout$1.union = (discr, defaultLayout, property) => new Union2(discr, defaultLayout, property);
      Layout$1.unionLayoutDiscriminator = (layout, property) => new UnionLayoutDiscriminator2(layout, property);
      blob4 = Layout$1.blob = (length, property) => new Blob2(length, property);
      Layout$1.cstr = (property) => new CString(property);
      Layout$1.utf8 = (maxSpan, property) => new UTF8(maxSpan, property);
      Layout$1.const = (value, property) => new Constant(value, property);
      publicKey5 = (property = "publicKey") => {
        return blob4(32, property);
      };
      uint642 = (property = "uint64") => {
        return blob4(8, property);
      };
      TOKEN_PROGRAM_ID2 = new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
      ASSOCIATED_TOKEN_PROGRAM_ID = new PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
      FAILED_TO_FIND_ACCOUNT = "Failed to find account";
      INVALID_ACCOUNT_OWNER = "Invalid account owner";
      u646 = class extends import_bn6.default {
        toBuffer() {
          const a = super.toArray().reverse();
          const b2 = buffer.Buffer.from(a);
          if (b2.length === 8) {
            return b2;
          }
          assert6(b2.length < 8, "u64 too large");
          const zeroPad = buffer.Buffer.alloc(8);
          b2.copy(zeroPad);
          return zeroPad;
        }
        static fromBuffer(buffer2) {
          assert6(buffer2.length === 8, `Invalid buffer length: ${buffer2.length}`);
          return new u646([...buffer2].reverse().map((i) => `00${i.toString(16)}`.slice(-2)).join(""), 16);
        }
      };
      AuthorityTypeCodes = {
        MintTokens: 0,
        FreezeAccount: 1,
        AccountOwner: 2,
        CloseAccount: 3
      };
      NATIVE_MINT = new PublicKey("So11111111111111111111111111111111111111112");
      MintLayout = struct5([u326("mintAuthorityOption"), publicKey5("mintAuthority"), uint642("supply"), u85("decimals"), u85("isInitialized"), u326("freezeAuthorityOption"), publicKey5("freezeAuthority")]);
      AccountLayout = struct5([publicKey5("mint"), publicKey5("owner"), uint642("amount"), u326("delegateOption"), publicKey5("delegate"), u85("state"), u326("isNativeOption"), uint642("isNative"), uint642("delegatedAmount"), u326("closeAuthorityOption"), publicKey5("closeAuthority")]);
      MultisigLayout = struct5([u85("m"), u85("n"), u85("is_initialized"), publicKey5("signer1"), publicKey5("signer2"), publicKey5("signer3"), publicKey5("signer4"), publicKey5("signer5"), publicKey5("signer6"), publicKey5("signer7"), publicKey5("signer8"), publicKey5("signer9"), publicKey5("signer10"), publicKey5("signer11")]);
      Token = class {
        constructor(connection, publicKey6, programId, payer) {
          _defineProperty(this, "connection", void 0);
          _defineProperty(this, "publicKey", void 0);
          _defineProperty(this, "programId", void 0);
          _defineProperty(this, "associatedProgramId", void 0);
          _defineProperty(this, "payer", void 0);
          Object.assign(this, {
            connection,
            publicKey: publicKey6,
            programId,
            payer,
            associatedProgramId: ASSOCIATED_TOKEN_PROGRAM_ID
          });
        }
        static async getMinBalanceRentForExemptMint(connection) {
          return await connection.getMinimumBalanceForRentExemption(MintLayout.span);
        }
        static async getMinBalanceRentForExemptAccount(connection) {
          return await connection.getMinimumBalanceForRentExemption(AccountLayout.span);
        }
        static async getMinBalanceRentForExemptMultisig(connection) {
          return await connection.getMinimumBalanceForRentExemption(MultisigLayout.span);
        }
        static async createMint(connection, payer, mintAuthority, freezeAuthority, decimals, programId) {
          const mintAccount = Keypair.generate();
          const token = new Token(connection, mintAccount.publicKey, programId, payer);
          const balanceNeeded = await Token.getMinBalanceRentForExemptMint(connection);
          const transaction = new Transaction();
          transaction.add(SystemProgram.createAccount({
            fromPubkey: payer.publicKey,
            newAccountPubkey: mintAccount.publicKey,
            lamports: balanceNeeded,
            space: MintLayout.span,
            programId
          }));
          transaction.add(Token.createInitMintInstruction(programId, mintAccount.publicKey, decimals, mintAuthority, freezeAuthority));
          await sendAndConfirmTransaction2("createAccount and InitializeMint", connection, transaction, payer, mintAccount);
          return token;
        }
        async createAccount(owner) {
          const balanceNeeded = await Token.getMinBalanceRentForExemptAccount(this.connection);
          const newAccount = Keypair.generate();
          const transaction = new Transaction();
          transaction.add(SystemProgram.createAccount({
            fromPubkey: this.payer.publicKey,
            newAccountPubkey: newAccount.publicKey,
            lamports: balanceNeeded,
            space: AccountLayout.span,
            programId: this.programId
          }));
          const mintPublicKey = this.publicKey;
          transaction.add(Token.createInitAccountInstruction(this.programId, mintPublicKey, newAccount.publicKey, owner));
          await sendAndConfirmTransaction2("createAccount and InitializeAccount", this.connection, transaction, this.payer, newAccount);
          return newAccount.publicKey;
        }
        async createAssociatedTokenAccount(owner) {
          const associatedAddress = await Token.getAssociatedTokenAddress(this.associatedProgramId, this.programId, this.publicKey, owner);
          return this.createAssociatedTokenAccountInternal(owner, associatedAddress);
        }
        async createAssociatedTokenAccountInternal(owner, associatedAddress) {
          await sendAndConfirmTransaction2("CreateAssociatedTokenAccount", this.connection, new Transaction().add(Token.createAssociatedTokenAccountInstruction(this.associatedProgramId, this.programId, this.publicKey, associatedAddress, owner, this.payer.publicKey)), this.payer);
          return associatedAddress;
        }
        async getOrCreateAssociatedAccountInfo(owner) {
          const associatedAddress = await Token.getAssociatedTokenAddress(this.associatedProgramId, this.programId, this.publicKey, owner);
          try {
            return await this.getAccountInfo(associatedAddress);
          } catch (err2) {
            if (err2.message === FAILED_TO_FIND_ACCOUNT || err2.message === INVALID_ACCOUNT_OWNER) {
              try {
                await this.createAssociatedTokenAccountInternal(owner, associatedAddress);
              } catch (err3) {
              }
              return await this.getAccountInfo(associatedAddress);
            } else {
              throw err2;
            }
          }
        }
        static async createWrappedNativeAccount(connection, programId, owner, payer, amount) {
          const balanceNeeded = await Token.getMinBalanceRentForExemptAccount(connection);
          const newAccount = Keypair.generate();
          const transaction = new Transaction();
          transaction.add(SystemProgram.createAccount({
            fromPubkey: payer.publicKey,
            newAccountPubkey: newAccount.publicKey,
            lamports: balanceNeeded,
            space: AccountLayout.span,
            programId
          }));
          transaction.add(SystemProgram.transfer({
            fromPubkey: payer.publicKey,
            toPubkey: newAccount.publicKey,
            lamports: amount
          }));
          transaction.add(Token.createInitAccountInstruction(programId, NATIVE_MINT, newAccount.publicKey, owner));
          await sendAndConfirmTransaction2("createAccount, transfer, and initializeAccount", connection, transaction, payer, newAccount);
          return newAccount.publicKey;
        }
        async createMultisig(m, signers) {
          const multisigAccount = Keypair.generate();
          const balanceNeeded = await Token.getMinBalanceRentForExemptMultisig(this.connection);
          const transaction = new Transaction();
          transaction.add(SystemProgram.createAccount({
            fromPubkey: this.payer.publicKey,
            newAccountPubkey: multisigAccount.publicKey,
            lamports: balanceNeeded,
            space: MultisigLayout.span,
            programId: this.programId
          }));
          let keys = [{
            pubkey: multisigAccount.publicKey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false
          }];
          signers.forEach((signer) => keys.push({
            pubkey: signer,
            isSigner: false,
            isWritable: false
          }));
          const dataLayout = struct5([u85("instruction"), u85("m")]);
          const data = buffer.Buffer.alloc(dataLayout.span);
          dataLayout.encode({
            instruction: 2,
            m
          }, data);
          transaction.add({
            keys,
            programId: this.programId,
            data
          });
          await sendAndConfirmTransaction2("createAccount and InitializeMultisig", this.connection, transaction, this.payer, multisigAccount);
          return multisigAccount.publicKey;
        }
        async getMintInfo() {
          const info = await this.connection.getAccountInfo(this.publicKey);
          if (info === null) {
            throw new Error("Failed to find mint account");
          }
          if (!info.owner.equals(this.programId)) {
            throw new Error(`Invalid mint owner: ${JSON.stringify(info.owner)}`);
          }
          if (info.data.length != MintLayout.span) {
            throw new Error(`Invalid mint size`);
          }
          const data = buffer.Buffer.from(info.data);
          const mintInfo = MintLayout.decode(data);
          if (mintInfo.mintAuthorityOption === 0) {
            mintInfo.mintAuthority = null;
          } else {
            mintInfo.mintAuthority = new PublicKey(mintInfo.mintAuthority);
          }
          mintInfo.supply = u646.fromBuffer(mintInfo.supply);
          mintInfo.isInitialized = mintInfo.isInitialized != 0;
          if (mintInfo.freezeAuthorityOption === 0) {
            mintInfo.freezeAuthority = null;
          } else {
            mintInfo.freezeAuthority = new PublicKey(mintInfo.freezeAuthority);
          }
          return mintInfo;
        }
        async getAccountInfo(account, commitment) {
          const info = await this.connection.getAccountInfo(account, commitment);
          if (info === null) {
            throw new Error(FAILED_TO_FIND_ACCOUNT);
          }
          if (!info.owner.equals(this.programId)) {
            throw new Error(INVALID_ACCOUNT_OWNER);
          }
          if (info.data.length != AccountLayout.span) {
            throw new Error(`Invalid account size`);
          }
          const data = buffer.Buffer.from(info.data);
          const accountInfo = AccountLayout.decode(data);
          accountInfo.address = account;
          accountInfo.mint = new PublicKey(accountInfo.mint);
          accountInfo.owner = new PublicKey(accountInfo.owner);
          accountInfo.amount = u646.fromBuffer(accountInfo.amount);
          if (accountInfo.delegateOption === 0) {
            accountInfo.delegate = null;
            accountInfo.delegatedAmount = new u646();
          } else {
            accountInfo.delegate = new PublicKey(accountInfo.delegate);
            accountInfo.delegatedAmount = u646.fromBuffer(accountInfo.delegatedAmount);
          }
          accountInfo.isInitialized = accountInfo.state !== 0;
          accountInfo.isFrozen = accountInfo.state === 2;
          if (accountInfo.isNativeOption === 1) {
            accountInfo.rentExemptReserve = u646.fromBuffer(accountInfo.isNative);
            accountInfo.isNative = true;
          } else {
            accountInfo.rentExemptReserve = null;
            accountInfo.isNative = false;
          }
          if (accountInfo.closeAuthorityOption === 0) {
            accountInfo.closeAuthority = null;
          } else {
            accountInfo.closeAuthority = new PublicKey(accountInfo.closeAuthority);
          }
          if (!accountInfo.mint.equals(this.publicKey)) {
            throw new Error(`Invalid account mint: ${JSON.stringify(accountInfo.mint)} !== ${JSON.stringify(this.publicKey)}`);
          }
          return accountInfo;
        }
        async getMultisigInfo(multisig) {
          const info = await this.connection.getAccountInfo(multisig);
          if (info === null) {
            throw new Error("Failed to find multisig");
          }
          if (!info.owner.equals(this.programId)) {
            throw new Error(`Invalid multisig owner`);
          }
          if (info.data.length != MultisigLayout.span) {
            throw new Error(`Invalid multisig size`);
          }
          const data = buffer.Buffer.from(info.data);
          const multisigInfo = MultisigLayout.decode(data);
          multisigInfo.signer1 = new PublicKey(multisigInfo.signer1);
          multisigInfo.signer2 = new PublicKey(multisigInfo.signer2);
          multisigInfo.signer3 = new PublicKey(multisigInfo.signer3);
          multisigInfo.signer4 = new PublicKey(multisigInfo.signer4);
          multisigInfo.signer5 = new PublicKey(multisigInfo.signer5);
          multisigInfo.signer6 = new PublicKey(multisigInfo.signer6);
          multisigInfo.signer7 = new PublicKey(multisigInfo.signer7);
          multisigInfo.signer8 = new PublicKey(multisigInfo.signer8);
          multisigInfo.signer9 = new PublicKey(multisigInfo.signer9);
          multisigInfo.signer10 = new PublicKey(multisigInfo.signer10);
          multisigInfo.signer11 = new PublicKey(multisigInfo.signer11);
          return multisigInfo;
        }
        async transfer(source, destination, owner, multiSigners, amount) {
          let ownerPublicKey;
          let signers;
          if (isAccount(owner)) {
            ownerPublicKey = owner.publicKey;
            signers = [owner];
          } else {
            ownerPublicKey = owner;
            signers = multiSigners;
          }
          return await sendAndConfirmTransaction2("Transfer", this.connection, new Transaction().add(Token.createTransferInstruction(this.programId, source, destination, ownerPublicKey, multiSigners, amount)), this.payer, ...signers);
        }
        async approve(account, delegate, owner, multiSigners, amount) {
          let ownerPublicKey;
          let signers;
          if (isAccount(owner)) {
            ownerPublicKey = owner.publicKey;
            signers = [owner];
          } else {
            ownerPublicKey = owner;
            signers = multiSigners;
          }
          await sendAndConfirmTransaction2("Approve", this.connection, new Transaction().add(Token.createApproveInstruction(this.programId, account, delegate, ownerPublicKey, multiSigners, amount)), this.payer, ...signers);
        }
        async revoke(account, owner, multiSigners) {
          let ownerPublicKey;
          let signers;
          if (isAccount(owner)) {
            ownerPublicKey = owner.publicKey;
            signers = [owner];
          } else {
            ownerPublicKey = owner;
            signers = multiSigners;
          }
          await sendAndConfirmTransaction2("Revoke", this.connection, new Transaction().add(Token.createRevokeInstruction(this.programId, account, ownerPublicKey, multiSigners)), this.payer, ...signers);
        }
        async setAuthority(account, newAuthority, authorityType, currentAuthority, multiSigners) {
          let currentAuthorityPublicKey;
          let signers;
          if (isAccount(currentAuthority)) {
            currentAuthorityPublicKey = currentAuthority.publicKey;
            signers = [currentAuthority];
          } else {
            currentAuthorityPublicKey = currentAuthority;
            signers = multiSigners;
          }
          await sendAndConfirmTransaction2("SetAuthority", this.connection, new Transaction().add(Token.createSetAuthorityInstruction(this.programId, account, newAuthority, authorityType, currentAuthorityPublicKey, multiSigners)), this.payer, ...signers);
        }
        async mintTo(dest, authority, multiSigners, amount) {
          let ownerPublicKey;
          let signers;
          if (isAccount(authority)) {
            ownerPublicKey = authority.publicKey;
            signers = [authority];
          } else {
            ownerPublicKey = authority;
            signers = multiSigners;
          }
          await sendAndConfirmTransaction2("MintTo", this.connection, new Transaction().add(Token.createMintToInstruction(this.programId, this.publicKey, dest, ownerPublicKey, multiSigners, amount)), this.payer, ...signers);
        }
        async burn(account, owner, multiSigners, amount) {
          let ownerPublicKey;
          let signers;
          if (isAccount(owner)) {
            ownerPublicKey = owner.publicKey;
            signers = [owner];
          } else {
            ownerPublicKey = owner;
            signers = multiSigners;
          }
          await sendAndConfirmTransaction2("Burn", this.connection, new Transaction().add(Token.createBurnInstruction(this.programId, this.publicKey, account, ownerPublicKey, multiSigners, amount)), this.payer, ...signers);
        }
        async closeAccount(account, dest, authority, multiSigners) {
          let authorityPublicKey;
          let signers;
          if (isAccount(authority)) {
            authorityPublicKey = authority.publicKey;
            signers = [authority];
          } else {
            authorityPublicKey = authority;
            signers = multiSigners;
          }
          await sendAndConfirmTransaction2("CloseAccount", this.connection, new Transaction().add(Token.createCloseAccountInstruction(this.programId, account, dest, authorityPublicKey, multiSigners)), this.payer, ...signers);
        }
        async freezeAccount(account, authority, multiSigners) {
          let authorityPublicKey;
          let signers;
          if (isAccount(authority)) {
            authorityPublicKey = authority.publicKey;
            signers = [authority];
          } else {
            authorityPublicKey = authority;
            signers = multiSigners;
          }
          await sendAndConfirmTransaction2("FreezeAccount", this.connection, new Transaction().add(Token.createFreezeAccountInstruction(this.programId, account, this.publicKey, authorityPublicKey, multiSigners)), this.payer, ...signers);
        }
        async thawAccount(account, authority, multiSigners) {
          let authorityPublicKey;
          let signers;
          if (isAccount(authority)) {
            authorityPublicKey = authority.publicKey;
            signers = [authority];
          } else {
            authorityPublicKey = authority;
            signers = multiSigners;
          }
          await sendAndConfirmTransaction2("ThawAccount", this.connection, new Transaction().add(Token.createThawAccountInstruction(this.programId, account, this.publicKey, authorityPublicKey, multiSigners)), this.payer, ...signers);
        }
        async transferChecked(source, destination, owner, multiSigners, amount, decimals) {
          let ownerPublicKey;
          let signers;
          if (isAccount(owner)) {
            ownerPublicKey = owner.publicKey;
            signers = [owner];
          } else {
            ownerPublicKey = owner;
            signers = multiSigners;
          }
          return await sendAndConfirmTransaction2("TransferChecked", this.connection, new Transaction().add(Token.createTransferCheckedInstruction(this.programId, source, this.publicKey, destination, ownerPublicKey, multiSigners, amount, decimals)), this.payer, ...signers);
        }
        async approveChecked(account, delegate, owner, multiSigners, amount, decimals) {
          let ownerPublicKey;
          let signers;
          if (isAccount(owner)) {
            ownerPublicKey = owner.publicKey;
            signers = [owner];
          } else {
            ownerPublicKey = owner;
            signers = multiSigners;
          }
          await sendAndConfirmTransaction2("ApproveChecked", this.connection, new Transaction().add(Token.createApproveCheckedInstruction(this.programId, account, this.publicKey, delegate, ownerPublicKey, multiSigners, amount, decimals)), this.payer, ...signers);
        }
        async mintToChecked(dest, authority, multiSigners, amount, decimals) {
          let ownerPublicKey;
          let signers;
          if (isAccount(authority)) {
            ownerPublicKey = authority.publicKey;
            signers = [authority];
          } else {
            ownerPublicKey = authority;
            signers = multiSigners;
          }
          await sendAndConfirmTransaction2("MintToChecked", this.connection, new Transaction().add(Token.createMintToCheckedInstruction(this.programId, this.publicKey, dest, ownerPublicKey, multiSigners, amount, decimals)), this.payer, ...signers);
        }
        async burnChecked(account, owner, multiSigners, amount, decimals) {
          let ownerPublicKey;
          let signers;
          if (isAccount(owner)) {
            ownerPublicKey = owner.publicKey;
            signers = [owner];
          } else {
            ownerPublicKey = owner;
            signers = multiSigners;
          }
          await sendAndConfirmTransaction2("BurnChecked", this.connection, new Transaction().add(Token.createBurnCheckedInstruction(this.programId, this.publicKey, account, ownerPublicKey, multiSigners, amount, decimals)), this.payer, ...signers);
        }
        async syncNative(nativeAccount) {
          await sendAndConfirmTransaction2("SyncNative", this.connection, new Transaction().add(Token.createSyncNativeInstruction(this.programId, nativeAccount)), this.payer);
        }
        static createInitMintInstruction(programId, mint, decimals, mintAuthority, freezeAuthority) {
          let keys = [{
            pubkey: mint,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false
          }];
          const commandDataLayout = struct5([u85("instruction"), u85("decimals"), publicKey5("mintAuthority"), u85("option"), publicKey5("freezeAuthority")]);
          let data = buffer.Buffer.alloc(1024);
          {
            const encodeLength2 = commandDataLayout.encode({
              instruction: 0,
              decimals,
              mintAuthority: pubkeyToBuffer(mintAuthority),
              option: freezeAuthority === null ? 0 : 1,
              freezeAuthority: pubkeyToBuffer(freezeAuthority || new PublicKey(0))
            }, data);
            data = data.slice(0, encodeLength2);
          }
          return new TransactionInstruction({
            keys,
            programId,
            data
          });
        }
        static createInitAccountInstruction(programId, mint, account, owner) {
          const keys = [{
            pubkey: account,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: mint,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: owner,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false
          }];
          const dataLayout = struct5([u85("instruction")]);
          const data = buffer.Buffer.alloc(dataLayout.span);
          dataLayout.encode({
            instruction: 1
          }, data);
          return new TransactionInstruction({
            keys,
            programId,
            data
          });
        }
        static createTransferInstruction(programId, source, destination, owner, multiSigners, amount) {
          const dataLayout = struct5([u85("instruction"), uint642("amount")]);
          const data = buffer.Buffer.alloc(dataLayout.span);
          dataLayout.encode({
            instruction: 3,
            amount: new u646(amount).toBuffer()
          }, data);
          let keys = [{
            pubkey: source,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: destination,
            isSigner: false,
            isWritable: true
          }];
          if (multiSigners.length === 0) {
            keys.push({
              pubkey: owner,
              isSigner: true,
              isWritable: false
            });
          } else {
            keys.push({
              pubkey: owner,
              isSigner: false,
              isWritable: false
            });
            multiSigners.forEach((signer) => keys.push({
              pubkey: signer.publicKey,
              isSigner: true,
              isWritable: false
            }));
          }
          return new TransactionInstruction({
            keys,
            programId,
            data
          });
        }
        static createApproveInstruction(programId, account, delegate, owner, multiSigners, amount) {
          const dataLayout = struct5([u85("instruction"), uint642("amount")]);
          const data = buffer.Buffer.alloc(dataLayout.span);
          dataLayout.encode({
            instruction: 4,
            amount: new u646(amount).toBuffer()
          }, data);
          let keys = [{
            pubkey: account,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: delegate,
            isSigner: false,
            isWritable: false
          }];
          if (multiSigners.length === 0) {
            keys.push({
              pubkey: owner,
              isSigner: true,
              isWritable: false
            });
          } else {
            keys.push({
              pubkey: owner,
              isSigner: false,
              isWritable: false
            });
            multiSigners.forEach((signer) => keys.push({
              pubkey: signer.publicKey,
              isSigner: true,
              isWritable: false
            }));
          }
          return new TransactionInstruction({
            keys,
            programId,
            data
          });
        }
        static createRevokeInstruction(programId, account, owner, multiSigners) {
          const dataLayout = struct5([u85("instruction")]);
          const data = buffer.Buffer.alloc(dataLayout.span);
          dataLayout.encode({
            instruction: 5
          }, data);
          let keys = [{
            pubkey: account,
            isSigner: false,
            isWritable: true
          }];
          if (multiSigners.length === 0) {
            keys.push({
              pubkey: owner,
              isSigner: true,
              isWritable: false
            });
          } else {
            keys.push({
              pubkey: owner,
              isSigner: false,
              isWritable: false
            });
            multiSigners.forEach((signer) => keys.push({
              pubkey: signer.publicKey,
              isSigner: true,
              isWritable: false
            }));
          }
          return new TransactionInstruction({
            keys,
            programId,
            data
          });
        }
        static createSetAuthorityInstruction(programId, account, newAuthority, authorityType, currentAuthority, multiSigners) {
          const commandDataLayout = struct5([u85("instruction"), u85("authorityType"), u85("option"), publicKey5("newAuthority")]);
          let data = buffer.Buffer.alloc(1024);
          {
            const encodeLength2 = commandDataLayout.encode({
              instruction: 6,
              authorityType: AuthorityTypeCodes[authorityType],
              option: newAuthority === null ? 0 : 1,
              newAuthority: pubkeyToBuffer(newAuthority || new PublicKey(0))
            }, data);
            data = data.slice(0, encodeLength2);
          }
          let keys = [{
            pubkey: account,
            isSigner: false,
            isWritable: true
          }];
          if (multiSigners.length === 0) {
            keys.push({
              pubkey: currentAuthority,
              isSigner: true,
              isWritable: false
            });
          } else {
            keys.push({
              pubkey: currentAuthority,
              isSigner: false,
              isWritable: false
            });
            multiSigners.forEach((signer) => keys.push({
              pubkey: signer.publicKey,
              isSigner: true,
              isWritable: false
            }));
          }
          return new TransactionInstruction({
            keys,
            programId,
            data
          });
        }
        static createMintToInstruction(programId, mint, dest, authority, multiSigners, amount) {
          const dataLayout = struct5([u85("instruction"), uint642("amount")]);
          const data = buffer.Buffer.alloc(dataLayout.span);
          dataLayout.encode({
            instruction: 7,
            amount: new u646(amount).toBuffer()
          }, data);
          let keys = [{
            pubkey: mint,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: dest,
            isSigner: false,
            isWritable: true
          }];
          if (multiSigners.length === 0) {
            keys.push({
              pubkey: authority,
              isSigner: true,
              isWritable: false
            });
          } else {
            keys.push({
              pubkey: authority,
              isSigner: false,
              isWritable: false
            });
            multiSigners.forEach((signer) => keys.push({
              pubkey: signer.publicKey,
              isSigner: true,
              isWritable: false
            }));
          }
          return new TransactionInstruction({
            keys,
            programId,
            data
          });
        }
        static createBurnInstruction(programId, mint, account, owner, multiSigners, amount) {
          const dataLayout = struct5([u85("instruction"), uint642("amount")]);
          const data = buffer.Buffer.alloc(dataLayout.span);
          dataLayout.encode({
            instruction: 8,
            amount: new u646(amount).toBuffer()
          }, data);
          let keys = [{
            pubkey: account,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: mint,
            isSigner: false,
            isWritable: true
          }];
          if (multiSigners.length === 0) {
            keys.push({
              pubkey: owner,
              isSigner: true,
              isWritable: false
            });
          } else {
            keys.push({
              pubkey: owner,
              isSigner: false,
              isWritable: false
            });
            multiSigners.forEach((signer) => keys.push({
              pubkey: signer.publicKey,
              isSigner: true,
              isWritable: false
            }));
          }
          return new TransactionInstruction({
            keys,
            programId,
            data
          });
        }
        static createCloseAccountInstruction(programId, account, dest, owner, multiSigners) {
          const dataLayout = struct5([u85("instruction")]);
          const data = buffer.Buffer.alloc(dataLayout.span);
          dataLayout.encode({
            instruction: 9
          }, data);
          let keys = [{
            pubkey: account,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: dest,
            isSigner: false,
            isWritable: true
          }];
          if (multiSigners.length === 0) {
            keys.push({
              pubkey: owner,
              isSigner: true,
              isWritable: false
            });
          } else {
            keys.push({
              pubkey: owner,
              isSigner: false,
              isWritable: false
            });
            multiSigners.forEach((signer) => keys.push({
              pubkey: signer.publicKey,
              isSigner: true,
              isWritable: false
            }));
          }
          return new TransactionInstruction({
            keys,
            programId,
            data
          });
        }
        static createFreezeAccountInstruction(programId, account, mint, authority, multiSigners) {
          const dataLayout = struct5([u85("instruction")]);
          const data = buffer.Buffer.alloc(dataLayout.span);
          dataLayout.encode({
            instruction: 10
          }, data);
          let keys = [{
            pubkey: account,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: mint,
            isSigner: false,
            isWritable: false
          }];
          if (multiSigners.length === 0) {
            keys.push({
              pubkey: authority,
              isSigner: true,
              isWritable: false
            });
          } else {
            keys.push({
              pubkey: authority,
              isSigner: false,
              isWritable: false
            });
            multiSigners.forEach((signer) => keys.push({
              pubkey: signer.publicKey,
              isSigner: true,
              isWritable: false
            }));
          }
          return new TransactionInstruction({
            keys,
            programId,
            data
          });
        }
        static createThawAccountInstruction(programId, account, mint, authority, multiSigners) {
          const dataLayout = struct5([u85("instruction")]);
          const data = buffer.Buffer.alloc(dataLayout.span);
          dataLayout.encode({
            instruction: 11
          }, data);
          let keys = [{
            pubkey: account,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: mint,
            isSigner: false,
            isWritable: false
          }];
          if (multiSigners.length === 0) {
            keys.push({
              pubkey: authority,
              isSigner: true,
              isWritable: false
            });
          } else {
            keys.push({
              pubkey: authority,
              isSigner: false,
              isWritable: false
            });
            multiSigners.forEach((signer) => keys.push({
              pubkey: signer.publicKey,
              isSigner: true,
              isWritable: false
            }));
          }
          return new TransactionInstruction({
            keys,
            programId,
            data
          });
        }
        static createTransferCheckedInstruction(programId, source, mint, destination, owner, multiSigners, amount, decimals) {
          const dataLayout = struct5([u85("instruction"), uint642("amount"), u85("decimals")]);
          const data = buffer.Buffer.alloc(dataLayout.span);
          dataLayout.encode({
            instruction: 12,
            amount: new u646(amount).toBuffer(),
            decimals
          }, data);
          let keys = [{
            pubkey: source,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: mint,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: destination,
            isSigner: false,
            isWritable: true
          }];
          if (multiSigners.length === 0) {
            keys.push({
              pubkey: owner,
              isSigner: true,
              isWritable: false
            });
          } else {
            keys.push({
              pubkey: owner,
              isSigner: false,
              isWritable: false
            });
            multiSigners.forEach((signer) => keys.push({
              pubkey: signer.publicKey,
              isSigner: true,
              isWritable: false
            }));
          }
          return new TransactionInstruction({
            keys,
            programId,
            data
          });
        }
        static createApproveCheckedInstruction(programId, account, mint, delegate, owner, multiSigners, amount, decimals) {
          const dataLayout = struct5([u85("instruction"), uint642("amount"), u85("decimals")]);
          const data = buffer.Buffer.alloc(dataLayout.span);
          dataLayout.encode({
            instruction: 13,
            amount: new u646(amount).toBuffer(),
            decimals
          }, data);
          let keys = [{
            pubkey: account,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: mint,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: delegate,
            isSigner: false,
            isWritable: false
          }];
          if (multiSigners.length === 0) {
            keys.push({
              pubkey: owner,
              isSigner: true,
              isWritable: false
            });
          } else {
            keys.push({
              pubkey: owner,
              isSigner: false,
              isWritable: false
            });
            multiSigners.forEach((signer) => keys.push({
              pubkey: signer.publicKey,
              isSigner: true,
              isWritable: false
            }));
          }
          return new TransactionInstruction({
            keys,
            programId,
            data
          });
        }
        static createMintToCheckedInstruction(programId, mint, dest, authority, multiSigners, amount, decimals) {
          const dataLayout = struct5([u85("instruction"), uint642("amount"), u85("decimals")]);
          const data = buffer.Buffer.alloc(dataLayout.span);
          dataLayout.encode({
            instruction: 14,
            amount: new u646(amount).toBuffer(),
            decimals
          }, data);
          let keys = [{
            pubkey: mint,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: dest,
            isSigner: false,
            isWritable: true
          }];
          if (multiSigners.length === 0) {
            keys.push({
              pubkey: authority,
              isSigner: true,
              isWritable: false
            });
          } else {
            keys.push({
              pubkey: authority,
              isSigner: false,
              isWritable: false
            });
            multiSigners.forEach((signer) => keys.push({
              pubkey: signer.publicKey,
              isSigner: true,
              isWritable: false
            }));
          }
          return new TransactionInstruction({
            keys,
            programId,
            data
          });
        }
        static createBurnCheckedInstruction(programId, mint, account, owner, multiSigners, amount, decimals) {
          const dataLayout = struct5([u85("instruction"), uint642("amount"), u85("decimals")]);
          const data = buffer.Buffer.alloc(dataLayout.span);
          dataLayout.encode({
            instruction: 15,
            amount: new u646(amount).toBuffer(),
            decimals
          }, data);
          let keys = [{
            pubkey: account,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: mint,
            isSigner: false,
            isWritable: true
          }];
          if (multiSigners.length === 0) {
            keys.push({
              pubkey: owner,
              isSigner: true,
              isWritable: false
            });
          } else {
            keys.push({
              pubkey: owner,
              isSigner: false,
              isWritable: false
            });
            multiSigners.forEach((signer) => keys.push({
              pubkey: signer.publicKey,
              isSigner: true,
              isWritable: false
            }));
          }
          return new TransactionInstruction({
            keys,
            programId,
            data
          });
        }
        static createSyncNativeInstruction(programId, nativeAccount) {
          const dataLayout = struct5([u85("instruction")]);
          const data = buffer.Buffer.alloc(dataLayout.span);
          dataLayout.encode({
            instruction: 17
          }, data);
          let keys = [{
            pubkey: nativeAccount,
            isSigner: false,
            isWritable: true
          }];
          return new TransactionInstruction({
            keys,
            programId,
            data
          });
        }
        static async getAssociatedTokenAddress(associatedProgramId, programId, mint, owner, allowOwnerOffCurve = false) {
          if (!allowOwnerOffCurve && !PublicKey.isOnCurve(owner.toBuffer())) {
            throw new Error(`Owner cannot sign: ${owner.toString()}`);
          }
          return (await PublicKey.findProgramAddress([owner.toBuffer(), programId.toBuffer(), mint.toBuffer()], associatedProgramId))[0];
        }
        static createAssociatedTokenAccountInstruction(associatedProgramId, programId, mint, associatedAccount, owner, payer) {
          const data = buffer.Buffer.alloc(0);
          let keys = [{
            pubkey: payer,
            isSigner: true,
            isWritable: true
          }, {
            pubkey: associatedAccount,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: owner,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: mint,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: SystemProgram.programId,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: programId,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false
          }];
          return new TransactionInstruction({
            keys,
            programId: associatedProgramId,
            data
          });
        }
      };
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/types/public/constants.js
  var require_constants = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/types/public/constants.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.FEE_RATE_MUL_VALUE = exports2.PROTOCOL_FEE_RATE_MUL_VALUE = exports2.MAX_SWAP_TICK_ARRAYS = exports2.METADATA_PROGRAM_ADDRESS = exports2.TICK_ARRAY_SIZE = exports2.MIN_SQRT_PRICE = exports2.MAX_SQRT_PRICE = exports2.MIN_TICK_INDEX = exports2.MAX_TICK_INDEX = exports2.NUM_REWARDS = exports2.ORCA_WHIRLPOOLS_CONFIG = exports2.ORCA_WHIRLPOOL_PROGRAM_ID = void 0;
      var anchor_1 = (init_browser(), __toCommonJS(browser_exports));
      var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
      exports2.ORCA_WHIRLPOOL_PROGRAM_ID = new web3_js_1.PublicKey("whirLbMiicVdio4qvUfM5KAg6Ct8VwpYzGff3uctyCc");
      exports2.ORCA_WHIRLPOOLS_CONFIG = new web3_js_1.PublicKey("2LecshUwdy9xi7meFgHtFJQNSKk4KdTrcpvaB56dP2NQ");
      exports2.NUM_REWARDS = 3;
      exports2.MAX_TICK_INDEX = 443636;
      exports2.MIN_TICK_INDEX = -443636;
      exports2.MAX_SQRT_PRICE = "79226673515401279992447579055";
      exports2.MIN_SQRT_PRICE = "4295048016";
      exports2.TICK_ARRAY_SIZE = 88;
      exports2.METADATA_PROGRAM_ADDRESS = new web3_js_1.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s");
      exports2.MAX_SWAP_TICK_ARRAYS = 3;
      exports2.PROTOCOL_FEE_RATE_MUL_VALUE = new anchor_1.BN(1e4);
      exports2.FEE_RATE_MUL_VALUE = new anchor_1.BN(1e6);
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/types/public/anchor-types.js
  var require_anchor_types = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/types/public/anchor-types.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.AccountName = void 0;
      var AccountName;
      (function(AccountName2) {
        AccountName2["WhirlpoolsConfig"] = "WhirlpoolsConfig";
        AccountName2["Position"] = "Position";
        AccountName2["TickArray"] = "TickArray";
        AccountName2["Whirlpool"] = "Whirlpool";
        AccountName2["FeeTier"] = "FeeTier";
      })(AccountName = exports2.AccountName || (exports2.AccountName = {}));
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/types/public/ix-types.js
  var require_ix_types = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/types/public/ix-types.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/types/public/client-types.js
  var require_client_types = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/types/public/client-types.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/types/public/index.js
  var require_public = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/types/public/index.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        var desc = Object.getOwnPropertyDescriptor(m, k2);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k2];
          } };
        }
        Object.defineProperty(o, k22, desc);
      } : function(o, m, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o[k22] = m[k2];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p2 in m)
          if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
            __createBinding(exports3, m, p2);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar(require_constants(), exports2);
      __exportStar(require_anchor_types(), exports2);
      __exportStar(require_ix_types(), exports2);
      __exportStar(require_client_types(), exports2);
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/node_modules/@orca-so/common-sdk/dist/math/decimal-util.js
  var require_decimal_util = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/node_modules/@orca-so/common-sdk/dist/math/decimal-util.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DecimalUtil = void 0;
      var spl_token_1 = (init_index_browser_esm2(), __toCommonJS(index_browser_esm_exports2));
      var decimal_js_1 = __importDefault(require_decimal());
      var DecimalUtil2 = class {
        static adjustDecimals(input, shift = 0) {
          return input.div(decimal_js_1.default.pow(10, shift));
        }
        static fromU64(input, shift = 0) {
          return new decimal_js_1.default(input.toString()).div(new decimal_js_1.default(10).pow(shift));
        }
        static fromNumber(input, shift = 0) {
          return new decimal_js_1.default(input).div(new decimal_js_1.default(10).pow(shift));
        }
        static toU64(input, shift = 0) {
          if (input.isNeg()) {
            throw new Error("Negative decimal value ${input} cannot be converted to u64.");
          }
          const shiftedValue = input.mul(new decimal_js_1.default(10).pow(shift));
          const zeroDecimalValue = shiftedValue.trunc();
          return new spl_token_1.u64(zeroDecimalValue.toString());
        }
      };
      exports2.DecimalUtil = DecimalUtil2;
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/node_modules/@orca-so/common-sdk/dist/math/math-util.js
  var require_math_util = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/node_modules/@orca-so/common-sdk/dist/math/math-util.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.MathUtil = exports2.U64_MAX = exports2.U128 = exports2.TWO = exports2.ONE = exports2.ZERO = void 0;
      var anchor_1 = (init_browser(), __toCommonJS(browser_exports));
      var decimal_js_1 = __importDefault(require_decimal());
      exports2.ZERO = new anchor_1.BN(0);
      exports2.ONE = new anchor_1.BN(1);
      exports2.TWO = new anchor_1.BN(2);
      exports2.U128 = exports2.TWO.pow(new anchor_1.BN(128));
      exports2.U64_MAX = exports2.TWO.pow(new anchor_1.BN(64)).sub(exports2.ONE);
      var MathUtil = class {
        static toX64_BN(num) {
          return num.mul(new anchor_1.BN(2).pow(new anchor_1.BN(64)));
        }
        static toX64_Decimal(num) {
          return num.mul(decimal_js_1.default.pow(2, 64));
        }
        static toX64(num) {
          return new anchor_1.BN(num.mul(decimal_js_1.default.pow(2, 64)).floor().toFixed());
        }
        static fromX64(num) {
          return new decimal_js_1.default(num.toString()).mul(decimal_js_1.default.pow(2, -64));
        }
        static fromX64_Decimal(num) {
          return num.mul(decimal_js_1.default.pow(2, -64));
        }
        static fromX64_BN(num) {
          return num.div(new anchor_1.BN(2).pow(new anchor_1.BN(64)));
        }
        static shiftRightRoundUp(n) {
          let result = n.shrn(64);
          if (n.mod(exports2.U64_MAX).gt(exports2.ZERO)) {
            result = result.add(exports2.ONE);
          }
          return result;
        }
        static divRoundUp(n0, n1) {
          const hasRemainder = !n0.mod(n1).eq(exports2.ZERO);
          if (hasRemainder) {
            return n0.div(n1).add(new anchor_1.BN(1));
          } else {
            return n0.div(n1);
          }
        }
        static subUnderflowU128(n0, n1) {
          return n0.add(exports2.U128).sub(n1).mod(exports2.U128);
        }
      };
      exports2.MathUtil = MathUtil;
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/node_modules/@orca-so/common-sdk/dist/math/percentage.js
  var require_percentage = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/node_modules/@orca-so/common-sdk/dist/math/percentage.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Percentage = void 0;
      var spl_token_1 = (init_index_browser_esm2(), __toCommonJS(index_browser_esm_exports2));
      var decimal_js_1 = __importDefault(require_decimal());
      var Percentage2 = class {
        constructor(numerator, denominator) {
          this.toString = () => {
            return `${this.numerator.toString()}/${this.denominator.toString()}`;
          };
          this.numerator = numerator;
          this.denominator = denominator;
        }
        static fromDecimal(number5) {
          return Percentage2.fromFraction(number5.toDecimalPlaces(1).mul(10).toNumber(), 1e3);
        }
        static fromFraction(numerator, denominator) {
          const num = typeof numerator === "number" ? new spl_token_1.u64(numerator.toString()) : numerator;
          const denom = typeof denominator === "number" ? new spl_token_1.u64(denominator.toString()) : denominator;
          return new Percentage2(num, denom);
        }
        toDecimal() {
          if (this.denominator.eq(new spl_token_1.u64(0))) {
            return new decimal_js_1.default(0);
          }
          return new decimal_js_1.default(this.numerator.toString()).div(new decimal_js_1.default(this.denominator.toString()));
        }
        add(p2) {
          const denomGcd = this.denominator.gcd(p2.denominator);
          const denomLcm = this.denominator.div(denomGcd).mul(p2.denominator);
          const p1DenomAdjustment = denomLcm.div(this.denominator);
          const p2DenomAdjustment = denomLcm.div(p2.denominator);
          const p1NumeratorAdjusted = this.numerator.mul(p1DenomAdjustment);
          const p2NumeratorAdjusted = p2.numerator.mul(p2DenomAdjustment);
          const newNumerator = p1NumeratorAdjusted.add(p2NumeratorAdjusted);
          return new Percentage2(new spl_token_1.u64(newNumerator.toString()), new spl_token_1.u64(denomLcm.toString()));
        }
      };
      exports2.Percentage = Percentage2;
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/node_modules/@orca-so/common-sdk/dist/math/index.js
  var require_math = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/node_modules/@orca-so/common-sdk/dist/math/index.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        var desc = Object.getOwnPropertyDescriptor(m, k2);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k2];
          } };
        }
        Object.defineProperty(o, k22, desc);
      } : function(o, m, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o[k22] = m[k2];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p2 in m)
          if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
            __createBinding(exports3, m, p2);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar(require_decimal_util(), exports2);
      __exportStar(require_math_util(), exports2);
      __exportStar(require_percentage(), exports2);
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/node_modules/@orca-so/common-sdk/dist/web3/address-util.js
  var require_address_util = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/node_modules/@orca-so/common-sdk/dist/web3/address-util.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.AddressUtil = void 0;
      var anchor_1 = (init_browser(), __toCommonJS(browser_exports));
      var AddressUtil = class {
        static toPubKey(address) {
          return (0, anchor_1.translateAddress)(address);
        }
        static toPubKeys(addresses) {
          return addresses.map((address) => AddressUtil.toPubKey(address));
        }
        static toString(address) {
          return AddressUtil.toPubKey(address).toBase58();
        }
        static toStrings(addresses) {
          return addresses.map((address) => AddressUtil.toString(address));
        }
        static findProgramAddress(seeds, programId) {
          const [publicKey6, bump] = anchor_1.utils.publicKey.findProgramAddressSync(seeds, programId);
          return { publicKey: publicKey6, bump };
        }
      };
      exports2.AddressUtil = AddressUtil;
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/node_modules/@orca-so/common-sdk/dist/helpers/token-instructions.js
  var require_token_instructions = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/node_modules/@orca-so/common-sdk/dist/helpers/token-instructions.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createWSOLAccountInstructions = void 0;
      var spl_token_1 = (init_index_browser_esm2(), __toCommonJS(index_browser_esm_exports2));
      var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
      function createWSOLAccountInstructions(walletAddress, amountIn, rentExemptLamports) {
        const tempAccount = new web3_js_1.Keypair();
        const createAccountInstruction = web3_js_1.SystemProgram.createAccount({
          fromPubkey: walletAddress,
          newAccountPubkey: tempAccount.publicKey,
          lamports: amountIn.toNumber() + rentExemptLamports,
          space: spl_token_1.AccountLayout.span,
          programId: spl_token_1.TOKEN_PROGRAM_ID
        });
        const initAccountInstruction = spl_token_1.Token.createInitAccountInstruction(spl_token_1.TOKEN_PROGRAM_ID, spl_token_1.NATIVE_MINT, tempAccount.publicKey, walletAddress);
        const closeWSOLAccountInstruction = spl_token_1.Token.createCloseAccountInstruction(spl_token_1.TOKEN_PROGRAM_ID, tempAccount.publicKey, walletAddress, walletAddress, []);
        return {
          address: tempAccount.publicKey,
          instructions: [createAccountInstruction, initAccountInstruction],
          cleanupInstructions: [closeWSOLAccountInstruction],
          signers: [tempAccount]
        };
      }
      exports2.createWSOLAccountInstructions = createWSOLAccountInstructions;
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/node_modules/@orca-so/common-sdk/dist/web3/token-util.js
  var require_token_util = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/node_modules/@orca-so/common-sdk/dist/web3/token-util.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __rest = exports2 && exports2.__rest || function(s, e) {
        var t2 = {};
        for (var p2 in s)
          if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)
            t2[p2] = s[p2];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
            if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
              t2[p2[i]] = s[p2[i]];
          }
        return t2;
      };
      var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.TokenUtil = void 0;
      var spl_token_1 = (init_index_browser_esm2(), __toCommonJS(index_browser_esm_exports2));
      var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
      var tiny_invariant_1 = __importDefault(require_tiny_invariant_cjs());
      var math_1 = require_math();
      var web3_1 = require_web3();
      var TokenUtil = class {
        static isNativeMint(mint) {
          return mint.equals(spl_token_1.NATIVE_MINT);
        }
        static createSendTokensToWalletInstruction(connection, sourceWallet, destinationWallet, tokenMint, tokenDecimals, amount, getAccountRentExempt, payer) {
          return __awaiter(this, void 0, void 0, function* () {
            (0, tiny_invariant_1.default)(!amount.eq(math_1.ZERO), "SendToken transaction must send more than 0 tokens.");
            if (tokenMint.equals(spl_token_1.NATIVE_MINT)) {
              const sendSolTxn = web3_js_1.SystemProgram.transfer({
                fromPubkey: sourceWallet,
                toPubkey: destinationWallet,
                lamports: BigInt(amount.toString())
              });
              return {
                instructions: [sendSolTxn],
                cleanupInstructions: [],
                signers: []
              };
            }
            const sourceTokenAccount = yield (0, web3_1.deriveATA)(sourceWallet, tokenMint);
            const _a = yield (0, web3_1.resolveOrCreateATA)(connection, destinationWallet, tokenMint, getAccountRentExempt, amount, payer), { address: destinationTokenAccount } = _a, destinationAtaIx = __rest(_a, ["address"]);
            const transferIx = spl_token_1.Token.createTransferCheckedInstruction(spl_token_1.TOKEN_PROGRAM_ID, sourceTokenAccount, tokenMint, destinationTokenAccount, sourceWallet, [], new spl_token_1.u64(amount.toString()), tokenDecimals);
            return {
              instructions: destinationAtaIx.instructions.concat(transferIx),
              cleanupInstructions: destinationAtaIx.cleanupInstructions,
              signers: destinationAtaIx.signers
            };
          });
        }
      };
      exports2.TokenUtil = TokenUtil;
      TokenUtil.deserializeTokenAccount = (data) => {
        if (!data) {
          return null;
        }
        if (data.byteLength !== spl_token_1.AccountLayout.span) {
          throw new Error("Invalid data length for TokenAccount");
        }
        const accountInfo = spl_token_1.AccountLayout.decode(data);
        accountInfo.mint = new web3_js_1.PublicKey(accountInfo.mint);
        accountInfo.owner = new web3_js_1.PublicKey(accountInfo.owner);
        accountInfo.amount = spl_token_1.u64.fromBuffer(accountInfo.amount);
        if (accountInfo.delegateOption === 0) {
          accountInfo.delegate = null;
          accountInfo.delegatedAmount = new spl_token_1.u64(0);
        } else {
          accountInfo.delegate = new web3_js_1.PublicKey(accountInfo.delegate);
          accountInfo.delegatedAmount = spl_token_1.u64.fromBuffer(accountInfo.delegatedAmount);
        }
        accountInfo.isInitialized = accountInfo.state !== 0;
        accountInfo.isFrozen = accountInfo.state === 2;
        if (accountInfo.isNativeOption === 1) {
          accountInfo.rentExemptReserve = spl_token_1.u64.fromBuffer(accountInfo.isNative);
          accountInfo.isNative = true;
        } else {
          accountInfo.rentExemptReserve = null;
          accountInfo.isNative = false;
        }
        if (accountInfo.closeAuthorityOption === 0) {
          accountInfo.closeAuthority = null;
        } else {
          accountInfo.closeAuthority = new web3_js_1.PublicKey(accountInfo.closeAuthority);
        }
        return accountInfo;
      };
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/node_modules/@orca-so/common-sdk/dist/web3/transactions/types.js
  var require_types2 = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/node_modules/@orca-so/common-sdk/dist/web3/transactions/types.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.EMPTY_INSTRUCTION = void 0;
      exports2.EMPTY_INSTRUCTION = {
        instructions: [],
        cleanupInstructions: [],
        signers: []
      };
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/node_modules/@orca-so/common-sdk/dist/web3/ata-util.js
  var require_ata_util = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/node_modules/@orca-so/common-sdk/dist/web3/ata-util.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.deriveATA = exports2.resolveOrCreateATAs = exports2.resolveOrCreateATA = void 0;
      var spl_token_1 = (init_index_browser_esm2(), __toCommonJS(index_browser_esm_exports2));
      var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
      var token_instructions_1 = require_token_instructions();
      var token_util_1 = require_token_util();
      var types_1 = require_types2();
      function resolveOrCreateATA2(connection, ownerAddress, tokenMint, getAccountRentExempt, wrappedSolAmountIn = new spl_token_1.u64(0), payer = ownerAddress, modeIdempotent = false) {
        return __awaiter(this, void 0, void 0, function* () {
          const instructions2 = yield resolveOrCreateATAs(connection, ownerAddress, [{ tokenMint, wrappedSolAmountIn }], getAccountRentExempt, payer, modeIdempotent);
          return instructions2[0];
        });
      }
      exports2.resolveOrCreateATA = resolveOrCreateATA2;
      function resolveOrCreateATAs(connection, ownerAddress, requests, getAccountRentExempt, payer = ownerAddress, modeIdempotent = false) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          const nonNativeMints = requests.filter(({ tokenMint }) => !tokenMint.equals(spl_token_1.NATIVE_MINT));
          const nativeMints = requests.filter(({ tokenMint }) => tokenMint.equals(spl_token_1.NATIVE_MINT));
          if (nativeMints.length > 1) {
            throw new Error("Cannot resolve multiple WSolAccounts");
          }
          let instructionMap = {};
          if (nonNativeMints.length > 0) {
            const nonNativeAddresses = yield Promise.all(nonNativeMints.map(({ tokenMint }) => deriveATA2(ownerAddress, tokenMint)));
            const tokenAccountInfos = yield connection.getMultipleAccountsInfo(nonNativeAddresses);
            const tokenAccounts = tokenAccountInfos.map((tai) => token_util_1.TokenUtil.deserializeTokenAccount(tai === null || tai === void 0 ? void 0 : tai.data));
            tokenAccounts.forEach((tokenAccount, index) => {
              const ataAddress = nonNativeAddresses[index];
              let resolvedInstruction;
              if (tokenAccount) {
                if (!tokenAccount.owner.equals(ownerAddress)) {
                  throw new Error(`ATA with change of ownership detected: ${ataAddress.toBase58()}`);
                }
                resolvedInstruction = Object.assign({ address: ataAddress }, types_1.EMPTY_INSTRUCTION);
              } else {
                const createAtaInstruction = createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, nonNativeMints[index].tokenMint, ataAddress, ownerAddress, payer, modeIdempotent);
                resolvedInstruction = {
                  address: ataAddress,
                  instructions: [createAtaInstruction],
                  cleanupInstructions: [],
                  signers: []
                };
              }
              instructionMap[nonNativeMints[index].tokenMint.toBase58()] = resolvedInstruction;
            });
          }
          if (nativeMints.length > 0) {
            const accountRentExempt = yield getAccountRentExempt();
            const wrappedSolAmountIn = ((_a = nativeMints[0]) === null || _a === void 0 ? void 0 : _a.wrappedSolAmountIn) || new spl_token_1.u64(0);
            instructionMap[spl_token_1.NATIVE_MINT.toBase58()] = (0, token_instructions_1.createWSOLAccountInstructions)(ownerAddress, wrappedSolAmountIn, accountRentExempt);
          }
          return requests.map(({ tokenMint }) => instructionMap[tokenMint.toBase58()]);
        });
      }
      exports2.resolveOrCreateATAs = resolveOrCreateATAs;
      function deriveATA2(ownerAddress, tokenMint) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield spl_token_1.Token.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, tokenMint, ownerAddress);
        });
      }
      exports2.deriveATA = deriveATA2;
      function createAssociatedTokenAccountInstruction(associatedTokenProgramId, tokenProgramId, mint, associatedAccount, owner, payer, modeIdempotent) {
        if (!modeIdempotent) {
          return spl_token_1.Token.createAssociatedTokenAccountInstruction(associatedTokenProgramId, tokenProgramId, mint, associatedAccount, owner, payer);
        }
        const keys = [
          { pubkey: payer, isSigner: true, isWritable: true },
          { pubkey: associatedAccount, isSigner: false, isWritable: true },
          { pubkey: owner, isSigner: false, isWritable: false },
          { pubkey: mint, isSigner: false, isWritable: false },
          { pubkey: web3_js_1.SystemProgram.programId, isSigner: false, isWritable: false },
          { pubkey: tokenProgramId, isSigner: false, isWritable: false }
        ];
        const instructionData = Buffer.from([1]);
        return new web3_js_1.TransactionInstruction({
          keys,
          programId: associatedTokenProgramId,
          data: instructionData
        });
      }
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/node_modules/@orca-so/common-sdk/dist/web3/network/account-requests.js
  var require_account_requests = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/node_modules/@orca-so/common-sdk/dist/web3/network/account-requests.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getMultipleAccounts = exports2.getMultipleParsedAccounts = exports2.getParsedAccount = void 0;
      var tiny_invariant_1 = __importDefault(require_tiny_invariant_cjs());
      var address_util_1 = require_address_util();
      function getParsedAccount(connection, address, parser) {
        return __awaiter(this, void 0, void 0, function* () {
          const value = yield connection.getAccountInfo(address_util_1.AddressUtil.toPubKey(address));
          return parser.parse(value === null || value === void 0 ? void 0 : value.data);
        });
      }
      exports2.getParsedAccount = getParsedAccount;
      function getMultipleParsedAccounts(connection, addresses, parser) {
        return __awaiter(this, void 0, void 0, function* () {
          if (addresses.length === 0) {
            return [];
          }
          const values = yield getMultipleAccounts(connection, address_util_1.AddressUtil.toPubKeys(addresses));
          const results = values.map((value) => parser.parse(value === null || value === void 0 ? void 0 : value.data)).filter((value) => value !== void 0);
          (0, tiny_invariant_1.default)(results.length === addresses.length, "not enough results fetched");
          return results;
        });
      }
      exports2.getMultipleParsedAccounts = getMultipleParsedAccounts;
      function getMultipleAccounts(connection, addresses) {
        return __awaiter(this, void 0, void 0, function* () {
          if (addresses.length === 0) {
            return [];
          }
          const responses = [];
          const chunk = 100;
          for (let i = 0; i < addresses.length; i += chunk) {
            const addressChunk = addresses.slice(i, i + chunk);
            const res = connection.getMultipleAccountsInfo(address_util_1.AddressUtil.toPubKeys(addressChunk), connection.commitment);
            responses.push(res);
          }
          const combinedResult = (yield Promise.all(responses)).flat();
          (0, tiny_invariant_1.default)(combinedResult.length === addresses.length, "getMultipleAccounts not enough results");
          return combinedResult;
        });
      }
      exports2.getMultipleAccounts = getMultipleAccounts;
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/node_modules/@orca-so/common-sdk/dist/web3/network/parsing.js
  var require_parsing = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/node_modules/@orca-so/common-sdk/dist/web3/network/parsing.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
        var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d2 = decorators[i])
              r = (c2 < 3 ? d2(r) : c2 > 3 ? d2(target, key, r) : d2(target, key)) || r;
        return c2 > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.staticImplements = exports2.ParsableMintInfo = exports2.ParsableTokenAccountInfo = void 0;
      var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
      var spl_token_1 = (init_index_browser_esm2(), __toCommonJS(index_browser_esm_exports2));
      var token_util_1 = require_token_util();
      var ParsableTokenAccountInfo = class ParsableTokenAccountInfo {
        constructor() {
        }
        static parse(data) {
          if (!data) {
            return null;
          }
          try {
            return token_util_1.TokenUtil.deserializeTokenAccount(data);
          } catch (e) {
            console.error(`error while parsing TokenAccount: ${e}`);
            return null;
          }
        }
      };
      ParsableTokenAccountInfo = __decorate([
        staticImplements()
      ], ParsableTokenAccountInfo);
      exports2.ParsableTokenAccountInfo = ParsableTokenAccountInfo;
      var ParsableMintInfo = class ParsableMintInfo {
        constructor() {
        }
        static parse(data) {
          if (!data) {
            return null;
          }
          try {
            if (data.byteLength !== spl_token_1.MintLayout.span) {
              throw new Error("Invalid data length for MintInfo");
            }
            const buffer2 = spl_token_1.MintLayout.decode(data);
            const mintInfo = {
              mintAuthority: buffer2.mintAuthorityOption === 0 ? null : new web3_js_1.PublicKey(buffer2.mintAuthority),
              supply: spl_token_1.u64.fromBuffer(buffer2.supply),
              decimals: buffer2.decimals,
              isInitialized: buffer2.isInitialized !== 0,
              freezeAuthority: buffer2.freezeAuthorityOption === 0 ? null : new web3_js_1.PublicKey(buffer2.freezeAuthority)
            };
            return mintInfo;
          } catch (e) {
            console.error(`error while parsing MintInfo: ${e}`);
            return null;
          }
        }
      };
      ParsableMintInfo = __decorate([
        staticImplements()
      ], ParsableMintInfo);
      exports2.ParsableMintInfo = ParsableMintInfo;
      function staticImplements() {
        return (constructor) => {
          constructor;
        };
      }
      exports2.staticImplements = staticImplements;
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/node_modules/@orca-so/common-sdk/dist/web3/network/index.js
  var require_network = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/node_modules/@orca-so/common-sdk/dist/web3/network/index.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        var desc = Object.getOwnPropertyDescriptor(m, k2);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k2];
          } };
        }
        Object.defineProperty(o, k22, desc);
      } : function(o, m, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o[k22] = m[k2];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p2 in m)
          if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
            __createBinding(exports3, m, p2);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar(require_account_requests(), exports2);
      __exportStar(require_parsing(), exports2);
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/node_modules/@orca-so/common-sdk/dist/web3/public-key-utils.js
  var require_public_key_utils = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/node_modules/@orca-so/common-sdk/dist/web3/public-key-utils.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.PublicKeyUtils = void 0;
      var PublicKeyUtils = class {
        static isBase58(value) {
          return /^[A-HJ-NP-Za-km-z1-9]*$/.test(value);
        }
        static orderKeys(...keys) {
          return keys.sort(comparePublicKeys);
        }
      };
      exports2.PublicKeyUtils = PublicKeyUtils;
      function comparePublicKeys(key1, key2) {
        const bytes1 = key1.toBytes();
        const bytes2 = key2.toBytes();
        if (bytes1.byteLength !== bytes2.byteLength) {
          return bytes1.byteLength - bytes2.byteLength;
        }
        for (let i = 0; i < bytes1.byteLength; i++) {
          let byte1 = bytes1[i];
          let byte2 = bytes2[i];
          if (byte1 !== byte2) {
            return byte1 - byte2;
          }
        }
        return 0;
      }
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/node_modules/@orca-so/common-sdk/dist/web3/transactions/transactions-processor.js
  var require_transactions_processor = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/node_modules/@orca-so/common-sdk/dist/web3/transactions/transactions-processor.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.TransactionProcessor = void 0;
      var TransactionProcessor = class {
        constructor(connection, wallet, commitment = "confirmed") {
          this.connection = connection;
          this.wallet = wallet;
          this.commitment = commitment;
        }
        signTransaction(txRequest) {
          return __awaiter(this, void 0, void 0, function* () {
            const { transactions, lastValidBlockHeight, blockhash } = yield this.signTransactions([
              txRequest
            ]);
            return { transaction: transactions[0], lastValidBlockHeight, blockhash };
          });
        }
        signTransactions(txRequests) {
          return __awaiter(this, void 0, void 0, function* () {
            const { blockhash, lastValidBlockHeight } = yield this.connection.getLatestBlockhash(this.commitment);
            const feePayer = this.wallet.publicKey;
            const pSignedTxs = txRequests.map((txRequest) => {
              return rewriteTransaction(txRequest, feePayer, blockhash);
            });
            const transactions = yield this.wallet.signAllTransactions(pSignedTxs);
            return {
              transactions,
              lastValidBlockHeight,
              blockhash
            };
          });
        }
        sendTransaction(transaction, lastValidBlockHeight, blockhash) {
          return __awaiter(this, void 0, void 0, function* () {
            const execute = this.constructSendTransactions([transaction], lastValidBlockHeight, blockhash);
            const txs = yield execute();
            const ex = txs[0];
            if (ex.status === "fulfilled") {
              return ex.value;
            } else {
              throw ex.reason;
            }
          });
        }
        constructSendTransactions(transactions, lastValidBlockHeight, blockhash, parallel = true) {
          const executeTx = (tx) => __awaiter(this, void 0, void 0, function* () {
            const rawTxs = tx.serialize();
            return this.connection.sendRawTransaction(rawTxs, {
              preflightCommitment: this.commitment
            });
          });
          const confirmTx = (txId) => __awaiter(this, void 0, void 0, function* () {
            const result = yield this.connection.confirmTransaction({
              signature: txId,
              lastValidBlockHeight,
              blockhash
            }, this.commitment);
            if (result.value.err) {
              throw new Error(`Transaction failed: ${JSON.stringify(result.value)}`);
            }
          });
          return () => __awaiter(this, void 0, void 0, function* () {
            if (parallel) {
              const results = transactions.map((tx) => __awaiter(this, void 0, void 0, function* () {
                const txId = yield executeTx(tx);
                yield confirmTx(txId);
                return txId;
              }));
              return Promise.allSettled(results);
            } else {
              const results = [];
              for (const tx of transactions) {
                const txId = yield executeTx(tx);
                yield confirmTx(txId);
                results.push(txId);
              }
              return Promise.allSettled(results);
            }
          });
        }
        signAndConstructTransaction(txRequest) {
          return __awaiter(this, void 0, void 0, function* () {
            const { transaction, lastValidBlockHeight, blockhash } = yield this.signTransaction(txRequest);
            return {
              signedTx: transaction,
              execute: () => __awaiter(this, void 0, void 0, function* () {
                return this.sendTransaction(transaction, lastValidBlockHeight, blockhash);
              })
            };
          });
        }
        signAndConstructTransactions(txRequests, parallel = true) {
          return __awaiter(this, void 0, void 0, function* () {
            const { transactions, lastValidBlockHeight, blockhash } = yield this.signTransactions(txRequests);
            const execute = this.constructSendTransactions(transactions, lastValidBlockHeight, blockhash, parallel);
            return { signedTxs: transactions, execute };
          });
        }
      };
      exports2.TransactionProcessor = TransactionProcessor;
      function rewriteTransaction(txRequest, feePayer, blockhash) {
        var _a;
        const signers = (_a = txRequest.signers) !== null && _a !== void 0 ? _a : [];
        const tx = txRequest.transaction;
        tx.feePayer = feePayer;
        tx.recentBlockhash = blockhash;
        signers.filter((s) => s !== void 0).forEach((keypair) => tx.partialSign(keypair));
        return tx;
      }
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/node_modules/@orca-so/common-sdk/dist/web3/transactions/transactions-builder.js
  var require_transactions_builder = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/node_modules/@orca-so/common-sdk/dist/web3/transactions/transactions-builder.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.TransactionBuilder = void 0;
      var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
      var transactions_processor_1 = require_transactions_processor();
      var TransactionBuilder2 = class {
        constructor(connection, wallet) {
          this.connection = connection;
          this.wallet = wallet;
          this.instructions = [];
          this.signers = [];
        }
        addInstruction(instruction) {
          this.instructions.push(instruction);
          return this;
        }
        addInstructions(instructions2) {
          this.instructions = this.instructions.concat(instructions2);
          return this;
        }
        prependInstruction(instruction) {
          this.instructions.unshift(instruction);
          return this;
        }
        prependInstructions(instructions2) {
          this.instructions = instructions2.concat(this.instructions);
          return this;
        }
        addSigner(signer) {
          this.signers.push(signer);
          return this;
        }
        isEmpty() {
          return this.instructions.length == 0;
        }
        compressIx(compressPost) {
          let instructions2 = [];
          let cleanupInstructions = [];
          let signers = [];
          this.instructions.forEach((curr) => {
            instructions2 = instructions2.concat(curr.instructions);
            cleanupInstructions = curr.cleanupInstructions.concat(cleanupInstructions);
            signers = signers.concat(curr.signers);
          });
          if (compressPost) {
            instructions2 = instructions2.concat(cleanupInstructions);
            cleanupInstructions = [];
          }
          return {
            instructions: [...instructions2],
            cleanupInstructions: [...cleanupInstructions],
            signers
          };
        }
        txnSize(options = { latestBlockhash: void 0 }) {
          return __awaiter(this, void 0, void 0, function* () {
            if (this.isEmpty()) {
              return 0;
            }
            const request = yield this.build(options);
            return request.transaction.serialize({ requireAllSignatures: false }).length;
          });
        }
        build(options = { latestBlockhash: void 0 }) {
          return __awaiter(this, void 0, void 0, function* () {
            const { latestBlockhash } = options;
            let recentBlockhash = !latestBlockhash ? yield this.connection.getLatestBlockhash("singleGossip") : latestBlockhash;
            const transaction = new web3_js_1.Transaction(Object.assign(Object.assign({}, recentBlockhash), { feePayer: this.wallet.publicKey }));
            const ix = this.compressIx(true);
            transaction.add(...ix.instructions);
            transaction.feePayer = this.wallet.publicKey;
            return {
              transaction,
              signers: ix.signers.concat(this.signers)
            };
          });
        }
        buildAndExecute() {
          return __awaiter(this, void 0, void 0, function* () {
            const tx = yield this.build();
            const tp = new transactions_processor_1.TransactionProcessor(this.connection, this.wallet);
            const { execute } = yield tp.signAndConstructTransaction(tx);
            return execute();
          });
        }
        static sendAll(provider, txns, opts) {
          return __awaiter(this, void 0, void 0, function* () {
            const txRequest = yield Promise.all(txns.map((txBuilder) => __awaiter(this, void 0, void 0, function* () {
              const { transaction, signers } = yield txBuilder.build();
              return { tx: transaction, signers };
            })));
            return yield provider.sendAll(txRequest, opts);
          });
        }
      };
      exports2.TransactionBuilder = TransactionBuilder2;
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/node_modules/@orca-so/common-sdk/dist/web3/transactions/index.js
  var require_transactions = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/node_modules/@orca-so/common-sdk/dist/web3/transactions/index.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        var desc = Object.getOwnPropertyDescriptor(m, k2);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k2];
          } };
        }
        Object.defineProperty(o, k22, desc);
      } : function(o, m, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o[k22] = m[k2];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p2 in m)
          if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
            __createBinding(exports3, m, p2);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar(require_transactions_builder(), exports2);
      __exportStar(require_transactions_processor(), exports2);
      __exportStar(require_types2(), exports2);
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/node_modules/@orca-so/common-sdk/dist/web3/index.js
  var require_web3 = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/node_modules/@orca-so/common-sdk/dist/web3/index.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        var desc = Object.getOwnPropertyDescriptor(m, k2);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k2];
          } };
        }
        Object.defineProperty(o, k22, desc);
      } : function(o, m, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o[k22] = m[k2];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p2 in m)
          if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
            __createBinding(exports3, m, p2);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar(require_address_util(), exports2);
      __exportStar(require_ata_util(), exports2);
      __exportStar(require_network(), exports2);
      __exportStar(require_public_key_utils(), exports2);
      __exportStar(require_token_util(), exports2);
      __exportStar(require_transactions(), exports2);
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/node_modules/@orca-so/common-sdk/dist/index.js
  var require_dist2 = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/node_modules/@orca-so/common-sdk/dist/index.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        var desc = Object.getOwnPropertyDescriptor(m, k2);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k2];
          } };
        }
        Object.defineProperty(o, k22, desc);
      } : function(o, m, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o[k22] = m[k2];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p2 in m)
          if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
            __createBinding(exports3, m, p2);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar(require_math(), exports2);
      __exportStar(require_web3(), exports2);
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/network/public/parsing.js
  var require_parsing2 = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/network/public/parsing.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        var desc = Object.getOwnPropertyDescriptor(m, k2);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k2];
          } };
        }
        Object.defineProperty(o, k22, desc);
      } : function(o, m, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o[k22] = m[k2];
      });
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v2) {
        Object.defineProperty(o, "default", { enumerable: true, value: v2 });
      } : function(o, v2) {
        o["default"] = v2;
      });
      var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
        var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d2 = decorators[i])
              r = (c2 < 3 ? d2(r) : c2 > 3 ? d2(target, key, r) : d2(target, key)) || r;
        return c2 > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __importStar = exports2 && exports2.__importStar || function(mod2) {
        if (mod2 && mod2.__esModule)
          return mod2;
        var result = {};
        if (mod2 != null) {
          for (var k2 in mod2)
            if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k2))
              __createBinding(result, mod2, k2);
        }
        __setModuleDefault(result, mod2);
        return result;
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ParsableMintInfo = exports2.ParsableTokenInfo = exports2.ParsableFeeTier = exports2.ParsableTickArray = exports2.ParsablePosition = exports2.ParsableWhirlpool = exports2.ParsableWhirlpoolsConfig = void 0;
      var spl_token_1 = (init_index_browser_esm2(), __toCommonJS(index_browser_esm_exports2));
      var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
      var public_1 = require_public();
      var anchor_1 = (init_browser(), __toCommonJS(browser_exports));
      var WhirlpoolIDL = __importStar(require_whirlpool());
      var common_sdk_1 = require_dist2();
      var ParsableWhirlpoolsConfig = class ParsableWhirlpoolsConfig {
        constructor() {
        }
        static parse(data) {
          if (!data) {
            return null;
          }
          try {
            return parseAnchorAccount(public_1.AccountName.WhirlpoolsConfig, data);
          } catch (e) {
            console.error(`error while parsing WhirlpoolsConfig: ${e}`);
            return null;
          }
        }
      };
      ParsableWhirlpoolsConfig = __decorate([
        staticImplements()
      ], ParsableWhirlpoolsConfig);
      exports2.ParsableWhirlpoolsConfig = ParsableWhirlpoolsConfig;
      var ParsableWhirlpool = class ParsableWhirlpool {
        constructor() {
        }
        static parse(data) {
          if (!data) {
            return null;
          }
          try {
            return parseAnchorAccount(public_1.AccountName.Whirlpool, data);
          } catch (e) {
            console.error(`error while parsing Whirlpool: ${e}`);
            return null;
          }
        }
      };
      ParsableWhirlpool = __decorate([
        staticImplements()
      ], ParsableWhirlpool);
      exports2.ParsableWhirlpool = ParsableWhirlpool;
      var ParsablePosition = class ParsablePosition {
        constructor() {
        }
        static parse(data) {
          if (!data) {
            return null;
          }
          try {
            return parseAnchorAccount(public_1.AccountName.Position, data);
          } catch (e) {
            console.error(`error while parsing Position: ${e}`);
            return null;
          }
        }
      };
      ParsablePosition = __decorate([
        staticImplements()
      ], ParsablePosition);
      exports2.ParsablePosition = ParsablePosition;
      var ParsableTickArray = class ParsableTickArray {
        constructor() {
        }
        static parse(data) {
          if (!data) {
            return null;
          }
          try {
            return parseAnchorAccount(public_1.AccountName.TickArray, data);
          } catch (e) {
            console.error(`error while parsing TickArray: ${e}`);
            return null;
          }
        }
      };
      ParsableTickArray = __decorate([
        staticImplements()
      ], ParsableTickArray);
      exports2.ParsableTickArray = ParsableTickArray;
      var ParsableFeeTier = class ParsableFeeTier {
        constructor() {
        }
        static parse(data) {
          if (!data) {
            return null;
          }
          try {
            return parseAnchorAccount(public_1.AccountName.FeeTier, data);
          } catch (e) {
            console.error(`error while parsing FeeTier: ${e}`);
            return null;
          }
        }
      };
      ParsableFeeTier = __decorate([
        staticImplements()
      ], ParsableFeeTier);
      exports2.ParsableFeeTier = ParsableFeeTier;
      var ParsableTokenInfo = class ParsableTokenInfo {
        constructor() {
        }
        static parse(data) {
          if (!data) {
            return null;
          }
          try {
            return common_sdk_1.TokenUtil.deserializeTokenAccount(data);
          } catch (e) {
            console.error(`error while parsing TokenAccount: ${e}`);
            return null;
          }
        }
      };
      ParsableTokenInfo = __decorate([
        staticImplements()
      ], ParsableTokenInfo);
      exports2.ParsableTokenInfo = ParsableTokenInfo;
      var ParsableMintInfo = class ParsableMintInfo {
        constructor() {
        }
        static parse(data) {
          if (!data) {
            return null;
          }
          try {
            const buffer2 = spl_token_1.MintLayout.decode(data);
            const mintInfo = {
              mintAuthority: buffer2.mintAuthorityOption === 0 ? null : new web3_js_1.PublicKey(buffer2.mintAuthority),
              supply: spl_token_1.u64.fromBuffer(buffer2.supply),
              decimals: buffer2.decimals,
              isInitialized: buffer2.isInitialized !== 0,
              freezeAuthority: buffer2.freezeAuthority === 0 ? null : new web3_js_1.PublicKey(buffer2.freezeAuthority)
            };
            return mintInfo;
          } catch (e) {
            console.error(`error while parsing MintInfo: ${e}`);
            return null;
          }
        }
      };
      ParsableMintInfo = __decorate([
        staticImplements()
      ], ParsableMintInfo);
      exports2.ParsableMintInfo = ParsableMintInfo;
      function staticImplements() {
        return (constructor) => {
          constructor;
        };
      }
      var WhirlpoolCoder = new anchor_1.BorshAccountsCoder(WhirlpoolIDL);
      function parseAnchorAccount(accountName, data) {
        const discriminator = anchor_1.BorshAccountsCoder.accountDiscriminator(accountName);
        if (discriminator.compare(data.slice(0, 8))) {
          console.error("incorrect account name during parsing");
          return null;
        }
        try {
          return WhirlpoolCoder.decode(accountName, data);
        } catch (_e2) {
          console.error("unknown account name during parsing");
          return null;
        }
      }
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/network/public/fetcher.js
  var require_fetcher = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/network/public/fetcher.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.AccountFetcher = void 0;
      var tiny_invariant_1 = __importDefault(require_tiny_invariant_cjs());
      var spl_token_1 = (init_index_browser_esm2(), __toCommonJS(index_browser_esm_exports2));
      var parsing_1 = require_parsing2();
      var common_sdk_1 = require_dist2();
      var AccountFetcher2 = class {
        constructor(connection, cache) {
          this._cache = {};
          this.connection = connection;
          this._cache = cache !== null && cache !== void 0 ? cache : {};
        }
        getAccountRentExempt(refresh = false) {
          return __awaiter(this, void 0, void 0, function* () {
            if (!this._accountRentExempt || refresh) {
              this._accountRentExempt = yield this.connection.getMinimumBalanceForRentExemption(spl_token_1.AccountLayout.span);
            }
            return this._accountRentExempt;
          });
        }
        getPool(address, refresh = false) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.get(common_sdk_1.AddressUtil.toPubKey(address), parsing_1.ParsableWhirlpool, refresh);
          });
        }
        getPosition(address, refresh = false) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.get(common_sdk_1.AddressUtil.toPubKey(address), parsing_1.ParsablePosition, refresh);
          });
        }
        getTickArray(address, refresh = false) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.get(common_sdk_1.AddressUtil.toPubKey(address), parsing_1.ParsableTickArray, refresh);
          });
        }
        getFeeTier(address, refresh = false) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.get(common_sdk_1.AddressUtil.toPubKey(address), parsing_1.ParsableFeeTier, refresh);
          });
        }
        getTokenInfo(address, refresh = false) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.get(common_sdk_1.AddressUtil.toPubKey(address), parsing_1.ParsableTokenInfo, refresh);
          });
        }
        getMintInfo(address, refresh = false) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.get(common_sdk_1.AddressUtil.toPubKey(address), parsing_1.ParsableMintInfo, refresh);
          });
        }
        getConfig(address, refresh = false) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.get(common_sdk_1.AddressUtil.toPubKey(address), parsing_1.ParsableWhirlpoolsConfig, refresh);
          });
        }
        listPools(addresses, refresh) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.list(common_sdk_1.AddressUtil.toPubKeys(addresses), parsing_1.ParsableWhirlpool, refresh);
          });
        }
        listPositions(addresses, refresh) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.list(common_sdk_1.AddressUtil.toPubKeys(addresses), parsing_1.ParsablePosition, refresh);
          });
        }
        listTickArrays(addresses, refresh) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.list(common_sdk_1.AddressUtil.toPubKeys(addresses), parsing_1.ParsableTickArray, refresh);
          });
        }
        listTokenInfos(addresses, refresh) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.list(common_sdk_1.AddressUtil.toPubKeys(addresses), parsing_1.ParsableTokenInfo, refresh);
          });
        }
        listMintInfos(addresses, refresh) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.list(common_sdk_1.AddressUtil.toPubKeys(addresses), parsing_1.ParsableMintInfo, refresh);
          });
        }
        refreshAll() {
          return __awaiter(this, void 0, void 0, function* () {
            const addresses = Object.keys(this._cache);
            const data = yield this.bulkRequest(addresses);
            for (const [idx, [key, cachedContent]] of Object.entries(this._cache).entries()) {
              const entity = cachedContent.entity;
              const value = entity.parse(data[idx]);
              this._cache[key] = { entity, value };
            }
          });
        }
        get(address, entity, refresh) {
          var _a;
          return __awaiter(this, void 0, void 0, function* () {
            const key = address.toBase58();
            const cachedValue = (_a = this._cache[key]) === null || _a === void 0 ? void 0 : _a.value;
            if (cachedValue !== void 0 && !refresh) {
              return cachedValue;
            }
            const accountInfo = yield this.connection.getAccountInfo(address);
            const accountData = accountInfo === null || accountInfo === void 0 ? void 0 : accountInfo.data;
            const value = entity.parse(accountData);
            this._cache[key] = { entity, value };
            return value;
          });
        }
        list(addresses, entity, refresh) {
          return __awaiter(this, void 0, void 0, function* () {
            const keys = addresses.map((address) => address.toBase58());
            const cachedValues = keys.map((key) => {
              var _a;
              return [
                key,
                refresh ? void 0 : (_a = this._cache[key]) === null || _a === void 0 ? void 0 : _a.value
              ];
            });
            const undefinedAccounts = [];
            cachedValues.forEach(([key, value], cacheIndex) => {
              if (value === void 0) {
                undefinedAccounts.push({ cacheIndex, key });
              }
            });
            if (undefinedAccounts.length > 0) {
              const data = yield this.bulkRequest(undefinedAccounts.map((account) => account.key));
              undefinedAccounts.forEach(({ cacheIndex, key }, dataIndex) => {
                var _a;
                const value = entity.parse(data[dataIndex]);
                (0, tiny_invariant_1.default)(((_a = cachedValues[cacheIndex]) === null || _a === void 0 ? void 0 : _a[1]) === void 0, "unexpected non-undefined value");
                cachedValues[cacheIndex] = [key, value];
                this._cache[key] = { entity, value };
              });
            }
            const result = cachedValues.map(([_2, value]) => value).filter((value) => value !== void 0);
            (0, tiny_invariant_1.default)(result.length === addresses.length, "not enough results fetched");
            return result;
          });
        }
        bulkRequest(addresses) {
          return __awaiter(this, void 0, void 0, function* () {
            const responses = [];
            const chunk = 100;
            for (let i = 0; i < addresses.length; i += chunk) {
              const addressesSubset = addresses.slice(i, i + chunk);
              const res = this.connection._rpcRequest("getMultipleAccounts", [
                addressesSubset,
                { commitment: this.connection.commitment }
              ]);
              responses.push(res);
            }
            const combinedResult = [];
            (yield Promise.all(responses)).forEach((res) => {
              var _a;
              (0, tiny_invariant_1.default)(!res.error, `bulkRequest result error: ${res.error}`);
              (0, tiny_invariant_1.default)(!!((_a = res.result) === null || _a === void 0 ? void 0 : _a.value), "bulkRequest no value");
              res.result.value.forEach((account) => {
                if (!account || account.data[1] !== "base64") {
                  combinedResult.push(null);
                } else {
                  combinedResult.push(Buffer.from(account.data[0], account.data[1]));
                }
              });
            });
            (0, tiny_invariant_1.default)(combinedResult.length === addresses.length, "bulkRequest not enough results");
            return combinedResult;
          });
        }
      };
      exports2.AccountFetcher = AccountFetcher2;
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/network/public/index.js
  var require_public2 = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/network/public/index.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        var desc = Object.getOwnPropertyDescriptor(m, k2);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k2];
          } };
        }
        Object.defineProperty(o, k22, desc);
      } : function(o, m, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o[k22] = m[k2];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p2 in m)
          if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
            __createBinding(exports3, m, p2);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar(require_fetcher(), exports2);
      __exportStar(require_parsing2(), exports2);
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/context.js
  var require_context = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/context.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.WhirlpoolContext = void 0;
      var anchor_1 = (init_browser(), __toCommonJS(browser_exports));
      var whirlpool_json_1 = __importDefault(require_whirlpool());
      var public_1 = require_public2();
      var WhirlpoolContext2 = class {
        constructor(provider, wallet, program, fetcher, opts) {
          this.connection = provider.connection;
          this.wallet = wallet;
          this.opts = opts;
          this.program = program;
          this.provider = provider;
          this.fetcher = fetcher;
        }
        static from(connection, wallet, programId, fetcher = new public_1.AccountFetcher(connection), opts = anchor_1.AnchorProvider.defaultOptions()) {
          const anchorProvider = new anchor_1.AnchorProvider(connection, wallet, opts);
          const program = new anchor_1.Program(whirlpool_json_1.default, programId, anchorProvider);
          return new WhirlpoolContext2(anchorProvider, anchorProvider.wallet, program, fetcher, opts);
        }
        static fromWorkspace(provider, program, fetcher = new public_1.AccountFetcher(provider.connection), opts = anchor_1.AnchorProvider.defaultOptions()) {
          return new WhirlpoolContext2(provider, provider.wallet, program, fetcher, opts);
        }
        static withProvider(provider, programId, fetcher = new public_1.AccountFetcher(provider.connection), opts = anchor_1.AnchorProvider.defaultOptions()) {
          const program = new anchor_1.Program(whirlpool_json_1.default, programId, provider);
          return new WhirlpoolContext2(provider, provider.wallet, program, fetcher, opts);
        }
      };
      exports2.WhirlpoolContext = WhirlpoolContext2;
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/utils/public/tick-utils.js
  var require_tick_utils = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/utils/public/tick-utils.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.TickArrayUtil = exports2.TickUtil = void 0;
      var tiny_invariant_1 = __importDefault(require_tiny_invariant_cjs());
      var public_1 = require_public();
      var pda_utils_1 = require_pda_utils();
      var TickSearchDirection;
      (function(TickSearchDirection2) {
        TickSearchDirection2[TickSearchDirection2["Left"] = 0] = "Left";
        TickSearchDirection2[TickSearchDirection2["Right"] = 1] = "Right";
      })(TickSearchDirection || (TickSearchDirection = {}));
      var TickUtil2 = class {
        constructor() {
        }
        static getStartTickIndex(tickIndex, tickSpacing, offset3 = 0) {
          const realIndex = Math.floor(tickIndex / tickSpacing / public_1.TICK_ARRAY_SIZE);
          const startTickIndex = (realIndex + offset3) * tickSpacing * public_1.TICK_ARRAY_SIZE;
          const ticksInArray = public_1.TICK_ARRAY_SIZE * tickSpacing;
          const minTickIndex = public_1.MIN_TICK_INDEX - (public_1.MIN_TICK_INDEX % ticksInArray + ticksInArray);
          (0, tiny_invariant_1.default)(startTickIndex >= minTickIndex, `startTickIndex is too small - - ${startTickIndex}`);
          (0, tiny_invariant_1.default)(startTickIndex <= public_1.MAX_TICK_INDEX, `startTickIndex is too large - ${startTickIndex}`);
          return startTickIndex;
        }
        static getInitializableTickIndex(tickIndex, tickSpacing) {
          return tickIndex - tickIndex % tickSpacing;
        }
        static getNextInitializableTickIndex(tickIndex, tickSpacing) {
          return TickUtil2.getInitializableTickIndex(tickIndex, tickSpacing) + tickSpacing;
        }
        static getPrevInitializableTickIndex(tickIndex, tickSpacing) {
          return TickUtil2.getInitializableTickIndex(tickIndex, tickSpacing) - tickSpacing;
        }
        static findPreviousInitializedTickIndex(account, currentTickIndex, tickSpacing) {
          return TickUtil2.findInitializedTick(account, currentTickIndex, tickSpacing, TickSearchDirection.Left);
        }
        static findNextInitializedTickIndex(account, currentTickIndex, tickSpacing) {
          return TickUtil2.findInitializedTick(account, currentTickIndex, tickSpacing, TickSearchDirection.Right);
        }
        static findInitializedTick(account, currentTickIndex, tickSpacing, searchDirection) {
          var _a;
          const currentTickArrayIndex = tickIndexToInnerIndex(account.startTickIndex, currentTickIndex, tickSpacing);
          const increment = searchDirection === TickSearchDirection.Right ? 1 : -1;
          let stepInitializedTickArrayIndex = searchDirection === TickSearchDirection.Right ? currentTickArrayIndex + increment : currentTickArrayIndex;
          while (stepInitializedTickArrayIndex >= 0 && stepInitializedTickArrayIndex < account.ticks.length) {
            if ((_a = account.ticks[stepInitializedTickArrayIndex]) === null || _a === void 0 ? void 0 : _a.initialized) {
              return innerIndexToTickIndex(account.startTickIndex, stepInitializedTickArrayIndex, tickSpacing);
            }
            stepInitializedTickArrayIndex += increment;
          }
          return null;
        }
        static checkTickInBounds(tick) {
          return tick <= public_1.MAX_TICK_INDEX && tick >= public_1.MIN_TICK_INDEX;
        }
        static isTickInitializable(tick, tickSpacing) {
          return tick % tickSpacing === 0;
        }
      };
      exports2.TickUtil = TickUtil2;
      var TickArrayUtil2 = class {
        static getTickFromArray(tickArray, tickIndex, tickSpacing) {
          const realIndex = tickIndexToInnerIndex(tickArray.startTickIndex, tickIndex, tickSpacing);
          const tick = tickArray.ticks[realIndex];
          (0, tiny_invariant_1.default)(!!tick, `tick realIndex out of range - start - ${tickArray.startTickIndex} index - ${tickIndex}, realIndex - ${realIndex}`);
          return tick;
        }
        static getTickArrayPDAs(tick, tickSpacing, numOfTickArrays, programId, whirlpoolAddress, aToB) {
          return __awaiter(this, void 0, void 0, function* () {
            let arrayIndexList = [...Array(numOfTickArrays).keys()];
            if (aToB) {
              arrayIndexList = arrayIndexList.map((value) => -value);
            }
            return arrayIndexList.map((value) => {
              const startTick = TickUtil2.getStartTickIndex(tick, tickSpacing, value);
              return pda_utils_1.PDAUtil.getTickArray(programId, whirlpoolAddress, startTick);
            });
          });
        }
        static getUninitializedArraysPDAs(ticks, programId, whirlpoolAddress, tickSpacing, fetcher, refresh) {
          return __awaiter(this, void 0, void 0, function* () {
            const startTicks = ticks.map((tick) => TickUtil2.getStartTickIndex(tick, tickSpacing));
            const removeDupeTicks = [...new Set(startTicks)];
            const tickArrayPDAs = removeDupeTicks.map((tick) => pda_utils_1.PDAUtil.getTickArray(programId, whirlpoolAddress, tick));
            const fetchedArrays = yield fetcher.listTickArrays(tickArrayPDAs.map((pda) => pda.publicKey), refresh);
            const uninitializedIndices = TickArrayUtil2.getUninitializedArrays(fetchedArrays);
            return uninitializedIndices.map((index) => {
              return {
                startIndex: removeDupeTicks[index],
                pda: tickArrayPDAs[index]
              };
            });
          });
        }
        static getUninitializedArrays(tickArrays) {
          return tickArrays.map((value, index) => {
            if (!value) {
              return index;
            }
            return -1;
          }).filter((index) => index >= 0);
        }
      };
      exports2.TickArrayUtil = TickArrayUtil2;
      function tickIndexToInnerIndex(startTickIndex, tickIndex, tickSpacing) {
        return Math.floor((tickIndex - startTickIndex) / tickSpacing);
      }
      function innerIndexToTickIndex(startTickIndex, tickArrayIndex, tickSpacing) {
        return startTickIndex + tickArrayIndex * tickSpacing;
      }
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/utils/public/price-math.js
  var require_price_math = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/utils/public/price-math.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.PriceMath = void 0;
      var common_sdk_1 = require_dist2();
      var anchor_1 = (init_browser(), __toCommonJS(browser_exports));
      var decimal_js_1 = __importDefault(require_decimal());
      var public_1 = require_public();
      var tick_utils_1 = require_tick_utils();
      var BIT_PRECISION = 14;
      var LOG_B_2_X32 = "59543866431248";
      var LOG_B_P_ERR_MARGIN_LOWER_X64 = "184467440737095516";
      var LOG_B_P_ERR_MARGIN_UPPER_X64 = "15793534762490258745";
      var PriceMath2 = class {
        static priceToSqrtPriceX64(price, decimalsA, decimalsB) {
          return common_sdk_1.MathUtil.toX64(price.mul(decimal_js_1.default.pow(10, decimalsB - decimalsA)).sqrt());
        }
        static sqrtPriceX64ToPrice(sqrtPriceX64, decimalsA, decimalsB) {
          return common_sdk_1.MathUtil.fromX64(sqrtPriceX64).pow(2).mul(decimal_js_1.default.pow(10, decimalsA - decimalsB));
        }
        static tickIndexToSqrtPriceX64(tickIndex) {
          if (tickIndex > 0) {
            return new anchor_1.BN(tickIndexToSqrtPricePositive(tickIndex));
          } else {
            return new anchor_1.BN(tickIndexToSqrtPriceNegative(tickIndex));
          }
        }
        static sqrtPriceX64ToTickIndex(sqrtPriceX64) {
          if (sqrtPriceX64.gt(new anchor_1.BN(public_1.MAX_SQRT_PRICE)) || sqrtPriceX64.lt(new anchor_1.BN(public_1.MIN_SQRT_PRICE))) {
            throw new Error("Provided sqrtPrice is not within the supported sqrtPrice range.");
          }
          const msb = sqrtPriceX64.bitLength() - 1;
          const adjustedMsb = new anchor_1.BN(msb - 64);
          const log2pIntegerX32 = signedShiftLeft(adjustedMsb, 32, 128);
          let bit = new anchor_1.BN("8000000000000000", "hex");
          let precision = 0;
          let log2pFractionX64 = new anchor_1.BN(0);
          let r = msb >= 64 ? sqrtPriceX64.shrn(msb - 63) : sqrtPriceX64.shln(63 - msb);
          while (bit.gt(new anchor_1.BN(0)) && precision < BIT_PRECISION) {
            r = r.mul(r);
            let rMoreThanTwo = r.shrn(127);
            r = r.shrn(63 + rMoreThanTwo.toNumber());
            log2pFractionX64 = log2pFractionX64.add(bit.mul(rMoreThanTwo));
            bit = bit.shrn(1);
            precision += 1;
          }
          const log2pFractionX32 = log2pFractionX64.shrn(32);
          const log2pX32 = log2pIntegerX32.add(log2pFractionX32);
          const logbpX64 = log2pX32.mul(new anchor_1.BN(LOG_B_2_X32));
          const tickLow = signedShiftRight(logbpX64.sub(new anchor_1.BN(LOG_B_P_ERR_MARGIN_LOWER_X64)), 64, 128).toNumber();
          const tickHigh = signedShiftRight(logbpX64.add(new anchor_1.BN(LOG_B_P_ERR_MARGIN_UPPER_X64)), 64, 128).toNumber();
          if (tickLow == tickHigh) {
            return tickLow;
          } else {
            const derivedTickHighSqrtPriceX64 = PriceMath2.tickIndexToSqrtPriceX64(tickHigh);
            if (derivedTickHighSqrtPriceX64.lte(sqrtPriceX64)) {
              return tickHigh;
            } else {
              return tickLow;
            }
          }
        }
        static tickIndexToPrice(tickIndex, decimalsA, decimalsB) {
          return PriceMath2.sqrtPriceX64ToPrice(PriceMath2.tickIndexToSqrtPriceX64(tickIndex), decimalsA, decimalsB);
        }
        static priceToTickIndex(price, decimalsA, decimalsB) {
          return PriceMath2.sqrtPriceX64ToTickIndex(PriceMath2.priceToSqrtPriceX64(price, decimalsA, decimalsB));
        }
        static priceToInitializableTickIndex(price, decimalsA, decimalsB, tickSpacing) {
          return tick_utils_1.TickUtil.getInitializableTickIndex(PriceMath2.priceToTickIndex(price, decimalsA, decimalsB), tickSpacing);
        }
      };
      exports2.PriceMath = PriceMath2;
      function tickIndexToSqrtPricePositive(tick) {
        let ratio;
        if ((tick & 1) != 0) {
          ratio = new anchor_1.BN("79232123823359799118286999567");
        } else {
          ratio = new anchor_1.BN("79228162514264337593543950336");
        }
        if ((tick & 2) != 0) {
          ratio = signedShiftRight(ratio.mul(new anchor_1.BN("79236085330515764027303304731")), 96, 256);
        }
        if ((tick & 4) != 0) {
          ratio = signedShiftRight(ratio.mul(new anchor_1.BN("79244008939048815603706035061")), 96, 256);
        }
        if ((tick & 8) != 0) {
          ratio = signedShiftRight(ratio.mul(new anchor_1.BN("79259858533276714757314932305")), 96, 256);
        }
        if ((tick & 16) != 0) {
          ratio = signedShiftRight(ratio.mul(new anchor_1.BN("79291567232598584799939703904")), 96, 256);
        }
        if ((tick & 32) != 0) {
          ratio = signedShiftRight(ratio.mul(new anchor_1.BN("79355022692464371645785046466")), 96, 256);
        }
        if ((tick & 64) != 0) {
          ratio = signedShiftRight(ratio.mul(new anchor_1.BN("79482085999252804386437311141")), 96, 256);
        }
        if ((tick & 128) != 0) {
          ratio = signedShiftRight(ratio.mul(new anchor_1.BN("79736823300114093921829183326")), 96, 256);
        }
        if ((tick & 256) != 0) {
          ratio = signedShiftRight(ratio.mul(new anchor_1.BN("80248749790819932309965073892")), 96, 256);
        }
        if ((tick & 512) != 0) {
          ratio = signedShiftRight(ratio.mul(new anchor_1.BN("81282483887344747381513967011")), 96, 256);
        }
        if ((tick & 1024) != 0) {
          ratio = signedShiftRight(ratio.mul(new anchor_1.BN("83390072131320151908154831281")), 96, 256);
        }
        if ((tick & 2048) != 0) {
          ratio = signedShiftRight(ratio.mul(new anchor_1.BN("87770609709833776024991924138")), 96, 256);
        }
        if ((tick & 4096) != 0) {
          ratio = signedShiftRight(ratio.mul(new anchor_1.BN("97234110755111693312479820773")), 96, 256);
        }
        if ((tick & 8192) != 0) {
          ratio = signedShiftRight(ratio.mul(new anchor_1.BN("119332217159966728226237229890")), 96, 256);
        }
        if ((tick & 16384) != 0) {
          ratio = signedShiftRight(ratio.mul(new anchor_1.BN("179736315981702064433883588727")), 96, 256);
        }
        if ((tick & 32768) != 0) {
          ratio = signedShiftRight(ratio.mul(new anchor_1.BN("407748233172238350107850275304")), 96, 256);
        }
        if ((tick & 65536) != 0) {
          ratio = signedShiftRight(ratio.mul(new anchor_1.BN("2098478828474011932436660412517")), 96, 256);
        }
        if ((tick & 131072) != 0) {
          ratio = signedShiftRight(ratio.mul(new anchor_1.BN("55581415166113811149459800483533")), 96, 256);
        }
        if ((tick & 262144) != 0) {
          ratio = signedShiftRight(ratio.mul(new anchor_1.BN("38992368544603139932233054999993551")), 96, 256);
        }
        return signedShiftRight(ratio, 32, 256);
      }
      function tickIndexToSqrtPriceNegative(tickIndex) {
        let tick = Math.abs(tickIndex);
        let ratio;
        if ((tick & 1) != 0) {
          ratio = new anchor_1.BN("18445821805675392311");
        } else {
          ratio = new anchor_1.BN("18446744073709551616");
        }
        if ((tick & 2) != 0) {
          ratio = signedShiftRight(ratio.mul(new anchor_1.BN("18444899583751176498")), 64, 256);
        }
        if ((tick & 4) != 0) {
          ratio = signedShiftRight(ratio.mul(new anchor_1.BN("18443055278223354162")), 64, 256);
        }
        if ((tick & 8) != 0) {
          ratio = signedShiftRight(ratio.mul(new anchor_1.BN("18439367220385604838")), 64, 256);
        }
        if ((tick & 16) != 0) {
          ratio = signedShiftRight(ratio.mul(new anchor_1.BN("18431993317065449817")), 64, 256);
        }
        if ((tick & 32) != 0) {
          ratio = signedShiftRight(ratio.mul(new anchor_1.BN("18417254355718160513")), 64, 256);
        }
        if ((tick & 64) != 0) {
          ratio = signedShiftRight(ratio.mul(new anchor_1.BN("18387811781193591352")), 64, 256);
        }
        if ((tick & 128) != 0) {
          ratio = signedShiftRight(ratio.mul(new anchor_1.BN("18329067761203520168")), 64, 256);
        }
        if ((tick & 256) != 0) {
          ratio = signedShiftRight(ratio.mul(new anchor_1.BN("18212142134806087854")), 64, 256);
        }
        if ((tick & 512) != 0) {
          ratio = signedShiftRight(ratio.mul(new anchor_1.BN("17980523815641551639")), 64, 256);
        }
        if ((tick & 1024) != 0) {
          ratio = signedShiftRight(ratio.mul(new anchor_1.BN("17526086738831147013")), 64, 256);
        }
        if ((tick & 2048) != 0) {
          ratio = signedShiftRight(ratio.mul(new anchor_1.BN("16651378430235024244")), 64, 256);
        }
        if ((tick & 4096) != 0) {
          ratio = signedShiftRight(ratio.mul(new anchor_1.BN("15030750278693429944")), 64, 256);
        }
        if ((tick & 8192) != 0) {
          ratio = signedShiftRight(ratio.mul(new anchor_1.BN("12247334978882834399")), 64, 256);
        }
        if ((tick & 16384) != 0) {
          ratio = signedShiftRight(ratio.mul(new anchor_1.BN("8131365268884726200")), 64, 256);
        }
        if ((tick & 32768) != 0) {
          ratio = signedShiftRight(ratio.mul(new anchor_1.BN("3584323654723342297")), 64, 256);
        }
        if ((tick & 65536) != 0) {
          ratio = signedShiftRight(ratio.mul(new anchor_1.BN("696457651847595233")), 64, 256);
        }
        if ((tick & 131072) != 0) {
          ratio = signedShiftRight(ratio.mul(new anchor_1.BN("26294789957452057")), 64, 256);
        }
        if ((tick & 262144) != 0) {
          ratio = signedShiftRight(ratio.mul(new anchor_1.BN("37481735321082")), 64, 256);
        }
        return ratio;
      }
      function signedShiftLeft(n0, shiftBy, bitWidth) {
        let twosN0 = n0.toTwos(bitWidth).shln(shiftBy);
        twosN0.imaskn(bitWidth + 1);
        return twosN0.fromTwos(bitWidth);
      }
      function signedShiftRight(n0, shiftBy, bitWidth) {
        let twoN0 = n0.toTwos(bitWidth).shrn(shiftBy);
        twoN0.imaskn(bitWidth - shiftBy + 1);
        return twoN0.fromTwos(bitWidth - shiftBy);
      }
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/utils/public/pda-utils.js
  var require_pda_utils = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/utils/public/pda-utils.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.PDAUtil = void 0;
      var common_sdk_1 = require_dist2();
      var anchor_1 = (init_browser(), __toCommonJS(browser_exports));
      var public_1 = require_public();
      var price_math_1 = require_price_math();
      var tick_utils_1 = require_tick_utils();
      var PDA_WHIRLPOOL_SEED = "whirlpool";
      var PDA_POSITION_SEED = "position";
      var PDA_METADATA_SEED = "metadata";
      var PDA_TICK_ARRAY_SEED = "tick_array";
      var PDA_FEE_TIER_SEED = "fee_tier";
      var PDA_ORACLE_SEED = "oracle";
      var PDAUtil2 = class {
        static getWhirlpool(programId, whirlpoolsConfigKey, tokenMintAKey, tokenMintBKey, tickSpacing) {
          return common_sdk_1.AddressUtil.findProgramAddress([
            Buffer.from(PDA_WHIRLPOOL_SEED),
            whirlpoolsConfigKey.toBuffer(),
            tokenMintAKey.toBuffer(),
            tokenMintBKey.toBuffer(),
            new anchor_1.BN(tickSpacing).toArrayLike(Buffer, "le", 2)
          ], programId);
        }
        static getPosition(programId, positionMintKey) {
          return common_sdk_1.AddressUtil.findProgramAddress([Buffer.from(PDA_POSITION_SEED), positionMintKey.toBuffer()], programId);
        }
        static getPositionMetadata(positionMintKey) {
          return common_sdk_1.AddressUtil.findProgramAddress([
            Buffer.from(PDA_METADATA_SEED),
            public_1.METADATA_PROGRAM_ADDRESS.toBuffer(),
            positionMintKey.toBuffer()
          ], public_1.METADATA_PROGRAM_ADDRESS);
        }
        static getTickArray(programId, whirlpoolAddress, startTick) {
          return common_sdk_1.AddressUtil.findProgramAddress([
            Buffer.from(PDA_TICK_ARRAY_SEED),
            whirlpoolAddress.toBuffer(),
            Buffer.from(startTick.toString())
          ], programId);
        }
        static getTickArrayFromTickIndex(tickIndex, tickSpacing, whirlpool, programId, tickArrayOffset = 0) {
          const startIndex = tick_utils_1.TickUtil.getStartTickIndex(tickIndex, tickSpacing, tickArrayOffset);
          return PDAUtil2.getTickArray(common_sdk_1.AddressUtil.toPubKey(programId), common_sdk_1.AddressUtil.toPubKey(whirlpool), startIndex);
        }
        static getTickArrayFromSqrtPrice(sqrtPriceX64, tickSpacing, whirlpool, programId, tickArrayOffset = 0) {
          const tickIndex = price_math_1.PriceMath.sqrtPriceX64ToTickIndex(sqrtPriceX64);
          return PDAUtil2.getTickArrayFromTickIndex(tickIndex, tickSpacing, whirlpool, programId, tickArrayOffset);
        }
        static getFeeTier(programId, whirlpoolsConfigAddress, tickSpacing) {
          return common_sdk_1.AddressUtil.findProgramAddress([
            Buffer.from(PDA_FEE_TIER_SEED),
            whirlpoolsConfigAddress.toBuffer(),
            new anchor_1.BN(tickSpacing).toArrayLike(Buffer, "le", 2)
          ], programId);
        }
        static getOracle(programId, whirlpoolAddress) {
          return common_sdk_1.AddressUtil.findProgramAddress([Buffer.from(PDA_ORACLE_SEED), whirlpoolAddress.toBuffer()], programId);
        }
      };
      exports2.PDAUtil = PDAUtil2;
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/utils/public/types.js
  var require_types3 = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/utils/public/types.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.TokenType = exports2.SwapDirection = void 0;
      var SwapDirection;
      (function(SwapDirection2) {
        SwapDirection2["AtoB"] = "aToB";
        SwapDirection2["BtoA"] = "bToA";
      })(SwapDirection = exports2.SwapDirection || (exports2.SwapDirection = {}));
      var TokenType;
      (function(TokenType2) {
        TokenType2[TokenType2["TokenA"] = 1] = "TokenA";
        TokenType2[TokenType2["TokenB"] = 2] = "TokenB";
      })(TokenType = exports2.TokenType || (exports2.TokenType = {}));
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/utils/public/pool-utils.js
  var require_pool_utils = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/utils/public/pool-utils.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.toTokenAmount = exports2.PoolUtil = void 0;
      var common_sdk_1 = require_dist2();
      var anchor_1 = (init_browser(), __toCommonJS(browser_exports));
      var spl_token_1 = (init_index_browser_esm2(), __toCommonJS(index_browser_esm_exports2));
      var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
      var decimal_js_1 = __importDefault(require_decimal());
      var price_math_1 = require_price_math();
      var types_1 = require_types3();
      var PoolUtil2 = class {
        constructor() {
        }
        static isRewardInitialized(rewardInfo) {
          return !web3_js_1.PublicKey.default.equals(rewardInfo.mint) && !web3_js_1.PublicKey.default.equals(rewardInfo.vault);
        }
        static getTokenType(pool, mint) {
          if (pool.tokenMintA.equals(mint)) {
            return types_1.TokenType.TokenA;
          } else if (pool.tokenMintB.equals(mint)) {
            return types_1.TokenType.TokenB;
          }
          return void 0;
        }
        static getFeeRate(feeRate) {
          return common_sdk_1.Percentage.fromFraction(feeRate, 1e6);
        }
        static getProtocolFeeRate(protocolFeeRate) {
          return common_sdk_1.Percentage.fromFraction(protocolFeeRate, 1e4);
        }
        static orderMints(mintX, mintY) {
          let mintA, mintB;
          if (Buffer.compare(common_sdk_1.AddressUtil.toPubKey(mintX).toBuffer(), common_sdk_1.AddressUtil.toPubKey(mintY).toBuffer()) < 0) {
            mintA = mintX;
            mintB = mintY;
          } else {
            mintA = mintY;
            mintB = mintX;
          }
          return [mintA, mintB];
        }
        static getTokenAmountsFromLiquidity(liquidity, currentPrice, lowerPrice, upperPrice, round_up) {
          const _liquidity = new decimal_js_1.default(liquidity.toString());
          const _currentPrice = new decimal_js_1.default(currentPrice.toString());
          const _lowerPrice = new decimal_js_1.default(lowerPrice.toString());
          const _upperPrice = new decimal_js_1.default(upperPrice.toString());
          let tokenA, tokenB;
          if (currentPrice.lt(lowerPrice)) {
            tokenA = common_sdk_1.MathUtil.toX64_Decimal(_liquidity).mul(_upperPrice.sub(_lowerPrice)).div(_lowerPrice.mul(_upperPrice));
            tokenB = new decimal_js_1.default(0);
          } else if (currentPrice.lt(upperPrice)) {
            tokenA = common_sdk_1.MathUtil.toX64_Decimal(_liquidity).mul(_upperPrice.sub(_currentPrice)).div(_currentPrice.mul(_upperPrice));
            tokenB = common_sdk_1.MathUtil.fromX64_Decimal(_liquidity.mul(_currentPrice.sub(_lowerPrice)));
          } else {
            tokenA = new decimal_js_1.default(0);
            tokenB = common_sdk_1.MathUtil.fromX64_Decimal(_liquidity.mul(_upperPrice.sub(_lowerPrice)));
          }
          if (round_up) {
            return {
              tokenA: new spl_token_1.u64(tokenA.ceil().toString()),
              tokenB: new spl_token_1.u64(tokenB.ceil().toString())
            };
          } else {
            return {
              tokenA: new spl_token_1.u64(tokenA.floor().toString()),
              tokenB: new spl_token_1.u64(tokenB.floor().toString())
            };
          }
        }
        static estimateLiquidityFromTokenAmounts(currTick, lowerTick, upperTick, tokenAmount) {
          if (upperTick < lowerTick) {
            throw new Error("upper tick cannot be lower than the lower tick");
          }
          const currSqrtPrice = price_math_1.PriceMath.tickIndexToSqrtPriceX64(currTick);
          const lowerSqrtPrice = price_math_1.PriceMath.tickIndexToSqrtPriceX64(lowerTick);
          const upperSqrtPrice = price_math_1.PriceMath.tickIndexToSqrtPriceX64(upperTick);
          if (currTick >= upperTick) {
            return estLiquidityForTokenB(upperSqrtPrice, lowerSqrtPrice, tokenAmount.tokenB);
          } else if (currTick < lowerTick) {
            return estLiquidityForTokenA(lowerSqrtPrice, upperSqrtPrice, tokenAmount.tokenA);
          } else {
            const estLiquidityAmountA = estLiquidityForTokenA(currSqrtPrice, upperSqrtPrice, tokenAmount.tokenA);
            const estLiquidityAmountB = estLiquidityForTokenB(currSqrtPrice, lowerSqrtPrice, tokenAmount.tokenB);
            return anchor_1.BN.min(estLiquidityAmountA, estLiquidityAmountB);
          }
        }
        static toBaseQuoteOrder(tokenMintAKey, tokenMintBKey) {
          const pair = [tokenMintAKey, tokenMintBKey];
          return pair.sort(sortByQuotePriority);
        }
      };
      exports2.PoolUtil = PoolUtil2;
      function toTokenAmount(a, b2) {
        return {
          tokenA: new spl_token_1.u64(a.toString()),
          tokenB: new spl_token_1.u64(b2.toString())
        };
      }
      exports2.toTokenAmount = toTokenAmount;
      var QUOTE_TOKENS = {
        Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB: 100,
        EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v: 90,
        USDH1SM1ojwWUga67PGrgFWUHibbjqMvuMaDkRJTgkX: 80,
        So11111111111111111111111111111111111111112: 70,
        mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So: 60,
        "7dHbWXmci3dT8UFYWYZweBLXgycu7Y3iL6trKn1Y7ARj": 50
      };
      var DEFAULT_QUOTE_PRIORITY = 0;
      function getQuoteTokenPriority(mint) {
        const value = QUOTE_TOKENS[mint];
        if (value) {
          return value;
        }
        return DEFAULT_QUOTE_PRIORITY;
      }
      function sortByQuotePriority(mintLeft, mintRight) {
        return getQuoteTokenPriority(mintLeft.toString()) - getQuoteTokenPriority(mintRight.toString());
      }
      function estLiquidityForTokenA(sqrtPrice1, sqrtPrice2, tokenAmount) {
        const lowerSqrtPriceX64 = anchor_1.BN.min(sqrtPrice1, sqrtPrice2);
        const upperSqrtPriceX64 = anchor_1.BN.max(sqrtPrice1, sqrtPrice2);
        const num = common_sdk_1.MathUtil.fromX64_BN(tokenAmount.mul(upperSqrtPriceX64).mul(lowerSqrtPriceX64));
        const dem = upperSqrtPriceX64.sub(lowerSqrtPriceX64);
        return num.div(dem);
      }
      function estLiquidityForTokenB(sqrtPrice1, sqrtPrice2, tokenAmount) {
        const lowerSqrtPriceX64 = anchor_1.BN.min(sqrtPrice1, sqrtPrice2);
        const upperSqrtPriceX64 = anchor_1.BN.max(sqrtPrice1, sqrtPrice2);
        const delta = upperSqrtPriceX64.sub(lowerSqrtPriceX64);
        return tokenAmount.shln(64).div(delta);
      }
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/utils/public/ix-utils.js
  var require_ix_utils = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/utils/public/ix-utils.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.toTx = void 0;
      var common_sdk_1 = require_dist2();
      function toTx(ctx, ix) {
        return new common_sdk_1.TransactionBuilder(ctx.provider.connection, ctx.provider.wallet).addInstruction(ix);
      }
      exports2.toTx = toTx;
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/errors/errors.js
  var require_errors2 = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/errors/errors.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.WhirlpoolsError = exports2.SwapErrorCode = exports2.TokenErrorCode = exports2.MathErrorCode = void 0;
      var MathErrorCode;
      (function(MathErrorCode2) {
        MathErrorCode2["MultiplicationOverflow"] = "MultiplicationOverflow";
        MathErrorCode2["MulDivOverflow"] = "MulDivOverflow";
        MathErrorCode2["MultiplicationShiftRightOverflow"] = "MultiplicationShiftRightOverflow";
        MathErrorCode2["DivideByZero"] = "DivideByZero";
      })(MathErrorCode = exports2.MathErrorCode || (exports2.MathErrorCode = {}));
      var TokenErrorCode;
      (function(TokenErrorCode2) {
        TokenErrorCode2["TokenMaxExceeded"] = "TokenMaxExceeded";
        TokenErrorCode2["TokenMinSubceeded"] = "TokenMinSubceeded";
      })(TokenErrorCode = exports2.TokenErrorCode || (exports2.TokenErrorCode = {}));
      var SwapErrorCode;
      (function(SwapErrorCode2) {
        SwapErrorCode2["InvalidSqrtPriceLimitDirection"] = "InvalidSqrtPriceLimitDirection";
        SwapErrorCode2["SqrtPriceOutOfBounds"] = "SqrtPriceOutOfBounds";
        SwapErrorCode2["ZeroTradableAmount"] = "ZeroTradableAmount";
        SwapErrorCode2["AmountOutBelowMinimum"] = "AmountOutBelowMinimum";
        SwapErrorCode2["AmountInAboveMaximum"] = "AmountInAboveMaximum";
        SwapErrorCode2["TickArrayCrossingAboveMax"] = "TickArrayCrossingAboveMax";
        SwapErrorCode2["TickArrayIndexNotInitialized"] = "TickArrayIndexNotInitialized";
        SwapErrorCode2["TickArraySequenceInvalid"] = "TickArraySequenceInvalid";
      })(SwapErrorCode = exports2.SwapErrorCode || (exports2.SwapErrorCode = {}));
      var WhirlpoolsError = class extends Error {
        constructor(message, errorCode) {
          super(message);
          this.message = message;
          this.errorCode = errorCode;
        }
        static isWhirlpoolsErrorCode(e, code2) {
          return e instanceof WhirlpoolsError && e.errorCode === code2;
        }
      };
      exports2.WhirlpoolsError = WhirlpoolsError;
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/utils/math/bit-math.js
  var require_bit_math = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/utils/math/bit-math.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.BitMath = void 0;
      var common_sdk_1 = require_dist2();
      var anchor_1 = (init_browser(), __toCommonJS(browser_exports));
      var errors_1 = require_errors2();
      var BitMath = class {
        static mul(n0, n1, limit) {
          const result = n0.mul(n1);
          if (this.isOverLimit(result, limit)) {
            throw new errors_1.WhirlpoolsError(`Mul result higher than u${limit}`, errors_1.MathErrorCode.MultiplicationOverflow);
          }
          return result;
        }
        static mulDiv(n0, n1, d2, limit) {
          return this.mulDivRoundUpIf(n0, n1, d2, false, limit);
        }
        static mulDivRoundUp(n0, n1, d2, limit) {
          return this.mulDivRoundUpIf(n0, n1, d2, true, limit);
        }
        static mulDivRoundUpIf(n0, n1, d2, roundUp, limit) {
          if (d2.eq(common_sdk_1.ZERO)) {
            throw new errors_1.WhirlpoolsError("mulDiv denominator is zero", errors_1.MathErrorCode.DivideByZero);
          }
          const p2 = this.mul(n0, n1, limit);
          const n = p2.div(d2);
          return roundUp && p2.mod(d2).gt(common_sdk_1.ZERO) ? n.add(common_sdk_1.ONE) : n;
        }
        static checked_mul_shift_right(n0, n1, limit) {
          return this.checked_mul_shift_right_round_up_if(n0, n1, false, limit);
        }
        static checked_mul_shift_right_round_up_if(n0, n1, roundUp, limit) {
          if (n0.eq(common_sdk_1.ZERO) || n1.eq(common_sdk_1.ZERO)) {
            return common_sdk_1.ZERO;
          }
          const p2 = this.mul(n0, n1, limit);
          if (this.isOverLimit(p2, limit)) {
            throw new errors_1.WhirlpoolsError(`MulShiftRight overflowed u${limit}.`, errors_1.MathErrorCode.MultiplicationShiftRightOverflow);
          }
          const result = common_sdk_1.MathUtil.fromX64_BN(p2);
          const shouldRound = roundUp && result.and(common_sdk_1.U64_MAX).gt(common_sdk_1.ZERO);
          if (shouldRound && result.eq(common_sdk_1.U64_MAX)) {
            throw new errors_1.WhirlpoolsError(`MulShiftRight overflowed u${limit}.`, errors_1.MathErrorCode.MultiplicationOverflow);
          }
          return shouldRound ? result.add(common_sdk_1.ONE) : result;
        }
        static isOverLimit(n0, limit) {
          const limitBN = common_sdk_1.TWO.pow(new anchor_1.BN(limit)).sub(common_sdk_1.ONE);
          return n0.gt(limitBN);
        }
        static divRoundUp(n, d2) {
          return this.divRoundUpIf(n, d2, true);
        }
        static divRoundUpIf(n, d2, roundUp) {
          if (d2.eq(common_sdk_1.ZERO)) {
            throw new errors_1.WhirlpoolsError("divRoundUpIf - divide by zero", errors_1.MathErrorCode.DivideByZero);
          }
          let q2 = n.div(d2);
          return roundUp && n.mod(d2).gt(common_sdk_1.ZERO) ? q2.add(common_sdk_1.ONE) : q2;
        }
      };
      exports2.BitMath = BitMath;
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/utils/math/token-math.js
  var require_token_math = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/utils/math/token-math.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.adjustForSlippage = exports2.getNextSqrtPrice = exports2.getAmountDeltaB = exports2.getAmountDeltaA = void 0;
      var common_sdk_1 = require_dist2();
      var anchor_1 = (init_browser(), __toCommonJS(browser_exports));
      var errors_1 = require_errors2();
      var public_1 = require_public();
      var bit_math_1 = require_bit_math();
      function getAmountDeltaA(currSqrtPrice, targetSqrtPrice, currLiquidity, roundUp) {
        let [sqrtPriceLower, sqrtPriceUpper] = toIncreasingPriceOrder(currSqrtPrice, targetSqrtPrice);
        let sqrtPriceDiff = sqrtPriceUpper.sub(sqrtPriceLower);
        let numerator = currLiquidity.mul(sqrtPriceDiff).shln(64);
        let denominator = sqrtPriceLower.mul(sqrtPriceUpper);
        let quotient = numerator.div(denominator);
        let remainder = numerator.mod(denominator);
        let result = roundUp && !remainder.eq(common_sdk_1.ZERO) ? quotient.add(new anchor_1.BN(1)) : quotient;
        if (result.gt(common_sdk_1.U64_MAX)) {
          throw new errors_1.WhirlpoolsError("Results larger than U64", errors_1.TokenErrorCode.TokenMaxExceeded);
        }
        return result;
      }
      exports2.getAmountDeltaA = getAmountDeltaA;
      function getAmountDeltaB(currSqrtPrice, targetSqrtPrice, currLiquidity, roundUp) {
        let [sqrtPriceLower, sqrtPriceUpper] = toIncreasingPriceOrder(currSqrtPrice, targetSqrtPrice);
        let sqrtPriceDiff = sqrtPriceUpper.sub(sqrtPriceLower);
        return bit_math_1.BitMath.checked_mul_shift_right_round_up_if(currLiquidity, sqrtPriceDiff, roundUp, 128);
      }
      exports2.getAmountDeltaB = getAmountDeltaB;
      function getNextSqrtPrice(sqrtPrice, currLiquidity, amount, amountSpecifiedIsInput, aToB) {
        if (amountSpecifiedIsInput === aToB) {
          return getNextSqrtPriceFromARoundUp(sqrtPrice, currLiquidity, amount, amountSpecifiedIsInput);
        } else {
          return getNextSqrtPriceFromBRoundDown(sqrtPrice, currLiquidity, amount, amountSpecifiedIsInput);
        }
      }
      exports2.getNextSqrtPrice = getNextSqrtPrice;
      function adjustForSlippage(n, { numerator, denominator }, adjustUp) {
        if (adjustUp) {
          return n.mul(denominator.add(numerator)).div(denominator);
        } else {
          return n.mul(denominator).div(denominator.add(numerator));
        }
      }
      exports2.adjustForSlippage = adjustForSlippage;
      function toIncreasingPriceOrder(sqrtPrice0, sqrtPrice1) {
        if (sqrtPrice0.gt(sqrtPrice1)) {
          return [sqrtPrice1, sqrtPrice0];
        } else {
          return [sqrtPrice0, sqrtPrice1];
        }
      }
      function getNextSqrtPriceFromARoundUp(sqrtPrice, currLiquidity, amount, amountSpecifiedIsInput) {
        if (amount.eq(common_sdk_1.ZERO)) {
          return sqrtPrice;
        }
        let p2 = bit_math_1.BitMath.mul(sqrtPrice, amount, 256);
        let numerator = bit_math_1.BitMath.mul(currLiquidity, sqrtPrice, 256).shln(64);
        if (bit_math_1.BitMath.isOverLimit(numerator, 256)) {
          throw new errors_1.WhirlpoolsError("getNextSqrtPriceFromARoundUp - numerator overflow u256", errors_1.MathErrorCode.MultiplicationOverflow);
        }
        let currLiquidityShiftLeft = currLiquidity.shln(64);
        if (!amountSpecifiedIsInput && currLiquidityShiftLeft.lte(p2)) {
          throw new errors_1.WhirlpoolsError("getNextSqrtPriceFromARoundUp - Unable to divide currLiquidityX64 by product", errors_1.MathErrorCode.DivideByZero);
        }
        let denominator = amountSpecifiedIsInput ? currLiquidityShiftLeft.add(p2) : currLiquidityShiftLeft.sub(p2);
        let price = bit_math_1.BitMath.divRoundUp(numerator, denominator);
        if (price.lt(new anchor_1.BN(public_1.MIN_SQRT_PRICE))) {
          throw new errors_1.WhirlpoolsError("getNextSqrtPriceFromARoundUp - price less than min sqrt price", errors_1.TokenErrorCode.TokenMinSubceeded);
        } else if (price.gt(new anchor_1.BN(public_1.MAX_SQRT_PRICE))) {
          throw new errors_1.WhirlpoolsError("getNextSqrtPriceFromARoundUp - price less than max sqrt price", errors_1.TokenErrorCode.TokenMaxExceeded);
        }
        return price;
      }
      function getNextSqrtPriceFromBRoundDown(sqrtPrice, currLiquidity, amount, amountSpecifiedIsInput) {
        let amountX64 = amount.shln(64);
        let delta = bit_math_1.BitMath.divRoundUpIf(amountX64, currLiquidity, !amountSpecifiedIsInput);
        if (amountSpecifiedIsInput) {
          sqrtPrice = sqrtPrice.add(delta);
        } else {
          sqrtPrice = sqrtPrice.sub(delta);
        }
        return sqrtPrice;
      }
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/utils/public/swap-utils.js
  var require_swap_utils = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/utils/public/swap-utils.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.SwapUtils = void 0;
      var common_sdk_1 = require_dist2();
      var bn_js_1 = __importDefault(require_bn());
      var public_1 = require_public();
      var token_math_1 = require_token_math();
      var pda_utils_1 = require_pda_utils();
      var pool_utils_1 = require_pool_utils();
      var tick_utils_1 = require_tick_utils();
      var types_1 = require_types3();
      var SwapUtils2 = class {
        static getDefaultSqrtPriceLimit(aToB) {
          return new bn_js_1.default(aToB ? public_1.MIN_SQRT_PRICE : public_1.MAX_SQRT_PRICE);
        }
        static getDefaultOtherAmountThreshold(amountSpecifiedIsInput) {
          return amountSpecifiedIsInput ? common_sdk_1.ZERO : common_sdk_1.U64_MAX;
        }
        static getSwapDirection(pool, swapTokenMint, swapTokenIsInput) {
          const tokenType = pool_utils_1.PoolUtil.getTokenType(pool, swapTokenMint);
          if (!tokenType) {
            return void 0;
          }
          return tokenType === types_1.TokenType.TokenA === swapTokenIsInput ? types_1.SwapDirection.AtoB : types_1.SwapDirection.BtoA;
        }
        static getTickArrayPublicKeys(tickCurrentIndex, tickSpacing, aToB, programId, whirlpoolAddress) {
          let offset3 = 0;
          let tickArrayAddresses = [];
          for (let i = 0; i < public_1.MAX_SWAP_TICK_ARRAYS; i++) {
            let startIndex;
            try {
              startIndex = tick_utils_1.TickUtil.getStartTickIndex(tickCurrentIndex, tickSpacing, offset3);
            } catch (_a) {
              return tickArrayAddresses;
            }
            const pda = pda_utils_1.PDAUtil.getTickArray(programId, whirlpoolAddress, startIndex);
            tickArrayAddresses.push(pda.publicKey);
            offset3 = aToB ? offset3 - 1 : offset3 + 1;
          }
          return tickArrayAddresses;
        }
        static getTickArrays(tickCurrentIndex, tickSpacing, aToB, programId, whirlpoolAddress, fetcher, refresh) {
          return __awaiter(this, void 0, void 0, function* () {
            const addresses = SwapUtils2.getTickArrayPublicKeys(tickCurrentIndex, tickSpacing, aToB, programId, whirlpoolAddress);
            const data = yield fetcher.listTickArrays(addresses, refresh);
            return addresses.map((addr, index) => {
              return {
                address: addr,
                data: data[index]
              };
            });
          });
        }
        static calculateSwapAmountsFromQuote(amount, estAmountIn, estAmountOut, slippageTolerance, amountSpecifiedIsInput) {
          if (amountSpecifiedIsInput) {
            return {
              amount,
              otherAmountThreshold: (0, token_math_1.adjustForSlippage)(estAmountOut, slippageTolerance, false)
            };
          } else {
            return {
              amount,
              otherAmountThreshold: (0, token_math_1.adjustForSlippage)(estAmountIn, slippageTolerance, true)
            };
          }
        }
      };
      exports2.SwapUtils = SwapUtils2;
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/utils/public/index.js
  var require_public3 = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/utils/public/index.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        var desc = Object.getOwnPropertyDescriptor(m, k2);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k2];
          } };
        }
        Object.defineProperty(o, k22, desc);
      } : function(o, m, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o[k22] = m[k2];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p2 in m)
          if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
            __createBinding(exports3, m, p2);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar(require_pda_utils(), exports2);
      __exportStar(require_price_math(), exports2);
      __exportStar(require_tick_utils(), exports2);
      __exportStar(require_pool_utils(), exports2);
      __exportStar(require_ix_utils(), exports2);
      __exportStar(require_types3(), exports2);
      __exportStar(require_swap_utils(), exports2);
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/utils/swap-utils.js
  var require_swap_utils2 = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/utils/swap-utils.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getUpperSqrtPriceFromTokenB = exports2.getLowerSqrtPriceFromTokenB = exports2.getUpperSqrtPriceFromTokenA = exports2.getLowerSqrtPriceFromTokenA = void 0;
      var common_sdk_1 = require_dist2();
      function getLowerSqrtPriceFromTokenA(amount, liquidity, sqrtPriceX64) {
        const numerator = liquidity.mul(sqrtPriceX64).shln(64);
        const denominator = liquidity.shln(64).add(amount.mul(sqrtPriceX64));
        return common_sdk_1.MathUtil.divRoundUp(numerator, denominator);
      }
      exports2.getLowerSqrtPriceFromTokenA = getLowerSqrtPriceFromTokenA;
      function getUpperSqrtPriceFromTokenA(amount, liquidity, sqrtPriceX64) {
        const numerator = liquidity.mul(sqrtPriceX64).shln(64);
        const denominator = liquidity.shln(64).sub(amount.mul(sqrtPriceX64));
        return common_sdk_1.MathUtil.divRoundUp(numerator, denominator);
      }
      exports2.getUpperSqrtPriceFromTokenA = getUpperSqrtPriceFromTokenA;
      function getLowerSqrtPriceFromTokenB(amount, liquidity, sqrtPriceX64) {
        return sqrtPriceX64.sub(common_sdk_1.MathUtil.divRoundUp(amount.shln(64), liquidity));
      }
      exports2.getLowerSqrtPriceFromTokenB = getLowerSqrtPriceFromTokenB;
      function getUpperSqrtPriceFromTokenB(amount, liquidity, sqrtPriceX64) {
        return sqrtPriceX64.add(amount.shln(64).div(liquidity));
      }
      exports2.getUpperSqrtPriceFromTokenB = getUpperSqrtPriceFromTokenB;
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/utils/position-util.js
  var require_position_util = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/utils/position-util.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getTokenBFromLiquidity = exports2.getTokenAFromLiquidity = exports2.getNextSqrtPrice = exports2.getAmountUnfixedDelta = exports2.getAmountFixedDelta = exports2.getLiquidityFromTokenB = exports2.getLiquidityFromTokenA = exports2.adjustAmountForSlippage = exports2.adjustForSlippage = exports2.PositionUtil = exports2.PositionStatus = exports2.AmountSpecified = exports2.SwapDirection = void 0;
      var common_sdk_1 = require_dist2();
      var swap_utils_1 = require_swap_utils2();
      var SwapDirection;
      (function(SwapDirection2) {
        SwapDirection2["AtoB"] = "Swap A to B";
        SwapDirection2["BtoA"] = "Swap B to A";
      })(SwapDirection = exports2.SwapDirection || (exports2.SwapDirection = {}));
      var AmountSpecified;
      (function(AmountSpecified2) {
        AmountSpecified2["Input"] = "Specified input amount";
        AmountSpecified2["Output"] = "Specified output amount";
      })(AmountSpecified = exports2.AmountSpecified || (exports2.AmountSpecified = {}));
      var PositionStatus;
      (function(PositionStatus2) {
        PositionStatus2[PositionStatus2["BelowRange"] = 0] = "BelowRange";
        PositionStatus2[PositionStatus2["InRange"] = 1] = "InRange";
        PositionStatus2[PositionStatus2["AboveRange"] = 2] = "AboveRange";
      })(PositionStatus = exports2.PositionStatus || (exports2.PositionStatus = {}));
      var PositionUtil = class {
        constructor() {
        }
        static getPositionStatus(tickCurrentIndex, tickLowerIndex, tickUpperIndex) {
          if (tickCurrentIndex < tickLowerIndex) {
            return PositionStatus.BelowRange;
          } else if (tickCurrentIndex < tickUpperIndex) {
            return PositionStatus.InRange;
          } else {
            return PositionStatus.AboveRange;
          }
        }
      };
      exports2.PositionUtil = PositionUtil;
      function adjustForSlippage(n, { numerator, denominator }, adjustUp) {
        if (adjustUp) {
          return n.mul(denominator.add(numerator)).div(denominator);
        } else {
          return n.mul(denominator).div(denominator.add(numerator));
        }
      }
      exports2.adjustForSlippage = adjustForSlippage;
      function adjustAmountForSlippage(amountIn, amountOut, { numerator, denominator }, amountSpecified) {
        if (amountSpecified === AmountSpecified.Input) {
          return amountOut.mul(denominator).div(denominator.add(numerator));
        } else {
          return amountIn.mul(denominator.add(numerator)).div(denominator);
        }
      }
      exports2.adjustAmountForSlippage = adjustAmountForSlippage;
      function getLiquidityFromTokenA(amount, sqrtPriceLowerX64, sqrtPriceUpperX64, roundUp) {
        const result = amount.mul(sqrtPriceLowerX64).mul(sqrtPriceUpperX64).div(sqrtPriceUpperX64.sub(sqrtPriceLowerX64));
        if (roundUp) {
          return common_sdk_1.MathUtil.shiftRightRoundUp(result);
        } else {
          return result.shrn(64);
        }
      }
      exports2.getLiquidityFromTokenA = getLiquidityFromTokenA;
      function getLiquidityFromTokenB(amount, sqrtPriceLowerX64, sqrtPriceUpperX64, roundUp) {
        const numerator = amount.shln(64);
        const denominator = sqrtPriceUpperX64.sub(sqrtPriceLowerX64);
        if (roundUp) {
          return common_sdk_1.MathUtil.divRoundUp(numerator, denominator);
        } else {
          return numerator.div(denominator);
        }
      }
      exports2.getLiquidityFromTokenB = getLiquidityFromTokenB;
      function getAmountFixedDelta(currentSqrtPriceX64, targetSqrtPriceX64, liquidity, amountSpecified, swapDirection) {
        if (amountSpecified == AmountSpecified.Input == (swapDirection == SwapDirection.AtoB)) {
          return getTokenAFromLiquidity(liquidity, currentSqrtPriceX64, targetSqrtPriceX64, amountSpecified == AmountSpecified.Input);
        } else {
          return getTokenBFromLiquidity(liquidity, currentSqrtPriceX64, targetSqrtPriceX64, amountSpecified == AmountSpecified.Input);
        }
      }
      exports2.getAmountFixedDelta = getAmountFixedDelta;
      function getAmountUnfixedDelta(currentSqrtPriceX64, targetSqrtPriceX64, liquidity, amountSpecified, swapDirection) {
        if (amountSpecified == AmountSpecified.Input == (swapDirection == SwapDirection.AtoB)) {
          return getTokenBFromLiquidity(liquidity, currentSqrtPriceX64, targetSqrtPriceX64, amountSpecified == AmountSpecified.Output);
        } else {
          return getTokenAFromLiquidity(liquidity, currentSqrtPriceX64, targetSqrtPriceX64, amountSpecified == AmountSpecified.Output);
        }
      }
      exports2.getAmountUnfixedDelta = getAmountUnfixedDelta;
      function getNextSqrtPrice(sqrtPriceX64, liquidity, amount, amountSpecified, swapDirection) {
        if (amountSpecified === AmountSpecified.Input && swapDirection === SwapDirection.AtoB) {
          return (0, swap_utils_1.getLowerSqrtPriceFromTokenA)(amount, liquidity, sqrtPriceX64);
        } else if (amountSpecified === AmountSpecified.Output && swapDirection === SwapDirection.BtoA) {
          return (0, swap_utils_1.getUpperSqrtPriceFromTokenA)(amount, liquidity, sqrtPriceX64);
        } else if (amountSpecified === AmountSpecified.Input && swapDirection === SwapDirection.BtoA) {
          return (0, swap_utils_1.getUpperSqrtPriceFromTokenB)(amount, liquidity, sqrtPriceX64);
        } else {
          return (0, swap_utils_1.getLowerSqrtPriceFromTokenB)(amount, liquidity, sqrtPriceX64);
        }
      }
      exports2.getNextSqrtPrice = getNextSqrtPrice;
      function getTokenAFromLiquidity(liquidity, sqrtPrice0X64, sqrtPrice1X64, roundUp) {
        const [sqrtPriceLowerX64, sqrtPriceUpperX64] = orderSqrtPrice(sqrtPrice0X64, sqrtPrice1X64);
        const numerator = liquidity.mul(sqrtPriceUpperX64.sub(sqrtPriceLowerX64)).shln(64);
        const denominator = sqrtPriceUpperX64.mul(sqrtPriceLowerX64);
        if (roundUp) {
          return common_sdk_1.MathUtil.divRoundUp(numerator, denominator);
        } else {
          return numerator.div(denominator);
        }
      }
      exports2.getTokenAFromLiquidity = getTokenAFromLiquidity;
      function getTokenBFromLiquidity(liquidity, sqrtPrice0X64, sqrtPrice1X64, roundUp) {
        const [sqrtPriceLowerX64, sqrtPriceUpperX64] = orderSqrtPrice(sqrtPrice0X64, sqrtPrice1X64);
        const result = liquidity.mul(sqrtPriceUpperX64.sub(sqrtPriceLowerX64));
        if (roundUp) {
          return common_sdk_1.MathUtil.shiftRightRoundUp(result);
        } else {
          return result.shrn(64);
        }
      }
      exports2.getTokenBFromLiquidity = getTokenBFromLiquidity;
      function orderSqrtPrice(sqrtPrice0X64, sqrtPrice1X64) {
        if (sqrtPrice0X64.lt(sqrtPrice1X64)) {
          return [sqrtPrice0X64, sqrtPrice1X64];
        } else {
          return [sqrtPrice1X64, sqrtPrice0X64];
        }
      }
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/quotes/public/increase-liquidity-quote.js
  var require_increase_liquidity_quote = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/quotes/public/increase-liquidity-quote.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.increaseLiquidityQuoteByInputTokenWithParams = exports2.increaseLiquidityQuoteByInputToken = void 0;
      var common_sdk_1 = require_dist2();
      var tiny_invariant_1 = __importDefault(require_tiny_invariant_cjs());
      var position_util_1 = require_position_util();
      var public_1 = require_public3();
      function increaseLiquidityQuoteByInputToken2(inputTokenMint, inputTokenAmount, tickLower, tickUpper, slippageTolerance, whirlpool) {
        const data = whirlpool.getData();
        const tokenAInfo = whirlpool.getTokenAInfo();
        const tokenBInfo = whirlpool.getTokenBInfo();
        const inputMint = common_sdk_1.AddressUtil.toPubKey(inputTokenMint);
        const inputTokenInfo = inputMint.equals(tokenAInfo.mint) ? tokenAInfo : tokenBInfo;
        return increaseLiquidityQuoteByInputTokenWithParams(Object.assign({ inputTokenMint: inputMint, inputTokenAmount: common_sdk_1.DecimalUtil.toU64(inputTokenAmount, inputTokenInfo.decimals), tickLowerIndex: public_1.TickUtil.getInitializableTickIndex(tickLower, data.tickSpacing), tickUpperIndex: public_1.TickUtil.getInitializableTickIndex(tickUpper, data.tickSpacing), slippageTolerance }, data));
      }
      exports2.increaseLiquidityQuoteByInputToken = increaseLiquidityQuoteByInputToken2;
      function increaseLiquidityQuoteByInputTokenWithParams(param) {
        (0, tiny_invariant_1.default)(public_1.TickUtil.checkTickInBounds(param.tickLowerIndex), "tickLowerIndex is out of bounds.");
        (0, tiny_invariant_1.default)(public_1.TickUtil.checkTickInBounds(param.tickUpperIndex), "tickUpperIndex is out of bounds.");
        (0, tiny_invariant_1.default)(param.inputTokenMint.equals(param.tokenMintA) || param.inputTokenMint.equals(param.tokenMintB), `input token mint ${param.inputTokenMint.toBase58()} does not match any tokens in the provided pool.`);
        const positionStatus = position_util_1.PositionUtil.getPositionStatus(param.tickCurrentIndex, param.tickLowerIndex, param.tickUpperIndex);
        switch (positionStatus) {
          case position_util_1.PositionStatus.BelowRange:
            return quotePositionBelowRange(param);
          case position_util_1.PositionStatus.InRange:
            return quotePositionInRange(param);
          case position_util_1.PositionStatus.AboveRange:
            return quotePositionAboveRange(param);
          default:
            throw new Error(`type ${positionStatus} is an unknown PositionStatus`);
        }
      }
      exports2.increaseLiquidityQuoteByInputTokenWithParams = increaseLiquidityQuoteByInputTokenWithParams;
      function quotePositionBelowRange(param) {
        const { tokenMintA, inputTokenMint, inputTokenAmount, tickLowerIndex, tickUpperIndex, slippageTolerance } = param;
        if (!tokenMintA.equals(inputTokenMint)) {
          return {
            tokenMaxA: common_sdk_1.ZERO,
            tokenMaxB: common_sdk_1.ZERO,
            tokenEstA: common_sdk_1.ZERO,
            tokenEstB: common_sdk_1.ZERO,
            liquidityAmount: common_sdk_1.ZERO
          };
        }
        const sqrtPriceLowerX64 = public_1.PriceMath.tickIndexToSqrtPriceX64(tickLowerIndex);
        const sqrtPriceUpperX64 = public_1.PriceMath.tickIndexToSqrtPriceX64(tickUpperIndex);
        const liquidityAmount = (0, position_util_1.getLiquidityFromTokenA)(inputTokenAmount, sqrtPriceLowerX64, sqrtPriceUpperX64, false);
        const tokenEstA = (0, position_util_1.getTokenAFromLiquidity)(liquidityAmount, sqrtPriceLowerX64, sqrtPriceUpperX64, true);
        const tokenMaxA = (0, position_util_1.adjustForSlippage)(tokenEstA, slippageTolerance, true);
        return {
          tokenMaxA,
          tokenMaxB: common_sdk_1.ZERO,
          tokenEstA,
          tokenEstB: common_sdk_1.ZERO,
          liquidityAmount
        };
      }
      function quotePositionInRange(param) {
        const { tokenMintA, sqrtPrice, inputTokenMint, inputTokenAmount, tickLowerIndex, tickUpperIndex, slippageTolerance } = param;
        const sqrtPriceX64 = sqrtPrice;
        const sqrtPriceLowerX64 = public_1.PriceMath.tickIndexToSqrtPriceX64(tickLowerIndex);
        const sqrtPriceUpperX64 = public_1.PriceMath.tickIndexToSqrtPriceX64(tickUpperIndex);
        let [tokenEstA, tokenEstB] = tokenMintA.equals(inputTokenMint) ? [inputTokenAmount, void 0] : [void 0, inputTokenAmount];
        let liquidityAmount;
        if (tokenEstA) {
          liquidityAmount = (0, position_util_1.getLiquidityFromTokenA)(tokenEstA, sqrtPriceX64, sqrtPriceUpperX64, false);
          tokenEstA = (0, position_util_1.getTokenAFromLiquidity)(liquidityAmount, sqrtPriceX64, sqrtPriceUpperX64, true);
          tokenEstB = (0, position_util_1.getTokenBFromLiquidity)(liquidityAmount, sqrtPriceLowerX64, sqrtPriceX64, true);
        } else if (tokenEstB) {
          liquidityAmount = (0, position_util_1.getLiquidityFromTokenB)(tokenEstB, sqrtPriceLowerX64, sqrtPriceX64, false);
          tokenEstA = (0, position_util_1.getTokenAFromLiquidity)(liquidityAmount, sqrtPriceX64, sqrtPriceUpperX64, true);
          tokenEstB = (0, position_util_1.getTokenBFromLiquidity)(liquidityAmount, sqrtPriceLowerX64, sqrtPriceX64, true);
        } else {
          throw new Error("invariant violation");
        }
        const tokenMaxA = (0, position_util_1.adjustForSlippage)(tokenEstA, slippageTolerance, true);
        const tokenMaxB = (0, position_util_1.adjustForSlippage)(tokenEstB, slippageTolerance, true);
        return {
          tokenMaxA,
          tokenMaxB,
          tokenEstA,
          tokenEstB,
          liquidityAmount
        };
      }
      function quotePositionAboveRange(param) {
        const { tokenMintB, inputTokenMint, inputTokenAmount, tickLowerIndex, tickUpperIndex, slippageTolerance } = param;
        if (!tokenMintB.equals(inputTokenMint)) {
          return {
            tokenMaxA: common_sdk_1.ZERO,
            tokenMaxB: common_sdk_1.ZERO,
            tokenEstA: common_sdk_1.ZERO,
            tokenEstB: common_sdk_1.ZERO,
            liquidityAmount: common_sdk_1.ZERO
          };
        }
        const sqrtPriceLowerX64 = public_1.PriceMath.tickIndexToSqrtPriceX64(tickLowerIndex);
        const sqrtPriceUpperX64 = public_1.PriceMath.tickIndexToSqrtPriceX64(tickUpperIndex);
        const liquidityAmount = (0, position_util_1.getLiquidityFromTokenB)(inputTokenAmount, sqrtPriceLowerX64, sqrtPriceUpperX64, false);
        const tokenEstB = (0, position_util_1.getTokenBFromLiquidity)(liquidityAmount, sqrtPriceLowerX64, sqrtPriceUpperX64, true);
        const tokenMaxB = (0, position_util_1.adjustForSlippage)(tokenEstB, slippageTolerance, true);
        return {
          tokenMaxA: common_sdk_1.ZERO,
          tokenMaxB,
          tokenEstA: common_sdk_1.ZERO,
          tokenEstB,
          liquidityAmount
        };
      }
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/quotes/public/decrease-liquidity-quote.js
  var require_decrease_liquidity_quote = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/quotes/public/decrease-liquidity-quote.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.decreaseLiquidityQuoteByLiquidityWithParams = exports2.decreaseLiquidityQuoteByLiquidity = void 0;
      var common_sdk_1 = require_dist2();
      var tiny_invariant_1 = __importDefault(require_tiny_invariant_cjs());
      var position_util_1 = require_position_util();
      var public_1 = require_public3();
      function decreaseLiquidityQuoteByLiquidity2(liquidity, slippageTolerance, position, whirlpool) {
        return __awaiter(this, void 0, void 0, function* () {
          const positionData = position.getData();
          const whirlpoolData = whirlpool.getData();
          (0, tiny_invariant_1.default)(liquidity.lte(positionData.liquidity), "Quote liquidity is more than the position liquidity.");
          return decreaseLiquidityQuoteByLiquidityWithParams({
            liquidity,
            slippageTolerance,
            tickLowerIndex: positionData.tickLowerIndex,
            tickUpperIndex: positionData.tickUpperIndex,
            sqrtPrice: whirlpoolData.sqrtPrice,
            tickCurrentIndex: whirlpoolData.tickCurrentIndex
          });
        });
      }
      exports2.decreaseLiquidityQuoteByLiquidity = decreaseLiquidityQuoteByLiquidity2;
      function decreaseLiquidityQuoteByLiquidityWithParams(param) {
        (0, tiny_invariant_1.default)(public_1.TickUtil.checkTickInBounds(param.tickLowerIndex), "tickLowerIndex is out of bounds.");
        (0, tiny_invariant_1.default)(public_1.TickUtil.checkTickInBounds(param.tickUpperIndex), "tickUpperIndex is out of bounds.");
        (0, tiny_invariant_1.default)(public_1.TickUtil.checkTickInBounds(param.tickCurrentIndex), "tickCurrentIndex is out of bounds.");
        const positionStatus = position_util_1.PositionUtil.getPositionStatus(param.tickCurrentIndex, param.tickLowerIndex, param.tickUpperIndex);
        switch (positionStatus) {
          case position_util_1.PositionStatus.BelowRange:
            return quotePositionBelowRange(param);
          case position_util_1.PositionStatus.InRange:
            return quotePositionInRange(param);
          case position_util_1.PositionStatus.AboveRange:
            return quotePositionAboveRange(param);
          default:
            throw new Error(`type ${positionStatus} is an unknown PositionStatus`);
        }
      }
      exports2.decreaseLiquidityQuoteByLiquidityWithParams = decreaseLiquidityQuoteByLiquidityWithParams;
      function quotePositionBelowRange(param) {
        const { tickLowerIndex, tickUpperIndex, liquidity, slippageTolerance } = param;
        const sqrtPriceLowerX64 = public_1.PriceMath.tickIndexToSqrtPriceX64(tickLowerIndex);
        const sqrtPriceUpperX64 = public_1.PriceMath.tickIndexToSqrtPriceX64(tickUpperIndex);
        const tokenEstA = (0, position_util_1.getTokenAFromLiquidity)(liquidity, sqrtPriceLowerX64, sqrtPriceUpperX64, false);
        const tokenMinA = (0, position_util_1.adjustForSlippage)(tokenEstA, slippageTolerance, false);
        return {
          tokenMinA,
          tokenMinB: common_sdk_1.ZERO,
          tokenEstA,
          tokenEstB: common_sdk_1.ZERO,
          liquidityAmount: liquidity
        };
      }
      function quotePositionInRange(param) {
        const { sqrtPrice, tickLowerIndex, tickUpperIndex, liquidity, slippageTolerance } = param;
        const sqrtPriceX64 = sqrtPrice;
        const sqrtPriceLowerX64 = public_1.PriceMath.tickIndexToSqrtPriceX64(tickLowerIndex);
        const sqrtPriceUpperX64 = public_1.PriceMath.tickIndexToSqrtPriceX64(tickUpperIndex);
        const tokenEstA = (0, position_util_1.getTokenAFromLiquidity)(liquidity, sqrtPriceX64, sqrtPriceUpperX64, false);
        const tokenMinA = (0, position_util_1.adjustForSlippage)(tokenEstA, slippageTolerance, false);
        const tokenEstB = (0, position_util_1.getTokenBFromLiquidity)(liquidity, sqrtPriceLowerX64, sqrtPriceX64, false);
        const tokenMinB = (0, position_util_1.adjustForSlippage)(tokenEstB, slippageTolerance, false);
        return {
          tokenMinA,
          tokenMinB,
          tokenEstA,
          tokenEstB,
          liquidityAmount: liquidity
        };
      }
      function quotePositionAboveRange(param) {
        const { tickLowerIndex, tickUpperIndex, liquidity, slippageTolerance } = param;
        const sqrtPriceLowerX64 = public_1.PriceMath.tickIndexToSqrtPriceX64(tickLowerIndex);
        const sqrtPriceUpperX64 = public_1.PriceMath.tickIndexToSqrtPriceX64(tickUpperIndex);
        const tokenEstB = (0, position_util_1.getTokenBFromLiquidity)(liquidity, sqrtPriceLowerX64, sqrtPriceUpperX64, false);
        const tokenMinB = (0, position_util_1.adjustForSlippage)(tokenEstB, slippageTolerance, false);
        return {
          tokenMinA: common_sdk_1.ZERO,
          tokenMinB,
          tokenEstA: common_sdk_1.ZERO,
          tokenEstB,
          liquidityAmount: liquidity
        };
      }
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/quotes/public/collect-fees-quote.js
  var require_collect_fees_quote = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/quotes/public/collect-fees-quote.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.collectFeesQuote = void 0;
      var common_sdk_1 = require_dist2();
      function collectFeesQuote2(param) {
        const { whirlpool, position, tickLower, tickUpper } = param;
        const { tickCurrentIndex, feeGrowthGlobalA: feeGrowthGlobalAX64, feeGrowthGlobalB: feeGrowthGlobalBX64 } = whirlpool;
        const { tickLowerIndex, tickUpperIndex, liquidity, feeOwedA, feeOwedB, feeGrowthCheckpointA: feeGrowthCheckpointAX64, feeGrowthCheckpointB: feeGrowthCheckpointBX64 } = position;
        const { feeGrowthOutsideA: tickLowerFeeGrowthOutsideAX64, feeGrowthOutsideB: tickLowerFeeGrowthOutsideBX64 } = tickLower;
        const { feeGrowthOutsideA: tickUpperFeeGrowthOutsideAX64, feeGrowthOutsideB: tickUpperFeeGrowthOutsideBX64 } = tickUpper;
        let feeGrowthBelowAX64 = null;
        let feeGrowthBelowBX64 = null;
        if (tickCurrentIndex < tickLowerIndex) {
          feeGrowthBelowAX64 = common_sdk_1.MathUtil.subUnderflowU128(feeGrowthGlobalAX64, tickLowerFeeGrowthOutsideAX64);
          feeGrowthBelowBX64 = common_sdk_1.MathUtil.subUnderflowU128(feeGrowthGlobalBX64, tickLowerFeeGrowthOutsideBX64);
        } else {
          feeGrowthBelowAX64 = tickLowerFeeGrowthOutsideAX64;
          feeGrowthBelowBX64 = tickLowerFeeGrowthOutsideBX64;
        }
        let feeGrowthAboveAX64 = null;
        let feeGrowthAboveBX64 = null;
        if (tickCurrentIndex < tickUpperIndex) {
          feeGrowthAboveAX64 = tickUpperFeeGrowthOutsideAX64;
          feeGrowthAboveBX64 = tickUpperFeeGrowthOutsideBX64;
        } else {
          feeGrowthAboveAX64 = common_sdk_1.MathUtil.subUnderflowU128(feeGrowthGlobalAX64, tickUpperFeeGrowthOutsideAX64);
          feeGrowthAboveBX64 = common_sdk_1.MathUtil.subUnderflowU128(feeGrowthGlobalBX64, tickUpperFeeGrowthOutsideBX64);
        }
        const feeGrowthInsideAX64 = common_sdk_1.MathUtil.subUnderflowU128(common_sdk_1.MathUtil.subUnderflowU128(feeGrowthGlobalAX64, feeGrowthBelowAX64), feeGrowthAboveAX64);
        const feeGrowthInsideBX64 = common_sdk_1.MathUtil.subUnderflowU128(common_sdk_1.MathUtil.subUnderflowU128(feeGrowthGlobalBX64, feeGrowthBelowBX64), feeGrowthAboveBX64);
        const feeOwedADelta = common_sdk_1.MathUtil.subUnderflowU128(feeGrowthInsideAX64, feeGrowthCheckpointAX64).mul(liquidity).shrn(64);
        const feeOwedBDelta = common_sdk_1.MathUtil.subUnderflowU128(feeGrowthInsideBX64, feeGrowthCheckpointBX64).mul(liquidity).shrn(64);
        const updatedFeeOwedA = feeOwedA.add(feeOwedADelta);
        const updatedFeeOwedB = feeOwedB.add(feeOwedBDelta);
        return {
          feeOwedA: updatedFeeOwedA,
          feeOwedB: updatedFeeOwedB
        };
      }
      exports2.collectFeesQuote = collectFeesQuote2;
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/quotes/public/collect-rewards-quote.js
  var require_collect_rewards_quote = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/quotes/public/collect-rewards-quote.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.collectRewardsQuote = void 0;
      var common_sdk_1 = require_dist2();
      var anchor_1 = (init_browser(), __toCommonJS(browser_exports));
      var tiny_invariant_1 = __importDefault(require_tiny_invariant_cjs());
      var public_1 = require_public();
      var pool_utils_1 = require_pool_utils();
      function collectRewardsQuote2(param) {
        var _a, _b, _c, _d, _e2, _f;
        const { whirlpool, position, tickLower, tickUpper } = param;
        const { tickCurrentIndex, rewardInfos: whirlpoolRewardsInfos } = whirlpool;
        const { tickLowerIndex, tickUpperIndex, liquidity, rewardInfos } = position;
        const range = [...Array(public_1.NUM_REWARDS).keys()];
        const rewardGrowthsBelowX64 = range.map(() => new anchor_1.BN(0));
        const rewardGrowthsAboveX64 = range.map(() => new anchor_1.BN(0));
        for (const i of range) {
          const rewardInfo = whirlpoolRewardsInfos[i];
          (0, tiny_invariant_1.default)(!!rewardInfo, "whirlpoolRewardsInfos cannot be undefined");
          const growthGlobalX64 = rewardInfo.growthGlobalX64;
          const lowerRewardGrowthsOutside = tickLower.rewardGrowthsOutside[i];
          const upperRewardGrowthsOutside = tickUpper.rewardGrowthsOutside[i];
          (0, tiny_invariant_1.default)(!!lowerRewardGrowthsOutside, "lowerRewardGrowthsOutside cannot be undefined");
          (0, tiny_invariant_1.default)(!!upperRewardGrowthsOutside, "upperRewardGrowthsOutside cannot be undefined");
          if (tickCurrentIndex < tickLowerIndex) {
            rewardGrowthsBelowX64[i] = common_sdk_1.MathUtil.subUnderflowU128(growthGlobalX64, lowerRewardGrowthsOutside);
          } else {
            rewardGrowthsBelowX64[i] = lowerRewardGrowthsOutside;
          }
          if (tickCurrentIndex < tickUpperIndex) {
            rewardGrowthsAboveX64[i] = upperRewardGrowthsOutside;
          } else {
            rewardGrowthsAboveX64[i] = common_sdk_1.MathUtil.subUnderflowU128(growthGlobalX64, upperRewardGrowthsOutside);
          }
        }
        const rewardGrowthsInsideX64 = range.map(() => [new anchor_1.BN(0), false]);
        for (const i of range) {
          const rewardInfo = whirlpoolRewardsInfos[i];
          (0, tiny_invariant_1.default)(!!rewardInfo, "whirlpoolRewardsInfos cannot be undefined");
          const isRewardInitialized = pool_utils_1.PoolUtil.isRewardInitialized(rewardInfo);
          if (isRewardInitialized) {
            const growthBelowX64 = rewardGrowthsBelowX64[i];
            const growthAboveX64 = rewardGrowthsAboveX64[i];
            (0, tiny_invariant_1.default)(!!growthBelowX64, "growthBelowX64 cannot be undefined");
            (0, tiny_invariant_1.default)(!!growthAboveX64, "growthAboveX64 cannot be undefined");
            const growthInsde = common_sdk_1.MathUtil.subUnderflowU128(common_sdk_1.MathUtil.subUnderflowU128(rewardInfo.growthGlobalX64, growthBelowX64), growthAboveX64);
            rewardGrowthsInsideX64[i] = [growthInsde, true];
          }
        }
        const updatedRewardInfosX64 = range.map(() => new anchor_1.BN(0));
        for (const i of range) {
          const growthInsideX64 = rewardGrowthsInsideX64[i];
          (0, tiny_invariant_1.default)(!!growthInsideX64, "growthInsideX64 cannot be undefined");
          const [rewardGrowthInsideX64, isRewardInitialized] = growthInsideX64;
          if (isRewardInitialized) {
            const rewardInfo = rewardInfos[i];
            (0, tiny_invariant_1.default)(!!rewardInfo, "rewardInfo cannot be undefined");
            const amountOwedX64 = rewardInfo.amountOwed.shln(64);
            const growthInsideCheckpointX64 = rewardInfo.growthInsideCheckpoint;
            updatedRewardInfosX64[i] = amountOwedX64.add(common_sdk_1.MathUtil.subUnderflowU128(rewardGrowthInsideX64, growthInsideCheckpointX64).mul(liquidity));
          }
        }
        (0, tiny_invariant_1.default)(rewardGrowthsInsideX64.length >= 3, "rewards length is less than 3");
        const rewardExistsA = (_a = rewardGrowthsInsideX64[0]) === null || _a === void 0 ? void 0 : _a[1];
        const rewardExistsB = (_b = rewardGrowthsInsideX64[1]) === null || _b === void 0 ? void 0 : _b[1];
        const rewardExistsC = (_c = rewardGrowthsInsideX64[2]) === null || _c === void 0 ? void 0 : _c[1];
        const rewardOwedA = rewardExistsA ? (_d = updatedRewardInfosX64[0]) === null || _d === void 0 ? void 0 : _d.shrn(64) : void 0;
        const rewardOwedB = rewardExistsB ? (_e2 = updatedRewardInfosX64[1]) === null || _e2 === void 0 ? void 0 : _e2.shrn(64) : void 0;
        const rewardOwedC = rewardExistsC ? (_f = updatedRewardInfosX64[2]) === null || _f === void 0 ? void 0 : _f.shrn(64) : void 0;
        return [rewardOwedA, rewardOwedB, rewardOwedC];
      }
      exports2.collectRewardsQuote = collectRewardsQuote2;
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/quotes/swap/tick-array-index.js
  var require_tick_array_index = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/quotes/swap/tick-array-index.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.TickArrayIndex = void 0;
      var public_1 = require_public();
      var TickArrayIndex = class {
        constructor(arrayIndex, offsetIndex, tickSpacing) {
          this.arrayIndex = arrayIndex;
          this.offsetIndex = offsetIndex;
          this.tickSpacing = tickSpacing;
          if (offsetIndex >= public_1.TICK_ARRAY_SIZE) {
            throw new Error("Invalid offsetIndex - value has to be smaller than TICK_ARRAY_SIZE");
          }
          if (offsetIndex < 0) {
            throw new Error("Invalid offsetIndex - value is smaller than 0");
          }
          if (tickSpacing < 0) {
            throw new Error("Invalid tickSpacing - value is less than 0");
          }
        }
        static fromTickIndex(index, tickSpacing) {
          const arrayIndex = Math.floor(Math.floor(index / tickSpacing) / public_1.TICK_ARRAY_SIZE);
          let offsetIndex = Math.floor(index % (tickSpacing * public_1.TICK_ARRAY_SIZE) / tickSpacing);
          if (offsetIndex < 0) {
            offsetIndex = public_1.TICK_ARRAY_SIZE + offsetIndex;
          }
          return new TickArrayIndex(arrayIndex, offsetIndex, tickSpacing);
        }
        toTickIndex() {
          return this.arrayIndex * public_1.TICK_ARRAY_SIZE * this.tickSpacing + this.offsetIndex * this.tickSpacing;
        }
        toNextInitializableTickIndex() {
          return TickArrayIndex.fromTickIndex(this.toTickIndex() + this.tickSpacing, this.tickSpacing);
        }
        toPrevInitializableTickIndex() {
          return TickArrayIndex.fromTickIndex(this.toTickIndex() - this.tickSpacing, this.tickSpacing);
        }
      };
      exports2.TickArrayIndex = TickArrayIndex;
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/quotes/swap/tick-array-sequence.js
  var require_tick_array_sequence = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/quotes/swap/tick-array-sequence.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.TickArraySequence = void 0;
      var errors_1 = require_errors2();
      var public_1 = require_public();
      var tick_array_index_1 = require_tick_array_index();
      var TickArraySequence = class {
        constructor(tickArrays, tickSpacing, aToB) {
          this.tickArrays = tickArrays;
          this.tickSpacing = tickSpacing;
          this.aToB = aToB;
          if (!tickArrays[0] || !tickArrays[0].data) {
            throw new Error("TickArray index 0 must be initialized");
          }
          this.touchedArrays = [...Array(tickArrays.length).fill(false)];
          this.startArrayIndex = tick_array_index_1.TickArrayIndex.fromTickIndex(tickArrays[0].data.startTickIndex, this.tickSpacing).arrayIndex;
        }
        checkArrayContainsTickIndex(sequenceIndex, tickIndex) {
          var _a;
          const tickArray = (_a = this.tickArrays[sequenceIndex]) === null || _a === void 0 ? void 0 : _a.data;
          if (!tickArray) {
            return false;
          }
          return this.checkIfIndexIsInTickArrayRange(tickArray.startTickIndex, tickIndex);
        }
        getNumOfTouchedArrays() {
          return this.touchedArrays.filter((val) => !!val).length;
        }
        getTouchedArrays(minArraySize) {
          let result = this.touchedArrays.reduce((prev, curr, index) => {
            if (curr) {
              prev.push(this.tickArrays[index].address);
            }
            return prev;
          }, []);
          if (result.length === 0) {
            return [];
          }
          const sizeDiff = minArraySize - result.length;
          if (sizeDiff > 0) {
            result = result.concat(Array(sizeDiff).fill(result[result.length - 1]));
          }
          return result;
        }
        getTick(index) {
          const targetTaIndex = tick_array_index_1.TickArrayIndex.fromTickIndex(index, this.tickSpacing);
          if (!this.isArrayIndexInBounds(targetTaIndex, this.aToB)) {
            throw new Error("Provided tick index is out of bounds for this sequence.");
          }
          const localArrayIndex = this.getLocalArrayIndex(targetTaIndex.arrayIndex, this.aToB);
          const tickArray = this.tickArrays[localArrayIndex].data;
          this.touchedArrays[localArrayIndex] = true;
          if (!tickArray) {
            throw new errors_1.WhirlpoolsError(`TickArray at index ${localArrayIndex} is not initialized.`, errors_1.SwapErrorCode.TickArrayIndexNotInitialized);
          }
          if (!this.checkIfIndexIsInTickArrayRange(tickArray.startTickIndex, index)) {
            throw new errors_1.WhirlpoolsError(`TickArray at index ${localArrayIndex} is unexpected for this sequence.`, errors_1.SwapErrorCode.TickArraySequenceInvalid);
          }
          return tickArray.ticks[targetTaIndex.offsetIndex];
        }
        findNextInitializedTickIndex(currIndex) {
          const searchIndex = this.aToB ? currIndex : currIndex + this.tickSpacing;
          let currTaIndex = tick_array_index_1.TickArrayIndex.fromTickIndex(searchIndex, this.tickSpacing);
          if (!this.isArrayIndexInBounds(currTaIndex, this.aToB)) {
            throw new errors_1.WhirlpoolsError(`Swap input value traversed too many arrays. Out of bounds at attempt to traverse tick index - ${currTaIndex.toTickIndex()}.`, errors_1.SwapErrorCode.TickArraySequenceInvalid);
          }
          while (this.isArrayIndexInBounds(currTaIndex, this.aToB)) {
            const currTickData = this.getTick(currTaIndex.toTickIndex());
            if (currTickData.initialized) {
              return { nextIndex: currTaIndex.toTickIndex(), nextTickData: currTickData };
            }
            currTaIndex = this.aToB ? currTaIndex.toPrevInitializableTickIndex() : currTaIndex.toNextInitializableTickIndex();
          }
          const lastIndexInArray = Math.max(Math.min(this.aToB ? currTaIndex.toTickIndex() + this.tickSpacing : currTaIndex.toTickIndex() - 1, public_1.MAX_TICK_INDEX), public_1.MIN_TICK_INDEX);
          return { nextIndex: lastIndexInArray, nextTickData: null };
        }
        getLocalArrayIndex(arrayIndex, aToB) {
          return aToB ? this.startArrayIndex - arrayIndex : arrayIndex - this.startArrayIndex;
        }
        isArrayIndexInBounds(index, aToB) {
          const localArrayIndex = this.getLocalArrayIndex(index.arrayIndex, aToB);
          const seqLength = this.tickArrays.length;
          return localArrayIndex >= 0 && localArrayIndex < seqLength;
        }
        checkIfIndexIsInTickArrayRange(startTick, tickIndex) {
          const upperBound = startTick + this.tickSpacing * public_1.TICK_ARRAY_SIZE;
          return !(tickIndex < startTick || tickIndex > upperBound);
        }
      };
      exports2.TickArraySequence = TickArraySequence;
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/utils/math/swap-math.js
  var require_swap_math = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/utils/math/swap-math.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.computeSwapStep = void 0;
      var anchor_1 = (init_browser(), __toCommonJS(browser_exports));
      var token_math_1 = require_token_math();
      var bit_math_1 = require_bit_math();
      var public_1 = require_public();
      function computeSwapStep(amountRemaining, feeRate, currLiquidity, currSqrtPrice, targetSqrtPrice, amountSpecifiedIsInput, aToB) {
        let amountFixedDelta = getAmountFixedDelta(currSqrtPrice, targetSqrtPrice, currLiquidity, amountSpecifiedIsInput, aToB);
        let amountCalc = amountRemaining;
        if (amountSpecifiedIsInput) {
          const result = bit_math_1.BitMath.mulDiv(amountRemaining, public_1.FEE_RATE_MUL_VALUE.sub(new anchor_1.BN(feeRate)), public_1.FEE_RATE_MUL_VALUE, 128);
          amountCalc = result;
        }
        let nextSqrtPrice = amountCalc.gte(amountFixedDelta) ? targetSqrtPrice : (0, token_math_1.getNextSqrtPrice)(currSqrtPrice, currLiquidity, amountCalc, amountSpecifiedIsInput, aToB);
        let isMaxSwap = nextSqrtPrice.eq(targetSqrtPrice);
        let amountUnfixedDelta = getAmountUnfixedDelta(currSqrtPrice, nextSqrtPrice, currLiquidity, amountSpecifiedIsInput, aToB);
        if (!isMaxSwap) {
          amountFixedDelta = getAmountFixedDelta(currSqrtPrice, nextSqrtPrice, currLiquidity, amountSpecifiedIsInput, aToB);
        }
        let amountIn = amountSpecifiedIsInput ? amountFixedDelta : amountUnfixedDelta;
        let amountOut = amountSpecifiedIsInput ? amountUnfixedDelta : amountFixedDelta;
        if (!amountSpecifiedIsInput && amountOut.gt(amountRemaining)) {
          amountOut = amountRemaining;
        }
        let feeAmount;
        if (amountSpecifiedIsInput && !isMaxSwap) {
          feeAmount = amountRemaining.sub(amountIn);
        } else {
          const feeRateBN = new anchor_1.BN(feeRate);
          feeAmount = bit_math_1.BitMath.mulDivRoundUp(amountIn, feeRateBN, public_1.FEE_RATE_MUL_VALUE.sub(feeRateBN), 128);
        }
        return {
          amountIn,
          amountOut,
          nextPrice: nextSqrtPrice,
          feeAmount
        };
      }
      exports2.computeSwapStep = computeSwapStep;
      function getAmountFixedDelta(currSqrtPrice, targetSqrtPrice, currLiquidity, amountSpecifiedIsInput, aToB) {
        if (aToB === amountSpecifiedIsInput) {
          return (0, token_math_1.getAmountDeltaA)(currSqrtPrice, targetSqrtPrice, currLiquidity, amountSpecifiedIsInput);
        } else {
          return (0, token_math_1.getAmountDeltaB)(currSqrtPrice, targetSqrtPrice, currLiquidity, amountSpecifiedIsInput);
        }
      }
      function getAmountUnfixedDelta(currSqrtPrice, targetSqrtPrice, currLiquidity, amountSpecifiedIsInput, aToB) {
        if (aToB === amountSpecifiedIsInput) {
          return (0, token_math_1.getAmountDeltaB)(currSqrtPrice, targetSqrtPrice, currLiquidity, !amountSpecifiedIsInput);
        } else {
          return (0, token_math_1.getAmountDeltaA)(currSqrtPrice, targetSqrtPrice, currLiquidity, !amountSpecifiedIsInput);
        }
      }
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/quotes/swap/swap-manager.js
  var require_swap_manager = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/quotes/swap/swap-manager.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.computeSwap = void 0;
      var common_sdk_1 = require_dist2();
      var spl_token_1 = (init_index_browser_esm2(), __toCommonJS(index_browser_esm_exports2));
      var bn_js_1 = __importDefault(require_bn());
      var public_1 = require_public();
      var public_2 = require_public3();
      var swap_math_1 = require_swap_math();
      function computeSwap(whirlpoolData, tickSequence, tokenAmount, sqrtPriceLimit, amountSpecifiedIsInput, aToB) {
        let amountRemaining = tokenAmount;
        let amountCalculated = common_sdk_1.ZERO;
        let currSqrtPrice = whirlpoolData.sqrtPrice;
        let currLiquidity = whirlpoolData.liquidity;
        let currTickIndex = whirlpoolData.tickCurrentIndex;
        let totalFeeAmount = common_sdk_1.ZERO;
        const feeRate = whirlpoolData.feeRate;
        const protocolFeeRate = whirlpoolData.protocolFeeRate;
        let currProtocolFee = new spl_token_1.u64(0);
        let currFeeGrowthGlobalInput = aToB ? whirlpoolData.feeGrowthGlobalA : whirlpoolData.feeGrowthGlobalB;
        while (amountRemaining.gt(common_sdk_1.ZERO) && !sqrtPriceLimit.eq(currSqrtPrice)) {
          let { nextIndex: nextTickIndex } = tickSequence.findNextInitializedTickIndex(currTickIndex);
          let { nextTickPrice, nextSqrtPriceLimit: targetSqrtPrice } = getNextSqrtPrices(nextTickIndex, sqrtPriceLimit, aToB);
          const swapComputation = (0, swap_math_1.computeSwapStep)(amountRemaining, feeRate, currLiquidity, currSqrtPrice, targetSqrtPrice, amountSpecifiedIsInput, aToB);
          totalFeeAmount = totalFeeAmount.add(swapComputation.feeAmount);
          if (amountSpecifiedIsInput) {
            amountRemaining = amountRemaining.sub(swapComputation.amountIn);
            amountRemaining = amountRemaining.sub(swapComputation.feeAmount);
            amountCalculated = amountCalculated.add(swapComputation.amountOut);
          } else {
            amountRemaining = amountRemaining.sub(swapComputation.amountOut);
            amountCalculated = amountCalculated.add(swapComputation.amountIn);
            amountCalculated = amountCalculated.add(swapComputation.feeAmount);
          }
          let { nextProtocolFee, nextFeeGrowthGlobalInput } = calculateFees(swapComputation.feeAmount, protocolFeeRate, currLiquidity, currProtocolFee, currFeeGrowthGlobalInput);
          currProtocolFee = nextProtocolFee;
          currFeeGrowthGlobalInput = nextFeeGrowthGlobalInput;
          if (swapComputation.nextPrice.eq(nextTickPrice)) {
            const nextTick2 = tickSequence.getTick(nextTickIndex);
            if (nextTick2.initialized) {
              currLiquidity = calculateNextLiquidity(nextTick2.liquidityNet, currLiquidity, aToB);
            }
            currTickIndex = aToB ? nextTickIndex - 1 : nextTickIndex;
          } else {
            currTickIndex = public_2.PriceMath.sqrtPriceX64ToTickIndex(swapComputation.nextPrice);
          }
          currSqrtPrice = swapComputation.nextPrice;
        }
        let { amountA, amountB } = calculateEstTokens(tokenAmount, amountRemaining, amountCalculated, aToB, amountSpecifiedIsInput);
        return {
          amountA,
          amountB,
          nextTickIndex: currTickIndex,
          nextSqrtPrice: currSqrtPrice,
          totalFeeAmount
        };
      }
      exports2.computeSwap = computeSwap;
      function getNextSqrtPrices(nextTick2, sqrtPriceLimit, aToB) {
        const nextTickPrice = public_2.PriceMath.tickIndexToSqrtPriceX64(nextTick2);
        const nextSqrtPriceLimit = aToB ? bn_js_1.default.max(sqrtPriceLimit, nextTickPrice) : bn_js_1.default.min(sqrtPriceLimit, nextTickPrice);
        return { nextTickPrice, nextSqrtPriceLimit };
      }
      function calculateFees(feeAmount, protocolFeeRate, currLiquidity, currProtocolFee, currFeeGrowthGlobalInput) {
        let nextProtocolFee = currProtocolFee;
        let nextFeeGrowthGlobalInput = currFeeGrowthGlobalInput;
        let globalFee = feeAmount;
        if (protocolFeeRate > 0) {
          let delta = calculateProtocolFee(globalFee, protocolFeeRate);
          globalFee = globalFee.sub(delta);
          nextProtocolFee = nextProtocolFee.add(currProtocolFee);
        }
        if (currLiquidity.gt(common_sdk_1.ZERO)) {
          const globalFeeIncrement = globalFee.shln(64).div(currLiquidity);
          nextFeeGrowthGlobalInput = nextFeeGrowthGlobalInput.add(globalFeeIncrement);
        }
        return {
          nextProtocolFee,
          nextFeeGrowthGlobalInput
        };
      }
      function calculateProtocolFee(globalFee, protocolFeeRate) {
        return globalFee.mul(new spl_token_1.u64(protocolFeeRate).div(public_1.PROTOCOL_FEE_RATE_MUL_VALUE));
      }
      function calculateEstTokens(amount, amountRemaining, amountCalculated, aToB, amountSpecifiedIsInput) {
        return aToB === amountSpecifiedIsInput ? {
          amountA: amount.sub(amountRemaining),
          amountB: amountCalculated
        } : {
          amountA: amountCalculated,
          amountB: amount.sub(amountRemaining)
        };
      }
      function calculateNextLiquidity(tickNetLiquidity, currLiquidity, aToB) {
        return aToB ? currLiquidity.sub(tickNetLiquidity) : currLiquidity.add(tickNetLiquidity);
      }
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/quotes/swap/swap-quote-impl.js
  var require_swap_quote_impl = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/quotes/swap/swap-quote-impl.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.simulateSwap = void 0;
      var common_sdk_1 = require_dist2();
      var spl_token_1 = (init_index_browser_esm2(), __toCommonJS(index_browser_esm_exports2));
      var tick_array_sequence_1 = require_tick_array_sequence();
      var swap_manager_1 = require_swap_manager();
      var public_1 = require_public();
      var errors_1 = require_errors2();
      function simulateSwap(params) {
        const { aToB, whirlpoolData, tickArrays, tokenAmount, sqrtPriceLimit, otherAmountThreshold, amountSpecifiedIsInput } = params;
        if (sqrtPriceLimit.gt(new spl_token_1.u64(public_1.MAX_SQRT_PRICE) || sqrtPriceLimit.lt(new spl_token_1.u64(public_1.MIN_SQRT_PRICE)))) {
          throw new errors_1.WhirlpoolsError("Provided SqrtPriceLimit is out of bounds.", errors_1.SwapErrorCode.SqrtPriceOutOfBounds);
        }
        if (aToB && sqrtPriceLimit.gt(whirlpoolData.sqrtPrice) || !aToB && sqrtPriceLimit.lt(whirlpoolData.sqrtPrice)) {
          throw new errors_1.WhirlpoolsError("Provided SqrtPriceLimit is in the opposite direction of the trade.", errors_1.SwapErrorCode.InvalidSqrtPriceLimitDirection);
        }
        if (tokenAmount.eq(common_sdk_1.ZERO)) {
          throw new errors_1.WhirlpoolsError("Provided tokenAmount is zero.", errors_1.SwapErrorCode.ZeroTradableAmount);
        }
        const tickSequence = new tick_array_sequence_1.TickArraySequence(tickArrays, whirlpoolData.tickSpacing, aToB);
        if (!tickSequence.checkArrayContainsTickIndex(0, whirlpoolData.tickCurrentIndex)) {
          throw new errors_1.WhirlpoolsError("TickArray at index 0 does not contain the Whirlpool current tick index.", errors_1.SwapErrorCode.TickArraySequenceInvalid);
        }
        const swapResults = (0, swap_manager_1.computeSwap)(whirlpoolData, tickSequence, tokenAmount, sqrtPriceLimit, amountSpecifiedIsInput, aToB);
        if (amountSpecifiedIsInput) {
          if (aToB && otherAmountThreshold.gt(swapResults.amountB) || !aToB && otherAmountThreshold.gt(swapResults.amountA)) {
            throw new errors_1.WhirlpoolsError("Quoted amount for the other token is below the otherAmountThreshold.", errors_1.SwapErrorCode.AmountOutBelowMinimum);
          }
        } else {
          if (aToB && otherAmountThreshold.lt(swapResults.amountA) || !aToB && otherAmountThreshold.lt(swapResults.amountB)) {
            throw new errors_1.WhirlpoolsError("Quoted amount for the other token is above the otherAmountThreshold.", errors_1.SwapErrorCode.AmountInAboveMaximum);
          }
        }
        const { estimatedAmountIn, estimatedAmountOut } = remapAndAdjustTokens(swapResults.amountA, swapResults.amountB, aToB);
        const numOfTickCrossings = tickSequence.getNumOfTouchedArrays();
        if (numOfTickCrossings > public_1.MAX_SWAP_TICK_ARRAYS) {
          throw new errors_1.WhirlpoolsError(`Input amount causes the quote to traverse more than the allowable amount of tick-arrays ${numOfTickCrossings}`, errors_1.SwapErrorCode.TickArrayCrossingAboveMax);
        }
        const touchedArrays = tickSequence.getTouchedArrays(public_1.MAX_SWAP_TICK_ARRAYS);
        return {
          estimatedAmountIn,
          estimatedAmountOut,
          estimatedEndTickIndex: swapResults.nextTickIndex,
          estimatedEndSqrtPrice: swapResults.nextSqrtPrice,
          estimatedFeeAmount: swapResults.totalFeeAmount,
          amount: tokenAmount,
          amountSpecifiedIsInput,
          aToB,
          otherAmountThreshold,
          sqrtPriceLimit,
          tickArray0: touchedArrays[0],
          tickArray1: touchedArrays[1],
          tickArray2: touchedArrays[2]
        };
      }
      exports2.simulateSwap = simulateSwap;
      function remapAndAdjustTokens(amountA, amountB, aToB) {
        const estimatedAmountIn = aToB ? amountA : amountB;
        const estimatedAmountOut = aToB ? amountB : amountA;
        return {
          estimatedAmountIn,
          estimatedAmountOut
        };
      }
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/quotes/public/swap-quote.js
  var require_swap_quote = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/quotes/public/swap-quote.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.swapQuoteWithParams = exports2.swapQuoteByOutputToken = exports2.swapQuoteByInputToken = void 0;
      var tiny_invariant_1 = __importDefault(require_tiny_invariant_cjs());
      var pool_utils_1 = require_pool_utils();
      var common_sdk_1 = require_dist2();
      var public_1 = require_public3();
      var swap_quote_impl_1 = require_swap_quote_impl();
      var swap_utils_1 = require_swap_utils();
      function swapQuoteByInputToken2(whirlpool, inputTokenMint, tokenAmount, slippageTolerance, programId, fetcher, refresh) {
        return __awaiter(this, void 0, void 0, function* () {
          return swapQuoteByToken(whirlpool, inputTokenMint, tokenAmount, slippageTolerance, public_1.TokenType.TokenA, true, programId, fetcher, refresh);
        });
      }
      exports2.swapQuoteByInputToken = swapQuoteByInputToken2;
      function swapQuoteByOutputToken(whirlpool, outputTokenMint, tokenAmount, slippageTolerance, programId, fetcher, refresh) {
        return __awaiter(this, void 0, void 0, function* () {
          return swapQuoteByToken(whirlpool, outputTokenMint, tokenAmount, slippageTolerance, public_1.TokenType.TokenB, false, programId, fetcher, refresh);
        });
      }
      exports2.swapQuoteByOutputToken = swapQuoteByOutputToken;
      function swapQuoteWithParams(params, slippageTolerance) {
        checkIfAllTickArraysInitialized(params.tickArrays);
        const quote = (0, swap_quote_impl_1.simulateSwap)(params);
        const slippageAdjustedQuote = Object.assign(Object.assign({}, quote), swap_utils_1.SwapUtils.calculateSwapAmountsFromQuote(params.tokenAmount, quote.estimatedAmountIn, quote.estimatedAmountOut, slippageTolerance, params.amountSpecifiedIsInput));
        return slippageAdjustedQuote;
      }
      exports2.swapQuoteWithParams = swapQuoteWithParams;
      function swapQuoteByToken(whirlpool, inputTokenMint, tokenAmount, slippageTolerance, amountSpecifiedTokenType, amountSpecifiedIsInput, programId, fetcher, refresh) {
        return __awaiter(this, void 0, void 0, function* () {
          const whirlpoolData = whirlpool.getData();
          const swapMintKey = common_sdk_1.AddressUtil.toPubKey(inputTokenMint);
          const swapTokenType = pool_utils_1.PoolUtil.getTokenType(whirlpoolData, swapMintKey);
          (0, tiny_invariant_1.default)(!!swapTokenType, "swapTokenMint does not match any tokens on this pool");
          const aToB = swapTokenType === amountSpecifiedTokenType;
          const tickArrays = yield swap_utils_1.SwapUtils.getTickArrays(whirlpoolData.tickCurrentIndex, whirlpoolData.tickSpacing, aToB, common_sdk_1.AddressUtil.toPubKey(programId), whirlpool.getAddress(), fetcher, refresh);
          return swapQuoteWithParams({
            whirlpoolData,
            tokenAmount,
            aToB,
            amountSpecifiedIsInput,
            sqrtPriceLimit: swap_utils_1.SwapUtils.getDefaultSqrtPriceLimit(aToB),
            otherAmountThreshold: swap_utils_1.SwapUtils.getDefaultOtherAmountThreshold(amountSpecifiedIsInput),
            tickArrays
          }, slippageTolerance);
        });
      }
      function checkIfAllTickArraysInitialized(tickArrays) {
        const uninitializedIndices = public_1.TickArrayUtil.getUninitializedArrays(tickArrays.map((array6) => array6.data));
        if (uninitializedIndices.length > 0) {
          const uninitializedArrays = uninitializedIndices.map((index) => tickArrays[index].address.toBase58()).join(", ");
          throw new Error(`TickArray addresses - [${uninitializedArrays}] need to be initialized.`);
        }
      }
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/quotes/public/index.js
  var require_public4 = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/quotes/public/index.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        var desc = Object.getOwnPropertyDescriptor(m, k2);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k2];
          } };
        }
        Object.defineProperty(o, k22, desc);
      } : function(o, m, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o[k22] = m[k2];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p2 in m)
          if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
            __createBinding(exports3, m, p2);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar(require_increase_liquidity_quote(), exports2);
      __exportStar(require_decrease_liquidity_quote(), exports2);
      __exportStar(require_collect_fees_quote(), exports2);
      __exportStar(require_collect_rewards_quote(), exports2);
      __exportStar(require_swap_quote(), exports2);
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/instructions/close-position-ix.js
  var require_close_position_ix = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/instructions/close-position-ix.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.closePositionIx = void 0;
      var spl_token_1 = (init_index_browser_esm2(), __toCommonJS(index_browser_esm_exports2));
      function closePositionIx(program, params) {
        const { positionAuthority, receiver, position, positionMint, positionTokenAccount } = params;
        const ix = program.instruction.closePosition({
          accounts: {
            positionAuthority,
            receiver,
            position,
            positionMint,
            positionTokenAccount,
            tokenProgram: spl_token_1.TOKEN_PROGRAM_ID
          }
        });
        return {
          instructions: [ix],
          cleanupInstructions: [],
          signers: []
        };
      }
      exports2.closePositionIx = closePositionIx;
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/instructions/collect-fees-ix.js
  var require_collect_fees_ix = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/instructions/collect-fees-ix.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.collectFeesIx = void 0;
      var spl_token_1 = (init_index_browser_esm2(), __toCommonJS(index_browser_esm_exports2));
      function collectFeesIx(program, params) {
        const { whirlpool, positionAuthority, position, positionTokenAccount, tokenOwnerAccountA, tokenOwnerAccountB, tokenVaultA, tokenVaultB } = params;
        const ix = program.instruction.collectFees({
          accounts: {
            whirlpool,
            positionAuthority,
            position,
            positionTokenAccount,
            tokenOwnerAccountA,
            tokenOwnerAccountB,
            tokenVaultA,
            tokenVaultB,
            tokenProgram: spl_token_1.TOKEN_PROGRAM_ID
          }
        });
        return {
          instructions: [ix],
          cleanupInstructions: [],
          signers: []
        };
      }
      exports2.collectFeesIx = collectFeesIx;
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/instructions/collect-protocol-fees-ix.js
  var require_collect_protocol_fees_ix = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/instructions/collect-protocol-fees-ix.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.collectProtocolFeesIx = void 0;
      var spl_token_1 = (init_index_browser_esm2(), __toCommonJS(index_browser_esm_exports2));
      function collectProtocolFeesIx(program, params) {
        const { whirlpoolsConfig, whirlpool, collectProtocolFeesAuthority, tokenVaultA, tokenVaultB, tokenOwnerAccountA: tokenDestinationA, tokenOwnerAccountB: tokenDestinationB } = params;
        const ix = program.instruction.collectProtocolFees({
          accounts: {
            whirlpoolsConfig,
            whirlpool,
            collectProtocolFeesAuthority,
            tokenVaultA,
            tokenVaultB,
            tokenDestinationA,
            tokenDestinationB,
            tokenProgram: spl_token_1.TOKEN_PROGRAM_ID
          }
        });
        return {
          instructions: [ix],
          cleanupInstructions: [],
          signers: []
        };
      }
      exports2.collectProtocolFeesIx = collectProtocolFeesIx;
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/instructions/collect-reward-ix.js
  var require_collect_reward_ix = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/instructions/collect-reward-ix.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.collectRewardIx = void 0;
      var spl_token_1 = (init_index_browser_esm2(), __toCommonJS(index_browser_esm_exports2));
      function collectRewardIx(program, params) {
        const { whirlpool, positionAuthority, position, positionTokenAccount, rewardOwnerAccount, rewardVault, rewardIndex } = params;
        const ix = program.instruction.collectReward(rewardIndex, {
          accounts: {
            whirlpool,
            positionAuthority,
            position,
            positionTokenAccount,
            rewardOwnerAccount,
            rewardVault,
            tokenProgram: spl_token_1.TOKEN_PROGRAM_ID
          }
        });
        return {
          instructions: [ix],
          cleanupInstructions: [],
          signers: []
        };
      }
      exports2.collectRewardIx = collectRewardIx;
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/instructions/decrease-liquidity-ix.js
  var require_decrease_liquidity_ix = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/instructions/decrease-liquidity-ix.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.decreaseLiquidityIx = void 0;
      var spl_token_1 = (init_index_browser_esm2(), __toCommonJS(index_browser_esm_exports2));
      function decreaseLiquidityIx(program, params) {
        const { liquidityAmount, tokenMinA, tokenMinB, whirlpool, positionAuthority, position, positionTokenAccount, tokenOwnerAccountA, tokenOwnerAccountB, tokenVaultA, tokenVaultB, tickArrayLower, tickArrayUpper } = params;
        const ix = program.instruction.decreaseLiquidity(liquidityAmount, tokenMinA, tokenMinB, {
          accounts: {
            whirlpool,
            tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            positionAuthority,
            position,
            positionTokenAccount,
            tokenOwnerAccountA,
            tokenOwnerAccountB,
            tokenVaultA,
            tokenVaultB,
            tickArrayLower,
            tickArrayUpper
          }
        });
        return {
          instructions: [ix],
          cleanupInstructions: [],
          signers: []
        };
      }
      exports2.decreaseLiquidityIx = decreaseLiquidityIx;
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/instructions/increase-liquidity-ix.js
  var require_increase_liquidity_ix = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/instructions/increase-liquidity-ix.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.increaseLiquidityIx = void 0;
      var spl_token_1 = (init_index_browser_esm2(), __toCommonJS(index_browser_esm_exports2));
      function increaseLiquidityIx(program, params) {
        const { liquidityAmount, tokenMaxA, tokenMaxB, whirlpool, positionAuthority, position, positionTokenAccount, tokenOwnerAccountA, tokenOwnerAccountB, tokenVaultA, tokenVaultB, tickArrayLower, tickArrayUpper } = params;
        const ix = program.instruction.increaseLiquidity(liquidityAmount, tokenMaxA, tokenMaxB, {
          accounts: {
            whirlpool,
            tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            positionAuthority,
            position,
            positionTokenAccount,
            tokenOwnerAccountA,
            tokenOwnerAccountB,
            tokenVaultA,
            tokenVaultB,
            tickArrayLower,
            tickArrayUpper
          }
        });
        return {
          instructions: [ix],
          cleanupInstructions: [],
          signers: []
        };
      }
      exports2.increaseLiquidityIx = increaseLiquidityIx;
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/instructions/initialize-config-ix.js
  var require_initialize_config_ix = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/instructions/initialize-config-ix.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.initializeConfigIx = void 0;
      var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
      function initializeConfigIx(program, params) {
        const { feeAuthority, collectProtocolFeesAuthority, rewardEmissionsSuperAuthority, defaultProtocolFeeRate, funder } = params;
        const ix = program.instruction.initializeConfig(feeAuthority, collectProtocolFeesAuthority, rewardEmissionsSuperAuthority, defaultProtocolFeeRate, {
          accounts: {
            config: params.whirlpoolsConfigKeypair.publicKey,
            funder,
            systemProgram: web3_js_1.SystemProgram.programId
          }
        });
        return {
          instructions: [ix],
          cleanupInstructions: [],
          signers: [params.whirlpoolsConfigKeypair]
        };
      }
      exports2.initializeConfigIx = initializeConfigIx;
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/instructions/initialize-fee-tier-ix.js
  var require_initialize_fee_tier_ix = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/instructions/initialize-fee-tier-ix.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.initializeFeeTierIx = void 0;
      var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
      function initializeFeeTierIx(program, params) {
        const { feeTierPda, whirlpoolsConfig, tickSpacing, feeAuthority, defaultFeeRate, funder } = params;
        const ix = program.instruction.initializeFeeTier(tickSpacing, defaultFeeRate, {
          accounts: {
            config: whirlpoolsConfig,
            feeTier: feeTierPda.publicKey,
            feeAuthority,
            funder,
            systemProgram: web3_js_1.SystemProgram.programId
          }
        });
        return {
          instructions: [ix],
          cleanupInstructions: [],
          signers: []
        };
      }
      exports2.initializeFeeTierIx = initializeFeeTierIx;
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/instructions/initialize-pool-ix.js
  var require_initialize_pool_ix = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/instructions/initialize-pool-ix.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.initializePoolIx = void 0;
      var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
      var spl_token_1 = (init_index_browser_esm2(), __toCommonJS(index_browser_esm_exports2));
      function initializePoolIx(program, params) {
        const { initSqrtPrice, tokenMintA, tokenMintB, whirlpoolsConfig, whirlpoolPda, feeTierKey, tokenVaultAKeypair, tokenVaultBKeypair, tickSpacing, funder } = params;
        const whirlpoolBumps = {
          whirlpoolBump: whirlpoolPda.bump
        };
        const ix = program.instruction.initializePool(whirlpoolBumps, tickSpacing, initSqrtPrice, {
          accounts: {
            whirlpoolsConfig,
            tokenMintA,
            tokenMintB,
            funder,
            whirlpool: whirlpoolPda.publicKey,
            tokenVaultA: tokenVaultAKeypair.publicKey,
            tokenVaultB: tokenVaultBKeypair.publicKey,
            feeTier: feeTierKey,
            tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            systemProgram: web3_js_1.SystemProgram.programId,
            rent: web3_js_1.SYSVAR_RENT_PUBKEY
          }
        });
        return {
          instructions: [ix],
          cleanupInstructions: [],
          signers: [tokenVaultAKeypair, tokenVaultBKeypair]
        };
      }
      exports2.initializePoolIx = initializePoolIx;
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/instructions/initialize-reward-ix.js
  var require_initialize_reward_ix = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/instructions/initialize-reward-ix.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        var desc = Object.getOwnPropertyDescriptor(m, k2);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k2];
          } };
        }
        Object.defineProperty(o, k22, desc);
      } : function(o, m, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o[k22] = m[k2];
      });
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v2) {
        Object.defineProperty(o, "default", { enumerable: true, value: v2 });
      } : function(o, v2) {
        o["default"] = v2;
      });
      var __importStar = exports2 && exports2.__importStar || function(mod2) {
        if (mod2 && mod2.__esModule)
          return mod2;
        var result = {};
        if (mod2 != null) {
          for (var k2 in mod2)
            if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k2))
              __createBinding(result, mod2, k2);
        }
        __setModuleDefault(result, mod2);
        return result;
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.initializeRewardIx = void 0;
      var anchor = __importStar((init_browser(), __toCommonJS(browser_exports)));
      var spl_token_1 = (init_index_browser_esm2(), __toCommonJS(index_browser_esm_exports2));
      var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
      function initializeRewardIx(program, params) {
        const { rewardAuthority, funder, whirlpool, rewardMint, rewardVaultKeypair, rewardIndex } = params;
        const ix = program.instruction.initializeReward(rewardIndex, {
          accounts: {
            rewardAuthority,
            funder,
            whirlpool,
            rewardMint,
            rewardVault: rewardVaultKeypair.publicKey,
            tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            systemProgram: web3_js_1.SystemProgram.programId,
            rent: anchor.web3.SYSVAR_RENT_PUBKEY
          }
        });
        return {
          instructions: [ix],
          cleanupInstructions: [],
          signers: [rewardVaultKeypair]
        };
      }
      exports2.initializeRewardIx = initializeRewardIx;
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/instructions/initialize-tick-array-ix.js
  var require_initialize_tick_array_ix = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/instructions/initialize-tick-array-ix.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        var desc = Object.getOwnPropertyDescriptor(m, k2);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k2];
          } };
        }
        Object.defineProperty(o, k22, desc);
      } : function(o, m, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o[k22] = m[k2];
      });
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v2) {
        Object.defineProperty(o, "default", { enumerable: true, value: v2 });
      } : function(o, v2) {
        o["default"] = v2;
      });
      var __importStar = exports2 && exports2.__importStar || function(mod2) {
        if (mod2 && mod2.__esModule)
          return mod2;
        var result = {};
        if (mod2 != null) {
          for (var k2 in mod2)
            if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k2))
              __createBinding(result, mod2, k2);
        }
        __setModuleDefault(result, mod2);
        return result;
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.initTickArrayIx = void 0;
      var anchor = __importStar((init_browser(), __toCommonJS(browser_exports)));
      function initTickArrayIx(program, params) {
        const { whirlpool, funder, tickArrayPda } = params;
        const ix = program.instruction.initializeTickArray(params.startTick, {
          accounts: {
            whirlpool,
            funder,
            tickArray: tickArrayPda.publicKey,
            systemProgram: anchor.web3.SystemProgram.programId
          }
        });
        return {
          instructions: [ix],
          cleanupInstructions: [],
          signers: []
        };
      }
      exports2.initTickArrayIx = initTickArrayIx;
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/utils/instructions-util.js
  var require_instructions_util = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/utils/instructions-util.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        var desc = Object.getOwnPropertyDescriptor(m, k2);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k2];
          } };
        }
        Object.defineProperty(o, k22, desc);
      } : function(o, m, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o[k22] = m[k2];
      });
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v2) {
        Object.defineProperty(o, "default", { enumerable: true, value: v2 });
      } : function(o, v2) {
        o["default"] = v2;
      });
      var __importStar = exports2 && exports2.__importStar || function(mod2) {
        if (mod2 && mod2.__esModule)
          return mod2;
        var result = {};
        if (mod2 != null) {
          for (var k2 in mod2)
            if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k2))
              __createBinding(result, mod2, k2);
        }
        __setModuleDefault(result, mod2);
        return result;
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.openPositionAccounts = void 0;
      var spl_token_1 = (init_index_browser_esm2(), __toCommonJS(index_browser_esm_exports2));
      var anchor = __importStar((init_browser(), __toCommonJS(browser_exports)));
      var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
      function openPositionAccounts(params) {
        const { funder, owner, positionPda, positionMintAddress, positionTokenAccount: positionTokenAccountAddress, whirlpool: whirlpoolKey } = params;
        return {
          funder,
          owner,
          position: positionPda.publicKey,
          positionMint: positionMintAddress,
          positionTokenAccount: positionTokenAccountAddress,
          whirlpool: whirlpoolKey,
          tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
          systemProgram: web3_js_1.SystemProgram.programId,
          rent: anchor.web3.SYSVAR_RENT_PUBKEY,
          associatedTokenProgram: spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID
        };
      }
      exports2.openPositionAccounts = openPositionAccounts;
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/instructions/open-position-ix.js
  var require_open_position_ix = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/instructions/open-position-ix.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.openPositionWithMetadataIx = exports2.openPositionIx = void 0;
      var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
      var __1 = require_dist3();
      var instructions_util_1 = require_instructions_util();
      function openPositionIx(program, params) {
        const { positionPda, tickLowerIndex, tickUpperIndex } = params;
        const bumps = {
          positionBump: positionPda.bump
        };
        const ix = program.instruction.openPosition(bumps, tickLowerIndex, tickUpperIndex, {
          accounts: (0, instructions_util_1.openPositionAccounts)(params)
        });
        return {
          instructions: [ix],
          cleanupInstructions: [],
          signers: []
        };
      }
      exports2.openPositionIx = openPositionIx;
      function openPositionWithMetadataIx(program, params) {
        const { positionPda, metadataPda, tickLowerIndex, tickUpperIndex } = params;
        const bumps = {
          positionBump: positionPda.bump,
          metadataBump: metadataPda.bump
        };
        const ix = program.instruction.openPositionWithMetadata(bumps, tickLowerIndex, tickUpperIndex, {
          accounts: Object.assign(Object.assign({}, (0, instructions_util_1.openPositionAccounts)(params)), { positionMetadataAccount: metadataPda.publicKey, metadataProgram: __1.METADATA_PROGRAM_ADDRESS, metadataUpdateAuth: new web3_js_1.PublicKey("3axbTs2z5GBy6usVbNVoqEgZMng3vZvMnAoX29BFfwhr") })
        });
        return {
          instructions: [ix],
          cleanupInstructions: [],
          signers: []
        };
      }
      exports2.openPositionWithMetadataIx = openPositionWithMetadataIx;
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/instructions/set-collect-protocol-fees-authority-ix.js
  var require_set_collect_protocol_fees_authority_ix = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/instructions/set-collect-protocol-fees-authority-ix.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.setCollectProtocolFeesAuthorityIx = void 0;
      function setCollectProtocolFeesAuthorityIx(program, params) {
        const { whirlpoolsConfig, collectProtocolFeesAuthority, newCollectProtocolFeesAuthority } = params;
        const ix = program.instruction.setCollectProtocolFeesAuthority({
          accounts: {
            whirlpoolsConfig,
            collectProtocolFeesAuthority,
            newCollectProtocolFeesAuthority
          }
        });
        return {
          instructions: [ix],
          cleanupInstructions: [],
          signers: []
        };
      }
      exports2.setCollectProtocolFeesAuthorityIx = setCollectProtocolFeesAuthorityIx;
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/instructions/set-default-fee-rate-ix.js
  var require_set_default_fee_rate_ix = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/instructions/set-default-fee-rate-ix.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.setDefaultFeeRateIx = void 0;
      var public_1 = require_public3();
      function setDefaultFeeRateIx(program, params) {
        const { whirlpoolsConfig, feeAuthority, tickSpacing, defaultFeeRate } = params;
        const feeTierPda = public_1.PDAUtil.getFeeTier(program.programId, whirlpoolsConfig, tickSpacing);
        const ix = program.instruction.setDefaultFeeRate(defaultFeeRate, {
          accounts: {
            whirlpoolsConfig,
            feeTier: feeTierPda.publicKey,
            feeAuthority
          }
        });
        return {
          instructions: [ix],
          cleanupInstructions: [],
          signers: []
        };
      }
      exports2.setDefaultFeeRateIx = setDefaultFeeRateIx;
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/instructions/set-default-protocol-fee-rate-ix.js
  var require_set_default_protocol_fee_rate_ix = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/instructions/set-default-protocol-fee-rate-ix.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.setDefaultProtocolFeeRateIx = void 0;
      function setDefaultProtocolFeeRateIx(program, params) {
        const { whirlpoolsConfig, feeAuthority, defaultProtocolFeeRate } = params;
        const ix = program.instruction.setDefaultProtocolFeeRate(defaultProtocolFeeRate, {
          accounts: {
            whirlpoolsConfig,
            feeAuthority
          }
        });
        return {
          instructions: [ix],
          cleanupInstructions: [],
          signers: []
        };
      }
      exports2.setDefaultProtocolFeeRateIx = setDefaultProtocolFeeRateIx;
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/instructions/set-fee-authority-ix.js
  var require_set_fee_authority_ix = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/instructions/set-fee-authority-ix.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.setFeeAuthorityIx = void 0;
      function setFeeAuthorityIx(program, params) {
        const { whirlpoolsConfig, feeAuthority, newFeeAuthority } = params;
        const ix = program.instruction.setFeeAuthority({
          accounts: {
            whirlpoolsConfig,
            feeAuthority,
            newFeeAuthority
          }
        });
        return {
          instructions: [ix],
          cleanupInstructions: [],
          signers: []
        };
      }
      exports2.setFeeAuthorityIx = setFeeAuthorityIx;
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/instructions/set-fee-rate-ix.js
  var require_set_fee_rate_ix = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/instructions/set-fee-rate-ix.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.setFeeRateIx = void 0;
      function setFeeRateIx(program, params) {
        const { whirlpoolsConfig, whirlpool, feeAuthority, feeRate } = params;
        const ix = program.instruction.setFeeRate(feeRate, {
          accounts: {
            whirlpoolsConfig,
            whirlpool,
            feeAuthority
          }
        });
        return {
          instructions: [ix],
          cleanupInstructions: [],
          signers: []
        };
      }
      exports2.setFeeRateIx = setFeeRateIx;
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/instructions/set-protocol-fee-rate-ix.js
  var require_set_protocol_fee_rate_ix = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/instructions/set-protocol-fee-rate-ix.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.setProtocolFeeRateIx = void 0;
      function setProtocolFeeRateIx(program, params) {
        const { whirlpoolsConfig, whirlpool, feeAuthority, protocolFeeRate } = params;
        const ix = program.instruction.setProtocolFeeRate(protocolFeeRate, {
          accounts: {
            whirlpoolsConfig,
            whirlpool,
            feeAuthority
          }
        });
        return {
          instructions: [ix],
          cleanupInstructions: [],
          signers: []
        };
      }
      exports2.setProtocolFeeRateIx = setProtocolFeeRateIx;
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/instructions/set-reward-authority-by-super-authority-ix.js
  var require_set_reward_authority_by_super_authority_ix = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/instructions/set-reward-authority-by-super-authority-ix.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.setRewardAuthorityBySuperAuthorityIx = void 0;
      function setRewardAuthorityBySuperAuthorityIx(program, params) {
        const { whirlpoolsConfig, whirlpool, rewardEmissionsSuperAuthority, newRewardAuthority, rewardIndex } = params;
        const ix = program.instruction.setRewardAuthorityBySuperAuthority(rewardIndex, {
          accounts: {
            whirlpoolsConfig,
            whirlpool,
            rewardEmissionsSuperAuthority,
            newRewardAuthority
          }
        });
        return {
          instructions: [ix],
          cleanupInstructions: [],
          signers: []
        };
      }
      exports2.setRewardAuthorityBySuperAuthorityIx = setRewardAuthorityBySuperAuthorityIx;
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/instructions/set-reward-authority-ix.js
  var require_set_reward_authority_ix = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/instructions/set-reward-authority-ix.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.setRewardAuthorityIx = void 0;
      function setRewardAuthorityIx(program, params) {
        const { whirlpool, rewardAuthority, newRewardAuthority, rewardIndex } = params;
        const ix = program.instruction.setRewardAuthority(rewardIndex, {
          accounts: {
            whirlpool,
            rewardAuthority,
            newRewardAuthority
          }
        });
        return {
          instructions: [ix],
          cleanupInstructions: [],
          signers: []
        };
      }
      exports2.setRewardAuthorityIx = setRewardAuthorityIx;
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/instructions/set-reward-emissions-ix.js
  var require_set_reward_emissions_ix = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/instructions/set-reward-emissions-ix.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.setRewardEmissionsIx = void 0;
      function setRewardEmissionsIx(program, params) {
        const { rewardAuthority, whirlpool, rewardIndex, rewardVaultKey: rewardVault, emissionsPerSecondX64 } = params;
        const ix = program.instruction.setRewardEmissions(rewardIndex, emissionsPerSecondX64, {
          accounts: {
            rewardAuthority,
            whirlpool,
            rewardVault
          }
        });
        return {
          instructions: [ix],
          cleanupInstructions: [],
          signers: []
        };
      }
      exports2.setRewardEmissionsIx = setRewardEmissionsIx;
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/instructions/set-reward-emissions-super-authority-ix.js
  var require_set_reward_emissions_super_authority_ix = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/instructions/set-reward-emissions-super-authority-ix.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.setRewardEmissionsSuperAuthorityIx = void 0;
      function setRewardEmissionsSuperAuthorityIx(program, params) {
        const { whirlpoolsConfig, rewardEmissionsSuperAuthority, newRewardEmissionsSuperAuthority } = params;
        const ix = program.instruction.setRewardEmissionsSuperAuthority({
          accounts: {
            whirlpoolsConfig,
            rewardEmissionsSuperAuthority,
            newRewardEmissionsSuperAuthority
          }
        });
        return {
          instructions: [ix],
          cleanupInstructions: [],
          signers: []
        };
      }
      exports2.setRewardEmissionsSuperAuthorityIx = setRewardEmissionsSuperAuthorityIx;
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/instructions/swap-ix.js
  var require_swap_ix = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/instructions/swap-ix.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.swapIx = void 0;
      var spl_token_1 = (init_index_browser_esm2(), __toCommonJS(index_browser_esm_exports2));
      function swapIx(program, params) {
        const { amount, otherAmountThreshold, sqrtPriceLimit, amountSpecifiedIsInput, aToB, whirlpool, tokenAuthority, tokenOwnerAccountA, tokenVaultA, tokenOwnerAccountB, tokenVaultB, tickArray0, tickArray1, tickArray2, oracle } = params;
        const ix = program.instruction.swap(amount, otherAmountThreshold, sqrtPriceLimit, amountSpecifiedIsInput, aToB, {
          accounts: {
            tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            tokenAuthority,
            whirlpool,
            tokenOwnerAccountA,
            tokenVaultA,
            tokenOwnerAccountB,
            tokenVaultB,
            tickArray0,
            tickArray1,
            tickArray2,
            oracle
          }
        });
        return {
          instructions: [ix],
          cleanupInstructions: [],
          signers: []
        };
      }
      exports2.swapIx = swapIx;
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/instructions/update-fees-and-rewards-ix.js
  var require_update_fees_and_rewards_ix = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/instructions/update-fees-and-rewards-ix.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.updateFeesAndRewardsIx = void 0;
      function updateFeesAndRewardsIx(program, params) {
        const { whirlpool, position, tickArrayLower, tickArrayUpper } = params;
        const ix = program.instruction.updateFeesAndRewards({
          accounts: {
            whirlpool,
            position,
            tickArrayLower,
            tickArrayUpper
          }
        });
        return {
          instructions: [ix],
          cleanupInstructions: [],
          signers: []
        };
      }
      exports2.updateFeesAndRewardsIx = updateFeesAndRewardsIx;
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/instructions/index.js
  var require_instructions = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/instructions/index.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        var desc = Object.getOwnPropertyDescriptor(m, k2);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k2];
          } };
        }
        Object.defineProperty(o, k22, desc);
      } : function(o, m, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o[k22] = m[k2];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p2 in m)
          if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
            __createBinding(exports3, m, p2);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar(require_close_position_ix(), exports2);
      __exportStar(require_collect_fees_ix(), exports2);
      __exportStar(require_collect_protocol_fees_ix(), exports2);
      __exportStar(require_collect_reward_ix(), exports2);
      __exportStar(require_decrease_liquidity_ix(), exports2);
      __exportStar(require_increase_liquidity_ix(), exports2);
      __exportStar(require_initialize_config_ix(), exports2);
      __exportStar(require_initialize_fee_tier_ix(), exports2);
      __exportStar(require_initialize_pool_ix(), exports2);
      __exportStar(require_initialize_reward_ix(), exports2);
      __exportStar(require_initialize_tick_array_ix(), exports2);
      __exportStar(require_open_position_ix(), exports2);
      __exportStar(require_set_collect_protocol_fees_authority_ix(), exports2);
      __exportStar(require_set_default_fee_rate_ix(), exports2);
      __exportStar(require_set_default_protocol_fee_rate_ix(), exports2);
      __exportStar(require_set_fee_authority_ix(), exports2);
      __exportStar(require_set_fee_rate_ix(), exports2);
      __exportStar(require_set_protocol_fee_rate_ix(), exports2);
      __exportStar(require_set_reward_authority_by_super_authority_ix(), exports2);
      __exportStar(require_set_reward_authority_ix(), exports2);
      __exportStar(require_set_reward_emissions_ix(), exports2);
      __exportStar(require_set_reward_emissions_super_authority_ix(), exports2);
      __exportStar(require_swap_ix(), exports2);
      __exportStar(require_update_fees_and_rewards_ix(), exports2);
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/ix.js
  var require_ix = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/ix.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        var desc = Object.getOwnPropertyDescriptor(m, k2);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k2];
          } };
        }
        Object.defineProperty(o, k22, desc);
      } : function(o, m, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o[k22] = m[k2];
      });
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v2) {
        Object.defineProperty(o, "default", { enumerable: true, value: v2 });
      } : function(o, v2) {
        o["default"] = v2;
      });
      var __importStar = exports2 && exports2.__importStar || function(mod2) {
        if (mod2 && mod2.__esModule)
          return mod2;
        var result = {};
        if (mod2 != null) {
          for (var k2 in mod2)
            if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k2))
              __createBinding(result, mod2, k2);
        }
        __setModuleDefault(result, mod2);
        return result;
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.WhirlpoolIx = void 0;
      var ix = __importStar(require_instructions());
      var WhirlpoolIx = class {
        static initializeConfigIx(program, params) {
          return ix.initializeConfigIx(program, params);
        }
        static initializeFeeTierIx(program, params) {
          return ix.initializeFeeTierIx(program, params);
        }
        static initializePoolIx(program, params) {
          return ix.initializePoolIx(program, params);
        }
        static initializeRewardIx(program, params) {
          return ix.initializeRewardIx(program, params);
        }
        static initTickArrayIx(program, params) {
          return ix.initTickArrayIx(program, params);
        }
        static openPositionIx(program, params) {
          return ix.openPositionIx(program, params);
        }
        static openPositionWithMetadataIx(program, params) {
          return ix.openPositionWithMetadataIx(program, params);
        }
        static increaseLiquidityIx(program, params) {
          return ix.increaseLiquidityIx(program, params);
        }
        static decreaseLiquidityIx(program, params) {
          return ix.decreaseLiquidityIx(program, params);
        }
        static closePositionIx(program, params) {
          return ix.closePositionIx(program, params);
        }
        static swapIx(program, params) {
          return ix.swapIx(program, params);
        }
        static updateFeesAndRewardsIx(program, params) {
          return ix.updateFeesAndRewardsIx(program, params);
        }
        static collectFeesIx(program, params) {
          return ix.collectFeesIx(program, params);
        }
        static collectProtocolFeesIx(program, params) {
          return ix.collectProtocolFeesIx(program, params);
        }
        static collectRewardIx(program, params) {
          return ix.collectRewardIx(program, params);
        }
        static setCollectProtocolFeesAuthorityIx(program, params) {
          return ix.setCollectProtocolFeesAuthorityIx(program, params);
        }
        static setDefaultFeeRateIx(program, params) {
          return ix.setDefaultFeeRateIx(program, params);
        }
        static setDefaultProtocolFeeRateIx(program, params) {
          return ix.setDefaultProtocolFeeRateIx(program, params);
        }
        static setFeeAuthorityIx(program, params) {
          return ix.setFeeAuthorityIx(program, params);
        }
        static setFeeRateIx(program, params) {
          return ix.setFeeRateIx(program, params);
        }
        static setProtocolFeeRateIx(program, params) {
          return ix.setProtocolFeeRateIx(program, params);
        }
        static setRewardAuthorityBySuperAuthorityIx(program, params) {
          return ix.setRewardAuthorityBySuperAuthorityIx(program, params);
        }
        static setRewardAuthorityIx(program, params) {
          return ix.setRewardAuthorityIx(program, params);
        }
        static setRewardEmissionsIx(program, params) {
          return ix.setRewardEmissionsIx(program, params);
        }
        static setRewardEmissionsSuperAuthorityIx(program, params) {
          return ix.setRewardEmissionsSuperAuthorityIx(program, params);
        }
      };
      exports2.WhirlpoolIx = WhirlpoolIx;
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/impl/position-impl.js
  var require_position_impl = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/impl/position-impl.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __rest = exports2 && exports2.__rest || function(s, e) {
        var t2 = {};
        for (var p2 in s)
          if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)
            t2[p2] = s[p2];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
            if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
              t2[p2[i]] = s[p2[i]];
          }
        return t2;
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.PositionImpl = void 0;
      var common_sdk_1 = require_dist2();
      var instructions_1 = require_instructions();
      var public_1 = require_public3();
      var PositionImpl = class {
        constructor(ctx, fetcher, address, data) {
          this.ctx = ctx;
          this.fetcher = fetcher;
          this.address = address;
          this.data = data;
        }
        getAddress() {
          return this.address;
        }
        getData() {
          return this.data;
        }
        refreshData() {
          return __awaiter(this, void 0, void 0, function* () {
            yield this.refresh();
            return this.data;
          });
        }
        increaseLiquidity(liquidityInput, resolveATA = true, sourceWallet, positionWallet, ataPayer) {
          return __awaiter(this, void 0, void 0, function* () {
            const sourceWalletKey = sourceWallet ? common_sdk_1.AddressUtil.toPubKey(sourceWallet) : this.ctx.wallet.publicKey;
            const positionWalletKey = positionWallet ? common_sdk_1.AddressUtil.toPubKey(positionWallet) : this.ctx.wallet.publicKey;
            const ataPayerKey = ataPayer ? common_sdk_1.AddressUtil.toPubKey(ataPayer) : this.ctx.wallet.publicKey;
            const whirlpool = yield this.fetcher.getPool(this.data.whirlpool, true);
            if (!whirlpool) {
              throw new Error("Unable to fetch whirlpool for this position.");
            }
            const txBuilder = new common_sdk_1.TransactionBuilder(this.ctx.provider.connection, this.ctx.provider.wallet);
            let tokenOwnerAccountA;
            let tokenOwnerAccountB;
            if (resolveATA) {
              const [ataA, ataB] = yield (0, common_sdk_1.resolveOrCreateATAs)(this.ctx.connection, sourceWalletKey, [
                { tokenMint: whirlpool.tokenMintA, wrappedSolAmountIn: liquidityInput.tokenMaxA },
                { tokenMint: whirlpool.tokenMintB, wrappedSolAmountIn: liquidityInput.tokenMaxB }
              ], () => this.fetcher.getAccountRentExempt(), ataPayerKey);
              const _a = ataA, { address: ataAddrA } = _a, tokenOwnerAccountAIx = __rest(_a, ["address"]);
              const _b = ataB, { address: ataAddrB } = _b, tokenOwnerAccountBIx = __rest(_b, ["address"]);
              tokenOwnerAccountA = ataAddrA;
              tokenOwnerAccountB = ataAddrB;
              txBuilder.addInstruction(tokenOwnerAccountAIx);
              txBuilder.addInstruction(tokenOwnerAccountBIx);
            } else {
              tokenOwnerAccountA = yield (0, common_sdk_1.deriveATA)(sourceWalletKey, whirlpool.tokenMintA);
              tokenOwnerAccountB = yield (0, common_sdk_1.deriveATA)(sourceWalletKey, whirlpool.tokenMintB);
            }
            const positionTokenAccount = yield (0, common_sdk_1.deriveATA)(positionWalletKey, this.data.positionMint);
            const increaseIx = (0, instructions_1.increaseLiquidityIx)(this.ctx.program, Object.assign(Object.assign({}, liquidityInput), {
              whirlpool: this.data.whirlpool,
              position: this.address,
              positionTokenAccount,
              tokenOwnerAccountA,
              tokenOwnerAccountB,
              tokenVaultA: whirlpool.tokenVaultA,
              tokenVaultB: whirlpool.tokenVaultB,
              tickArrayLower: public_1.PDAUtil.getTickArray(this.ctx.program.programId, this.data.whirlpool, public_1.TickUtil.getStartTickIndex(this.data.tickLowerIndex, whirlpool.tickSpacing)).publicKey,
              tickArrayUpper: public_1.PDAUtil.getTickArray(this.ctx.program.programId, this.data.whirlpool, public_1.TickUtil.getStartTickIndex(this.data.tickUpperIndex, whirlpool.tickSpacing)).publicKey,
              positionAuthority: positionWalletKey
            }));
            txBuilder.addInstruction(increaseIx);
            return txBuilder;
          });
        }
        decreaseLiquidity(liquidityInput, resolveATA = true, sourceWallet, positionWallet, ataPayer) {
          return __awaiter(this, void 0, void 0, function* () {
            const sourceWalletKey = sourceWallet ? common_sdk_1.AddressUtil.toPubKey(sourceWallet) : this.ctx.wallet.publicKey;
            const positionWalletKey = positionWallet ? common_sdk_1.AddressUtil.toPubKey(positionWallet) : this.ctx.wallet.publicKey;
            const ataPayerKey = ataPayer ? common_sdk_1.AddressUtil.toPubKey(ataPayer) : this.ctx.wallet.publicKey;
            const whirlpool = yield this.fetcher.getPool(this.data.whirlpool, true);
            if (!whirlpool) {
              throw new Error("Unable to fetch whirlpool for this position.");
            }
            const txBuilder = new common_sdk_1.TransactionBuilder(this.ctx.provider.connection, this.ctx.provider.wallet);
            let tokenOwnerAccountA;
            let tokenOwnerAccountB;
            if (resolveATA) {
              const [ataA, ataB] = yield (0, common_sdk_1.resolveOrCreateATAs)(this.ctx.connection, sourceWalletKey, [{ tokenMint: whirlpool.tokenMintA }, { tokenMint: whirlpool.tokenMintB }], () => this.fetcher.getAccountRentExempt(), ataPayerKey);
              const _a = ataA, { address: ataAddrA } = _a, tokenOwnerAccountAIx = __rest(_a, ["address"]);
              const _b = ataB, { address: ataAddrB } = _b, tokenOwnerAccountBIx = __rest(_b, ["address"]);
              tokenOwnerAccountA = ataAddrA;
              tokenOwnerAccountB = ataAddrB;
              txBuilder.addInstruction(tokenOwnerAccountAIx);
              txBuilder.addInstruction(tokenOwnerAccountBIx);
            } else {
              tokenOwnerAccountA = yield (0, common_sdk_1.deriveATA)(sourceWalletKey, whirlpool.tokenMintA);
              tokenOwnerAccountB = yield (0, common_sdk_1.deriveATA)(sourceWalletKey, whirlpool.tokenMintB);
            }
            const decreaseIx = (0, instructions_1.decreaseLiquidityIx)(this.ctx.program, Object.assign(Object.assign({}, liquidityInput), {
              whirlpool: this.data.whirlpool,
              position: this.address,
              positionTokenAccount: yield (0, common_sdk_1.deriveATA)(positionWalletKey, this.data.positionMint),
              tokenOwnerAccountA,
              tokenOwnerAccountB,
              tokenVaultA: whirlpool.tokenVaultA,
              tokenVaultB: whirlpool.tokenVaultB,
              tickArrayLower: public_1.PDAUtil.getTickArray(this.ctx.program.programId, this.data.whirlpool, public_1.TickUtil.getStartTickIndex(this.data.tickLowerIndex, whirlpool.tickSpacing)).publicKey,
              tickArrayUpper: public_1.PDAUtil.getTickArray(this.ctx.program.programId, this.data.whirlpool, public_1.TickUtil.getStartTickIndex(this.data.tickUpperIndex, whirlpool.tickSpacing)).publicKey,
              positionAuthority: positionWalletKey
            }));
            txBuilder.addInstruction(decreaseIx);
            return txBuilder;
          });
        }
        refresh() {
          return __awaiter(this, void 0, void 0, function* () {
            const account = yield this.fetcher.getPosition(this.address, true);
            if (!!account) {
              this.data = account;
            }
          });
        }
      };
      exports2.PositionImpl = PositionImpl;
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/impl/whirlpool-impl.js
  var require_whirlpool_impl = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/impl/whirlpool-impl.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __rest = exports2 && exports2.__rest || function(s, e) {
        var t2 = {};
        for (var p2 in s)
          if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)
            t2[p2] = s[p2];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
            if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
              t2[p2[i]] = s[p2[i]];
          }
        return t2;
      };
      var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.WhirlpoolImpl = void 0;
      var common_sdk_1 = require_dist2();
      var anchor_1 = (init_browser(), __toCommonJS(browser_exports));
      var instructions_1 = require_instructions();
      var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
      var spl_token_1 = (init_index_browser_esm2(), __toCommonJS(index_browser_esm_exports2));
      var tiny_invariant_1 = __importDefault(require_tiny_invariant_cjs());
      var public_1 = require_public3();
      var public_2 = require_public4();
      var WhirlpoolImpl = class {
        constructor(ctx, fetcher, address, tokenAInfo, tokenBInfo, data) {
          this.ctx = ctx;
          this.fetcher = fetcher;
          this.address = address;
          this.tokenAInfo = tokenAInfo;
          this.tokenBInfo = tokenBInfo;
          this.data = data;
        }
        getAddress() {
          return this.address;
        }
        getData() {
          return this.data;
        }
        getTokenAInfo() {
          return this.tokenAInfo;
        }
        getTokenBInfo() {
          return this.tokenBInfo;
        }
        refreshData() {
          return __awaiter(this, void 0, void 0, function* () {
            yield this.refresh();
            return this.data;
          });
        }
        openPosition(tickLower, tickUpper, liquidityInput, wallet, funder) {
          return __awaiter(this, void 0, void 0, function* () {
            yield this.refresh();
            return this.getOpenPositionWithOptMetadataTx(tickLower, tickUpper, liquidityInput, !!wallet ? common_sdk_1.AddressUtil.toPubKey(wallet) : this.ctx.wallet.publicKey, !!funder ? common_sdk_1.AddressUtil.toPubKey(funder) : this.ctx.wallet.publicKey);
          });
        }
        openPositionWithMetadata(tickLower, tickUpper, liquidityInput, sourceWallet, positionWallet, funder) {
          return __awaiter(this, void 0, void 0, function* () {
            yield this.refresh();
            return this.getOpenPositionWithOptMetadataTx(tickLower, tickUpper, liquidityInput, !!sourceWallet ? common_sdk_1.AddressUtil.toPubKey(sourceWallet) : this.ctx.wallet.publicKey, !!funder ? common_sdk_1.AddressUtil.toPubKey(funder) : this.ctx.wallet.publicKey, true);
          });
        }
        initTickArrayForTicks(ticks, funder, refresh = true) {
          return __awaiter(this, void 0, void 0, function* () {
            const initTickArrayStartPdas = yield public_1.TickArrayUtil.getUninitializedArraysPDAs(ticks, this.ctx.program.programId, this.address, this.data.tickSpacing, this.fetcher, refresh);
            if (!initTickArrayStartPdas.length) {
              return null;
            }
            const txBuilder = new common_sdk_1.TransactionBuilder(this.ctx.provider.connection, this.ctx.provider.wallet);
            initTickArrayStartPdas.forEach((initTickArrayInfo) => {
              txBuilder.addInstruction((0, instructions_1.initTickArrayIx)(this.ctx.program, {
                startTick: initTickArrayInfo.startIndex,
                tickArrayPda: initTickArrayInfo.pda,
                whirlpool: this.address,
                funder: !!funder ? common_sdk_1.AddressUtil.toPubKey(funder) : this.ctx.provider.wallet.publicKey
              }));
            });
            return txBuilder;
          });
        }
        closePosition(positionAddress, slippageTolerance, destinationWallet, positionWallet, payer) {
          return __awaiter(this, void 0, void 0, function* () {
            yield this.refresh();
            const positionWalletKey = positionWallet ? common_sdk_1.AddressUtil.toPubKey(positionWallet) : this.ctx.wallet.publicKey;
            const destinationWalletKey = destinationWallet ? common_sdk_1.AddressUtil.toPubKey(destinationWallet) : this.ctx.wallet.publicKey;
            const payerKey = payer ? common_sdk_1.AddressUtil.toPubKey(payer) : this.ctx.wallet.publicKey;
            return this.getClosePositionIx(common_sdk_1.AddressUtil.toPubKey(positionAddress), slippageTolerance, destinationWalletKey, positionWalletKey, payerKey);
          });
        }
        swap(quote, sourceWallet) {
          return __awaiter(this, void 0, void 0, function* () {
            const sourceWalletKey = sourceWallet ? common_sdk_1.AddressUtil.toPubKey(sourceWallet) : this.ctx.wallet.publicKey;
            return this.getSwapTx(quote, sourceWalletKey);
          });
        }
        getOpenPositionWithOptMetadataTx(tickLower, tickUpper, liquidityInput, wallet, funder, withMetadata = false) {
          return __awaiter(this, void 0, void 0, function* () {
            (0, tiny_invariant_1.default)(public_1.TickUtil.checkTickInBounds(tickLower), "tickLower is out of bounds.");
            (0, tiny_invariant_1.default)(public_1.TickUtil.checkTickInBounds(tickUpper), "tickUpper is out of bounds.");
            const { liquidityAmount: liquidity, tokenMaxA, tokenMaxB } = liquidityInput;
            (0, tiny_invariant_1.default)(liquidity.gt(new spl_token_1.u64(0)), "liquidity must be greater than zero");
            const whirlpool = yield this.fetcher.getPool(this.address, false);
            if (!whirlpool) {
              throw new Error(`Whirlpool not found: ${(0, anchor_1.translateAddress)(this.address).toBase58()}`);
            }
            (0, tiny_invariant_1.default)(public_1.TickUtil.isTickInitializable(tickLower, whirlpool.tickSpacing), `lower tick ${tickLower} is not an initializable tick for tick-spacing ${whirlpool.tickSpacing}`);
            (0, tiny_invariant_1.default)(public_1.TickUtil.isTickInitializable(tickUpper, whirlpool.tickSpacing), `upper tick ${tickUpper} is not an initializable tick for tick-spacing ${whirlpool.tickSpacing}`);
            const positionMintKeypair = web3_js_1.Keypair.generate();
            const positionPda = public_1.PDAUtil.getPosition(this.ctx.program.programId, positionMintKeypair.publicKey);
            const metadataPda = public_1.PDAUtil.getPositionMetadata(positionMintKeypair.publicKey);
            const positionTokenAccountAddress = yield (0, common_sdk_1.deriveATA)(wallet, positionMintKeypair.publicKey);
            const txBuilder = new common_sdk_1.TransactionBuilder(this.ctx.provider.connection, this.ctx.provider.wallet);
            const positionIx = (withMetadata ? instructions_1.openPositionWithMetadataIx : instructions_1.openPositionIx)(this.ctx.program, {
              funder,
              owner: wallet,
              positionPda,
              metadataPda,
              positionMintAddress: positionMintKeypair.publicKey,
              positionTokenAccount: positionTokenAccountAddress,
              whirlpool: this.address,
              tickLowerIndex: tickLower,
              tickUpperIndex: tickUpper
            });
            txBuilder.addInstruction(positionIx).addSigner(positionMintKeypair);
            const [ataA, ataB] = yield (0, common_sdk_1.resolveOrCreateATAs)(this.ctx.connection, wallet, [
              { tokenMint: whirlpool.tokenMintA, wrappedSolAmountIn: tokenMaxA },
              { tokenMint: whirlpool.tokenMintB, wrappedSolAmountIn: tokenMaxB }
            ], () => this.fetcher.getAccountRentExempt(), funder);
            const { address: tokenOwnerAccountA } = ataA, tokenOwnerAccountAIx = __rest(ataA, ["address"]);
            const { address: tokenOwnerAccountB } = ataB, tokenOwnerAccountBIx = __rest(ataB, ["address"]);
            txBuilder.addInstruction(tokenOwnerAccountAIx);
            txBuilder.addInstruction(tokenOwnerAccountBIx);
            const tickArrayLowerPda = public_1.PDAUtil.getTickArrayFromTickIndex(tickLower, this.data.tickSpacing, this.address, this.ctx.program.programId);
            const tickArrayUpperPda = public_1.PDAUtil.getTickArrayFromTickIndex(tickUpper, this.data.tickSpacing, this.address, this.ctx.program.programId);
            const liquidityIx = (0, instructions_1.increaseLiquidityIx)(this.ctx.program, {
              liquidityAmount: liquidity,
              tokenMaxA,
              tokenMaxB,
              whirlpool: this.address,
              positionAuthority: wallet,
              position: positionPda.publicKey,
              positionTokenAccount: positionTokenAccountAddress,
              tokenOwnerAccountA,
              tokenOwnerAccountB,
              tokenVaultA: whirlpool.tokenVaultA,
              tokenVaultB: whirlpool.tokenVaultB,
              tickArrayLower: tickArrayLowerPda.publicKey,
              tickArrayUpper: tickArrayUpperPda.publicKey
            });
            txBuilder.addInstruction(liquidityIx);
            return {
              positionMint: positionMintKeypair.publicKey,
              tx: txBuilder
            };
          });
        }
        getClosePositionIx(positionAddress, slippageTolerance, destinationWallet, positionWallet, payerKey) {
          return __awaiter(this, void 0, void 0, function* () {
            const position = yield this.fetcher.getPosition(positionAddress, true);
            if (!position) {
              throw new Error(`Position not found: ${positionAddress.toBase58()}`);
            }
            const whirlpool = this.data;
            (0, tiny_invariant_1.default)(position.whirlpool.equals(this.address), `Position ${positionAddress.toBase58()} is not a position for Whirlpool ${this.address.toBase58()}`);
            const tickArrayLower = public_1.PDAUtil.getTickArrayFromTickIndex(position.tickLowerIndex, whirlpool.tickSpacing, position.whirlpool, this.ctx.program.programId).publicKey;
            const tickArrayUpper = public_1.PDAUtil.getTickArrayFromTickIndex(position.tickUpperIndex, whirlpool.tickSpacing, position.whirlpool, this.ctx.program.programId).publicKey;
            const positionTokenAccount = yield (0, common_sdk_1.deriveATA)(positionWallet, position.positionMint);
            const txBuilder = new common_sdk_1.TransactionBuilder(this.ctx.provider.connection, this.ctx.provider.wallet);
            const resolvedAssociatedTokenAddresses = {};
            const [ataA, ataB] = yield (0, common_sdk_1.resolveOrCreateATAs)(this.ctx.connection, destinationWallet, [{ tokenMint: whirlpool.tokenMintA }, { tokenMint: whirlpool.tokenMintB }], () => this.fetcher.getAccountRentExempt(), payerKey);
            const { address: tokenOwnerAccountA } = ataA, createTokenOwnerAccountAIx = __rest(ataA, ["address"]);
            const { address: tokenOwnerAccountB } = ataB, createTokenOwnerAccountBIx = __rest(ataB, ["address"]);
            txBuilder.addInstruction(createTokenOwnerAccountAIx).addInstruction(createTokenOwnerAccountBIx);
            resolvedAssociatedTokenAddresses[whirlpool.tokenMintA.toBase58()] = tokenOwnerAccountA;
            resolvedAssociatedTokenAddresses[whirlpool.tokenMintB.toBase58()] = tokenOwnerAccountB;
            if (position.liquidity.gt(new spl_token_1.u64(0))) {
              const decreaseLiqQuote = (0, public_2.decreaseLiquidityQuoteByLiquidityWithParams)({
                liquidity: position.liquidity,
                slippageTolerance,
                sqrtPrice: whirlpool.sqrtPrice,
                tickCurrentIndex: whirlpool.tickCurrentIndex,
                tickLowerIndex: position.tickLowerIndex,
                tickUpperIndex: position.tickUpperIndex
              });
              const liquidityIx = (0, instructions_1.decreaseLiquidityIx)(this.ctx.program, {
                liquidityAmount: decreaseLiqQuote.liquidityAmount,
                tokenMinA: decreaseLiqQuote.tokenMinA,
                tokenMinB: decreaseLiqQuote.tokenMinB,
                whirlpool: position.whirlpool,
                positionAuthority: positionWallet,
                position: positionAddress,
                positionTokenAccount,
                tokenOwnerAccountA,
                tokenOwnerAccountB,
                tokenVaultA: whirlpool.tokenVaultA,
                tokenVaultB: whirlpool.tokenVaultB,
                tickArrayLower,
                tickArrayUpper
              });
              txBuilder.addInstruction(liquidityIx);
            }
            const positionIx = (0, instructions_1.closePositionIx)(this.ctx.program, {
              positionAuthority: positionWallet,
              receiver: destinationWallet,
              positionTokenAccount,
              position: positionAddress,
              positionMint: position.positionMint
            });
            txBuilder.addInstruction(positionIx);
            return txBuilder;
          });
        }
        getSwapTx(input, wallet) {
          return __awaiter(this, void 0, void 0, function* () {
            const { amount, aToB } = input;
            const whirlpool = this.data;
            const txBuilder = new common_sdk_1.TransactionBuilder(this.ctx.provider.connection, this.ctx.provider.wallet);
            const [ataA, ataB] = yield (0, common_sdk_1.resolveOrCreateATAs)(this.ctx.connection, wallet, [
              { tokenMint: whirlpool.tokenMintA, wrappedSolAmountIn: aToB ? amount : common_sdk_1.ZERO },
              { tokenMint: whirlpool.tokenMintB, wrappedSolAmountIn: !aToB ? amount : common_sdk_1.ZERO }
            ], () => this.fetcher.getAccountRentExempt());
            const { address: tokenOwnerAccountA } = ataA, tokenOwnerAccountAIx = __rest(ataA, ["address"]);
            const { address: tokenOwnerAccountB } = ataB, tokenOwnerAccountBIx = __rest(ataB, ["address"]);
            txBuilder.addInstruction(tokenOwnerAccountAIx);
            txBuilder.addInstruction(tokenOwnerAccountBIx);
            const oraclePda = public_1.PDAUtil.getOracle(this.ctx.program.programId, this.address);
            txBuilder.addInstruction((0, instructions_1.swapIx)(this.ctx.program, Object.assign(Object.assign({}, input), { whirlpool: this.address, tokenAuthority: wallet, tokenOwnerAccountA, tokenVaultA: whirlpool.tokenVaultA, tokenOwnerAccountB, tokenVaultB: whirlpool.tokenVaultB, oracle: oraclePda.publicKey })));
            return txBuilder;
          });
        }
        refresh() {
          return __awaiter(this, void 0, void 0, function* () {
            const account = yield this.fetcher.getPool(this.address, true);
            if (!!account) {
              this.data = account;
            }
          });
        }
      };
      exports2.WhirlpoolImpl = WhirlpoolImpl;
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/impl/whirlpool-client-impl.js
  var require_whirlpool_client_impl = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/impl/whirlpool-client-impl.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.WhirlpoolClientImpl = void 0;
      var common_sdk_1 = require_dist2();
      var position_impl_1 = require_position_impl();
      var whirlpool_impl_1 = require_whirlpool_impl();
      var WhirlpoolClientImpl = class {
        constructor(ctx) {
          this.ctx = ctx;
        }
        getContext() {
          return this.ctx;
        }
        getFetcher() {
          return this.ctx.fetcher;
        }
        getPool(poolAddress, refresh = false) {
          return __awaiter(this, void 0, void 0, function* () {
            const account = yield this.ctx.fetcher.getPool(poolAddress, refresh);
            if (!account) {
              throw new Error(`Unable to fetch Whirlpool at address at ${poolAddress}`);
            }
            const tokenInfos = yield getTokenInfos(this.ctx.fetcher, account, false);
            return new whirlpool_impl_1.WhirlpoolImpl(this.ctx, this.ctx.fetcher, common_sdk_1.AddressUtil.toPubKey(poolAddress), tokenInfos[0], tokenInfos[1], account);
          });
        }
        getPosition(positionAddress, refresh = false) {
          return __awaiter(this, void 0, void 0, function* () {
            const account = yield this.ctx.fetcher.getPosition(positionAddress, refresh);
            if (!account) {
              throw new Error(`Unable to fetch Position at address at ${positionAddress}`);
            }
            return new position_impl_1.PositionImpl(this.ctx, this.ctx.fetcher, common_sdk_1.AddressUtil.toPubKey(positionAddress), account);
          });
        }
      };
      exports2.WhirlpoolClientImpl = WhirlpoolClientImpl;
      function getTokenInfos(fetcher, data, refresh) {
        return __awaiter(this, void 0, void 0, function* () {
          const mintA = data.tokenMintA;
          const infoA = yield fetcher.getMintInfo(mintA, refresh);
          if (!infoA) {
            throw new Error(`Unable to fetch MintInfo for mint - ${mintA}`);
          }
          const mintB = data.tokenMintB;
          const infoB = yield fetcher.getMintInfo(mintB, refresh);
          if (!infoB) {
            throw new Error(`Unable to fetch MintInfo for mint - ${mintB}`);
          }
          return [
            Object.assign({ mint: mintA }, infoA),
            Object.assign({ mint: mintB }, infoB)
          ];
        });
      }
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/whirlpool-client.js
  var require_whirlpool_client = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/whirlpool-client.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.buildWhirlpoolClient = void 0;
      var whirlpool_client_impl_1 = require_whirlpool_client_impl();
      function buildWhirlpoolClient2(ctx) {
        return new whirlpool_client_impl_1.WhirlpoolClientImpl(ctx);
      }
      exports2.buildWhirlpoolClient = buildWhirlpoolClient2;
    }
  });

  // node_modules/@orca-so/whirlpools-sdk/dist/index.js
  var require_dist3 = __commonJS({
    "node_modules/@orca-so/whirlpools-sdk/dist/index.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        var desc = Object.getOwnPropertyDescriptor(m, k2);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k2];
          } };
        }
        Object.defineProperty(o, k22, desc);
      } : function(o, m, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o[k22] = m[k2];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p2 in m)
          if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
            __createBinding(exports3, m, p2);
      };
      var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      var decimal_js_1 = __importDefault(require_decimal());
      __exportStar(require_context(), exports2);
      __exportStar(require_public(), exports2);
      __exportStar(require_public3(), exports2);
      __exportStar(require_public2(), exports2);
      __exportStar(require_public4(), exports2);
      __exportStar(require_ix(), exports2);
      __exportStar(require_whirlpool_client(), exports2);
      __exportStar(require_anchor_types(), exports2);
      decimal_js_1.default.set({ precision: 40, toExpPos: 40, toExpNeg: -20, rounding: 1 });
    }
  });

  // node_modules/@orca-so/common-sdk/dist/math/decimal-util.js
  var require_decimal_util2 = __commonJS({
    "node_modules/@orca-so/common-sdk/dist/math/decimal-util.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DecimalUtil = void 0;
      var spl_token_1 = (init_index_browser_esm2(), __toCommonJS(index_browser_esm_exports2));
      var decimal_js_1 = __importDefault(require_decimal());
      var DecimalUtil2 = class {
        static adjustDecimals(input, shift = 0) {
          return input.div(decimal_js_1.default.pow(10, shift));
        }
        static fromU64(input, shift = 0) {
          return new decimal_js_1.default(input.toString()).div(new decimal_js_1.default(10).pow(shift));
        }
        static fromNumber(input, shift = 0) {
          return new decimal_js_1.default(input).div(new decimal_js_1.default(10).pow(shift));
        }
        static toU64(input, shift = 0) {
          if (input.isNeg()) {
            throw new Error("Negative decimal value ${input} cannot be converted to u64.");
          }
          const shiftedValue = input.mul(new decimal_js_1.default(10).pow(shift));
          const zeroDecimalValue = shiftedValue.trunc();
          return new spl_token_1.u64(zeroDecimalValue.toString());
        }
      };
      exports2.DecimalUtil = DecimalUtil2;
    }
  });

  // node_modules/@orca-so/common-sdk/dist/math/math-util.js
  var require_math_util2 = __commonJS({
    "node_modules/@orca-so/common-sdk/dist/math/math-util.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.MathUtil = exports2.U64_MAX = exports2.U128 = exports2.TWO = exports2.ONE = exports2.ZERO = void 0;
      var bn_js_1 = __importDefault(require_bn());
      var decimal_js_1 = __importDefault(require_decimal());
      exports2.ZERO = new bn_js_1.default(0);
      exports2.ONE = new bn_js_1.default(1);
      exports2.TWO = new bn_js_1.default(2);
      exports2.U128 = exports2.TWO.pow(new bn_js_1.default(128));
      exports2.U64_MAX = exports2.TWO.pow(new bn_js_1.default(64)).sub(exports2.ONE);
      var MathUtil = class {
        static toX64_BN(num) {
          return num.mul(new bn_js_1.default(2).pow(new bn_js_1.default(64)));
        }
        static toX64_Decimal(num) {
          return num.mul(decimal_js_1.default.pow(2, 64));
        }
        static toX64(num) {
          return new bn_js_1.default(num.mul(decimal_js_1.default.pow(2, 64)).floor().toFixed());
        }
        static fromX64(num) {
          return new decimal_js_1.default(num.toString()).mul(decimal_js_1.default.pow(2, -64));
        }
        static fromX64_Decimal(num) {
          return num.mul(decimal_js_1.default.pow(2, -64));
        }
        static fromX64_BN(num) {
          return num.div(new bn_js_1.default(2).pow(new bn_js_1.default(64)));
        }
        static shiftRightRoundUp(n) {
          let result = n.shrn(64);
          if (n.mod(exports2.U64_MAX).gt(exports2.ZERO)) {
            result = result.add(exports2.ONE);
          }
          return result;
        }
        static divRoundUp(n0, n1) {
          const hasRemainder = !n0.mod(n1).eq(exports2.ZERO);
          if (hasRemainder) {
            return n0.div(n1).add(new bn_js_1.default(1));
          } else {
            return n0.div(n1);
          }
        }
        static subUnderflowU128(n0, n1) {
          return n0.add(exports2.U128).sub(n1).mod(exports2.U128);
        }
      };
      exports2.MathUtil = MathUtil;
    }
  });

  // node_modules/@orca-so/common-sdk/dist/math/percentage.js
  var require_percentage2 = __commonJS({
    "node_modules/@orca-so/common-sdk/dist/math/percentage.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Percentage = void 0;
      var spl_token_1 = (init_index_browser_esm2(), __toCommonJS(index_browser_esm_exports2));
      var decimal_js_1 = __importDefault(require_decimal());
      var Percentage2 = class {
        constructor(numerator, denominator) {
          this.toString = () => {
            return `${this.numerator.toString()}/${this.denominator.toString()}`;
          };
          this.numerator = numerator;
          this.denominator = denominator;
        }
        static fromDecimal(number5) {
          return Percentage2.fromFraction(number5.toDecimalPlaces(1).mul(10).toNumber(), 1e3);
        }
        static fromFraction(numerator, denominator) {
          const num = typeof numerator === "number" ? new spl_token_1.u64(numerator.toString()) : numerator;
          const denom = typeof denominator === "number" ? new spl_token_1.u64(denominator.toString()) : denominator;
          return new Percentage2(num, denom);
        }
        toDecimal() {
          if (this.denominator.eq(new spl_token_1.u64(0))) {
            return new decimal_js_1.default(0);
          }
          return new decimal_js_1.default(this.numerator.toString()).div(new decimal_js_1.default(this.denominator.toString()));
        }
        add(p2) {
          const denomGcd = this.denominator.gcd(p2.denominator);
          const denomLcm = this.denominator.div(denomGcd).mul(p2.denominator);
          const p1DenomAdjustment = denomLcm.div(this.denominator);
          const p2DenomAdjustment = denomLcm.div(p2.denominator);
          const p1NumeratorAdjusted = this.numerator.mul(p1DenomAdjustment);
          const p2NumeratorAdjusted = p2.numerator.mul(p2DenomAdjustment);
          const newNumerator = p1NumeratorAdjusted.add(p2NumeratorAdjusted);
          return new Percentage2(new spl_token_1.u64(newNumerator.toString()), new spl_token_1.u64(denomLcm.toString()));
        }
      };
      exports2.Percentage = Percentage2;
    }
  });

  // node_modules/@orca-so/common-sdk/dist/math/index.js
  var require_math2 = __commonJS({
    "node_modules/@orca-so/common-sdk/dist/math/index.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        var desc = Object.getOwnPropertyDescriptor(m, k2);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k2];
          } };
        }
        Object.defineProperty(o, k22, desc);
      } : function(o, m, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o[k22] = m[k2];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p2 in m)
          if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
            __createBinding(exports3, m, p2);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar(require_decimal_util2(), exports2);
      __exportStar(require_math_util2(), exports2);
      __exportStar(require_percentage2(), exports2);
    }
  });

  // node_modules/@orca-so/common-sdk/dist/web3/address-util.js
  var require_address_util2 = __commonJS({
    "node_modules/@orca-so/common-sdk/dist/web3/address-util.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.AddressUtil = void 0;
      var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
      var AddressUtil = class {
        static toPubKey(address) {
          return address instanceof web3_js_1.PublicKey ? address : new web3_js_1.PublicKey(address);
        }
        static toPubKeys(addresses) {
          return addresses.map((address) => AddressUtil.toPubKey(address));
        }
        static toString(address) {
          if (typeof address === "string") {
            return address;
          }
          return AddressUtil.toPubKey(address).toBase58();
        }
        static toStrings(addresses) {
          return addresses.map((address) => AddressUtil.toString(address));
        }
        static findProgramAddress(seeds, programId) {
          const [publicKey6, bump] = web3_js_1.PublicKey.findProgramAddressSync(seeds, programId);
          return { publicKey: publicKey6, bump };
        }
      };
      exports2.AddressUtil = AddressUtil;
    }
  });

  // node_modules/@orca-so/common-sdk/dist/helpers/token-instructions.js
  var require_token_instructions2 = __commonJS({
    "node_modules/@orca-so/common-sdk/dist/helpers/token-instructions.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createWSOLAccountInstructions = void 0;
      var spl_token_1 = (init_index_browser_esm2(), __toCommonJS(index_browser_esm_exports2));
      var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
      function createWSOLAccountInstructions(walletAddress, amountIn, rentExemptLamports) {
        const tempAccount = new web3_js_1.Keypair();
        const createAccountInstruction = web3_js_1.SystemProgram.createAccount({
          fromPubkey: walletAddress,
          newAccountPubkey: tempAccount.publicKey,
          lamports: amountIn.toNumber() + rentExemptLamports,
          space: spl_token_1.AccountLayout.span,
          programId: spl_token_1.TOKEN_PROGRAM_ID
        });
        const initAccountInstruction = spl_token_1.Token.createInitAccountInstruction(spl_token_1.TOKEN_PROGRAM_ID, spl_token_1.NATIVE_MINT, tempAccount.publicKey, walletAddress);
        const closeWSOLAccountInstruction = spl_token_1.Token.createCloseAccountInstruction(spl_token_1.TOKEN_PROGRAM_ID, tempAccount.publicKey, walletAddress, walletAddress, []);
        return {
          address: tempAccount.publicKey,
          instructions: [createAccountInstruction, initAccountInstruction],
          cleanupInstructions: [closeWSOLAccountInstruction],
          signers: [tempAccount]
        };
      }
      exports2.createWSOLAccountInstructions = createWSOLAccountInstructions;
    }
  });

  // node_modules/@orca-so/common-sdk/dist/web3/transactions/types.js
  var require_types4 = __commonJS({
    "node_modules/@orca-so/common-sdk/dist/web3/transactions/types.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.EMPTY_INSTRUCTION = void 0;
      exports2.EMPTY_INSTRUCTION = {
        instructions: [],
        cleanupInstructions: [],
        signers: []
      };
    }
  });

  // node_modules/@orca-so/common-sdk/dist/web3/network/account-requests.js
  var require_account_requests2 = __commonJS({
    "node_modules/@orca-so/common-sdk/dist/web3/network/account-requests.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getMultipleAccounts = exports2.getMultipleParsedAccounts = exports2.getParsedAccount = void 0;
      var tiny_invariant_1 = __importDefault(require_tiny_invariant_cjs());
      var address_util_1 = require_address_util2();
      function getParsedAccount(connection, address, parser) {
        return __awaiter(this, void 0, void 0, function* () {
          const value = yield connection.getAccountInfo(address_util_1.AddressUtil.toPubKey(address));
          return parser.parse(value === null || value === void 0 ? void 0 : value.data);
        });
      }
      exports2.getParsedAccount = getParsedAccount;
      function getMultipleParsedAccounts(connection, addresses, parser) {
        return __awaiter(this, void 0, void 0, function* () {
          if (addresses.length === 0) {
            return [];
          }
          const values = yield getMultipleAccounts(connection, address_util_1.AddressUtil.toPubKeys(addresses));
          const results = values.map((value) => parser.parse(value === null || value === void 0 ? void 0 : value.data)).filter((value) => value !== void 0);
          (0, tiny_invariant_1.default)(results.length === addresses.length, "not enough results fetched");
          return results;
        });
      }
      exports2.getMultipleParsedAccounts = getMultipleParsedAccounts;
      function getMultipleAccounts(connection, addresses) {
        return __awaiter(this, void 0, void 0, function* () {
          if (addresses.length === 0) {
            return [];
          }
          const responses = [];
          const chunk = 100;
          for (let i = 0; i < addresses.length; i += chunk) {
            const addressChunk = addresses.slice(i, i + chunk);
            const res = connection.getMultipleAccountsInfo(address_util_1.AddressUtil.toPubKeys(addressChunk), connection.commitment);
            responses.push(res);
          }
          const combinedResult = (yield Promise.all(responses)).flat();
          (0, tiny_invariant_1.default)(combinedResult.length === addresses.length, "getMultipleAccounts not enough results");
          return combinedResult;
        });
      }
      exports2.getMultipleAccounts = getMultipleAccounts;
    }
  });

  // node_modules/@orca-so/common-sdk/dist/web3/token-util.js
  var require_token_util2 = __commonJS({
    "node_modules/@orca-so/common-sdk/dist/web3/token-util.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __rest = exports2 && exports2.__rest || function(s, e) {
        var t2 = {};
        for (var p2 in s)
          if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)
            t2[p2] = s[p2];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
            if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
              t2[p2[i]] = s[p2[i]];
          }
        return t2;
      };
      var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.TokenUtil = void 0;
      var spl_token_1 = (init_index_browser_esm2(), __toCommonJS(index_browser_esm_exports2));
      var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
      var tiny_invariant_1 = __importDefault(require_tiny_invariant_cjs());
      var math_1 = require_math2();
      var web3_1 = require_web32();
      var TokenUtil = class {
        static isNativeMint(mint) {
          return mint.equals(spl_token_1.NATIVE_MINT);
        }
        static createSendTokensToWalletInstruction(connection, sourceWallet, destinationWallet, tokenMint, tokenDecimals, amount, getAccountRentExempt, payer) {
          return __awaiter(this, void 0, void 0, function* () {
            (0, tiny_invariant_1.default)(!amount.eq(math_1.ZERO), "SendToken transaction must send more than 0 tokens.");
            if (tokenMint.equals(spl_token_1.NATIVE_MINT)) {
              const sendSolTxn = web3_js_1.SystemProgram.transfer({
                fromPubkey: sourceWallet,
                toPubkey: destinationWallet,
                lamports: BigInt(amount.toString())
              });
              return {
                instructions: [sendSolTxn],
                cleanupInstructions: [],
                signers: []
              };
            }
            const sourceTokenAccount = yield (0, web3_1.deriveATA)(sourceWallet, tokenMint);
            const _a = yield (0, web3_1.resolveOrCreateATA)(connection, destinationWallet, tokenMint, getAccountRentExempt, amount, payer), { address: destinationTokenAccount } = _a, destinationAtaIx = __rest(_a, ["address"]);
            const transferIx = spl_token_1.Token.createTransferCheckedInstruction(spl_token_1.TOKEN_PROGRAM_ID, sourceTokenAccount, tokenMint, destinationTokenAccount, sourceWallet, [], new spl_token_1.u64(amount.toString()), tokenDecimals);
            return {
              instructions: destinationAtaIx.instructions.concat(transferIx),
              cleanupInstructions: destinationAtaIx.cleanupInstructions,
              signers: destinationAtaIx.signers
            };
          });
        }
      };
      exports2.TokenUtil = TokenUtil;
      TokenUtil.deserializeTokenAccount = (data) => {
        if (!data) {
          return null;
        }
        if (data.byteLength !== spl_token_1.AccountLayout.span) {
          throw new Error("Invalid data length for TokenAccount");
        }
        const accountInfo = spl_token_1.AccountLayout.decode(data);
        accountInfo.mint = new web3_js_1.PublicKey(accountInfo.mint);
        accountInfo.owner = new web3_js_1.PublicKey(accountInfo.owner);
        accountInfo.amount = spl_token_1.u64.fromBuffer(accountInfo.amount);
        if (accountInfo.delegateOption === 0) {
          accountInfo.delegate = null;
          accountInfo.delegatedAmount = new spl_token_1.u64(0);
        } else {
          accountInfo.delegate = new web3_js_1.PublicKey(accountInfo.delegate);
          accountInfo.delegatedAmount = spl_token_1.u64.fromBuffer(accountInfo.delegatedAmount);
        }
        accountInfo.isInitialized = accountInfo.state !== 0;
        accountInfo.isFrozen = accountInfo.state === 2;
        if (accountInfo.isNativeOption === 1) {
          accountInfo.rentExemptReserve = spl_token_1.u64.fromBuffer(accountInfo.isNative);
          accountInfo.isNative = true;
        } else {
          accountInfo.rentExemptReserve = null;
          accountInfo.isNative = false;
        }
        if (accountInfo.closeAuthorityOption === 0) {
          accountInfo.closeAuthority = null;
        } else {
          accountInfo.closeAuthority = new web3_js_1.PublicKey(accountInfo.closeAuthority);
        }
        return accountInfo;
      };
    }
  });

  // node_modules/@orca-so/common-sdk/dist/web3/network/parsing.js
  var require_parsing3 = __commonJS({
    "node_modules/@orca-so/common-sdk/dist/web3/network/parsing.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
        var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d2 = decorators[i])
              r = (c2 < 3 ? d2(r) : c2 > 3 ? d2(target, key, r) : d2(target, key)) || r;
        return c2 > 3 && r && Object.defineProperty(target, key, r), r;
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.staticImplements = exports2.ParsableMintInfo = exports2.ParsableTokenAccountInfo = void 0;
      var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
      var spl_token_1 = (init_index_browser_esm2(), __toCommonJS(index_browser_esm_exports2));
      var token_util_1 = require_token_util2();
      var ParsableTokenAccountInfo = class ParsableTokenAccountInfo {
        constructor() {
        }
        static parse(data) {
          if (!data) {
            return null;
          }
          try {
            return token_util_1.TokenUtil.deserializeTokenAccount(data);
          } catch (e) {
            console.error(`error while parsing TokenAccount: ${e}`);
            return null;
          }
        }
      };
      ParsableTokenAccountInfo = __decorate([
        staticImplements()
      ], ParsableTokenAccountInfo);
      exports2.ParsableTokenAccountInfo = ParsableTokenAccountInfo;
      var ParsableMintInfo = class ParsableMintInfo {
        constructor() {
        }
        static parse(data) {
          if (!data) {
            return null;
          }
          try {
            if (data.byteLength !== spl_token_1.MintLayout.span) {
              throw new Error("Invalid data length for MintInfo");
            }
            const buffer2 = spl_token_1.MintLayout.decode(data);
            const mintInfo = {
              mintAuthority: buffer2.mintAuthorityOption === 0 ? null : new web3_js_1.PublicKey(buffer2.mintAuthority),
              supply: spl_token_1.u64.fromBuffer(buffer2.supply),
              decimals: buffer2.decimals,
              isInitialized: buffer2.isInitialized !== 0,
              freezeAuthority: buffer2.freezeAuthorityOption === 0 ? null : new web3_js_1.PublicKey(buffer2.freezeAuthority)
            };
            return mintInfo;
          } catch (e) {
            console.error(`error while parsing MintInfo: ${e}`);
            return null;
          }
        }
      };
      ParsableMintInfo = __decorate([
        staticImplements()
      ], ParsableMintInfo);
      exports2.ParsableMintInfo = ParsableMintInfo;
      function staticImplements() {
        return (constructor) => {
          constructor;
        };
      }
      exports2.staticImplements = staticImplements;
    }
  });

  // node_modules/@orca-so/common-sdk/dist/web3/network/index.js
  var require_network2 = __commonJS({
    "node_modules/@orca-so/common-sdk/dist/web3/network/index.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        var desc = Object.getOwnPropertyDescriptor(m, k2);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k2];
          } };
        }
        Object.defineProperty(o, k22, desc);
      } : function(o, m, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o[k22] = m[k2];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p2 in m)
          if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
            __createBinding(exports3, m, p2);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar(require_account_requests2(), exports2);
      __exportStar(require_parsing3(), exports2);
    }
  });

  // node_modules/@orca-so/common-sdk/dist/web3/ata-util.js
  var require_ata_util2 = __commonJS({
    "node_modules/@orca-so/common-sdk/dist/web3/ata-util.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.deriveATA = exports2.resolveOrCreateATAs = exports2.resolveOrCreateATA = void 0;
      var spl_token_1 = (init_index_browser_esm2(), __toCommonJS(index_browser_esm_exports2));
      var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
      var token_instructions_1 = require_token_instructions2();
      var types_1 = require_types4();
      var network_1 = require_network2();
      function resolveOrCreateATA2(connection, ownerAddress, tokenMint, getAccountRentExempt, wrappedSolAmountIn = new spl_token_1.u64(0), payer = ownerAddress, modeIdempotent = false) {
        return __awaiter(this, void 0, void 0, function* () {
          const instructions2 = yield resolveOrCreateATAs(connection, ownerAddress, [{ tokenMint, wrappedSolAmountIn }], getAccountRentExempt, payer, modeIdempotent);
          return instructions2[0];
        });
      }
      exports2.resolveOrCreateATA = resolveOrCreateATA2;
      function resolveOrCreateATAs(connection, ownerAddress, requests, getAccountRentExempt, payer = ownerAddress, modeIdempotent = false) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          const nonNativeMints = requests.filter(({ tokenMint }) => !tokenMint.equals(spl_token_1.NATIVE_MINT));
          const nativeMints = requests.filter(({ tokenMint }) => tokenMint.equals(spl_token_1.NATIVE_MINT));
          if (nativeMints.length > 1) {
            throw new Error("Cannot resolve multiple WSolAccounts");
          }
          let instructionMap = {};
          if (nonNativeMints.length > 0) {
            const nonNativeAddresses = yield Promise.all(nonNativeMints.map(({ tokenMint }) => deriveATA2(ownerAddress, tokenMint)));
            const tokenAccounts = yield (0, network_1.getMultipleParsedAccounts)(connection, nonNativeAddresses, network_1.ParsableTokenAccountInfo);
            tokenAccounts.forEach((tokenAccount, index) => {
              const ataAddress = nonNativeAddresses[index];
              let resolvedInstruction;
              if (tokenAccount) {
                if (!tokenAccount.owner.equals(ownerAddress)) {
                  throw new Error(`ATA with change of ownership detected: ${ataAddress.toBase58()}`);
                }
                resolvedInstruction = Object.assign({ address: ataAddress }, types_1.EMPTY_INSTRUCTION);
              } else {
                const createAtaInstruction = createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, nonNativeMints[index].tokenMint, ataAddress, ownerAddress, payer, modeIdempotent);
                resolvedInstruction = {
                  address: ataAddress,
                  instructions: [createAtaInstruction],
                  cleanupInstructions: [],
                  signers: []
                };
              }
              instructionMap[nonNativeMints[index].tokenMint.toBase58()] = resolvedInstruction;
            });
          }
          if (nativeMints.length > 0) {
            const accountRentExempt = yield getAccountRentExempt();
            const wrappedSolAmountIn = ((_a = nativeMints[0]) === null || _a === void 0 ? void 0 : _a.wrappedSolAmountIn) || new spl_token_1.u64(0);
            instructionMap[spl_token_1.NATIVE_MINT.toBase58()] = (0, token_instructions_1.createWSOLAccountInstructions)(ownerAddress, wrappedSolAmountIn, accountRentExempt);
          }
          return requests.map(({ tokenMint }) => instructionMap[tokenMint.toBase58()]);
        });
      }
      exports2.resolveOrCreateATAs = resolveOrCreateATAs;
      function deriveATA2(ownerAddress, tokenMint) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield spl_token_1.Token.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, tokenMint, ownerAddress);
        });
      }
      exports2.deriveATA = deriveATA2;
      function createAssociatedTokenAccountInstruction(associatedTokenProgramId, tokenProgramId, mint, associatedAccount, owner, payer, modeIdempotent) {
        if (!modeIdempotent) {
          return spl_token_1.Token.createAssociatedTokenAccountInstruction(associatedTokenProgramId, tokenProgramId, mint, associatedAccount, owner, payer);
        }
        const keys = [
          { pubkey: payer, isSigner: true, isWritable: true },
          { pubkey: associatedAccount, isSigner: false, isWritable: true },
          { pubkey: owner, isSigner: false, isWritable: false },
          { pubkey: mint, isSigner: false, isWritable: false },
          { pubkey: web3_js_1.SystemProgram.programId, isSigner: false, isWritable: false },
          { pubkey: tokenProgramId, isSigner: false, isWritable: false }
        ];
        const instructionData = Buffer.from([1]);
        return new web3_js_1.TransactionInstruction({
          keys,
          programId: associatedTokenProgramId,
          data: instructionData
        });
      }
    }
  });

  // node_modules/@orca-so/common-sdk/dist/web3/lookup-table-fetcher.js
  var require_lookup_table_fetcher = __commonJS({
    "node_modules/@orca-so/common-sdk/dist/web3/lookup-table-fetcher.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
    }
  });

  // node_modules/@orca-so/common-sdk/dist/web3/public-key-utils.js
  var require_public_key_utils2 = __commonJS({
    "node_modules/@orca-so/common-sdk/dist/web3/public-key-utils.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.PublicKeyUtils = void 0;
      var PublicKeyUtils = class {
        static isBase58(value) {
          return /^[A-HJ-NP-Za-km-z1-9]*$/.test(value);
        }
        static orderKeys(...keys) {
          return keys.sort(comparePublicKeys);
        }
      };
      exports2.PublicKeyUtils = PublicKeyUtils;
      function comparePublicKeys(key1, key2) {
        const bytes1 = key1.toBytes();
        const bytes2 = key2.toBytes();
        if (bytes1.byteLength !== bytes2.byteLength) {
          return bytes1.byteLength - bytes2.byteLength;
        }
        for (let i = 0; i < bytes1.byteLength; i++) {
          let byte1 = bytes1[i];
          let byte2 = bytes2[i];
          if (byte1 !== byte2) {
            return byte1 - byte2;
          }
        }
        return 0;
      }
    }
  });

  // node_modules/@orca-so/common-sdk/dist/web3/transactions/constants.js
  var require_constants2 = __commonJS({
    "node_modules/@orca-so/common-sdk/dist/web3/transactions/constants.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.MEASUREMENT_BLOCKHASH = exports2.TX_BASE64_ENCODED_SIZE_LIMIT = exports2.TX_SIZE_LIMIT = void 0;
      var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
      exports2.TX_SIZE_LIMIT = web3_js_1.PACKET_DATA_SIZE;
      exports2.TX_BASE64_ENCODED_SIZE_LIMIT = Math.ceil(exports2.TX_SIZE_LIMIT / 3) * 4;
      exports2.MEASUREMENT_BLOCKHASH = {
        blockhash: "65FJ2gp6jC2x87bycfdZpxDyjiodcAoymxR6PMZzfavY",
        lastValidBlockHeight: 160381350
      };
    }
  });

  // node_modules/@orca-so/common-sdk/dist/web3/transactions/transactions-builder.js
  var require_transactions_builder2 = __commonJS({
    "node_modules/@orca-so/common-sdk/dist/web3/transactions/transactions-builder.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.isVersionedTransaction = exports2.TransactionBuilder = exports2.defaultTransactionBuilderOptions = void 0;
      var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
      var constants_1 = require_constants2();
      var LEGACY_TX_UNIQUE_KEYS_LIMIT = 35;
      exports2.defaultTransactionBuilderOptions = {
        defaultBuildOption: {
          maxSupportedTransactionVersion: 0,
          blockhashCommitment: "confirmed"
        },
        defaultSendOption: {
          skipPreflight: false,
          preflightCommitment: "confirmed",
          maxRetries: 3
        },
        defaultConfirmationCommitment: "confirmed"
      };
      var TransactionBuilder2 = class {
        constructor(connection, wallet, defaultOpts) {
          this.connection = connection;
          this.wallet = wallet;
          this.instructions = [];
          this.signers = [];
          this.opts = defaultOpts !== null && defaultOpts !== void 0 ? defaultOpts : exports2.defaultTransactionBuilderOptions;
        }
        addInstruction(instruction) {
          this.instructions.push(instruction);
          return this;
        }
        addInstructions(instructions2) {
          this.instructions = this.instructions.concat(instructions2);
          return this;
        }
        prependInstruction(instruction) {
          this.instructions.unshift(instruction);
          return this;
        }
        prependInstructions(instructions2) {
          this.instructions = instructions2.concat(this.instructions);
          return this;
        }
        addSigner(signer) {
          this.signers.push(signer);
          return this;
        }
        isEmpty() {
          return this.instructions.length == 0;
        }
        compressIx(compressPost) {
          let instructions2 = [];
          let cleanupInstructions = [];
          let signers = [];
          this.instructions.forEach((curr) => {
            instructions2 = instructions2.concat(curr.instructions);
            cleanupInstructions = curr.cleanupInstructions.concat(cleanupInstructions);
            signers = signers.concat(curr.signers);
          });
          if (compressPost) {
            instructions2 = instructions2.concat(cleanupInstructions);
            cleanupInstructions = [];
          }
          return {
            instructions: [...instructions2],
            cleanupInstructions: [...cleanupInstructions],
            signers
          };
        }
        txnSize(userOptions) {
          const finalOptions = Object.assign(Object.assign(Object.assign({}, this.opts.defaultBuildOption), userOptions), { latestBlockhash: constants_1.MEASUREMENT_BLOCKHASH });
          if (this.isEmpty()) {
            return 0;
          }
          const request = this.buildSync(finalOptions);
          const tx = request.transaction;
          return (0, exports2.isVersionedTransaction)(tx) ? measureV0Tx(tx) : measureLegacyTx(tx);
        }
        buildSync(options) {
          const { latestBlockhash, maxSupportedTransactionVersion } = options;
          const ix = this.compressIx(true);
          const allSigners = ix.signers.concat(this.signers);
          const recentBlockhash = latestBlockhash;
          if (maxSupportedTransactionVersion === "legacy") {
            const transaction = new web3_js_1.Transaction(Object.assign(Object.assign({}, recentBlockhash), { feePayer: this.wallet.publicKey }));
            transaction.add(...ix.instructions);
            transaction.feePayer = this.wallet.publicKey;
            return {
              transaction,
              signers: allSigners,
              recentBlockhash
            };
          }
          const txnMsg = new web3_js_1.TransactionMessage({
            recentBlockhash: recentBlockhash.blockhash,
            payerKey: this.wallet.publicKey,
            instructions: ix.instructions
          });
          const { lookupTableAccounts } = options;
          const msg = txnMsg.compileToV0Message(lookupTableAccounts);
          const v0txn = new web3_js_1.VersionedTransaction(msg);
          return {
            transaction: v0txn,
            signers: allSigners,
            recentBlockhash
          };
        }
        build(userOptions) {
          return __awaiter(this, void 0, void 0, function* () {
            const finalOptions = Object.assign(Object.assign({}, this.opts.defaultBuildOption), userOptions);
            const { latestBlockhash, blockhashCommitment } = finalOptions;
            let recentBlockhash = latestBlockhash;
            if (!recentBlockhash) {
              recentBlockhash = yield this.connection.getLatestBlockhash(blockhashCommitment);
            }
            return this.buildSync(Object.assign(Object.assign({}, finalOptions), { latestBlockhash: recentBlockhash }));
          });
        }
        buildAndExecute(options, sendOptions, confirmCommitment) {
          return __awaiter(this, void 0, void 0, function* () {
            const sendOpts = Object.assign(Object.assign({}, this.opts.defaultSendOption), sendOptions);
            const btx = yield this.build(options);
            const txn = btx.transaction;
            const resolvedConfirmCommitment = confirmCommitment !== null && confirmCommitment !== void 0 ? confirmCommitment : this.opts.defaultConfirmationCommitment;
            let txId;
            if ((0, exports2.isVersionedTransaction)(txn)) {
              const signedTxn = yield this.wallet.signTransaction(txn);
              signedTxn.sign(btx.signers);
              txId = yield this.connection.sendTransaction(signedTxn, sendOpts);
            } else {
              const signedTxn = yield this.wallet.signTransaction(txn);
              btx.signers.filter((s) => s !== void 0).forEach((keypair) => signedTxn.partialSign(keypair));
              txId = yield this.connection.sendRawTransaction(signedTxn.serialize(), sendOpts);
            }
            const result = yield this.connection.confirmTransaction(Object.assign({ signature: txId }, btx.recentBlockhash), resolvedConfirmCommitment);
            const confirmTxErr = result.value.err;
            if (confirmTxErr) {
              throw new Error(confirmTxErr.toString());
            }
            return txId;
          });
        }
      };
      exports2.TransactionBuilder = TransactionBuilder2;
      var isVersionedTransaction2 = (tx) => {
        return "version" in tx;
      };
      exports2.isVersionedTransaction = isVersionedTransaction2;
      function measureLegacyTx(tx) {
        const uniqueKeys = /* @__PURE__ */ new Set();
        for (const instruction of tx.instructions) {
          for (const key of instruction.keys) {
            uniqueKeys.add(key.pubkey.toBase58());
          }
          uniqueKeys.add(instruction.programId.toBase58());
        }
        if (uniqueKeys.size > LEGACY_TX_UNIQUE_KEYS_LIMIT) {
          throw new Error("Unable to measure transaction size. Too many unique keys in transaction.");
        }
        try {
          const serialized = tx.serialize({ requireAllSignatures: false });
          return serialized.length;
        } catch (e) {
          throw new Error("Unable to measure transaction size. Unable to serialize transaction.");
        }
      }
      function measureV0Tx(tx) {
        let serialized;
        try {
          serialized = tx.serialize();
        } catch (e) {
          throw new Error("Unable to measure transaction size. Unable to serialize transaction.");
        }
        if (serialized.length > web3_js_1.PACKET_DATA_SIZE) {
          throw new Error("Unable to measure transaction size. Transaction too large.");
        }
        return serialized.length;
      }
    }
  });

  // node_modules/@orca-so/common-sdk/dist/web3/transactions/transactions-processor.js
  var require_transactions_processor2 = __commonJS({
    "node_modules/@orca-so/common-sdk/dist/web3/transactions/transactions-processor.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.TransactionProcessor = void 0;
      var TransactionProcessor = class {
        constructor(connection, wallet, commitment = "confirmed") {
          this.connection = connection;
          this.wallet = wallet;
          this.commitment = commitment;
        }
        signTransaction(txRequest) {
          return __awaiter(this, void 0, void 0, function* () {
            const { transactions, lastValidBlockHeight, blockhash } = yield this.signTransactions([
              txRequest
            ]);
            return { transaction: transactions[0], lastValidBlockHeight, blockhash };
          });
        }
        signTransactions(txRequests) {
          return __awaiter(this, void 0, void 0, function* () {
            const { blockhash, lastValidBlockHeight } = yield this.connection.getLatestBlockhash(this.commitment);
            const feePayer = this.wallet.publicKey;
            const pSignedTxs = txRequests.map((txRequest) => {
              return rewriteTransaction(txRequest, feePayer, blockhash);
            });
            const transactions = yield this.wallet.signAllTransactions(pSignedTxs);
            return {
              transactions,
              lastValidBlockHeight,
              blockhash
            };
          });
        }
        sendTransaction(transaction, lastValidBlockHeight, blockhash) {
          return __awaiter(this, void 0, void 0, function* () {
            const execute = this.constructSendTransactions([transaction], lastValidBlockHeight, blockhash);
            const txs = yield execute();
            const ex = txs[0];
            if (ex.status === "fulfilled") {
              return ex.value;
            } else {
              throw ex.reason;
            }
          });
        }
        constructSendTransactions(transactions, lastValidBlockHeight, blockhash, parallel = true) {
          const executeTx = (tx) => __awaiter(this, void 0, void 0, function* () {
            const rawTxs = tx.serialize();
            return this.connection.sendRawTransaction(rawTxs, {
              preflightCommitment: this.commitment
            });
          });
          const confirmTx = (txId) => __awaiter(this, void 0, void 0, function* () {
            const result = yield this.connection.confirmTransaction({
              signature: txId,
              lastValidBlockHeight,
              blockhash
            }, this.commitment);
            if (result.value.err) {
              throw new Error(`Transaction failed: ${JSON.stringify(result.value)}`);
            }
          });
          return () => __awaiter(this, void 0, void 0, function* () {
            if (parallel) {
              const results = transactions.map((tx) => __awaiter(this, void 0, void 0, function* () {
                const txId = yield executeTx(tx);
                yield confirmTx(txId);
                return txId;
              }));
              return Promise.allSettled(results);
            } else {
              const results = [];
              for (const tx of transactions) {
                const txId = yield executeTx(tx);
                yield confirmTx(txId);
                results.push(txId);
              }
              return Promise.allSettled(results);
            }
          });
        }
        signAndConstructTransaction(txRequest) {
          return __awaiter(this, void 0, void 0, function* () {
            const { transaction, lastValidBlockHeight, blockhash } = yield this.signTransaction(txRequest);
            return {
              signedTx: transaction,
              execute: () => __awaiter(this, void 0, void 0, function* () {
                return this.sendTransaction(transaction, lastValidBlockHeight, blockhash);
              })
            };
          });
        }
        signAndConstructTransactions(txRequests, parallel = true) {
          return __awaiter(this, void 0, void 0, function* () {
            const { transactions, lastValidBlockHeight, blockhash } = yield this.signTransactions(txRequests);
            const execute = this.constructSendTransactions(transactions, lastValidBlockHeight, blockhash, parallel);
            return { signedTxs: transactions, execute };
          });
        }
      };
      exports2.TransactionProcessor = TransactionProcessor;
      function rewriteTransaction(txRequest, feePayer, blockhash) {
        var _a;
        const signers = (_a = txRequest.signers) !== null && _a !== void 0 ? _a : [];
        const tx = txRequest.transaction;
        tx.feePayer = feePayer;
        tx.recentBlockhash = blockhash;
        signers.filter((s) => s !== void 0).forEach((keypair) => tx.partialSign(keypair));
        return tx;
      }
    }
  });

  // node_modules/@orca-so/common-sdk/dist/web3/transactions/index.js
  var require_transactions2 = __commonJS({
    "node_modules/@orca-so/common-sdk/dist/web3/transactions/index.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        var desc = Object.getOwnPropertyDescriptor(m, k2);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k2];
          } };
        }
        Object.defineProperty(o, k22, desc);
      } : function(o, m, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o[k22] = m[k2];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p2 in m)
          if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
            __createBinding(exports3, m, p2);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar(require_constants2(), exports2);
      __exportStar(require_transactions_builder2(), exports2);
      __exportStar(require_transactions_processor2(), exports2);
      __exportStar(require_types4(), exports2);
    }
  });

  // node_modules/@orca-so/common-sdk/dist/web3/wallet.js
  var require_wallet = __commonJS({
    "node_modules/@orca-so/common-sdk/dist/web3/wallet.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
    }
  });

  // node_modules/@orca-so/common-sdk/dist/web3/index.js
  var require_web32 = __commonJS({
    "node_modules/@orca-so/common-sdk/dist/web3/index.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        var desc = Object.getOwnPropertyDescriptor(m, k2);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k2];
          } };
        }
        Object.defineProperty(o, k22, desc);
      } : function(o, m, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o[k22] = m[k2];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p2 in m)
          if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
            __createBinding(exports3, m, p2);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar(require_address_util2(), exports2);
      __exportStar(require_ata_util2(), exports2);
      __exportStar(require_lookup_table_fetcher(), exports2);
      __exportStar(require_network2(), exports2);
      __exportStar(require_public_key_utils2(), exports2);
      __exportStar(require_token_util2(), exports2);
      __exportStar(require_transactions2(), exports2);
      __exportStar(require_wallet(), exports2);
    }
  });

  // node_modules/@orca-so/common-sdk/dist/index.js
  var require_dist4 = __commonJS({
    "node_modules/@orca-so/common-sdk/dist/index.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        var desc = Object.getOwnPropertyDescriptor(m, k2);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k2];
          } };
        }
        Object.defineProperty(o, k22, desc);
      } : function(o, m, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o[k22] = m[k2];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p2 in m)
          if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
            __createBinding(exports3, m, p2);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar(require_math2(), exports2);
      __exportStar(require_web32(), exports2);
    }
  });

  // node_modules/@coral-xyz/anchor/dist/cjs/utils/token.js
  var require_token = __commonJS({
    "node_modules/@coral-xyz/anchor/dist/cjs/utils/token.js"(exports2) {
      "use strict";
      init_virtual_process_polyfill();
      init_buffer();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.associatedAddress = exports2.ASSOCIATED_PROGRAM_ID = exports2.TOKEN_PROGRAM_ID = void 0;
      var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
      exports2.TOKEN_PROGRAM_ID = new web3_js_1.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
      exports2.ASSOCIATED_PROGRAM_ID = new web3_js_1.PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
      function associatedAddress({ mint, owner }) {
        return web3_js_1.PublicKey.findProgramAddressSync([owner.toBuffer(), exports2.TOKEN_PROGRAM_ID.toBuffer(), mint.toBuffer()], exports2.ASSOCIATED_PROGRAM_ID)[0];
      }
      exports2.associatedAddress = associatedAddress;
    }
  });

  // src/index.tsx
  init_virtual_process_polyfill();
  init_buffer();
  var import_react19 = __toESM(require_react());

  // node_modules/react-xnft/dist/esm/index.js
  init_virtual_process_polyfill();
  init_buffer();

  // node_modules/react-xnft/dist/esm/reconciler.js
  init_virtual_process_polyfill();
  init_buffer();
  var import_react_reconciler = __toESM(require_react_reconciler());

  // node_modules/@coral-xyz/common-public/dist/esm/index.js
  init_virtual_process_polyfill();
  init_buffer();

  // node_modules/@coral-xyz/common-public/dist/esm/constants.js
  init_virtual_process_polyfill();
  init_buffer();
  var MOBILE_CHANNEL_LOGS = "mobile-logs";

  // node_modules/@coral-xyz/common-public/dist/esm/types.js
  init_virtual_process_polyfill();
  init_buffer();

  // node_modules/@coral-xyz/common-public/dist/esm/logging.js
  init_virtual_process_polyfill();
  init_buffer();

  // node_modules/@coral-xyz/common-public/dist/esm/zustand-store.js
  init_virtual_process_polyfill();
  init_buffer();

  // node_modules/zustand/esm/index.mjs
  init_virtual_process_polyfill();
  init_buffer();

  // node_modules/zustand/esm/vanilla.mjs
  init_virtual_process_polyfill();
  init_buffer();
  var import_meta = {};
  var createStoreImpl = (createState) => {
    let state;
    const listeners = /* @__PURE__ */ new Set();
    const setState = (partial, replace2) => {
      const nextState = typeof partial === "function" ? partial(state) : partial;
      if (!Object.is(nextState, state)) {
        const previousState = state;
        state = (replace2 != null ? replace2 : typeof nextState !== "object") ? nextState : Object.assign({}, state, nextState);
        listeners.forEach((listener) => listener(state, previousState));
      }
    };
    const getState = () => state;
    const subscribe = (listener) => {
      listeners.add(listener);
      return () => listeners.delete(listener);
    };
    const destroy = () => {
      if ((import_meta.env ? import_meta.env.MODE : void 0) !== "production") {
        console.warn(
          "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
        );
      }
      listeners.clear();
    };
    const api = { setState, getState, subscribe, destroy };
    state = createState(setState, getState, api);
    return api;
  };
  var createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;
  var vanilla = (createState) => {
    if ((import_meta.env ? import_meta.env.MODE : void 0) !== "production") {
      console.warn(
        "[DEPRECATED] Default export is deprecated. Instead use import { createStore } from 'zustand/vanilla'."
      );
    }
    return createStore(createState);
  };

  // node_modules/zustand/esm/index.mjs
  var import_react = __toESM(require_react(), 1);
  var import_with_selector = __toESM(require_with_selector(), 1);
  var import_meta2 = {};
  var { useSyncExternalStoreWithSelector } = import_with_selector.default;
  function useStore(api, selector4 = api.getState, equalityFn) {
    const slice2 = useSyncExternalStoreWithSelector(
      api.subscribe,
      api.getState,
      api.getServerState || api.getState,
      selector4,
      equalityFn
    );
    (0, import_react.useDebugValue)(slice2);
    return slice2;
  }
  var createImpl = (createState) => {
    if ((import_meta2.env ? import_meta2.env.MODE : void 0) !== "production" && typeof createState !== "function") {
      console.warn(
        "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."
      );
    }
    const api = typeof createState === "function" ? createStore(createState) : createState;
    const useBoundStore = (selector4, equalityFn) => useStore(api, selector4, equalityFn);
    Object.assign(useBoundStore, api);
    return useBoundStore;
  };
  var create = (createState) => createState ? createImpl(createState) : createImpl;
  var react = (createState) => {
    if ((import_meta2.env ? import_meta2.env.MODE : void 0) !== "production") {
      console.warn(
        "[DEPRECATED] Default export is deprecated. Instead use `import { create } from 'zustand'`."
      );
    }
    return create(createState);
  };

  // node_modules/@coral-xyz/common-public/dist/esm/zustand-store.js
  var vanillaStore = vanilla((set) => ({
    injectJavaScript: void 0,
    setInjectJavaScript: (injectJavaScript) => set(() => ({ injectJavaScript }))
  }));
  var useStore2 = react(vanillaStore);

  // node_modules/@coral-xyz/common-public/dist/esm/utils.js
  init_virtual_process_polyfill();
  init_buffer();
  var IS_MOBILE = globalThis.chrome ? false : globalThis.browser ? false : true;
  function isServiceWorker() {
    return globalThis.clients !== void 0;
  }

  // node_modules/@coral-xyz/common-public/dist/esm/logging.js
  function getLogger(mod2) {
    return (() => {
      const _mod = mod2;
      const prefix = isServiceWorker() ? "service-worker:" : "";
      return {
        debug: (str3, ...args) => debug(`${prefix}anchor: ${_mod}: ${str3}`, ...args),
        error: (str3, ...args) => error(`${prefix}anchor: ${_mod}: ${str3}`, ...args),
        _log
      };
    })();
  }
  function debug(str3, ...args) {
    log(str3, ...args);
  }
  function error(str3, ...args) {
    log(`ERROR: ${str3}`, ...args);
  }
  function log(str3, ...args) {
    if (IS_MOBILE) {
      _mobileLog(str3, ...args);
    } else {
      _log(str3, ...args);
    }
  }
  function _log(str3, ...args) {
    console.log(str3, ...args);
  }
  async function _mobileLog(...args) {
    var _a, _b;
    try {
      const clients = await self.clients.matchAll({
        includeUncontrolled: true,
        type: "window"
      });
      clients.forEach((client) => {
        client.postMessage({
          channel: MOBILE_CHANNEL_LOGS,
          data: args
        });
      });
    } catch (err2) {
      (_b = (_a = vanillaStore.getState()) === null || _a === void 0 ? void 0 : _a.injectJavaScript) === null || _b === void 0 ? void 0 : _b.call(_a, `navigator.serviceWorker.onmessage(${JSON.stringify({
        data: {
          channel: MOBILE_CHANNEL_LOGS,
          data: args
        }
      })}); true;`);
    }
  }

  // node_modules/react-xnft/dist/esm/reconciler.js
  var import_eventemitter3 = __toESM(require_eventemitter3());

  // node_modules/react-xnft/dist/esm/Context.js
  init_virtual_process_polyfill();
  init_buffer();
  var import_jsx_runtime = __toESM(require_jsx_runtime());
  var import_react2 = __toESM(require_react());

  // node_modules/@coral-xyz/themes/dist/esm/index.js
  init_virtual_process_polyfill();
  init_buffer();

  // node_modules/@coral-xyz/themes/node_modules/@mui/styles/createStyles/index.js
  init_virtual_process_polyfill();
  init_buffer();

  // node_modules/@coral-xyz/themes/node_modules/@mui/styles/createStyles/createStyles.js
  init_virtual_process_polyfill();
  init_buffer();
  function createStyles(styles) {
    return styles;
  }

  // node_modules/@coral-xyz/themes/dist/esm/index.js
  var baseTheme = createStyles({
    typography: {
      fontFamily: ["Inter", "sans-serif"].join(","),
      fontWeight: 500,
      allVariants: {
        fontWeight: 500
      },
      body: {
        fontWeight: 500
      },
      p: {
        fontWeight: 500
      }
    }
  });
  var BACKGROUND_COLOR_0 = "#18181b";
  var BACKGROUND_COLOR_1 = "#27272a";
  var BACKGROUND_COLOR_2 = "#3F3F46";
  var FONT_COLOR = "#FFFFFF";
  var FONT_COLOR_1 = "#71717A";
  var FONT_COLOR_2 = "#D4D4D8";
  var FONT_COLOR_3 = "#A1A1AA";
  var BRAND_COLOR = "#47dfbe";
  var BUTTON_FONT_COLOR = FONT_COLOR;
  var BORDER_COLOR = "#393C43";
  var BORDER_COLOR_1 = "#52525B";
  var POSITIVE_COLOR = "#35A63A";
  var NEGATIVE_COLOR = "#E95050";
  var SCROLLBAR_THUMB_COLOR = "rgb(153 164 180)";
  var DISABLED_BUTTON_COLOR = BRAND_COLOR;
  var componentOverrides = {
    MuiPaper: {
      styleOverrides: {
        root: {
          backgroundImage: "none"
        }
      }
    },
    MuiSelect: {
      styleOverrides: {
        icon: {
          color: FONT_COLOR_1
        }
      }
    }
  };
  var darkTheme = {
    ...baseTheme,
    palette: {
      mode: "dark",
      background: {
        default: BACKGROUND_COLOR_0,
        paper: BACKGROUND_COLOR_1
      }
    },
    components: componentOverrides,
    custom: {
      colors: {
        background: BACKGROUND_COLOR_0,
        nav: BACKGROUND_COLOR_1,
        fontColor: FONT_COLOR,
        fontColor2: FONT_COLOR_2,
        border: BORDER_COLOR,
        activeNavButton: BRAND_COLOR,
        hamburger: FONT_COLOR_1,
        scrollbarTrack: BACKGROUND_COLOR_0,
        scrollbarThumb: SCROLLBAR_THUMB_COLOR,
        tabIconBackground: FONT_COLOR_1,
        tabIconSelected: BRAND_COLOR,
        secondary: FONT_COLOR_1,
        positive: POSITIVE_COLOR,
        negative: NEGATIVE_COLOR,
        primaryButton: BRAND_COLOR,
        secondaryButton: BACKGROUND_COLOR_2,
        dangerButton: "#DC2626",
        buttonFontColor: BUTTON_FONT_COLOR,
        sendGradient: `linear-gradient(180deg, ${BACKGROUND_COLOR_0} 0%, rgba(27, 29, 35, 0) 100%)`,
        swapGradient: `linear-gradient(180deg, ${BACKGROUND_COLOR_1} 0%, rgba(41, 44, 51, 0) 100%)`,
        drawerGradient: `linear-gradient(180deg, ${BACKGROUND_COLOR_1} 0%, rgba(41, 44, 51, 0) 100%)`,
        alpha: FONT_COLOR_2,
        bg2: BACKGROUND_COLOR_2,
        border1: BORDER_COLOR_1,
        disabledButton: DISABLED_BUTTON_COLOR,
        subtext: FONT_COLOR_3
      }
    }
  };
  var LIGHT_BACKGROUND_COLOR_0 = "#ECEFF3";
  var LIGHT_BACKGROUND_COLOR_1 = "#ffffff";
  var LIGHT_BACKGROUND_COLOR_2 = LIGHT_BACKGROUND_COLOR_0;
  var LIGHT_FONT_COLOR = "#43546D";
  var LIGHT_FONT_COLOR_1 = "#67758B";
  var LIGHT_FONT_COLOR_2 = "#D4D4D8";
  var LIGHT_FONT_COLOR_3 = LIGHT_FONT_COLOR_1;
  var LIGHT_BRAND_COLOR = BRAND_COLOR;
  var LIGHT_BUTTON_FONT_COLOR = FONT_COLOR;
  var LIGHT_BORDER_COLOR = "#DBDADB";
  var LIGHT_BORDER_COLOR_1 = "#DBDADB";
  var LIGHT_POSITIVE_COLOR = POSITIVE_COLOR;
  var LIGHT_NEGATIVE_COLOR = NEGATIVE_COLOR;
  var LIGHT_SCROLLBAR_THUMB_COLOR = SCROLLBAR_THUMB_COLOR;
  var lightTheme = {
    ...baseTheme,
    components: componentOverrides,
    custom: {
      colors: {
        background: LIGHT_BACKGROUND_COLOR_0,
        nav: LIGHT_BACKGROUND_COLOR_1,
        fontColor: LIGHT_FONT_COLOR,
        fontColor2: LIGHT_FONT_COLOR_2,
        border: LIGHT_BORDER_COLOR,
        activeNavButton: LIGHT_BRAND_COLOR,
        hamburger: LIGHT_FONT_COLOR_1,
        scrollbarTrack: LIGHT_BACKGROUND_COLOR_0,
        scrollbarThumb: LIGHT_SCROLLBAR_THUMB_COLOR,
        tabIconBackground: LIGHT_FONT_COLOR_1,
        tabIconSelected: LIGHT_BRAND_COLOR,
        secondary: LIGHT_FONT_COLOR_1,
        positive: LIGHT_POSITIVE_COLOR,
        negative: LIGHT_NEGATIVE_COLOR,
        primaryButton: LIGHT_BRAND_COLOR,
        secondaryButton: LIGHT_BACKGROUND_COLOR_2,
        dangerButton: "#DC2626",
        buttonFontColor: LIGHT_BUTTON_FONT_COLOR,
        sendGradient: `linear-gradient(180deg, ${LIGHT_BACKGROUND_COLOR_0} 0%, rgba(27, 29, 35, 0) 100%)`,
        swapGradient: `linear-gradient(180deg, ${LIGHT_BACKGROUND_COLOR_1} 0%, rgba(41, 44, 51, 0) 100%)`,
        drawerGradient: `linear-gradient(180deg, ${LIGHT_BACKGROUND_COLOR_1} 0%, rgba(41, 44, 51, 0) 100%)`,
        alpha: LIGHT_FONT_COLOR,
        bg2: LIGHT_BACKGROUND_COLOR_2,
        border1: LIGHT_BORDER_COLOR_1,
        disabledButton: DISABLED_BUTTON_COLOR,
        subtext: LIGHT_FONT_COLOR_3
      }
    }
  };

  // node_modules/react-xnft/dist/esm/Context.js
  var _AnchorContext = (0, import_react2.createContext)(null);
  var NAV_STACK = [];
  function AnchorProvider(props) {
    return (0, import_jsx_runtime.jsx)(_AnchorContext.Provider, { value: {
      theme: darkTheme
    }, children: props.children });
  }
  function useAnchorContext() {
    const ctx = (0, import_react2.useContext)(_AnchorContext);
    if (ctx === null) {
      throw new Error("Context not available");
    }
    return ctx;
  }
  function useTheme() {
    const { theme } = useAnchorContext();
    return theme;
  }

  // node_modules/react-xnft/dist/esm/EVENTS.js
  init_virtual_process_polyfill();
  init_buffer();
  var CONNECT = "connect";
  var SOLANA_CONNECT = "solana-connect";
  var ETHEREUM_CONNECT = "ethereum-connect";

  // node_modules/react-xnft/dist/esm/ReactDom.js
  init_virtual_process_polyfill();
  init_buffer();
  var logger = getLogger("react-xnft/reconciler");
  var PendingUpdates = class {
    constructor() {
      this._renderUpdatesTimer = 1e3;
      this._timeouts = {};
    }
    addRenderUpdate(instanceId) {
      if (this._timeouts[instanceId]) {
        window.clearTimeout(this._timeouts[instanceId]);
      }
      this._timeouts[instanceId] = window.setTimeout(() => {
        console.error(`Render fn222 not found for instance ${instanceId}`);
        delete this._timeouts[instanceId];
      }, this._renderUpdatesTimer);
    }
    isPendingRender(instanceId) {
      if (this._timeouts[instanceId]) {
        return true;
      }
      return false;
    }
    removeRenderUpdate(instanceId) {
      if (this._timeouts[instanceId]) {
        window.clearTimeout(this._timeouts[instanceId]);
        delete this._timeouts[instanceId];
      }
    }
  };
  var ReactDom = class {
    constructor() {
      this.clear();
      this.pendingUpdates = new PendingUpdates();
    }
    static getInstance() {
      if (!this.instance) {
        this.instance = new ReactDom();
      }
      return this.instance;
    }
    clear() {
      this._vdomRoot = { children: [] };
      this._vdom = /* @__PURE__ */ new Map();
      this._renderFns = /* @__PURE__ */ new Map();
    }
    onRender(viewId, fn2) {
      this._renderFns.set(viewId, fn2);
      if (this.pendingUpdates.isPendingRender(viewId)) {
        const element = this._vdom.get(viewId);
        if (!element) {
          throw new Error("element not found");
        }
        fn2(element);
        this.pendingUpdates.removeRenderUpdate(viewId);
      }
    }
    onRenderRoot(fn2) {
      this._renderRootFn = fn2;
      if (this._needsRenderRoot) {
        this._needsRenderRoot = false;
        this._renderRoot();
      }
    }
    commitUpdate(instanceId, updatePayload) {
      const instance2 = this._vdom.get(instanceId);
      logger.debug("commitUpdate", instanceId, updatePayload, instance2);
      if (!instance2) {
        throw new Error("element not found");
      }
      instance2.props = { ...updatePayload.props };
      this._render(instanceId);
    }
    commitTextUpdate(textInstanceId, newText) {
      const textInstance = this._vdom.get(textInstanceId);
      textInstance.text = newText;
      this._render(textInstanceId);
    }
    appendChildToContainer(child) {
      this._vdomRoot.children.push(child);
      this._saveToDom(child);
      this._renderRoot();
    }
    appendChild(parentId, child) {
      const instance2 = this._vdom.get(parentId);
      instance2.children.push(child);
      this._saveToDom(child);
      this._render(parentId);
    }
    insertInContainerBefore(child, beforeId) {
      const element = this._vdomRoot.children.find((e) => e.id === beforeId);
      if (!element) {
        throw new Error("element not found");
      }
      const newChildren = this._vdomRoot.children.filter((c2) => c2.id !== child.id);
      const idx = newChildren.indexOf(element);
      if (idx === -1) {
        throw new Error("child not found");
      }
      this._vdomRoot.children = newChildren.slice(0, idx).concat([child]).concat(newChildren.slice(idx));
      this._saveToDom(child);
      this._renderRoot();
    }
    insertBefore(parentId, child, beforeId) {
      const parent = this._vdom.get(parentId);
      if (!parent) {
        throw new Error("parent not found");
      }
      const beforeElement = parent.children.find((e) => e.id === beforeId);
      if (!beforeElement) {
        logger.error("before element not found", parent, child, beforeId);
        throw new Error("before element not found");
      }
      const newChildren = parent.children.filter((c2) => c2.id !== child.id);
      const beforeIdx = newChildren.indexOf(beforeElement);
      if (beforeIdx === -1) {
        throw new Error("child not found");
      }
      parent.children = newChildren.slice(0, beforeIdx).concat([child]).concat(newChildren.slice(beforeIdx));
      this._saveToDom(child);
      this._render(parentId);
    }
    removeChild(parentId, childId) {
      const parent = this._vdom.get(parentId);
      if (!parent) {
        throw new Error("parent not found");
      }
      parent.children = parent.children.filter((c2) => c2.id !== childId);
      this._removeFromDom(this._vdom.get(childId));
      this._render(parentId);
    }
    removeChildFromContainer(childId) {
      this._vdomRoot.children = this._vdomRoot.children.filter((c2) => c2.id !== childId);
      this._removeFromDom(this._vdom.get(childId));
      this._renderRoot();
    }
    _renderRoot() {
      if (!this._renderRootFn) {
        throw new Error("render root fn not found");
      }
      this._renderRootFn(this._vdomRoot.children);
    }
    _render(instanceId) {
      const element = this._vdom.get(instanceId);
      if (!element) {
        throw new Error("element not found");
      }
      const renderFn = this._renderFns.get(instanceId);
      if (!renderFn) {
        this.pendingUpdates.addRenderUpdate(instanceId);
        return;
      }
      renderFn(element);
    }
    _saveToDom(element) {
      this._vdom.set(element.id, element);
      if (element.children) {
        element.children.forEach((e) => {
          this._saveToDom(e);
        });
      }
    }
    _removeFromDom(element) {
      this._vdom.delete(element.id);
      if (element.children) {
        element.children.forEach((e) => {
          this._removeFromDom(e);
        });
      }
    }
  };
  if (!window.dom) {
    Object.defineProperties(window, { dom: { value: ReactDom.getInstance() } });
  }

  // node_modules/react-xnft/dist/esm/reconciler.js
  var logger2 = getLogger("react-xnft/reconciler");
  var events = new import_eventemitter3.EventEmitter();
  var ReactXnft = {
    events,
    render(reactNode) {
      window.addEventListener("load", () => {
        window.xnft.on("connect", () => {
          logger2.debug("connect");
          NAV_STACK.push(reactNode);
          events.emit(CONNECT);
        });
        window.xnft.solana.on("connect", () => {
          events.emit(SOLANA_CONNECT);
        });
        window.xnft.ethereum.on("connect", () => {
          events.emit(ETHEREUM_CONNECT);
        });
        window.xnft.on("mount", () => {
          logger2.debug("mount");
          const node = NAV_STACK[NAV_STACK.length - 1];
          reconcilerRender(node);
        });
        window.xnft.on("unmount", () => {
          logger2.debug("unmount");
        });
        window.xnft.on("pop", () => {
          logger2.debug("pop");
          NAV_STACK.pop();
        });
      });
    },
    renderWidget(reactNode) {
    }
  };
  function reconcilerRender(reactNode) {
    const cb = () => {
    };
    const root2 = {
      host: HOST,
      children: []
    };
    const container = RECONCILER.createContainer(root2, false, false);
    RECONCILER.updateContainer(reactNode, container, null, cb);
  }
  var RECONCILER = (0, import_react_reconciler.default)({
    isPrimaryRenderer: true,
    supportsMutation: true,
    supportsHydration: false,
    supportsPersistence: false,
    now: Date.now,
    noTimeout: -1,
    getRootHostContext: (root2) => {
      logger2.debug("getRootHostContext");
      return root2.host;
    },
    getChildHostContext: (parentHost, kind, root2) => {
      logger2.debug("getChildHostContext");
      return parentHost;
    },
    createInstance: (kind, props, r, h2, o) => {
      logger2.debug("createInstance", kind, props);
      switch (kind) {
        case NodeKind.View:
          return createViewInstance(kind, props, r, h2, o);
        case NodeKind.Table:
          return createTableInstance(kind, props, r, h2, o);
        case NodeKind.TableRow:
          return createTableRowInstance(kind, props, r, h2, o);
        case NodeKind.Text:
          return createTextLabelInstance(kind, props, r, h2, o);
        case NodeKind.TextField:
          return createTextFieldInstance(kind, props, r, h2, o);
        case NodeKind.Image:
          return createImageInstance(kind, props, r, h2, o);
        case NodeKind.Button:
          return createButtonInstance(kind, props, r, h2, o);
        case NodeKind.Loading:
          return createLoadingInstance(kind, props, r, h2, o);
        case NodeKind.Audio:
          return createAudioInstance(kind, props, r, h2, o);
        case NodeKind.Video:
          return createVideoInstance(kind, props, r, h2, o);
        case NodeKind.ScrollBar:
          return createScrollBarInstance(kind, props, r, h2, o);
        case NodeKind.Svg:
          return createSvgInstance(kind, props, r, h2, o);
        case NodeKind.Path:
          return createPathInstance(kind, props, r, h2, o);
        case NodeKind.Circle:
          return createCircleInstance(kind, props, r, h2, o);
        case NodeKind.Iframe:
          return createIframeInstance(kind, props, r, h2, o);
        case NodeKind.NavAnimation:
          return createNavAnimationInstance(kind, props, r, h2, o);
        case NodeKind.BalancesTable:
          return createBalancesTableInstance(kind, props, r, h2, o);
        case NodeKind.BalancesTableHead:
          return createBalancesTableHeadInstance(kind, props, r, h2, o);
        case NodeKind.BalancesTableContent:
          return createBalancesTableContentInstance(kind, props, r, h2, o);
        case NodeKind.BalancesTableRow:
          return createBalancesTableRowInstance(kind, props, r, h2, o);
        case NodeKind.BalancesTableCell:
          return createBalancesTableCellInstance(kind, props, r, h2, o);
        case NodeKind.BalancesTableFooter:
          return createBalancesTableFooterInstance(kind, props, r, h2, o);
        case NodeKind.Custom:
          if (!props.component) {
            throw new Error("Component not found in Custom Node");
          }
          return createCustomInstance(kind, props, r, h2, o);
        default:
          throw new Error(`Component ${kind} is not part of the ReactXnft library, please use the available set of components.`);
      }
    },
    createTextInstance: (text, _r, h2, _o) => {
      logger2.debug("createTextInstance", text);
      const instance2 = {
        id: h2.nextId(),
        kind: "raw",
        text
      };
      return instance2;
    },
    appendInitialChild: (parent, child) => {
      logger2.debug("appendInitialChild", parent, child);
      parent.children.push(child);
    },
    prepareUpdate: (instance2, type5, oldProps, newProps, root2, host) => {
      logger2.debug("prepareUpdate", instance2, type5, oldProps, newProps);
      return {
        props: newProps
      };
    },
    finalizeInitialChildren: (_parent, _kind, _props, _root, _host) => {
      logger2.debug("finalizeInitialChildren", _parent, _kind, _props, _root, _host);
      return false;
    },
    prepareForCommit: (_c) => {
      logger2.debug("prepareForCommit", _c);
      return null;
    },
    commitUpdate: (instance2, updatePayload, type5, oldProps, newProps, internalInstanceHandle) => {
      logger2.debug("commitUpdate", instance2, type5, updatePayload, oldProps, newProps);
      if (updatePayload === null || Object.keys(updatePayload).length === 0) {
        return;
      }
      instance2.props = updatePayload.props;
      ReactDom.getInstance().commitUpdate(instance2.id, updatePayload);
    },
    commitTextUpdate: (textInstance, oldText, nextText) => {
      logger2.debug("commitTextUpdate");
      textInstance.text = nextText;
      ReactDom.getInstance().commitTextUpdate(textInstance.id, nextText);
    },
    appendChildToContainer: (c2, child) => {
      logger2.debug("appendChildToContainer", c2, child);
      ReactDom.getInstance().appendChildToContainer(child);
    },
    appendChild: (parent, child) => {
      logger2.debug("appendChild", parent, child);
      ReactDom.getInstance().appendChild(parent.id, child);
    },
    insertInContainerBefore: (root2, child, before) => {
      logger2.debug("insertInContainerBefore");
      ReactDom.getInstance().insertInContainerBefore(child, before.id);
    },
    insertBefore: (parent, child, before) => {
      logger2.debug("insertBefore");
      ReactDom.getInstance().insertBefore(parent.id, child, before.id);
    },
    removeChild: (parent, child) => {
      logger2.debug("removeChild", parent, child);
      ReactDom.getInstance().removeChild(parent.id, child.id);
    },
    removeChildFromContainer: (root2, child) => {
      logger2.debug("removeChildFromContainer", root2, child);
      ReactDom.getInstance().removeChildFromContainer(child.id);
    },
    getPublicInstance: (instance2) => {
      logger2.debug("getPublicInstance");
      return instance2;
    },
    shouldSetTextContent: () => {
      logger2.debug("shouldSetTextContent");
      return false;
    },
    resetAfterCommit: (root2) => {
      logger2.debug("resetAfterCommit", root2);
    },
    clearContainer: (root2) => {
      logger2.debug("clearContainer", root2);
      root2.children = [];
    },
    shouldDeleteUnhydratedTailInstances: () => {
      logger2.debug("shouldDeleteUnhydratedTailInstances");
    },
    scheduleTimeout: (fn2, delay) => {
      logger2.debug("scheduleTimeout");
      return setTimeout(fn2, delay);
    }
  });
  function createViewInstance(_kind, props, _r, h2, _o) {
    const id = h2.nextId();
    return {
      id,
      kind: NodeKind.View,
      props,
      children: []
    };
  }
  function createTableInstance(_kind, props, _r, h2, _o) {
    return {
      id: h2.nextId(),
      kind: NodeKind.Table,
      props,
      children: []
    };
  }
  function createTableRowInstance(_kind, props, _r, h2, _o) {
    return {
      id: h2.nextId(),
      kind: NodeKind.TableRow,
      props,
      children: []
    };
  }
  function createTextLabelInstance(_kind, props, _r, h2, _o) {
    return {
      id: h2.nextId(),
      kind: NodeKind.Text,
      props,
      children: []
    };
  }
  function createTextFieldInstance(_kind, props, _r, h2, _o) {
    const id = h2.nextId();
    return {
      id,
      kind: NodeKind.TextField,
      props,
      children: []
    };
  }
  function createImageInstance(_kind, props, _r, h2, _o) {
    const id = h2.nextId();
    const src = props.src;
    return {
      id,
      kind: NodeKind.Image,
      props: {
        ...props,
        src,
        children: props.children
      },
      children: []
    };
  }
  function createButtonInstance(_kind, props, _r, h2, _o) {
    const id = h2.nextId();
    return {
      id,
      kind: NodeKind.Button,
      props,
      children: []
    };
  }
  function createAudioInstance(_kind, props, _r, h2, _o) {
    const id = h2.nextId();
    return {
      id,
      kind: NodeKind.Audio,
      props,
      children: []
    };
  }
  function createVideoInstance(_kind, props, _r, h2, _o) {
    const id = h2.nextId();
    return {
      id,
      kind: NodeKind.Video,
      props,
      children: []
    };
  }
  function createLoadingInstance(_kind, props, _r, h2, _o) {
    const id = h2.nextId();
    return {
      id,
      kind: NodeKind.Loading,
      props,
      children: []
    };
  }
  function createScrollBarInstance(_kind, props, _r, h2, _o) {
    const id = h2.nextId();
    return {
      id,
      kind: NodeKind.ScrollBar,
      props,
      children: []
    };
  }
  function createSvgInstance(_kind, props, _r, h2, _o) {
    return {
      id: h2.nextId(),
      kind: NodeKind.Svg,
      props,
      children: []
    };
  }
  function createPathInstance(_kind, props, _r, h2, _o) {
    return {
      id: h2.nextId(),
      kind: NodeKind.Path,
      props: {
        ...props
      },
      children: []
    };
  }
  function createCircleInstance(_kind, props, _r, h2, _o) {
    return {
      id: h2.nextId(),
      kind: NodeKind.Circle,
      props: {
        ...props
      },
      children: []
    };
  }
  function createIframeInstance(_kind, props, _r, h2, _o) {
    return {
      id: h2.nextId(),
      kind: NodeKind.Iframe,
      props: {
        ...props
      },
      children: []
    };
  }
  function createCustomInstance(kind, props, _r, h2, _o) {
    return {
      id: h2.nextId(),
      kind: NodeKind.Custom,
      props,
      children: [],
      component: kind
    };
  }
  function createNavAnimationInstance(_kind, props, _r, h2, _o) {
    return {
      id: h2.nextId(),
      kind: NodeKind.NavAnimation,
      props,
      children: []
    };
  }
  function createBalancesTableInstance(_kind, props, _r, h2, _o) {
    return {
      id: h2.nextId(),
      kind: NodeKind.BalancesTable,
      props,
      children: []
    };
  }
  function createBalancesTableHeadInstance(_kind, props, _r, h2, _o) {
    return {
      id: h2.nextId(),
      kind: NodeKind.BalancesTableHead,
      props,
      children: []
    };
  }
  function createBalancesTableContentInstance(_kind, props, _r, h2, _o) {
    return {
      id: h2.nextId(),
      kind: NodeKind.BalancesTableContent,
      props,
      children: []
    };
  }
  function createBalancesTableRowInstance(_kind, props, _r, h2, _o) {
    const id = h2.nextId();
    return {
      id,
      kind: NodeKind.BalancesTableRow,
      props,
      children: []
    };
  }
  function createBalancesTableCellInstance(_kind, props, _r, h2, _o) {
    return {
      id: h2.nextId(),
      kind: NodeKind.BalancesTableCell,
      props,
      children: []
    };
  }
  function createBalancesTableFooterInstance(_kind, props, _r, h2, _o) {
    return {
      id: h2.nextId(),
      kind: NodeKind.BalancesTableFooter,
      props,
      children: []
    };
  }
  var HOST = {
    nextId: (() => {
      let id = 0;
      return () => id++;
    })()
  };
  var NodeKind;
  (function(NodeKind2) {
    NodeKind2["Table"] = "Table";
    NodeKind2["TableRow"] = "TableRow";
    NodeKind2["Text"] = "Text";
    NodeKind2["TextField"] = "TextField";
    NodeKind2["Image"] = "Image";
    NodeKind2["View"] = "View";
    NodeKind2["Audio"] = "Audio";
    NodeKind2["Video"] = "Video";
    NodeKind2["Button"] = "Button";
    NodeKind2["Loading"] = "Loading";
    NodeKind2["ScrollBar"] = "ScrollBar";
    NodeKind2["Svg"] = "Svg";
    NodeKind2["Path"] = "Path";
    NodeKind2["Circle"] = "Circle";
    NodeKind2["Iframe"] = "Iframe";
    NodeKind2["NavAnimation"] = "NavAnimation";
    NodeKind2["BalancesTable"] = "BalancesTable";
    NodeKind2["BalancesTableHead"] = "BalancesTableHead";
    NodeKind2["BalancesTableContent"] = "BalancesTableContent";
    NodeKind2["BalancesTableRow"] = "BalancesTableRow";
    NodeKind2["BalancesTableCell"] = "BalancesTableCell";
    NodeKind2["BalancesTableFooter"] = "BalancesTableFooter";
    NodeKind2["Custom"] = "Custom";
  })(NodeKind || (NodeKind = {}));

  // node_modules/react-xnft/dist/esm/Dom.js
  init_virtual_process_polyfill();
  init_buffer();
  var import_jsx_runtime2 = __toESM(require_jsx_runtime());
  function AnchorDom({ children }) {
    return (0, import_jsx_runtime2.jsx)(AnchorProvider, { children });
  }

  // node_modules/react-xnft/dist/esm/elements.js
  init_virtual_process_polyfill();
  init_buffer();
  var import_react3 = __toESM(require_react());
  var c = (name2) => (props) => import_react3.default.createElement(name2, props);
  var Text = c("Text");
  var TextField = c("TextField");
  var Image = c("Image");
  var Table = c("Table");
  var TableHead = c("TableHead");
  var TableRow = c("TableRow");
  var TableFooter = c("TableFooter");
  var View = c("View");
  var Button = c("Button");
  var Loading = c("Loading");
  var ScrollBar = c("ScrollBar");
  var Svg = c("Svg");
  var Path = c("Path");
  var Circle = c("Circle");
  var NavAnimation = c("NavAnimation");
  var Iframe = c("Iframe");
  var BalancesTable = c("BalancesTable");
  var BalancesTableContent = c("BalancesTableContent");
  var BalancesTableHead = c("BalancesTableHead");
  var BalancesTableRow = c("BalancesTableRow");
  var BalancesTableCell = c("BalancesTableCell");
  var BalancesTableFooter = c("BalancesTableFooter");
  var Custom = c("Custom");

  // node_modules/react-xnft/dist/esm/hooks.js
  init_virtual_process_polyfill();
  init_buffer();
  var import_react4 = __toESM(require_react());
  function usePublicKey() {
    var _a;
    const [publicKey6, setPublicKey] = (0, import_react4.useState)((_a = window.xnft.solana) === null || _a === void 0 ? void 0 : _a.publicKey);
    (0, import_react4.useEffect)(() => {
      var _a2;
      (_a2 = window.xnft.solana) === null || _a2 === void 0 ? void 0 : _a2.on("publicKeyUpdate", () => {
        setPublicKey(window.xnft.solana.publicKey);
      });
    }, [setPublicKey]);
    return publicKey6;
  }
  function useConnection() {
    var _a;
    const [connection, setConnection] = (0, import_react4.useState)((_a = window.xnft.solana) === null || _a === void 0 ? void 0 : _a.connection);
    (0, import_react4.useEffect)(() => {
      var _a2;
      (_a2 = window.xnft.solana) === null || _a2 === void 0 ? void 0 : _a2.on("connectionUpdate", () => {
        setConnection(window.xnft.solana.connection);
      });
    }, [setConnection]);
    return connection;
  }

  // node_modules/react-xnft/dist/esm/native.js
  init_virtual_process_polyfill();
  init_buffer();

  // node_modules/react-xnft/dist/esm/sdk/index.js
  init_virtual_process_polyfill();
  init_buffer();

  // node_modules/react-xnft/dist/esm/sdk/Icons.js
  init_virtual_process_polyfill();
  init_buffer();
  var import_jsx_runtime3 = __toESM(require_jsx_runtime());
  function ArrowBack({ fill: fill2 = "#99A4B4" }) {
    return (0, import_jsx_runtime3.jsx)(Svg, { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", children: (0, import_jsx_runtime3.jsx)(Path, { d: "M18.7912 11.0051H7.62124L12.5012 6.1251C12.8912 5.7351 12.8912 5.0951 12.5012 4.7051C12.1112 4.3151 11.4812 4.3151 11.0912 4.7051L4.50124 11.2951C4.11124 11.6851 4.11124 12.3151 4.50124 12.7051L11.0912 19.2951C11.4812 19.6851 12.1112 19.6851 12.5012 19.2951C12.8912 18.9051 12.8912 18.2751 12.5012 17.8851L7.62124 13.0051H18.7912C19.3412 13.0051 19.7912 12.5551 19.7912 12.0051C19.7912 11.4551 19.3412 11.0051 18.7912 11.0051Z", fill: fill2 }) });
  }

  // node_modules/react-xnft/dist/esm/sdk/List.js
  init_virtual_process_polyfill();
  init_buffer();
  var import_jsx_runtime4 = __toESM(require_jsx_runtime());

  // node_modules/react-xnft/dist/esm/sdk/Stack/index.js
  init_virtual_process_polyfill();
  init_buffer();
  var import_jsx_runtime6 = __toESM(require_jsx_runtime());

  // node_modules/react-xnft/dist/esm/sdk/Stack/Context.js
  init_virtual_process_polyfill();
  init_buffer();
  var import_jsx_runtime5 = __toESM(require_jsx_runtime());
  var import_react5 = __toESM(require_react());
  var _NavStackContext = import_react5.default.createContext(null);
  function useNavigation() {
    const ctx = (0, import_react5.useContext)(_NavStackContext);
    if (ctx === null) {
      throw new Error("Context not available");
    }
    return ctx;
  }
  function NavStackProvider({ initialRoute, navButtonRight, style, titleStyle, children }) {
    const [stack, setStack] = (0, import_react5.useState)([{ navAction: "push", ...initialRoute }]);
    const [titleOverride, setTitleOverride] = (0, import_react5.useState)(initialRoute.title);
    const [navButtonRightOverride, setNavButtonRightOverride] = (0, import_react5.useState)(navButtonRight);
    const [_style, setStyle] = (0, import_react5.useState)(style);
    const [contentStyle, setContentStyle] = (0, import_react5.useState)({});
    const [_titleStyle, _setTitleStyle] = (0, import_react5.useState)(titleStyle);
    const push = (route, props) => {
      setStack((oldStack) => [
        ...oldStack,
        { name: route, props, navAction: "push" }
      ]);
    };
    const pop = () => {
      setStack((oldStack) => {
        let newStack = [...oldStack];
        newStack = newStack.slice(0, newStack.length - 1);
        newStack[newStack.length - 1]["navAction"] = "pop";
        return newStack;
      });
    };
    const toRoot = () => {
      setStack([stack[0]]);
    };
    return (0, import_jsx_runtime5.jsx)(_NavStackContext.Provider, { value: {
      activeRoute: stack[stack.length - 1],
      push,
      pop,
      isRoot: stack.length === 1,
      toRoot,
      title: titleOverride,
      setTitle: setTitleOverride,
      navButtonRight: navButtonRightOverride,
      setNavButtonRight: setNavButtonRightOverride,
      style: _style,
      setStyle,
      contentStyle,
      setContentStyle,
      titleStyle: _titleStyle,
      setTitleStyle: _setTitleStyle
    }, children });
  }

  // node_modules/react-xnft/dist/esm/sdk/Stack/index.js
  var NAV_BAR_HEIGHT = 56;
  var NAV_BUTTON_WIDTH = 38;
  var Stack = {
    Navigator,
    Screen
  };
  function Navigator({ initialRoute, children, options, style, titleStyle, navButtonRight }) {
    const isArray2 = children && children.length !== void 0;
    const navScreens = children === void 0 ? [] : isArray2 ? children : [children];
    return (0, import_jsx_runtime6.jsx)(NavStackProvider, { initialRoute, style, titleStyle, navButtonRight, children: (0, import_jsx_runtime6.jsx)(NavStackInner, { navScreens, options }) });
  }
  function NavStackInner({ navScreens, options }) {
    var _a;
    let { isRoot, activeRoute, pop, navButtonRight, title: title2, style, contentStyle, titleStyle } = useNavigation();
    const navButtonLeft = isRoot ? null : (0, import_jsx_runtime6.jsx)(NavBackButton, { onClick: () => pop() });
    const activeScreen = navScreens.find((c2) => c2.props.name === activeRoute.name);
    const { title: titleDefault } = options({
      route: activeRoute
    });
    if (!title2) {
      title2 = titleDefault;
    }
    return (0, import_jsx_runtime6.jsx)(NavAnimation, { routeName: activeRoute.name, navAction: "push", children: (0, import_jsx_runtime6.jsx)(WithNav, { title: title2, navButtonLeft, navButtonRight, navbarStyle: style, navbarTitleStyle: titleStyle, navContentStyle: contentStyle, children: activeScreen.props.component({ ...(_a = activeRoute.props) !== null && _a !== void 0 ? _a : {} }) }) });
  }
  function Screen({ component, name: name2 }) {
    return (0, import_jsx_runtime6.jsx)(View, { style: { display: "none" } });
  }
  function WithNav({ title: title2, navButtonLeft, navButtonRight, children, navbarStyle = {}, navbarTitleStyle = {}, navContentStyle = {} }) {
    return (0, import_jsx_runtime6.jsxs)(View, { style: { display: "flex", flexDirection: "column", height: "100%" }, children: [(0, import_jsx_runtime6.jsx)(NavBar, { title: title2 || "", navButtonLeft, navButtonRight, style: navbarStyle, titleStyle: navbarTitleStyle }), (0, import_jsx_runtime6.jsx)(NavContent, { style: navContentStyle, renderComponent: children })] });
  }
  function NavBar({ title: title2, navButtonLeft, navButtonRight, style = {}, titleStyle = {} }) {
    return (0, import_jsx_runtime6.jsx)(View, { style: {
      display: "flex",
      height: `${NAV_BAR_HEIGHT}px`,
      position: "relative",
      justifyContent: "space-between",
      padding: "10px 16px",
      ...style
    }, children: (0, import_jsx_runtime6.jsxs)(View, { style: { position: "relative", width: "100%", display: "flex" }, children: [(0, import_jsx_runtime6.jsx)(NavButton, { button: navButtonLeft }), (0, import_jsx_runtime6.jsx)(CenterDisplay, { title: title2, titleStyle }), (0, import_jsx_runtime6.jsx)(NavButton, { button: navButtonRight, align: "right" })] }) });
  }
  function NavButton({ button, align = "left" }) {
    const alignment = { [align]: 0 };
    return (0, import_jsx_runtime6.jsx)(View, { style: {
      position: "absolute",
      height: "100%",
      display: "flex",
      justifyContent: "center",
      flexDirection: "column",
      ...alignment
    }, children: button ? button : (0, import_jsx_runtime6.jsx)(DummyButton, {}) });
  }
  function NavBackButton({ onClick }) {
    const theme = useTheme();
    return (0, import_jsx_runtime6.jsx)(View, { style: {
      width: `${NAV_BUTTON_WIDTH}px`,
      display: "flex",
      justifyContent: "center",
      flexDirection: "column",
      position: "relative"
    }, children: (0, import_jsx_runtime6.jsx)(Button, { onClick, style: {
      backgroundColor: "transparent",
      height: "24px",
      width: "24px",
      minWidth: "24px",
      padding: 0
    }, children: (0, import_jsx_runtime6.jsx)(ArrowBack, { fill: theme.custom.colors.secondary }) }) });
  }
  function NavContent({ renderComponent, style }) {
    const _style = {
      flex: 1,
      ...style
    };
    return (0, import_jsx_runtime6.jsx)(View, { style: _style, children: (0, import_jsx_runtime6.jsx)(ScrollBar, { children: renderComponent }) });
  }
  function CenterDisplay({ title: title2, titleStyle }) {
    return (0, import_jsx_runtime6.jsx)(View, { style: {
      visibility: title2 ? void 0 : "hidden",
      overflow: "hidden",
      maxWidth: `calc(100% - ${NAV_BUTTON_WIDTH * 2}px)`,
      margin: "0 auto",
      display: "flex",
      alignItems: "center"
    }, children: (0, import_jsx_runtime6.jsx)(NavTitleLabel, { title: title2, style: titleStyle }) });
  }
  function NavTitleLabel({ title: title2, style }) {
    const theme = useTheme();
    return (0, import_jsx_runtime6.jsx)(Text, { style: {
      fontSize: "18px",
      fontWeight: 500,
      color: theme.custom.colors.fontColor,
      overflow: "hidden",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap",
      textAlign: "center",
      lineHeight: "24px",
      ...style
    }, children: title2 });
  }
  function DummyButton() {
    return (0, import_jsx_runtime6.jsx)(View, { style: {
      width: `${NAV_BUTTON_WIDTH}px`,
      display: "flex",
      justifyContent: "center",
      flexDirection: "column"
    } });
  }

  // node_modules/react-xnft/dist/esm/sdk/storage.js
  init_virtual_process_polyfill();
  init_buffer();

  // node_modules/react-xnft/dist/esm/sdk/Tab.js
  init_virtual_process_polyfill();
  init_buffer();
  var import_jsx_runtime7 = __toESM(require_jsx_runtime());
  var import_react6 = __toESM(require_react());
  var _TabContext = import_react6.default.createContext(null);

  // node_modules/react-xnft/dist/esm/index.js
  var esm_default = ReactXnft;

  // src/App/App.tsx
  init_virtual_process_polyfill();
  init_buffer();
  var import_react18 = __toESM(require_react());

  // node_modules/reselect/es/index.js
  init_virtual_process_polyfill();
  init_buffer();

  // node_modules/reselect/es/defaultMemoize.js
  init_virtual_process_polyfill();
  init_buffer();
  var NOT_FOUND = "NOT_FOUND";
  function createSingletonCache(equals2) {
    var entry;
    return {
      get: function get(key) {
        if (entry && equals2(entry.key, key)) {
          return entry.value;
        }
        return NOT_FOUND;
      },
      put: function put(key, value) {
        entry = {
          key,
          value
        };
      },
      getEntries: function getEntries() {
        return entry ? [entry] : [];
      },
      clear: function clear() {
        entry = void 0;
      }
    };
  }
  function createLruCache(maxSize, equals2) {
    var entries = [];
    function get(key) {
      var cacheIndex = entries.findIndex(function(entry2) {
        return equals2(key, entry2.key);
      });
      if (cacheIndex > -1) {
        var entry = entries[cacheIndex];
        if (cacheIndex > 0) {
          entries.splice(cacheIndex, 1);
          entries.unshift(entry);
        }
        return entry.value;
      }
      return NOT_FOUND;
    }
    function put(key, value) {
      if (get(key) === NOT_FOUND) {
        entries.unshift({
          key,
          value
        });
        if (entries.length > maxSize) {
          entries.pop();
        }
      }
    }
    function getEntries() {
      return entries;
    }
    function clear() {
      entries = [];
    }
    return {
      get,
      put,
      getEntries,
      clear
    };
  }
  var defaultEqualityCheck = function defaultEqualityCheck2(a, b2) {
    return a === b2;
  };
  function createCacheKeyComparator(equalityCheck) {
    return function areArgumentsShallowlyEqual(prev, next) {
      if (prev === null || next === null || prev.length !== next.length) {
        return false;
      }
      var length = prev.length;
      for (var i = 0; i < length; i++) {
        if (!equalityCheck(prev[i], next[i])) {
          return false;
        }
      }
      return true;
    };
  }
  function defaultMemoize(func, equalityCheckOrOptions) {
    var providedOptions = typeof equalityCheckOrOptions === "object" ? equalityCheckOrOptions : {
      equalityCheck: equalityCheckOrOptions
    };
    var _providedOptions$equa = providedOptions.equalityCheck, equalityCheck = _providedOptions$equa === void 0 ? defaultEqualityCheck : _providedOptions$equa, _providedOptions$maxS = providedOptions.maxSize, maxSize = _providedOptions$maxS === void 0 ? 1 : _providedOptions$maxS, resultEqualityCheck = providedOptions.resultEqualityCheck;
    var comparator = createCacheKeyComparator(equalityCheck);
    var cache = maxSize === 1 ? createSingletonCache(comparator) : createLruCache(maxSize, comparator);
    function memoized() {
      var value = cache.get(arguments);
      if (value === NOT_FOUND) {
        value = func.apply(null, arguments);
        if (resultEqualityCheck) {
          var entries = cache.getEntries();
          var matchingEntry = entries.find(function(entry) {
            return resultEqualityCheck(entry.value, value);
          });
          if (matchingEntry) {
            value = matchingEntry.value;
          }
        }
        cache.put(arguments, value);
      }
      return value;
    }
    memoized.clearCache = function() {
      return cache.clear();
    };
    return memoized;
  }

  // node_modules/reselect/es/index.js
  function getDependencies(funcs) {
    var dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;
    if (!dependencies.every(function(dep) {
      return typeof dep === "function";
    })) {
      var dependencyTypes = dependencies.map(function(dep) {
        return typeof dep === "function" ? "function " + (dep.name || "unnamed") + "()" : typeof dep;
      }).join(", ");
      throw new Error("createSelector expects all input-selectors to be functions, but received the following types: [" + dependencyTypes + "]");
    }
    return dependencies;
  }
  function createSelectorCreator(memoize) {
    for (var _len = arguments.length, memoizeOptionsFromArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      memoizeOptionsFromArgs[_key - 1] = arguments[_key];
    }
    var createSelector2 = function createSelector3() {
      for (var _len2 = arguments.length, funcs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        funcs[_key2] = arguments[_key2];
      }
      var _recomputations = 0;
      var _lastResult;
      var directlyPassedOptions = {
        memoizeOptions: void 0
      };
      var resultFunc = funcs.pop();
      if (typeof resultFunc === "object") {
        directlyPassedOptions = resultFunc;
        resultFunc = funcs.pop();
      }
      if (typeof resultFunc !== "function") {
        throw new Error("createSelector expects an output function after the inputs, but received: [" + typeof resultFunc + "]");
      }
      var _directlyPassedOption = directlyPassedOptions, _directlyPassedOption2 = _directlyPassedOption.memoizeOptions, memoizeOptions = _directlyPassedOption2 === void 0 ? memoizeOptionsFromArgs : _directlyPassedOption2;
      var finalMemoizeOptions = Array.isArray(memoizeOptions) ? memoizeOptions : [memoizeOptions];
      var dependencies = getDependencies(funcs);
      var memoizedResultFunc = memoize.apply(void 0, [function recomputationWrapper() {
        _recomputations++;
        return resultFunc.apply(null, arguments);
      }].concat(finalMemoizeOptions));
      var selector4 = memoize(function dependenciesChecker() {
        var params = [];
        var length = dependencies.length;
        for (var i = 0; i < length; i++) {
          params.push(dependencies[i].apply(null, arguments));
        }
        _lastResult = memoizedResultFunc.apply(null, params);
        return _lastResult;
      });
      Object.assign(selector4, {
        resultFunc,
        memoizedResultFunc,
        dependencies,
        lastResult: function lastResult() {
          return _lastResult;
        },
        recomputations: function recomputations() {
          return _recomputations;
        },
        resetRecomputations: function resetRecomputations() {
          return _recomputations = 0;
        }
      });
      return selector4;
    };
    return createSelector2;
  }
  var createSelector = /* @__PURE__ */ createSelectorCreator(defaultMemoize);

  // src/state.ts
  init_virtual_process_polyfill();
  init_buffer();

  // src/App/_actions/INITIALIZE_STATE.ts
  init_virtual_process_polyfill();
  init_buffer();

  // src/App/_helpers/redux.tsx
  init_virtual_process_polyfill();
  init_buffer();
  var import_react7 = __toESM(require_react());
  var redux_default = createRedux;
  var createSimpleAction = (type5) => (values) => ({ type: type5, ...values });
  function createRedux(reducer2, initialState2) {
    const StateContext = (0, import_react7.createContext)({ state: initialState2 });
    const DispatchContext = (0, import_react7.createContext)({ dispatch: () => {
    } });
    const ReduxProvider2 = ({ children }) => {
      const { state: initialState3 } = (0, import_react7.useContext)(StateContext);
      const [state, dispatch] = useThunk(
        (0, import_react7.useReducer)(reducer2, initialState3)
      );
      return /* @__PURE__ */ import_react7.default.createElement(StateContext.Provider, { value: { state } }, (0, import_react7.useMemo)(
        () => /* @__PURE__ */ import_react7.default.createElement(DispatchContext.Provider, { value: { dispatch } }, children),
        []
      ));
    };
    const connect2 = (selector4) => (Component) => (props) => {
      const currentSelector = selector4 || (() => null);
      const { state } = (0, import_react7.useContext)(StateContext);
      const [selection, updateSelection] = (0, import_react7.useState)(
        () => currentSelector(state, props, null)
      );
      const newSelection = currentSelector(state, props, selection);
      (0, import_react7.useEffect)(() => updateSelection(newSelection), [newSelection]);
      return (0, import_react7.useMemo)(
        () => /* @__PURE__ */ import_react7.default.createElement(Component, { ...props, ...selection ?? {} }),
        [selection, props]
      );
    };
    const useDispatch2 = () => {
      const { dispatch } = (0, import_react7.useContext)(DispatchContext);
      return dispatch;
    };
    return {
      connect: connect2,
      ReduxProvider: ReduxProvider2,
      useDispatch: useDispatch2
    };
  }
  function useThunk([state, dispatch]) {
    const containerRef = (0, import_react7.useRef)(state);
    const thunkDispatch = (0, import_react7.useCallback)(
      (action) => {
        switch (typeof action) {
          case "object": {
            dispatch(action);
            break;
          }
          case "function": {
            const thunk = action;
            thunk(thunkDispatch, () => containerRef.current);
            break;
          }
        }
      },
      [containerRef, dispatch]
    );
    return [state, thunkDispatch];
  }

  // src/App/_actions/INITIALIZE_STATE.ts
  var INITIALIZE_STATE = createSimpleAction("INITIALIZE_STATE");
  var INITIALIZE_STATE_reducer = (state, action) => {
    return {
      ...action.state ? action.state : state,
      initialized: true
    };
  };

  // src/App/_actions/SET_TOKENLIST.ts
  init_virtual_process_polyfill();
  init_buffer();
  var SET_TOKENLIST = createSimpleAction("SET_TOKENLIST");
  var SET_TOKENLIST_reducer = (state, action) => {
    const tokenInfos = {};
    const tokenList = action.tokenData.map((token) => {
      tokenInfos[token.id] = token;
      return token.id;
    });
    return {
      ...state,
      tokenList,
      tokenInfos
    };
  };

  // node_modules/superstruct/lib/index.mjs
  init_virtual_process_polyfill();
  init_buffer();
  var StructError = class extends TypeError {
    constructor(failure, failures) {
      let cached;
      const {
        message,
        ...rest
      } = failure;
      const {
        path
      } = failure;
      const msg = path.length === 0 ? message : `At path: ${path.join(".")} -- ${message}`;
      super(msg);
      this.value = void 0;
      this.key = void 0;
      this.type = void 0;
      this.refinement = void 0;
      this.path = void 0;
      this.branch = void 0;
      this.failures = void 0;
      Object.assign(this, rest);
      this.name = this.constructor.name;
      this.failures = () => {
        return cached ?? (cached = [failure, ...failures()]);
      };
    }
  };
  function isIterable(x2) {
    return isObject(x2) && typeof x2[Symbol.iterator] === "function";
  }
  function isObject(x2) {
    return typeof x2 === "object" && x2 != null;
  }
  function print(value) {
    if (typeof value === "symbol") {
      return value.toString();
    }
    return typeof value === "string" ? JSON.stringify(value) : `${value}`;
  }
  function shiftIterator(input) {
    const {
      done,
      value
    } = input.next();
    return done ? void 0 : value;
  }
  function toFailure(result, context, struct6, value) {
    if (result === true) {
      return;
    } else if (result === false) {
      result = {};
    } else if (typeof result === "string") {
      result = {
        message: result
      };
    }
    const {
      path,
      branch
    } = context;
    const {
      type: type5
    } = struct6;
    const {
      refinement,
      message = `Expected a value of type \`${type5}\`${refinement ? ` with refinement \`${refinement}\`` : ""}, but received: \`${print(value)}\``
    } = result;
    return {
      value,
      type: type5,
      refinement,
      key: path[path.length - 1],
      path,
      branch,
      ...result,
      message
    };
  }
  function* toFailures(result, context, struct6, value) {
    if (!isIterable(result)) {
      result = [result];
    }
    for (const r of result) {
      const failure = toFailure(r, context, struct6, value);
      if (failure) {
        yield failure;
      }
    }
  }
  function* run(value, struct6, options) {
    if (options === void 0) {
      options = {};
    }
    const {
      path = [],
      branch = [value],
      coerce: coerce3 = false,
      mask: mask4 = false
    } = options;
    const ctx = {
      path,
      branch
    };
    if (coerce3) {
      value = struct6.coercer(value, ctx);
      if (mask4 && struct6.type !== "type" && isObject(struct6.schema) && isObject(value) && !Array.isArray(value)) {
        for (const key in value) {
          if (struct6.schema[key] === void 0) {
            delete value[key];
          }
        }
      }
    }
    let status = "valid";
    for (const failure of struct6.validator(value, ctx)) {
      status = "not_valid";
      yield [failure, void 0];
    }
    for (let [k2, v2, s] of struct6.entries(value, ctx)) {
      const ts = run(v2, s, {
        path: k2 === void 0 ? path : [...path, k2],
        branch: k2 === void 0 ? branch : [...branch, v2],
        coerce: coerce3,
        mask: mask4
      });
      for (const t2 of ts) {
        if (t2[0]) {
          status = t2[0].refinement != null ? "not_refined" : "not_valid";
          yield [t2[0], void 0];
        } else if (coerce3) {
          v2 = t2[1];
          if (k2 === void 0) {
            value = v2;
          } else if (value instanceof Map) {
            value.set(k2, v2);
          } else if (value instanceof Set) {
            value.add(v2);
          } else if (isObject(value)) {
            if (v2 !== void 0 || k2 in value)
              value[k2] = v2;
          }
        }
      }
    }
    if (status !== "not_valid") {
      for (const failure of struct6.refiner(value, ctx)) {
        status = "not_refined";
        yield [failure, void 0];
      }
    }
    if (status === "valid") {
      yield [void 0, value];
    }
  }
  var Struct = class {
    constructor(props) {
      this.TYPE = void 0;
      this.type = void 0;
      this.schema = void 0;
      this.coercer = void 0;
      this.validator = void 0;
      this.refiner = void 0;
      this.entries = void 0;
      const {
        type: type5,
        schema,
        validator,
        refiner,
        coercer = (value) => value,
        entries = function* () {
        }
      } = props;
      this.type = type5;
      this.schema = schema;
      this.entries = entries;
      this.coercer = coercer;
      if (validator) {
        this.validator = (value, context) => {
          const result = validator(value, context);
          return toFailures(result, context, this, value);
        };
      } else {
        this.validator = () => [];
      }
      if (refiner) {
        this.refiner = (value, context) => {
          const result = refiner(value, context);
          return toFailures(result, context, this, value);
        };
      } else {
        this.refiner = () => [];
      }
    }
    assert(value) {
      return assert(value, this);
    }
    create(value) {
      return create2(value, this);
    }
    is(value) {
      return is(value, this);
    }
    mask(value) {
      return mask(value, this);
    }
    validate(value, options) {
      if (options === void 0) {
        options = {};
      }
      return validate2(value, this, options);
    }
  };
  function assert(value, struct6) {
    const result = validate2(value, struct6);
    if (result[0]) {
      throw result[0];
    }
  }
  function create2(value, struct6) {
    const result = validate2(value, struct6, {
      coerce: true
    });
    if (result[0]) {
      throw result[0];
    } else {
      return result[1];
    }
  }
  function mask(value, struct6) {
    const result = validate2(value, struct6, {
      coerce: true,
      mask: true
    });
    if (result[0]) {
      throw result[0];
    } else {
      return result[1];
    }
  }
  function is(value, struct6) {
    const result = validate2(value, struct6);
    return !result[0];
  }
  function validate2(value, struct6, options) {
    if (options === void 0) {
      options = {};
    }
    const tuples = run(value, struct6, options);
    const tuple4 = shiftIterator(tuples);
    if (tuple4[0]) {
      const error2 = new StructError(tuple4[0], function* () {
        for (const t2 of tuples) {
          if (t2[0]) {
            yield t2[0];
          }
        }
      });
      return [error2, void 0];
    } else {
      const v2 = tuple4[1];
      return [void 0, v2];
    }
  }
  function define2(name2, validator) {
    return new Struct({
      type: name2,
      schema: null,
      validator
    });
  }
  function array(Element) {
    return new Struct({
      type: "array",
      schema: Element,
      *entries(value) {
        if (Element && Array.isArray(value)) {
          for (const [i, v2] of value.entries()) {
            yield [i, v2, Element];
          }
        }
      },
      coercer(value) {
        return Array.isArray(value) ? value.slice() : value;
      },
      validator(value) {
        return Array.isArray(value) || `Expected an array value, but received: ${print(value)}`;
      }
    });
  }
  function boolean() {
    return define2("boolean", (value) => {
      return typeof value === "boolean";
    });
  }
  function enums(values) {
    const schema = {};
    const description = values.map((v2) => print(v2)).join();
    for (const key of values) {
      schema[key] = key;
    }
    return new Struct({
      type: "enums",
      schema,
      validator(value) {
        return values.includes(value) || `Expected one of \`${description}\`, but received: ${print(value)}`;
      }
    });
  }
  function literal(constant) {
    const description = print(constant);
    const t2 = typeof constant;
    return new Struct({
      type: "literal",
      schema: t2 === "string" || t2 === "number" || t2 === "boolean" ? constant : null,
      validator(value) {
        return value === constant || `Expected the literal \`${description}\`, but received: ${print(value)}`;
      }
    });
  }
  function never() {
    return define2("never", () => false);
  }
  function nullable(struct6) {
    return new Struct({
      ...struct6,
      validator: (value, ctx) => value === null || struct6.validator(value, ctx),
      refiner: (value, ctx) => value === null || struct6.refiner(value, ctx)
    });
  }
  function number() {
    return define2("number", (value) => {
      return typeof value === "number" && !isNaN(value) || `Expected a number, but received: ${print(value)}`;
    });
  }
  function object(schema) {
    const knowns = schema ? Object.keys(schema) : [];
    const Never = never();
    return new Struct({
      type: "object",
      schema: schema ? schema : null,
      *entries(value) {
        if (schema && isObject(value)) {
          const unknowns = new Set(Object.keys(value));
          for (const key of knowns) {
            unknowns.delete(key);
            yield [key, value[key], schema[key]];
          }
          for (const key of unknowns) {
            yield [key, value[key], Never];
          }
        }
      },
      validator(value) {
        return isObject(value) || `Expected an object, but received: ${print(value)}`;
      },
      coercer(value) {
        return isObject(value) ? {
          ...value
        } : value;
      }
    });
  }
  function optional(struct6) {
    return new Struct({
      ...struct6,
      validator: (value, ctx) => value === void 0 || struct6.validator(value, ctx),
      refiner: (value, ctx) => value === void 0 || struct6.refiner(value, ctx)
    });
  }
  function record(Key, Value) {
    return new Struct({
      type: "record",
      schema: null,
      *entries(value) {
        if (isObject(value)) {
          for (const k2 in value) {
            const v2 = value[k2];
            yield [k2, k2, Key];
            yield [k2, v2, Value];
          }
        }
      },
      validator(value) {
        return isObject(value) || `Expected an object, but received: ${print(value)}`;
      }
    });
  }
  function string() {
    return define2("string", (value) => {
      return typeof value === "string" || `Expected a string, but received: ${print(value)}`;
    });
  }
  function tuple(Structs) {
    const Never = never();
    return new Struct({
      type: "tuple",
      schema: null,
      *entries(value) {
        if (Array.isArray(value)) {
          const length = Math.max(Structs.length, value.length);
          for (let i = 0; i < length; i++) {
            yield [i, value[i], Structs[i] || Never];
          }
        }
      },
      validator(value) {
        return Array.isArray(value) || `Expected an array, but received: ${print(value)}`;
      }
    });
  }
  function type(schema) {
    const keys = Object.keys(schema);
    return new Struct({
      type: "type",
      schema,
      *entries(value) {
        if (isObject(value)) {
          for (const k2 of keys) {
            yield [k2, value[k2], schema[k2]];
          }
        }
      },
      validator(value) {
        return isObject(value) || `Expected an object, but received: ${print(value)}`;
      }
    });
  }
  function union(Structs) {
    const description = Structs.map((s) => s.type).join(" | ");
    return new Struct({
      type: "union",
      schema: null,
      coercer(value, ctx) {
        const firstMatch = Structs.find((s) => {
          const [e] = s.validate(value, {
            coerce: true
          });
          return !e;
        }) || unknown();
        return firstMatch.coercer(value, ctx);
      },
      validator(value, ctx) {
        const failures = [];
        for (const S2 of Structs) {
          const [...tuples] = run(value, S2, ctx);
          const [first] = tuples;
          if (!first[0]) {
            return [];
          } else {
            for (const [failure] of tuples) {
              if (failure) {
                failures.push(failure);
              }
            }
          }
        }
        return [`Expected the value to satisfy a union of \`${description}\`, but received: ${print(value)}`, ...failures];
      }
    });
  }
  function unknown() {
    return define2("unknown", () => true);
  }

  // src/App/_types/TokenListType.ts
  init_virtual_process_polyfill();
  init_buffer();

  // src/App/_types/TokenInfoType.ts
  init_virtual_process_polyfill();
  init_buffer();
  var TokenInfoType = type({
    id: string(),
    symbol: string(),
    name: string(),
    image: string(),
    image2: string(),
    current_price: number(),
    tokenA: string(),
    tokenB: string(),
    price_change_percentage_24h: number(),
    sparkline_in_7d: type({
      price: array(number())
    })
  });

  // src/App/_types/TokenListType.ts
  var TokenListType = array(TokenInfoType);

  // src/App/_helpers/persistentReducer.ts
  init_virtual_process_polyfill();
  init_buffer();
  var import_debounce = __toESM(require_debounce());
  var debouncedLocalstorageUpdate = (0, import_debounce.default)(
    async (state) => {
      window.localStorage.setItem("PricesState", state);
    },
    500,
    true
  );
  var persistentReducer = (reducer2) => (state, action) => {
    const newState = reducer2(state, action);
    if (newState !== state) {
      debouncedLocalstorageUpdate(newState);
    }
    return newState;
  };
  var persistentReducer_default = persistentReducer;

  // src/App/_actions/FAVORITE.ts
  init_virtual_process_polyfill();
  init_buffer();
  var FAVORITE = createSimpleAction("FAVORITE");
  var FAVORITE_reducer = (state, action) => {
    return {
      ...state,
      favorites: {
        ...state.favorites,
        [action.assetId]: action.isFavorited
      }
    };
  };

  // src/App/_types/TokenChartType.ts
  init_virtual_process_polyfill();
  init_buffer();

  // src/App/_types/GraphDataPointType.ts
  init_virtual_process_polyfill();
  init_buffer();
  var GraphDataPointType = tuple([number(), number()]);

  // src/App/_types/ChartType.ts
  init_virtual_process_polyfill();
  init_buffer();
  var ChartType = enums(["1H", "1D", "1W", "1M", "1Y", "ALL"]);

  // src/App/_types/TokenChartType.ts
  var TokenChartType = object({
    activeChart: optional(ChartType),
    minute: optional(array(GraphDataPointType)),
    hour: optional(array(GraphDataPointType)),
    day: optional(array(GraphDataPointType))
  });

  // src/App/_actions/SET_TOKEN_CHART.ts
  init_virtual_process_polyfill();
  init_buffer();
  var SET_TOKEN_CHART = createSimpleAction("SET_TOKEN_CHART");
  var SET_TOKEN_CHART_reducer = (state, action) => {
    return {
      ...state,
      tokenCharts: {
        ...state.tokenCharts,
        [action.tokenId]: {
          ...state.tokenCharts[action.tokenId],
          ...action.chartData
        }
      }
    };
  };

  // src/state.ts
  var StateType = type({
    initialized: boolean(),
    loadingStatus: record(
      string(),
      union([literal("LOADING"), literal("SUCCESS"), literal("ERROR")])
    ),
    tokenCharts: record(string(), TokenChartType),
    tokenInfo: nullable(
      object({
        updated: number(),
        data: TokenListType
      })
    ),
    tokenInfos: record(string(), TokenInfoType),
    tokenList: nullable(array(string())),
    favorites: record(string(), boolean())
  });
  var reducer = (state, action) => {
    switch (action.type) {
      case "INITIALIZE_STATE":
        return INITIALIZE_STATE_reducer(state, action);
      case "SET_TOKENLIST":
        return SET_TOKENLIST_reducer(state, action);
      case "SET_TOKEN_CHART":
        return SET_TOKEN_CHART_reducer(state, action);
      case "FAVORITE":
        return FAVORITE_reducer(state, action);
      default:
        return state;
    }
  };
  var initialState = {
    initialized: false,
    tokenInfo: null,
    tokenInfos: {},
    tokenList: null,
    tokenCharts: {},
    loadingStatus: {},
    favorites: {}
  };
  var { useDispatch, ReduxProvider, connect } = redux_default(persistentReducer_default(reducer), initialState);

  // src/App/_hooks/useRefreshTokenList.ts
  init_virtual_process_polyfill();
  init_buffer();
  var import_react8 = __toESM(require_react());
  var refreshtime = 1e3 * 60;
  var url = `https://api.mainnet.orca.so/v1/whirlpool/list`;
  function useRefreshTokenList() {
    const dispatch = useDispatch();
    (0, import_react8.useEffect)(() => {
      const fetchTokenList = () => {
        fetch(url).then(async (response) => {
          const jsona = await response.json();
          let json = [];
          let goodLogo = "";
          for (var j2 in jsona.whirlpools) {
            jsona.whirlpools[j2].tokenA.logoURI ? goodLogo = jsona.whirlpools[j2].tokenA.logoURI : goodLogo = goodLogo;
            console.log(j2);
            json.push({
              tokenA: jsona.whirlpools[j2].tokenA.mint,
              tokenB: jsona.whirlpools[j2].tokenB.mint,
              price_change_percentage_24h: jsona.whirlpools[j2].priceRange ? jsona.whirlpools[j2].priceRange.day.max - jsona.whirlpools[j2].priceRange.day.min : 0,
              sparkline_in_7d: jsona.whirlpools[j2].priceRange ? { price: [
                jsona.whirlpools[j2].priceRange.day.min,
                jsona.whirlpools[j2].priceRange.week.min,
                jsona.whirlpools[j2].priceRange.month.min
              ] } : {
                price: []
              },
              id: jsona.whirlpools[j2].address.toString(),
              symbol: jsona.whirlpools[j2].tokenA.symbol + "-" + jsona.whirlpools[j2].tokenB.symbol,
              name: jsona.whirlpools[j2].tokenA.name + "-" + jsona.whirlpools[j2].tokenB.name,
              image: jsona.whirlpools[j2].tokenA.logoURI || goodLogo,
              image2: jsona.whirlpools[j2].tokenB.logoURI || goodLogo,
              current_price: jsona.whirlpools[j2].price
            });
          }
          if (TokenListType.is(json)) {
            dispatch(
              SET_TOKENLIST({
                tokenData: json
              })
            );
          } else {
            throw TokenListType.validate(json)[0];
          }
        }).catch((e) => {
          console.error(e, "refreshing in", refreshtime);
        });
      };
      fetchTokenList();
      const refresh = setInterval(fetchTokenList, refreshtime);
      return () => {
        clearInterval(refresh);
      };
    }, []);
  }
  var useRefreshTokenList_default = useRefreshTokenList;

  // src/App/CenteredLoader.tsx
  init_virtual_process_polyfill();
  init_buffer();
  var import_react9 = __toESM(require_react());
  function CenteredLoader() {
    return /* @__PURE__ */ import_react9.default.createElement(
      View,
      {
        style: {
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          height: "100%"
        }
      },
      /* @__PURE__ */ import_react9.default.createElement(Loading, null)
    );
  }
  var CenteredLoader_default = CenteredLoader;

  // src/App/Navigation.tsx
  init_virtual_process_polyfill();
  init_buffer();
  var import_react17 = __toESM(require_react());

  // src/App/TokenDetails.tsx
  init_virtual_process_polyfill();
  init_buffer();
  var import_react15 = __toESM(require_react());

  // src/App/_helpers/color.ts
  init_virtual_process_polyfill();
  init_buffer();
  var green = "#34D399";
  var red = "#EF4444";

  // node_modules/@coral-xyz/anchor/dist/browser/index.js
  init_virtual_process_polyfill();
  init_buffer();
  var import_buffer89 = __toESM(require_buffer());
  init_index_browser_esm();
  init_index_browser_esm();
  var import_bn2 = __toESM(require_bn());
  var import_bn3 = __toESM(require_bn());
  var import_bs582 = __toESM(require_bs58());
  var base64$1 = __toESM(require_base64_js());
  var import_camelcase = __toESM(require_camelcase());
  var import_js_sha256 = __toESM(require_sha256());
  var borsh = __toESM(require_dist());
  init_pako_esm();
  var import_eventemitter32 = __toESM(require_eventemitter3());
  function chunks(array6, size) {
    return Array.apply(0, new Array(Math.ceil(array6.length / size))).map((_2, index) => array6.slice(index * size, (index + 1) * size));
  }
  var isVersionedTransaction = (tx) => {
    return "version" in tx;
  };
  function decode$2(array6) {
    const decoder = new TextDecoder("utf-8");
    return decoder.decode(array6);
  }
  function encode$2(input) {
    const encoder = new TextEncoder();
    return encoder.encode(input);
  }
  function encode$1(data) {
    return import_bs582.default.encode(data);
  }
  function decode(data) {
    return import_buffer89.Buffer.from(base64$1.toByteArray(data));
  }
  function parseIdlErrors(idl) {
    const errors = /* @__PURE__ */ new Map();
    if (idl.errors) {
      idl.errors.forEach((e) => {
        var _a;
        let msg = (_a = e.msg) !== null && _a !== void 0 ? _a : e.name;
        errors.set(e.code, msg);
      });
    }
    return errors;
  }
  function toInstruction(idlIx, ...args) {
    if (idlIx.args.length != args.length) {
      throw new Error("Invalid argument length");
    }
    const ix = {};
    let idx = 0;
    idlIx.args.forEach((ixArg) => {
      ix[ixArg.name] = args[idx];
      idx += 1;
    });
    return ix;
  }
  function validateAccounts(ixAccounts, accounts = {}) {
    ixAccounts.forEach((acc) => {
      if ("accounts" in acc) {
        validateAccounts(acc.accounts, accounts[acc.name]);
      } else {
        if (accounts[acc.name] === void 0) {
          throw new Error(`Invalid arguments: ${acc.name} not provided.`);
        }
      }
    });
  }
  function translateAddress(address) {
    return address instanceof PublicKey ? address : new PublicKey(address);
  }
  var StructError3 = class extends TypeError {
    constructor(failure, failures) {
      let cached;
      const {
        message,
        ...rest
      } = failure;
      const {
        path
      } = failure;
      const msg = path.length === 0 ? message : "At path: " + path.join(".") + " -- " + message;
      super(msg);
      this.value = void 0;
      this.key = void 0;
      this.type = void 0;
      this.refinement = void 0;
      this.path = void 0;
      this.branch = void 0;
      this.failures = void 0;
      Object.assign(this, rest);
      this.name = this.constructor.name;
      this.failures = () => {
        var _cached;
        return (_cached = cached) != null ? _cached : cached = [failure, ...failures()];
      };
    }
  };
  function isIterable3(x2) {
    return isObject3(x2) && typeof x2[Symbol.iterator] === "function";
  }
  function isObject3(x2) {
    return typeof x2 === "object" && x2 != null;
  }
  function print3(value) {
    return typeof value === "string" ? JSON.stringify(value) : "" + value;
  }
  function shiftIterator3(input) {
    const {
      done,
      value
    } = input.next();
    return done ? void 0 : value;
  }
  function toFailure3(result, context, struct6, value) {
    if (result === true) {
      return;
    } else if (result === false) {
      result = {};
    } else if (typeof result === "string") {
      result = {
        message: result
      };
    }
    const {
      path,
      branch
    } = context;
    const {
      type: type5
    } = struct6;
    const {
      refinement,
      message = "Expected a value of type `" + type5 + "`" + (refinement ? " with refinement `" + refinement + "`" : "") + ", but received: `" + print3(value) + "`"
    } = result;
    return {
      value,
      type: type5,
      refinement,
      key: path[path.length - 1],
      path,
      branch,
      ...result,
      message
    };
  }
  function* toFailures3(result, context, struct6, value) {
    if (!isIterable3(result)) {
      result = [result];
    }
    for (const r of result) {
      const failure = toFailure3(r, context, struct6, value);
      if (failure) {
        yield failure;
      }
    }
  }
  function* run3(value, struct6, options) {
    if (options === void 0) {
      options = {};
    }
    const {
      path = [],
      branch = [value],
      coerce: coerce3 = false,
      mask: mask4 = false
    } = options;
    const ctx = {
      path,
      branch
    };
    if (coerce3) {
      value = struct6.coercer(value, ctx);
      if (mask4 && struct6.type !== "type" && isObject3(struct6.schema) && isObject3(value) && !Array.isArray(value)) {
        for (const key in value) {
          if (struct6.schema[key] === void 0) {
            delete value[key];
          }
        }
      }
    }
    let valid = true;
    for (const failure of struct6.validator(value, ctx)) {
      valid = false;
      yield [failure, void 0];
    }
    for (let [k2, v2, s] of struct6.entries(value, ctx)) {
      const ts = run3(v2, s, {
        path: k2 === void 0 ? path : [...path, k2],
        branch: k2 === void 0 ? branch : [...branch, v2],
        coerce: coerce3,
        mask: mask4
      });
      for (const t2 of ts) {
        if (t2[0]) {
          valid = false;
          yield [t2[0], void 0];
        } else if (coerce3) {
          v2 = t2[1];
          if (k2 === void 0) {
            value = v2;
          } else if (value instanceof Map) {
            value.set(k2, v2);
          } else if (value instanceof Set) {
            value.add(v2);
          } else if (isObject3(value)) {
            value[k2] = v2;
          }
        }
      }
    }
    if (valid) {
      for (const failure of struct6.refiner(value, ctx)) {
        valid = false;
        yield [failure, void 0];
      }
    }
    if (valid) {
      yield [void 0, value];
    }
  }
  var Struct4 = class {
    constructor(props) {
      this.TYPE = void 0;
      this.type = void 0;
      this.schema = void 0;
      this.coercer = void 0;
      this.validator = void 0;
      this.refiner = void 0;
      this.entries = void 0;
      const {
        type: type5,
        schema,
        validator,
        refiner,
        coercer = (value) => value,
        entries = function* () {
        }
      } = props;
      this.type = type5;
      this.schema = schema;
      this.entries = entries;
      this.coercer = coercer;
      if (validator) {
        this.validator = (value, context) => {
          const result = validator(value, context);
          return toFailures3(result, context, this, value);
        };
      } else {
        this.validator = () => [];
      }
      if (refiner) {
        this.refiner = (value, context) => {
          const result = refiner(value, context);
          return toFailures3(result, context, this, value);
        };
      } else {
        this.refiner = () => [];
      }
    }
    assert(value) {
      return assert5(value, this);
    }
    create(value) {
      return create4(value, this);
    }
    is(value) {
      return is3(value, this);
    }
    mask(value) {
      return mask3(value, this);
    }
    validate(value, options) {
      if (options === void 0) {
        options = {};
      }
      return validate4(value, this, options);
    }
  };
  function assert5(value, struct6) {
    const result = validate4(value, struct6);
    if (result[0]) {
      throw result[0];
    }
  }
  function create4(value, struct6) {
    const result = validate4(value, struct6, {
      coerce: true
    });
    if (result[0]) {
      throw result[0];
    } else {
      return result[1];
    }
  }
  function mask3(value, struct6) {
    const result = validate4(value, struct6, {
      coerce: true,
      mask: true
    });
    if (result[0]) {
      throw result[0];
    } else {
      return result[1];
    }
  }
  function is3(value, struct6) {
    const result = validate4(value, struct6);
    return !result[0];
  }
  function validate4(value, struct6, options) {
    if (options === void 0) {
      options = {};
    }
    const tuples = run3(value, struct6, options);
    const tuple4 = shiftIterator3(tuples);
    if (tuple4[0]) {
      const error2 = new StructError3(tuple4[0], function* () {
        for (const t2 of tuples) {
          if (t2[0]) {
            yield t2[0];
          }
        }
      });
      return [error2, void 0];
    } else {
      const v2 = tuple4[1];
      return [void 0, v2];
    }
  }
  function define4(name2, validator) {
    return new Struct4({
      type: name2,
      schema: null,
      validator
    });
  }
  function any2() {
    return define4("any", () => true);
  }
  function array4(Element) {
    return new Struct4({
      type: "array",
      schema: Element,
      *entries(value) {
        if (Element && Array.isArray(value)) {
          for (const [i, v2] of value.entries()) {
            yield [i, v2, Element];
          }
        }
      },
      coercer(value) {
        return Array.isArray(value) ? value.slice() : value;
      },
      validator(value) {
        return Array.isArray(value) || "Expected an array value, but received: " + print3(value);
      }
    });
  }
  function boolean3() {
    return define4("boolean", (value) => {
      return typeof value === "boolean";
    });
  }
  function literal3(constant) {
    const description = print3(constant);
    const t2 = typeof constant;
    return new Struct4({
      type: "literal",
      schema: t2 === "string" || t2 === "number" || t2 === "boolean" ? constant : null,
      validator(value) {
        return value === constant || "Expected the literal `" + description + "`, but received: " + print3(value);
      }
    });
  }
  function nullable5(struct6) {
    return new Struct4({
      ...struct6,
      validator: (value, ctx) => value === null || struct6.validator(value, ctx),
      refiner: (value, ctx) => value === null || struct6.refiner(value, ctx)
    });
  }
  function number4() {
    return define4("number", (value) => {
      return typeof value === "number" && !isNaN(value) || "Expected a number, but received: " + print3(value);
    });
  }
  function optional3(struct6) {
    return new Struct4({
      ...struct6,
      validator: (value, ctx) => value === void 0 || struct6.validator(value, ctx),
      refiner: (value, ctx) => value === void 0 || struct6.refiner(value, ctx)
    });
  }
  function string3() {
    return define4("string", (value) => {
      return typeof value === "string" || "Expected a string, but received: " + print3(value);
    });
  }
  function type4(schema) {
    const keys = Object.keys(schema);
    return new Struct4({
      type: "type",
      schema,
      *entries(value) {
        if (isObject3(value)) {
          for (const k2 of keys) {
            yield [k2, value[k2], schema[k2]];
          }
        }
      },
      validator(value) {
        return isObject3(value) || "Expected an object, but received: " + print3(value);
      }
    });
  }
  function union$1(Structs) {
    const description = Structs.map((s) => s.type).join(" | ");
    return new Struct4({
      type: "union",
      schema: null,
      coercer(value, ctx) {
        const firstMatch = Structs.find((s) => {
          const [e] = s.validate(value, {
            coerce: true
          });
          return !e;
        }) || unknown3();
        return firstMatch.coercer(value, ctx);
      },
      validator(value, ctx) {
        const failures = [];
        for (const S2 of Structs) {
          const [...tuples] = run3(value, S2, ctx);
          const [first] = tuples;
          if (!first[0]) {
            return [];
          } else {
            for (const [failure] of tuples) {
              if (failure) {
                failures.push(failure);
              }
            }
          }
        }
        return ["Expected the value to satisfy a union of `" + description + "`, but received: " + print3(value), ...failures];
      }
    });
  }
  function unknown3() {
    return define4("unknown", () => true);
  }
  function coerce2(struct6, condition, coercer) {
    return new Struct4({
      ...struct6,
      coercer: (value, ctx) => {
        return is3(value, condition) ? struct6.coercer(coercer(value, ctx), ctx) : struct6.coercer(value, ctx);
      }
    });
  }
  var GET_MULTIPLE_ACCOUNTS_LIMIT = 99;
  async function getMultipleAccountsAndContext(connection, publicKeys, commitment) {
    if (publicKeys.length <= GET_MULTIPLE_ACCOUNTS_LIMIT) {
      return await getMultipleAccountsAndContextCore(connection, publicKeys, commitment);
    } else {
      const batches = chunks(publicKeys, GET_MULTIPLE_ACCOUNTS_LIMIT);
      const results = await Promise.all(batches.map((batch) => getMultipleAccountsAndContextCore(connection, batch, commitment)));
      return results.flat();
    }
  }
  async function getMultipleAccountsAndContextCore(connection, publicKeys, commitmentOverride) {
    const commitment = commitmentOverride !== null && commitmentOverride !== void 0 ? commitmentOverride : connection.commitment;
    const { value: accountInfos, context } = await connection.getMultipleAccountsInfoAndContext(publicKeys, commitment);
    const accounts = accountInfos.map((account, idx) => {
      if (account === null) {
        return null;
      }
      return {
        publicKey: publicKeys[idx],
        account,
        context
      };
    });
    return accounts;
  }
  async function simulateTransaction(connection, transaction, signers, commitment, includeAccounts) {
    var _a;
    if (signers && signers.length > 0) {
      transaction.sign(...signers);
    }
    const message = transaction._compile();
    const signData = message.serialize();
    const wireTransaction = transaction._serialize(signData);
    const encodedTransaction = wireTransaction.toString("base64");
    const config2 = {
      encoding: "base64",
      commitment: commitment !== null && commitment !== void 0 ? commitment : connection.commitment
    };
    if (includeAccounts) {
      const addresses = (Array.isArray(includeAccounts) ? includeAccounts : message.nonProgramIds()).map((key) => key.toBase58());
      config2["accounts"] = {
        encoding: "base64",
        addresses
      };
    }
    if (signers) {
      config2.sigVerify = true;
    }
    const args = [encodedTransaction, config2];
    const unsafeRes = await connection._rpcRequest("simulateTransaction", args);
    const res = create4(unsafeRes, SimulatedTransactionResponseStruct2);
    if ("error" in res) {
      let logs;
      if ("data" in res.error) {
        logs = (_a = res.error.data) === null || _a === void 0 ? void 0 : _a.logs;
        if (logs && Array.isArray(logs)) {
          const traceIndent = "\n    ";
          const logTrace = traceIndent + logs.join(traceIndent);
          console.error(res.error.message, logTrace);
        }
      }
      throw new SendTransactionError("failed to simulate transaction: " + res.error.message, logs);
    }
    return res.result;
  }
  function jsonRpcResult2(schema) {
    return coerce2(createRpcResult2(schema), UnknownRpcResult2, (value) => {
      if ("error" in value) {
        return value;
      } else {
        return {
          ...value,
          result: create4(value.result, schema)
        };
      }
    });
  }
  var UnknownRpcResult2 = createRpcResult2(unknown3());
  function createRpcResult2(result) {
    return union$1([
      type4({
        jsonrpc: literal3("2.0"),
        id: string3(),
        result
      }),
      type4({
        jsonrpc: literal3("2.0"),
        id: string3(),
        error: type4({
          code: unknown3(),
          message: string3(),
          data: optional3(any2())
        })
      })
    ]);
  }
  function jsonRpcResultAndContext2(value) {
    return jsonRpcResult2(type4({
      context: type4({
        slot: number4()
      }),
      value
    }));
  }
  var SimulatedTransactionResponseStruct2 = jsonRpcResultAndContext2(type4({
    err: nullable5(union$1([type4({}), string3()])),
    logs: nullable5(array4(string3())),
    accounts: optional3(nullable5(array4(nullable5(type4({
      executable: boolean3(),
      owner: string3(),
      lamports: number4(),
      data: array4(string3()),
      rentEpoch: optional3(number4())
    }))))),
    unitsConsumed: optional3(number4())
  }));
  var AnchorProvider2 = class {
    constructor(connection, wallet, opts) {
      this.connection = connection;
      this.wallet = wallet;
      this.opts = opts;
      this.publicKey = wallet === null || wallet === void 0 ? void 0 : wallet.publicKey;
    }
    static defaultOptions() {
      return {
        preflightCommitment: "processed",
        commitment: "processed"
      };
    }
    static local(url2, opts) {
      {
        throw new Error(`Provider local is not available on browser.`);
      }
    }
    static env() {
      {
        throw new Error(`Provider env is not available on browser.`);
      }
    }
    async sendAndConfirm(tx, signers, opts) {
      var _a, _b, _c, _d;
      if (opts === void 0) {
        opts = this.opts;
      }
      if (isVersionedTransaction(tx)) {
        if (signers) {
          tx.sign(signers);
        }
      } else {
        tx.feePayer = (_a = tx.feePayer) !== null && _a !== void 0 ? _a : this.wallet.publicKey;
        tx.recentBlockhash = (await this.connection.getLatestBlockhash(opts.preflightCommitment)).blockhash;
        if (signers) {
          for (const signer of signers) {
            tx.partialSign(signer);
          }
        }
      }
      tx = await this.wallet.signTransaction(tx);
      const rawTx = tx.serialize();
      try {
        return await sendAndConfirmRawTransaction2(this.connection, rawTx, opts);
      } catch (err2) {
        if (err2 instanceof ConfirmError) {
          const txSig = encode$1(isVersionedTransaction(tx) ? ((_b = tx.signatures) === null || _b === void 0 ? void 0 : _b[0]) || new Uint8Array() : (_c = tx.signature) !== null && _c !== void 0 ? _c : new Uint8Array());
          const failedTx = await this.connection.getTransaction(txSig, {
            commitment: "confirmed"
          });
          if (!failedTx) {
            throw err2;
          } else {
            const logs = (_d = failedTx.meta) === null || _d === void 0 ? void 0 : _d.logMessages;
            throw !logs ? err2 : new SendTransactionError(err2.message, logs);
          }
        } else {
          throw err2;
        }
      }
    }
    async sendAll(txWithSigners, opts) {
      var _a, _b, _c;
      if (opts === void 0) {
        opts = this.opts;
      }
      const recentBlockhash = (await this.connection.getLatestBlockhash(opts.preflightCommitment)).blockhash;
      let txs = txWithSigners.map((r) => {
        var _a2, _b2;
        if (isVersionedTransaction(r.tx)) {
          let tx = r.tx;
          if (r.signers) {
            tx.sign(r.signers);
          }
          return tx;
        } else {
          let tx = r.tx;
          let signers = (_a2 = r.signers) !== null && _a2 !== void 0 ? _a2 : [];
          tx.feePayer = (_b2 = tx.feePayer) !== null && _b2 !== void 0 ? _b2 : this.wallet.publicKey;
          tx.recentBlockhash = recentBlockhash;
          signers.forEach((kp) => {
            tx.partialSign(kp);
          });
          return tx;
        }
      });
      const signedTxs = await this.wallet.signAllTransactions(txs);
      const sigs = [];
      for (let k2 = 0; k2 < txs.length; k2 += 1) {
        const tx = signedTxs[k2];
        const rawTx = tx.serialize();
        try {
          sigs.push(await sendAndConfirmRawTransaction2(this.connection, rawTx, opts));
        } catch (err2) {
          if (err2 instanceof ConfirmError) {
            const txSig = encode$1(isVersionedTransaction(tx) ? ((_a = tx.signatures) === null || _a === void 0 ? void 0 : _a[0]) || new Uint8Array() : (_b = tx.signature) !== null && _b !== void 0 ? _b : new Uint8Array());
            const failedTx = await this.connection.getTransaction(txSig, {
              commitment: "confirmed"
            });
            if (!failedTx) {
              throw err2;
            } else {
              const logs = (_c = failedTx.meta) === null || _c === void 0 ? void 0 : _c.logMessages;
              throw !logs ? err2 : new SendTransactionError(err2.message, logs);
            }
          } else {
            throw err2;
          }
        }
      }
      return sigs;
    }
    async simulate(tx, signers, commitment, includeAccounts) {
      let recentBlockhash = (await this.connection.getLatestBlockhash(commitment !== null && commitment !== void 0 ? commitment : this.connection.commitment)).blockhash;
      let result;
      if (isVersionedTransaction(tx)) {
        if (signers) {
          tx.sign(signers);
          tx = await this.wallet.signTransaction(tx);
        }
        result = await this.connection.simulateTransaction(tx, { commitment });
      } else {
        tx.feePayer = tx.feePayer || this.wallet.publicKey;
        tx.recentBlockhash = recentBlockhash;
        if (signers) {
          tx = await this.wallet.signTransaction(tx);
        }
        result = await simulateTransaction(this.connection, tx, signers, commitment, includeAccounts);
      }
      if (result.value.err) {
        throw new SimulateError(result.value);
      }
      return result.value;
    }
  };
  var SimulateError = class extends Error {
    constructor(simulationResponse, message) {
      super(message);
      this.simulationResponse = simulationResponse;
    }
  };
  async function sendAndConfirmRawTransaction2(connection, rawTransaction, options) {
    const sendOptions = options && {
      skipPreflight: options.skipPreflight,
      preflightCommitment: options.preflightCommitment || options.commitment
    };
    const signature2 = await connection.sendRawTransaction(rawTransaction, sendOptions);
    const status = (await connection.confirmTransaction(signature2, options && options.commitment)).value;
    if (status.err) {
      throw new ConfirmError(`Raw transaction ${signature2} failed (${JSON.stringify(status)})`);
    }
    return signature2;
  }
  var ConfirmError = class extends Error {
    constructor(message) {
      super(message);
    }
  };
  function getProvider() {
    if (_provider === null) {
      return AnchorProvider2.local();
    }
    return _provider;
  }
  var _provider = null;
  var _FEATURES = /* @__PURE__ */ new Map();
  function isSet(key) {
    return _FEATURES.get(key) !== void 0;
  }
  var IdlError = class extends Error {
    constructor(message) {
      super(message);
      this.name = "IdlError";
    }
  };
  var ProgramErrorStack = class {
    constructor(stack) {
      this.stack = stack;
    }
    static parse(logs) {
      var _a;
      const programKeyRegex = /^Program (\w*) invoke/;
      const successRegex = /^Program \w* success/;
      const programStack = [];
      for (let i = 0; i < logs.length; i++) {
        if (successRegex.exec(logs[i])) {
          programStack.pop();
          continue;
        }
        const programKey = (_a = programKeyRegex.exec(logs[i])) === null || _a === void 0 ? void 0 : _a[1];
        if (!programKey) {
          continue;
        }
        programStack.push(new PublicKey(programKey));
      }
      return new ProgramErrorStack(programStack);
    }
  };
  var AnchorError = class extends Error {
    constructor(errorCode, errorMessage, errorLogs, logs, origin, comparedValues) {
      super(errorLogs.join("\n").replace("Program log: ", ""));
      this.errorLogs = errorLogs;
      this.logs = logs;
      this.error = { errorCode, errorMessage, comparedValues, origin };
      this._programErrorStack = ProgramErrorStack.parse(logs);
    }
    static parse(logs) {
      if (!logs) {
        return null;
      }
      const anchorErrorLogIndex = logs.findIndex((log2) => log2.startsWith("Program log: AnchorError"));
      if (anchorErrorLogIndex === -1) {
        return null;
      }
      const anchorErrorLog = logs[anchorErrorLogIndex];
      const errorLogs = [anchorErrorLog];
      let comparedValues;
      if (anchorErrorLogIndex + 1 < logs.length) {
        if (logs[anchorErrorLogIndex + 1] === "Program log: Left:") {
          const pubkeyRegex = /^Program log: (.*)$/;
          const leftPubkey = pubkeyRegex.exec(logs[anchorErrorLogIndex + 2])[1];
          const rightPubkey = pubkeyRegex.exec(logs[anchorErrorLogIndex + 4])[1];
          comparedValues = [
            new PublicKey(leftPubkey),
            new PublicKey(rightPubkey)
          ];
          errorLogs.push(...logs.slice(anchorErrorLogIndex + 1, anchorErrorLogIndex + 5));
        } else if (logs[anchorErrorLogIndex + 1].startsWith("Program log: Left:")) {
          const valueRegex = /^Program log: (Left|Right): (.*)$/;
          const leftValue = valueRegex.exec(logs[anchorErrorLogIndex + 1])[2];
          const rightValue = valueRegex.exec(logs[anchorErrorLogIndex + 2])[2];
          errorLogs.push(...logs.slice(anchorErrorLogIndex + 1, anchorErrorLogIndex + 3));
          comparedValues = [leftValue, rightValue];
        }
      }
      const regexNoInfo = /^Program log: AnchorError occurred\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./;
      const noInfoAnchorErrorLog = regexNoInfo.exec(anchorErrorLog);
      const regexFileLine = /^Program log: AnchorError thrown in (.*):(\d*)\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./;
      const fileLineAnchorErrorLog = regexFileLine.exec(anchorErrorLog);
      const regexAccountName = /^Program log: AnchorError caused by account: (.*)\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./;
      const accountNameAnchorErrorLog = regexAccountName.exec(anchorErrorLog);
      if (noInfoAnchorErrorLog) {
        const [errorCodeString, errorNumber, errorMessage] = noInfoAnchorErrorLog.slice(1, 4);
        const errorCode = {
          code: errorCodeString,
          number: parseInt(errorNumber)
        };
        return new AnchorError(errorCode, errorMessage, errorLogs, logs, void 0, comparedValues);
      } else if (fileLineAnchorErrorLog) {
        const [file, line, errorCodeString, errorNumber, errorMessage] = fileLineAnchorErrorLog.slice(1, 6);
        const errorCode = {
          code: errorCodeString,
          number: parseInt(errorNumber)
        };
        const fileLine = { file, line: parseInt(line) };
        return new AnchorError(errorCode, errorMessage, errorLogs, logs, fileLine, comparedValues);
      } else if (accountNameAnchorErrorLog) {
        const [accountName, errorCodeString, errorNumber, errorMessage] = accountNameAnchorErrorLog.slice(1, 5);
        const origin = accountName;
        const errorCode = {
          code: errorCodeString,
          number: parseInt(errorNumber)
        };
        return new AnchorError(errorCode, errorMessage, errorLogs, logs, origin, comparedValues);
      } else {
        return null;
      }
    }
    get program() {
      return this._programErrorStack.stack[this._programErrorStack.stack.length - 1];
    }
    get programErrorStack() {
      return this._programErrorStack.stack;
    }
    toString() {
      return this.message;
    }
  };
  var ProgramError = class extends Error {
    constructor(code2, msg, logs) {
      super();
      this.code = code2;
      this.msg = msg;
      this.logs = logs;
      if (logs) {
        this._programErrorStack = ProgramErrorStack.parse(logs);
      }
    }
    static parse(err2, idlErrors) {
      const errString = err2.toString();
      let unparsedErrorCode;
      if (errString.includes("custom program error:")) {
        let components = errString.split("custom program error: ");
        if (components.length !== 2) {
          return null;
        } else {
          unparsedErrorCode = components[1];
        }
      } else {
        const matches = errString.match(/"Custom":([0-9]+)}/g);
        if (!matches || matches.length > 1) {
          return null;
        }
        unparsedErrorCode = matches[0].match(/([0-9]+)/g)[0];
      }
      let errorCode;
      try {
        errorCode = parseInt(unparsedErrorCode);
      } catch (parseErr) {
        return null;
      }
      let errorMsg = idlErrors.get(errorCode);
      if (errorMsg !== void 0) {
        return new ProgramError(errorCode, errorMsg, err2.logs);
      }
      errorMsg = LangErrorMessage.get(errorCode);
      if (errorMsg !== void 0) {
        return new ProgramError(errorCode, errorMsg, err2.logs);
      }
      return null;
    }
    get program() {
      var _a;
      return (_a = this._programErrorStack) === null || _a === void 0 ? void 0 : _a.stack[this._programErrorStack.stack.length - 1];
    }
    get programErrorStack() {
      var _a;
      return (_a = this._programErrorStack) === null || _a === void 0 ? void 0 : _a.stack;
    }
    toString() {
      return this.msg;
    }
  };
  function translateError(err2, idlErrors) {
    if (isSet("debug-logs")) {
      console.log("Translating error:", err2);
    }
    const anchorError = AnchorError.parse(err2.logs);
    if (anchorError) {
      return anchorError;
    }
    const programError = ProgramError.parse(err2, idlErrors);
    if (programError) {
      return programError;
    }
    if (err2.logs) {
      const handler = {
        get: function(target, prop) {
          if (prop === "programErrorStack") {
            return target.programErrorStack.stack;
          } else if (prop === "program") {
            return target.programErrorStack.stack[err2.programErrorStack.stack.length - 1];
          } else {
            return Reflect.get(...arguments);
          }
        }
      };
      err2.programErrorStack = ProgramErrorStack.parse(err2.logs);
      return new Proxy(err2, handler);
    }
    return err2;
  }
  var LangErrorCode = {
    InstructionMissing: 100,
    InstructionFallbackNotFound: 101,
    InstructionDidNotDeserialize: 102,
    InstructionDidNotSerialize: 103,
    IdlInstructionStub: 1e3,
    IdlInstructionInvalidProgram: 1001,
    ConstraintMut: 2e3,
    ConstraintHasOne: 2001,
    ConstraintSigner: 2002,
    ConstraintRaw: 2003,
    ConstraintOwner: 2004,
    ConstraintRentExempt: 2005,
    ConstraintSeeds: 2006,
    ConstraintExecutable: 2007,
    ConstraintState: 2008,
    ConstraintAssociated: 2009,
    ConstraintAssociatedInit: 2010,
    ConstraintClose: 2011,
    ConstraintAddress: 2012,
    ConstraintZero: 2013,
    ConstraintTokenMint: 2014,
    ConstraintTokenOwner: 2015,
    ConstraintMintMintAuthority: 2016,
    ConstraintMintFreezeAuthority: 2017,
    ConstraintMintDecimals: 2018,
    ConstraintSpace: 2019,
    ConstraintAccountIsNone: 2020,
    RequireViolated: 2500,
    RequireEqViolated: 2501,
    RequireKeysEqViolated: 2502,
    RequireNeqViolated: 2503,
    RequireKeysNeqViolated: 2504,
    RequireGtViolated: 2505,
    RequireGteViolated: 2506,
    AccountDiscriminatorAlreadySet: 3e3,
    AccountDiscriminatorNotFound: 3001,
    AccountDiscriminatorMismatch: 3002,
    AccountDidNotDeserialize: 3003,
    AccountDidNotSerialize: 3004,
    AccountNotEnoughKeys: 3005,
    AccountNotMutable: 3006,
    AccountOwnedByWrongProgram: 3007,
    InvalidProgramId: 3008,
    InvalidProgramExecutable: 3009,
    AccountNotSigner: 3010,
    AccountNotSystemOwned: 3011,
    AccountNotInitialized: 3012,
    AccountNotProgramData: 3013,
    AccountNotAssociatedTokenAccount: 3014,
    AccountSysvarMismatch: 3015,
    AccountReallocExceedsLimit: 3016,
    AccountDuplicateReallocs: 3017,
    DeclaredProgramIdMismatch: 4100,
    Deprecated: 5e3
  };
  var LangErrorMessage = /* @__PURE__ */ new Map([
    [
      LangErrorCode.InstructionMissing,
      "8 byte instruction identifier not provided"
    ],
    [
      LangErrorCode.InstructionFallbackNotFound,
      "Fallback functions are not supported"
    ],
    [
      LangErrorCode.InstructionDidNotDeserialize,
      "The program could not deserialize the given instruction"
    ],
    [
      LangErrorCode.InstructionDidNotSerialize,
      "The program could not serialize the given instruction"
    ],
    [
      LangErrorCode.IdlInstructionStub,
      "The program was compiled without idl instructions"
    ],
    [
      LangErrorCode.IdlInstructionInvalidProgram,
      "The transaction was given an invalid program for the IDL instruction"
    ],
    [LangErrorCode.ConstraintMut, "A mut constraint was violated"],
    [LangErrorCode.ConstraintHasOne, "A has one constraint was violated"],
    [LangErrorCode.ConstraintSigner, "A signer constraint was violated"],
    [LangErrorCode.ConstraintRaw, "A raw constraint was violated"],
    [LangErrorCode.ConstraintOwner, "An owner constraint was violated"],
    [
      LangErrorCode.ConstraintRentExempt,
      "A rent exemption constraint was violated"
    ],
    [LangErrorCode.ConstraintSeeds, "A seeds constraint was violated"],
    [LangErrorCode.ConstraintExecutable, "An executable constraint was violated"],
    [
      LangErrorCode.ConstraintState,
      "Deprecated Error, feel free to replace with something else"
    ],
    [LangErrorCode.ConstraintAssociated, "An associated constraint was violated"],
    [
      LangErrorCode.ConstraintAssociatedInit,
      "An associated init constraint was violated"
    ],
    [LangErrorCode.ConstraintClose, "A close constraint was violated"],
    [LangErrorCode.ConstraintAddress, "An address constraint was violated"],
    [LangErrorCode.ConstraintZero, "Expected zero account discriminant"],
    [LangErrorCode.ConstraintTokenMint, "A token mint constraint was violated"],
    [LangErrorCode.ConstraintTokenOwner, "A token owner constraint was violated"],
    [
      LangErrorCode.ConstraintMintMintAuthority,
      "A mint mint authority constraint was violated"
    ],
    [
      LangErrorCode.ConstraintMintFreezeAuthority,
      "A mint freeze authority constraint was violated"
    ],
    [
      LangErrorCode.ConstraintMintDecimals,
      "A mint decimals constraint was violated"
    ],
    [LangErrorCode.ConstraintSpace, "A space constraint was violated"],
    [
      LangErrorCode.ConstraintAccountIsNone,
      "A required account for the constraint is None"
    ],
    [LangErrorCode.RequireViolated, "A require expression was violated"],
    [LangErrorCode.RequireEqViolated, "A require_eq expression was violated"],
    [
      LangErrorCode.RequireKeysEqViolated,
      "A require_keys_eq expression was violated"
    ],
    [LangErrorCode.RequireNeqViolated, "A require_neq expression was violated"],
    [
      LangErrorCode.RequireKeysNeqViolated,
      "A require_keys_neq expression was violated"
    ],
    [LangErrorCode.RequireGtViolated, "A require_gt expression was violated"],
    [LangErrorCode.RequireGteViolated, "A require_gte expression was violated"],
    [
      LangErrorCode.AccountDiscriminatorAlreadySet,
      "The account discriminator was already set on this account"
    ],
    [
      LangErrorCode.AccountDiscriminatorNotFound,
      "No 8 byte discriminator was found on the account"
    ],
    [
      LangErrorCode.AccountDiscriminatorMismatch,
      "8 byte discriminator did not match what was expected"
    ],
    [LangErrorCode.AccountDidNotDeserialize, "Failed to deserialize the account"],
    [LangErrorCode.AccountDidNotSerialize, "Failed to serialize the account"],
    [
      LangErrorCode.AccountNotEnoughKeys,
      "Not enough account keys given to the instruction"
    ],
    [LangErrorCode.AccountNotMutable, "The given account is not mutable"],
    [
      LangErrorCode.AccountOwnedByWrongProgram,
      "The given account is owned by a different program than expected"
    ],
    [LangErrorCode.InvalidProgramId, "Program ID was not as expected"],
    [LangErrorCode.InvalidProgramExecutable, "Program account is not executable"],
    [LangErrorCode.AccountNotSigner, "The given account did not sign"],
    [
      LangErrorCode.AccountNotSystemOwned,
      "The given account is not owned by the system program"
    ],
    [
      LangErrorCode.AccountNotInitialized,
      "The program expected this account to be already initialized"
    ],
    [
      LangErrorCode.AccountNotProgramData,
      "The given account is not a program data account"
    ],
    [
      LangErrorCode.AccountNotAssociatedTokenAccount,
      "The given account is not the associated token account"
    ],
    [
      LangErrorCode.AccountSysvarMismatch,
      "The given public key does not match the required sysvar"
    ],
    [
      LangErrorCode.AccountReallocExceedsLimit,
      "The account reallocation exceeds the MAX_PERMITTED_DATA_INCREASE limit"
    ],
    [
      LangErrorCode.AccountDuplicateReallocs,
      "The account was duplicated for more than one reallocation"
    ],
    [
      LangErrorCode.DeclaredProgramIdMismatch,
      "The declared program id does not match the actual program id"
    ],
    [
      LangErrorCode.Deprecated,
      "The API being used is deprecated and should no longer be used"
    ]
  ]);
  var __assign$1 = function() {
    __assign$1 = Object.assign || function __assign2(t2) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p2 in s)
          if (Object.prototype.hasOwnProperty.call(s, p2))
            t2[p2] = s[p2];
      }
      return t2;
    };
    return __assign$1.apply(this, arguments);
  };
  var __assign = function() {
    __assign = Object.assign || function __assign2(t2) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p2 in s)
          if (Object.prototype.hasOwnProperty.call(s, p2))
            t2[p2] = s[p2];
      }
      return t2;
    };
    return __assign.apply(this, arguments);
  };
  function lowerCase(str3) {
    return str3.toLowerCase();
  }
  var DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g];
  var DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi;
  function noCase(input, options) {
    if (options === void 0) {
      options = {};
    }
    var _a = options.splitRegexp, splitRegexp = _a === void 0 ? DEFAULT_SPLIT_REGEXP : _a, _b = options.stripRegexp, stripRegexp = _b === void 0 ? DEFAULT_STRIP_REGEXP : _b, _c = options.transform, transform = _c === void 0 ? lowerCase : _c, _d = options.delimiter, delimiter = _d === void 0 ? " " : _d;
    var result = replace(replace(input, splitRegexp, "$1\0$2"), stripRegexp, "\0");
    var start = 0;
    var end = result.length;
    while (result.charAt(start) === "\0")
      start++;
    while (result.charAt(end - 1) === "\0")
      end--;
    return result.slice(start, end).split("\0").map(transform).join(delimiter);
  }
  function replace(input, re2, value) {
    if (re2 instanceof RegExp)
      return input.replace(re2, value);
    return re2.reduce(function(input2, re3) {
      return input2.replace(re3, value);
    }, input);
  }
  function dotCase(input, options) {
    if (options === void 0) {
      options = {};
    }
    return noCase(input, __assign({ delimiter: "." }, options));
  }
  function snakeCase(input, options) {
    if (options === void 0) {
      options = {};
    }
    return dotCase(input, __assign$1({ delimiter: "_" }, options));
  }
  var IdlCoder = class {
    static fieldLayout(field, types2) {
      const fieldName = field.name !== void 0 ? (0, import_camelcase.default)(field.name) : void 0;
      switch (field.type) {
        case "bool": {
          return borsh.bool(fieldName);
        }
        case "u8": {
          return borsh.u8(fieldName);
        }
        case "i8": {
          return borsh.i8(fieldName);
        }
        case "u16": {
          return borsh.u16(fieldName);
        }
        case "i16": {
          return borsh.i16(fieldName);
        }
        case "u32": {
          return borsh.u32(fieldName);
        }
        case "i32": {
          return borsh.i32(fieldName);
        }
        case "f32": {
          return borsh.f32(fieldName);
        }
        case "u64": {
          return borsh.u64(fieldName);
        }
        case "i64": {
          return borsh.i64(fieldName);
        }
        case "f64": {
          return borsh.f64(fieldName);
        }
        case "u128": {
          return borsh.u128(fieldName);
        }
        case "i128": {
          return borsh.i128(fieldName);
        }
        case "u256": {
          return borsh.u256(fieldName);
        }
        case "i256": {
          return borsh.i256(fieldName);
        }
        case "bytes": {
          return borsh.vecU8(fieldName);
        }
        case "string": {
          return borsh.str(fieldName);
        }
        case "publicKey": {
          return borsh.publicKey(fieldName);
        }
        default: {
          if ("vec" in field.type) {
            return borsh.vec(IdlCoder.fieldLayout({
              name: void 0,
              type: field.type.vec
            }, types2), fieldName);
          } else if ("option" in field.type) {
            return borsh.option(IdlCoder.fieldLayout({
              name: void 0,
              type: field.type.option
            }, types2), fieldName);
          } else if ("defined" in field.type) {
            const defined = field.type.defined;
            if (types2 === void 0) {
              throw new IdlError("User defined types not provided");
            }
            const filtered = types2.filter((t2) => t2.name === defined);
            if (filtered.length !== 1) {
              throw new IdlError(`Type not found: ${JSON.stringify(field)}`);
            }
            return IdlCoder.typeDefLayout(filtered[0], types2, fieldName);
          } else if ("array" in field.type) {
            let arrayTy = field.type.array[0];
            let arrayLen = field.type.array[1];
            let innerLayout = IdlCoder.fieldLayout({
              name: void 0,
              type: arrayTy
            }, types2);
            return borsh.array(innerLayout, arrayLen, fieldName);
          } else {
            throw new Error(`Not yet implemented: ${field}`);
          }
        }
      }
    }
    static typeDefLayout(typeDef, types2 = [], name2) {
      if (typeDef.type.kind === "struct") {
        const fieldLayouts = typeDef.type.fields.map((field) => {
          const x2 = IdlCoder.fieldLayout(field, types2);
          return x2;
        });
        return borsh.struct(fieldLayouts, name2);
      } else if (typeDef.type.kind === "enum") {
        let variants = typeDef.type.variants.map((variant) => {
          const name3 = (0, import_camelcase.default)(variant.name);
          if (variant.fields === void 0) {
            return borsh.struct([], name3);
          }
          const fieldLayouts = variant.fields.map((f3, i) => {
            if (!f3.hasOwnProperty("name")) {
              return IdlCoder.fieldLayout({ type: f3, name: i.toString() }, types2);
            }
            return IdlCoder.fieldLayout(f3, types2);
          });
          return borsh.struct(fieldLayouts, name3);
        });
        if (name2 !== void 0) {
          return borsh.rustEnum(variants).replicate(name2);
        }
        return borsh.rustEnum(variants, name2);
      } else {
        throw new Error(`Unknown type kint: ${typeDef}`);
      }
    }
  };
  var SIGHASH_GLOBAL_NAMESPACE = "global";
  var BorshInstructionCoder = class {
    constructor(idl) {
      this.idl = idl;
      this.ixLayout = BorshInstructionCoder.parseIxLayout(idl);
      const sighashLayouts = /* @__PURE__ */ new Map();
      idl.instructions.forEach((ix) => {
        const sh = sighash(SIGHASH_GLOBAL_NAMESPACE, ix.name);
        sighashLayouts.set(import_bs582.default.encode(sh), {
          layout: this.ixLayout.get(ix.name),
          name: ix.name
        });
      });
      this.sighashLayouts = sighashLayouts;
    }
    encode(ixName, ix) {
      return this._encode(SIGHASH_GLOBAL_NAMESPACE, ixName, ix);
    }
    _encode(nameSpace, ixName, ix) {
      const buffer2 = import_buffer89.Buffer.alloc(1e3);
      const methodName = (0, import_camelcase.default)(ixName);
      const layout = this.ixLayout.get(methodName);
      if (!layout) {
        throw new Error(`Unknown method: ${methodName}`);
      }
      const len = layout.encode(ix, buffer2);
      const data = buffer2.slice(0, len);
      return import_buffer89.Buffer.concat([sighash(nameSpace, ixName), data]);
    }
    static parseIxLayout(idl) {
      const ixLayouts = idl.instructions.map((ix) => {
        let fieldLayouts = ix.args.map((arg) => {
          var _a, _b;
          return IdlCoder.fieldLayout(arg, Array.from([...(_a = idl.accounts) !== null && _a !== void 0 ? _a : [], ...(_b = idl.types) !== null && _b !== void 0 ? _b : []]));
        });
        const name2 = (0, import_camelcase.default)(ix.name);
        return [name2, borsh.struct(fieldLayouts, name2)];
      });
      return new Map(ixLayouts);
    }
    decode(ix, encoding = "hex") {
      if (typeof ix === "string") {
        ix = encoding === "hex" ? import_buffer89.Buffer.from(ix, "hex") : import_bs582.default.decode(ix);
      }
      let sighash2 = import_bs582.default.encode(ix.slice(0, 8));
      let data = ix.slice(8);
      const decoder = this.sighashLayouts.get(sighash2);
      if (!decoder) {
        return null;
      }
      return {
        data: decoder.layout.decode(data),
        name: decoder.name
      };
    }
    format(ix, accountMetas) {
      return InstructionFormatter.format(ix, accountMetas, this.idl);
    }
  };
  var InstructionFormatter = class {
    static format(ix, accountMetas, idl) {
      const idlIx = idl.instructions.filter((i) => ix.name === i.name)[0];
      if (idlIx === void 0) {
        console.error("Invalid instruction given");
        return null;
      }
      const args = idlIx.args.map((idlField) => {
        return {
          name: idlField.name,
          type: InstructionFormatter.formatIdlType(idlField.type),
          data: InstructionFormatter.formatIdlData(idlField, ix.data[idlField.name], idl.types)
        };
      });
      const flatIdlAccounts = InstructionFormatter.flattenIdlAccounts(idlIx.accounts);
      const accounts = accountMetas.map((meta, idx) => {
        if (idx < flatIdlAccounts.length) {
          return {
            name: flatIdlAccounts[idx].name,
            ...meta
          };
        } else {
          return {
            name: void 0,
            ...meta
          };
        }
      });
      return {
        args,
        accounts
      };
    }
    static formatIdlType(idlType) {
      if (typeof idlType === "string") {
        return idlType;
      }
      if ("vec" in idlType) {
        return `Vec<${this.formatIdlType(idlType.vec)}>`;
      }
      if ("option" in idlType) {
        return `Option<${this.formatIdlType(idlType.option)}>`;
      }
      if ("defined" in idlType) {
        return idlType.defined;
      }
      if ("array" in idlType) {
        return `Array<${idlType.array[0]}; ${idlType.array[1]}>`;
      }
      throw new Error(`Unknown IDL type: ${idlType}`);
    }
    static formatIdlData(idlField, data, types2) {
      if (typeof idlField.type === "string") {
        return data.toString();
      }
      if (idlField.type.hasOwnProperty("vec")) {
        return "[" + data.map((d2) => this.formatIdlData({ name: "", type: idlField.type.vec }, d2)).join(", ") + "]";
      }
      if (idlField.type.hasOwnProperty("option")) {
        return data === null ? "null" : this.formatIdlData({ name: "", type: idlField.type.option }, data, types2);
      }
      if (idlField.type.hasOwnProperty("defined")) {
        if (types2 === void 0) {
          throw new Error("User defined types not provided");
        }
        const filtered = types2.filter((t2) => t2.name === idlField.type.defined);
        if (filtered.length !== 1) {
          throw new Error(`Type not found: ${idlField.type.defined}`);
        }
        return InstructionFormatter.formatIdlDataDefined(filtered[0], data, types2);
      }
      return "unknown";
    }
    static formatIdlDataDefined(typeDef, data, types2) {
      if (typeDef.type.kind === "struct") {
        const struct6 = typeDef.type;
        const fields = Object.keys(data).map((k2) => {
          const f3 = struct6.fields.filter((f4) => f4.name === k2)[0];
          if (f3 === void 0) {
            throw new Error("Unable to find type");
          }
          return k2 + ": " + InstructionFormatter.formatIdlData(f3, data[k2], types2);
        }).join(", ");
        return "{ " + fields + " }";
      } else {
        if (typeDef.type.variants.length === 0) {
          return "{}";
        }
        if (typeDef.type.variants[0].name) {
          const variants = typeDef.type.variants;
          const variant = Object.keys(data)[0];
          const enumType = data[variant];
          const namedFields = Object.keys(enumType).map((f3) => {
            var _a;
            const fieldData = enumType[f3];
            const idlField = (_a = variants[variant]) === null || _a === void 0 ? void 0 : _a.filter((v2) => v2.name === f3)[0];
            if (idlField === void 0) {
              throw new Error("Unable to find variant");
            }
            return f3 + ": " + InstructionFormatter.formatIdlData(idlField, fieldData, types2);
          }).join(", ");
          const variantName = (0, import_camelcase.default)(variant, { pascalCase: true });
          if (namedFields.length === 0) {
            return variantName;
          }
          return `${variantName} { ${namedFields} }`;
        } else {
          return "Tuple formatting not yet implemented";
        }
      }
    }
    static flattenIdlAccounts(accounts, prefix) {
      return accounts.map((account) => {
        const accName = sentenceCase(account.name);
        if (account.hasOwnProperty("accounts")) {
          const newPrefix = prefix ? `${prefix} > ${accName}` : accName;
          return InstructionFormatter.flattenIdlAccounts(account.accounts, newPrefix);
        } else {
          return {
            ...account,
            name: prefix ? `${prefix} > ${accName}` : accName
          };
        }
      }).flat();
    }
  };
  function sentenceCase(field) {
    const result = field.replace(/([A-Z])/g, " $1");
    return result.charAt(0).toUpperCase() + result.slice(1);
  }
  function sighash(nameSpace, ixName) {
    let name2 = snakeCase(ixName);
    let preimage = `${nameSpace}:${name2}`;
    return import_buffer89.Buffer.from(import_js_sha256.sha256.digest(preimage)).slice(0, 8);
  }
  function accountSize(idl, idlAccount) {
    if (idlAccount.type.kind === "enum") {
      let variantSizes = idlAccount.type.variants.map((variant) => {
        if (variant.fields === void 0) {
          return 0;
        }
        return variant.fields.map((f3) => {
          if (!(typeof f3 === "object" && "name" in f3)) {
            throw new Error("Tuple enum variants not yet implemented.");
          }
          return typeSize(idl, f3.type);
        }).reduce((a, b2) => a + b2);
      });
      return Math.max(...variantSizes) + 1;
    }
    if (idlAccount.type.fields === void 0) {
      return 0;
    }
    return idlAccount.type.fields.map((f3) => typeSize(idl, f3.type)).reduce((a, b2) => a + b2, 0);
  }
  function typeSize(idl, ty) {
    var _a, _b;
    switch (ty) {
      case "bool":
        return 1;
      case "u8":
        return 1;
      case "i8":
        return 1;
      case "i16":
        return 2;
      case "u16":
        return 2;
      case "u32":
        return 4;
      case "i32":
        return 4;
      case "f32":
        return 4;
      case "u64":
        return 8;
      case "i64":
        return 8;
      case "f64":
        return 8;
      case "u128":
        return 16;
      case "i128":
        return 16;
      case "u256":
        return 32;
      case "i256":
        return 32;
      case "bytes":
        return 1;
      case "string":
        return 1;
      case "publicKey":
        return 32;
      default:
        if ("vec" in ty) {
          return 1;
        }
        if ("option" in ty) {
          return 1 + typeSize(idl, ty.option);
        }
        if ("coption" in ty) {
          return 4 + typeSize(idl, ty.coption);
        }
        if ("defined" in ty) {
          const filtered = (_b = (_a = idl.types) === null || _a === void 0 ? void 0 : _a.filter((t2) => t2.name === ty.defined)) !== null && _b !== void 0 ? _b : [];
          if (filtered.length !== 1) {
            throw new IdlError(`Type not found: ${JSON.stringify(ty)}`);
          }
          let typeDef = filtered[0];
          return accountSize(idl, typeDef);
        }
        if ("array" in ty) {
          let arrayTy = ty.array[0];
          let arraySize = ty.array[1];
          return typeSize(idl, arrayTy) * arraySize;
        }
        throw new Error(`Invalid type ${JSON.stringify(ty)}`);
    }
  }
  var ACCOUNT_DISCRIMINATOR_SIZE = 8;
  var BorshAccountsCoder = class {
    constructor(idl) {
      if (idl.accounts === void 0) {
        this.accountLayouts = /* @__PURE__ */ new Map();
        return;
      }
      const layouts = idl.accounts.map((acc) => {
        return [acc.name, IdlCoder.typeDefLayout(acc, idl.types)];
      });
      this.accountLayouts = new Map(layouts);
      this.idl = idl;
    }
    async encode(accountName, account) {
      const buffer2 = import_buffer89.Buffer.alloc(1e3);
      const layout = this.accountLayouts.get(accountName);
      if (!layout) {
        throw new Error(`Unknown account: ${accountName}`);
      }
      const len = layout.encode(account, buffer2);
      let accountData = buffer2.slice(0, len);
      let discriminator = BorshAccountsCoder.accountDiscriminator(accountName);
      return import_buffer89.Buffer.concat([discriminator, accountData]);
    }
    decode(accountName, data) {
      const discriminator = BorshAccountsCoder.accountDiscriminator(accountName);
      if (discriminator.compare(data.slice(0, 8))) {
        throw new Error("Invalid account discriminator");
      }
      return this.decodeUnchecked(accountName, data);
    }
    decodeAny(data) {
      const accountDescriminator = data.slice(0, 8);
      const accountName = Array.from(this.accountLayouts.keys()).find((key) => BorshAccountsCoder.accountDiscriminator(key).equals(accountDescriminator));
      if (!accountName) {
        throw new Error("Account descriminator not found");
      }
      return this.decodeUnchecked(accountName, data);
    }
    decodeUnchecked(accountName, ix) {
      const data = ix.slice(ACCOUNT_DISCRIMINATOR_SIZE);
      const layout = this.accountLayouts.get(accountName);
      if (!layout) {
        throw new Error(`Unknown account: ${accountName}`);
      }
      return layout.decode(data);
    }
    memcmp(accountName, appendData) {
      const discriminator = BorshAccountsCoder.accountDiscriminator(accountName);
      return {
        offset: 0,
        bytes: import_bs582.default.encode(appendData ? import_buffer89.Buffer.concat([discriminator, appendData]) : discriminator)
      };
    }
    size(idlAccount) {
      var _a;
      return ACCOUNT_DISCRIMINATOR_SIZE + ((_a = accountSize(this.idl, idlAccount)) !== null && _a !== void 0 ? _a : 0);
    }
    static accountDiscriminator(name2) {
      return import_buffer89.Buffer.from(import_js_sha256.sha256.digest(`account:${(0, import_camelcase.default)(name2, {
        pascalCase: true,
        preserveConsecutiveUppercase: true
      })}`)).slice(0, ACCOUNT_DISCRIMINATOR_SIZE);
    }
  };
  var BorshEventCoder = class {
    constructor(idl) {
      if (idl.events === void 0) {
        this.layouts = /* @__PURE__ */ new Map();
        return;
      }
      const layouts = idl.events.map((event) => {
        let eventTypeDef = {
          name: event.name,
          type: {
            kind: "struct",
            fields: event.fields.map((f3) => {
              return { name: f3.name, type: f3.type };
            })
          }
        };
        return [event.name, IdlCoder.typeDefLayout(eventTypeDef, idl.types)];
      });
      this.layouts = new Map(layouts);
      this.discriminators = new Map(idl.events === void 0 ? [] : idl.events.map((e) => [
        base64$1.fromByteArray(eventDiscriminator(e.name)),
        e.name
      ]));
    }
    decode(log2) {
      let logArr;
      try {
        logArr = import_buffer89.Buffer.from(base64$1.toByteArray(log2));
      } catch (e) {
        return null;
      }
      const disc = base64$1.fromByteArray(logArr.slice(0, 8));
      const eventName = this.discriminators.get(disc);
      if (eventName === void 0) {
        return null;
      }
      const layout = this.layouts.get(eventName);
      if (!layout) {
        throw new Error(`Unknown event: ${eventName}`);
      }
      const data = layout.decode(logArr.slice(8));
      return { data, name: eventName };
    }
  };
  function eventDiscriminator(name2) {
    return import_buffer89.Buffer.from(import_js_sha256.sha256.digest(`event:${name2}`)).slice(0, 8);
  }
  var BorshTypesCoder = class {
    constructor(idl) {
      if (idl.types === void 0) {
        this.typeLayouts = /* @__PURE__ */ new Map();
        return;
      }
      const layouts = idl.types.map((acc) => {
        return [acc.name, IdlCoder.typeDefLayout(acc, idl.types)];
      });
      this.typeLayouts = new Map(layouts);
      this.idl = idl;
    }
    encode(typeName, type5) {
      const buffer2 = import_buffer89.Buffer.alloc(1e3);
      const layout = this.typeLayouts.get(typeName);
      if (!layout) {
        throw new Error(`Unknown type: ${typeName}`);
      }
      const len = layout.encode(type5, buffer2);
      return buffer2.slice(0, len);
    }
    decode(typeName, typeData) {
      const layout = this.typeLayouts.get(typeName);
      if (!layout) {
        throw new Error(`Unknown type: ${typeName}`);
      }
      return layout.decode(typeData);
    }
  };
  var BorshCoder = class {
    constructor(idl) {
      this.instruction = new BorshInstructionCoder(idl);
      this.accounts = new BorshAccountsCoder(idl);
      this.events = new BorshEventCoder(idl);
      this.types = new BorshTypesCoder(idl);
    }
  };
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs2(x2) {
    return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
  }
  var Layout = class {
    constructor(span, property) {
      if (!Number.isInteger(span)) {
        throw new TypeError("span must be an integer");
      }
      this.span = span;
      this.property = property;
    }
    makeDestinationObject() {
      return {};
    }
    decode(b2, offset3) {
      throw new Error("Layout is abstract");
    }
    encode(src, b2, offset3) {
      throw new Error("Layout is abstract");
    }
    getSpan(b2, offset3) {
      if (0 > this.span) {
        throw new RangeError("indeterminate span");
      }
      return this.span;
    }
    replicate(property) {
      const rv = Object.create(this.constructor.prototype);
      Object.assign(rv, this);
      rv.property = property;
      return rv;
    }
    fromArray(values) {
      return void 0;
    }
  };
  var Layout_2 = Layout;
  function nameWithProperty(name2, lo) {
    if (lo.property) {
      return name2 + "[" + lo.property + "]";
    }
    return name2;
  }
  var ExternalLayout = class extends Layout {
    isCount() {
      throw new Error("ExternalLayout is abstract");
    }
  };
  var OffsetLayout = class extends ExternalLayout {
    constructor(layout, offset3, property) {
      if (!(layout instanceof Layout)) {
        throw new TypeError("layout must be a Layout");
      }
      if (void 0 === offset3) {
        offset3 = 0;
      } else if (!Number.isInteger(offset3)) {
        throw new TypeError("offset must be integer or undefined");
      }
      super(layout.span, property || layout.property);
      this.layout = layout;
      this.offset = offset3;
    }
    isCount() {
      return this.layout instanceof UInt || this.layout instanceof UIntBE;
    }
    decode(b2, offset3) {
      if (void 0 === offset3) {
        offset3 = 0;
      }
      return this.layout.decode(b2, offset3 + this.offset);
    }
    encode(src, b2, offset3) {
      if (void 0 === offset3) {
        offset3 = 0;
      }
      return this.layout.encode(src, b2, offset3 + this.offset);
    }
  };
  var UInt = class extends Layout {
    constructor(span, property) {
      super(span, property);
      if (6 < this.span) {
        throw new RangeError("span must not exceed 6 bytes");
      }
    }
    decode(b2, offset3) {
      if (void 0 === offset3) {
        offset3 = 0;
      }
      return b2.readUIntLE(offset3, this.span);
    }
    encode(src, b2, offset3) {
      if (void 0 === offset3) {
        offset3 = 0;
      }
      b2.writeUIntLE(src, offset3, this.span);
      return this.span;
    }
  };
  var UIntBE = class extends Layout {
    constructor(span, property) {
      super(span, property);
      if (6 < this.span) {
        throw new RangeError("span must not exceed 6 bytes");
      }
    }
    decode(b2, offset3) {
      if (void 0 === offset3) {
        offset3 = 0;
      }
      return b2.readUIntBE(offset3, this.span);
    }
    encode(src, b2, offset3) {
      if (void 0 === offset3) {
        offset3 = 0;
      }
      b2.writeUIntBE(src, offset3, this.span);
      return this.span;
    }
  };
  var V2E32 = Math.pow(2, 32);
  function divmodInt64(src) {
    const hi32 = Math.floor(src / V2E32);
    const lo32 = src - hi32 * V2E32;
    return { hi32, lo32 };
  }
  function roundedInt64(hi32, lo32) {
    return hi32 * V2E32 + lo32;
  }
  var NearUInt64 = class extends Layout {
    constructor(property) {
      super(8, property);
    }
    decode(b2, offset3) {
      if (void 0 === offset3) {
        offset3 = 0;
      }
      const lo32 = b2.readUInt32LE(offset3);
      const hi32 = b2.readUInt32LE(offset3 + 4);
      return roundedInt64(hi32, lo32);
    }
    encode(src, b2, offset3) {
      if (void 0 === offset3) {
        offset3 = 0;
      }
      const split2 = divmodInt64(src);
      b2.writeUInt32LE(split2.lo32, offset3);
      b2.writeUInt32LE(split2.hi32, offset3 + 4);
      return 8;
    }
  };
  var NearInt64 = class extends Layout {
    constructor(property) {
      super(8, property);
    }
    decode(b2, offset3) {
      if (void 0 === offset3) {
        offset3 = 0;
      }
      const lo32 = b2.readUInt32LE(offset3);
      const hi32 = b2.readInt32LE(offset3 + 4);
      return roundedInt64(hi32, lo32);
    }
    encode(src, b2, offset3) {
      if (void 0 === offset3) {
        offset3 = 0;
      }
      const split2 = divmodInt64(src);
      b2.writeUInt32LE(split2.lo32, offset3);
      b2.writeInt32LE(split2.hi32, offset3 + 4);
      return 8;
    }
  };
  var Structure = class extends Layout {
    constructor(fields, property, decodePrefixes) {
      if (!(Array.isArray(fields) && fields.reduce((acc, v2) => acc && v2 instanceof Layout, true))) {
        throw new TypeError("fields must be array of Layout instances");
      }
      if ("boolean" === typeof property && void 0 === decodePrefixes) {
        decodePrefixes = property;
        property = void 0;
      }
      for (const fd of fields) {
        if (0 > fd.span && void 0 === fd.property) {
          throw new Error("fields cannot contain unnamed variable-length layout");
        }
      }
      let span = -1;
      try {
        span = fields.reduce((span2, fd) => span2 + fd.getSpan(), 0);
      } catch (e) {
      }
      super(span, property);
      this.fields = fields;
      this.decodePrefixes = !!decodePrefixes;
    }
    getSpan(b2, offset3) {
      if (0 <= this.span) {
        return this.span;
      }
      if (void 0 === offset3) {
        offset3 = 0;
      }
      let span = 0;
      try {
        span = this.fields.reduce((span2, fd) => {
          const fsp = fd.getSpan(b2, offset3);
          offset3 += fsp;
          return span2 + fsp;
        }, 0);
      } catch (e) {
        throw new RangeError("indeterminate span");
      }
      return span;
    }
    decode(b2, offset3) {
      if (void 0 === offset3) {
        offset3 = 0;
      }
      const dest = this.makeDestinationObject();
      for (const fd of this.fields) {
        if (void 0 !== fd.property) {
          dest[fd.property] = fd.decode(b2, offset3);
        }
        offset3 += fd.getSpan(b2, offset3);
        if (this.decodePrefixes && b2.length === offset3) {
          break;
        }
      }
      return dest;
    }
    encode(src, b2, offset3) {
      if (void 0 === offset3) {
        offset3 = 0;
      }
      const firstOffset = offset3;
      let lastOffset = 0;
      let lastWrote = 0;
      for (const fd of this.fields) {
        let span = fd.span;
        lastWrote = 0 < span ? span : 0;
        if (void 0 !== fd.property) {
          const fv = src[fd.property];
          if (void 0 !== fv) {
            lastWrote = fd.encode(fv, b2, offset3);
            if (0 > span) {
              span = fd.getSpan(b2, offset3);
            }
          }
        }
        lastOffset = offset3;
        offset3 += span;
      }
      return lastOffset + lastWrote - firstOffset;
    }
    fromArray(values) {
      const dest = this.makeDestinationObject();
      for (const fd of this.fields) {
        if (void 0 !== fd.property && 0 < values.length) {
          dest[fd.property] = values.shift();
        }
      }
      return dest;
    }
    layoutFor(property) {
      if ("string" !== typeof property) {
        throw new TypeError("property must be string");
      }
      for (const fd of this.fields) {
        if (fd.property === property) {
          return fd;
        }
      }
    }
    offsetOf(property) {
      if ("string" !== typeof property) {
        throw new TypeError("property must be string");
      }
      let offset3 = 0;
      for (const fd of this.fields) {
        if (fd.property === property) {
          return offset3;
        }
        if (0 > fd.span) {
          offset3 = -1;
        } else if (0 <= offset3) {
          offset3 += fd.span;
        }
      }
    }
  };
  var UnionDiscriminator = class {
    constructor(property) {
      this.property = property;
    }
    decode() {
      throw new Error("UnionDiscriminator is abstract");
    }
    encode() {
      throw new Error("UnionDiscriminator is abstract");
    }
  };
  var UnionLayoutDiscriminator = class extends UnionDiscriminator {
    constructor(layout, property) {
      if (!(layout instanceof ExternalLayout && layout.isCount())) {
        throw new TypeError("layout must be an unsigned integer ExternalLayout");
      }
      super(property || layout.property || "variant");
      this.layout = layout;
    }
    decode(b2, offset3) {
      return this.layout.decode(b2, offset3);
    }
    encode(src, b2, offset3) {
      return this.layout.encode(src, b2, offset3);
    }
  };
  var Union = class extends Layout {
    constructor(discr, defaultLayout, property) {
      const upv = discr instanceof UInt || discr instanceof UIntBE;
      if (upv) {
        discr = new UnionLayoutDiscriminator(new OffsetLayout(discr));
      } else if (discr instanceof ExternalLayout && discr.isCount()) {
        discr = new UnionLayoutDiscriminator(discr);
      } else if (!(discr instanceof UnionDiscriminator)) {
        throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
      }
      if (void 0 === defaultLayout) {
        defaultLayout = null;
      }
      if (!(null === defaultLayout || defaultLayout instanceof Layout)) {
        throw new TypeError("defaultLayout must be null or a Layout");
      }
      if (null !== defaultLayout) {
        if (0 > defaultLayout.span) {
          throw new Error("defaultLayout must have constant span");
        }
        if (void 0 === defaultLayout.property) {
          defaultLayout = defaultLayout.replicate("content");
        }
      }
      let span = -1;
      if (defaultLayout) {
        span = defaultLayout.span;
        if (0 <= span && upv) {
          span += discr.layout.span;
        }
      }
      super(span, property);
      this.discriminator = discr;
      this.usesPrefixDiscriminator = upv;
      this.defaultLayout = defaultLayout;
      this.registry = {};
      let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);
      this.getSourceVariant = function(src) {
        return boundGetSourceVariant(src);
      };
      this.configGetSourceVariant = function(gsv) {
        boundGetSourceVariant = gsv.bind(this);
      };
    }
    getSpan(b2, offset3) {
      if (0 <= this.span) {
        return this.span;
      }
      if (void 0 === offset3) {
        offset3 = 0;
      }
      const vlo = this.getVariant(b2, offset3);
      if (!vlo) {
        throw new Error("unable to determine span for unrecognized variant");
      }
      return vlo.getSpan(b2, offset3);
    }
    defaultGetSourceVariant(src) {
      if (src.hasOwnProperty(this.discriminator.property)) {
        if (this.defaultLayout && src.hasOwnProperty(this.defaultLayout.property)) {
          return void 0;
        }
        const vlo = this.registry[src[this.discriminator.property]];
        if (vlo && (!vlo.layout || src.hasOwnProperty(vlo.property))) {
          return vlo;
        }
      } else {
        for (const tag in this.registry) {
          const vlo = this.registry[tag];
          if (src.hasOwnProperty(vlo.property)) {
            return vlo;
          }
        }
      }
      throw new Error("unable to infer src variant");
    }
    decode(b2, offset3) {
      if (void 0 === offset3) {
        offset3 = 0;
      }
      let dest;
      const dlo = this.discriminator;
      const discr = dlo.decode(b2, offset3);
      let clo = this.registry[discr];
      if (void 0 === clo) {
        let contentOffset = 0;
        clo = this.defaultLayout;
        if (this.usesPrefixDiscriminator) {
          contentOffset = dlo.layout.span;
        }
        dest = this.makeDestinationObject();
        dest[dlo.property] = discr;
        dest[clo.property] = this.defaultLayout.decode(b2, offset3 + contentOffset);
      } else {
        dest = clo.decode(b2, offset3);
      }
      return dest;
    }
    encode(src, b2, offset3) {
      if (void 0 === offset3) {
        offset3 = 0;
      }
      const vlo = this.getSourceVariant(src);
      if (void 0 === vlo) {
        const dlo = this.discriminator;
        const clo = this.defaultLayout;
        let contentOffset = 0;
        if (this.usesPrefixDiscriminator) {
          contentOffset = dlo.layout.span;
        }
        dlo.encode(src[dlo.property], b2, offset3);
        return contentOffset + clo.encode(
          src[clo.property],
          b2,
          offset3 + contentOffset
        );
      }
      return vlo.encode(src, b2, offset3);
    }
    addVariant(variant, layout, property) {
      const rv = new VariantLayout(this, variant, layout, property);
      this.registry[variant] = rv;
      return rv;
    }
    getVariant(vb, offset3) {
      let variant = vb;
      if (Buffer.isBuffer(vb)) {
        if (void 0 === offset3) {
          offset3 = 0;
        }
        variant = this.discriminator.decode(vb, offset3);
      }
      return this.registry[variant];
    }
  };
  var VariantLayout = class extends Layout {
    constructor(union4, variant, layout, property) {
      if (!(union4 instanceof Union)) {
        throw new TypeError("union must be a Union");
      }
      if (!Number.isInteger(variant) || 0 > variant) {
        throw new TypeError("variant must be a (non-negative) integer");
      }
      if ("string" === typeof layout && void 0 === property) {
        property = layout;
        layout = null;
      }
      if (layout) {
        if (!(layout instanceof Layout)) {
          throw new TypeError("layout must be a Layout");
        }
        if (null !== union4.defaultLayout && 0 <= layout.span && layout.span > union4.defaultLayout.span) {
          throw new Error("variant span exceeds span of containing union");
        }
        if ("string" !== typeof property) {
          throw new TypeError("variant must have a String property");
        }
      }
      let span = union4.span;
      if (0 > union4.span) {
        span = layout ? layout.span : 0;
        if (0 <= span && union4.usesPrefixDiscriminator) {
          span += union4.discriminator.layout.span;
        }
      }
      super(span, property);
      this.union = union4;
      this.variant = variant;
      this.layout = layout || null;
    }
    getSpan(b2, offset3) {
      if (0 <= this.span) {
        return this.span;
      }
      if (void 0 === offset3) {
        offset3 = 0;
      }
      let contentOffset = 0;
      if (this.union.usesPrefixDiscriminator) {
        contentOffset = this.union.discriminator.layout.span;
      }
      return contentOffset + this.layout.getSpan(b2, offset3 + contentOffset);
    }
    decode(b2, offset3) {
      const dest = this.makeDestinationObject();
      if (void 0 === offset3) {
        offset3 = 0;
      }
      if (this !== this.union.getVariant(b2, offset3)) {
        throw new Error("variant mismatch");
      }
      let contentOffset = 0;
      if (this.union.usesPrefixDiscriminator) {
        contentOffset = this.union.discriminator.layout.span;
      }
      if (this.layout) {
        dest[this.property] = this.layout.decode(b2, offset3 + contentOffset);
      } else if (this.property) {
        dest[this.property] = true;
      } else if (this.union.usesPrefixDiscriminator) {
        dest[this.union.discriminator.property] = this.variant;
      }
      return dest;
    }
    encode(src, b2, offset3) {
      if (void 0 === offset3) {
        offset3 = 0;
      }
      let contentOffset = 0;
      if (this.union.usesPrefixDiscriminator) {
        contentOffset = this.union.discriminator.layout.span;
      }
      if (this.layout && !src.hasOwnProperty(this.property)) {
        throw new TypeError("variant lacks property " + this.property);
      }
      this.union.discriminator.encode(this.variant, b2, offset3);
      let span = contentOffset;
      if (this.layout) {
        this.layout.encode(src[this.property], b2, offset3 + contentOffset);
        span += this.layout.getSpan(b2, offset3 + contentOffset);
        if (0 <= this.union.span && span > this.union.span) {
          throw new Error("encoded variant overruns containing union");
        }
      }
      return span;
    }
    fromArray(values) {
      if (this.layout) {
        return this.layout.fromArray(values);
      }
    }
  };
  var Blob$1 = class extends Layout {
    constructor(length, property) {
      if (!(length instanceof ExternalLayout && length.isCount() || Number.isInteger(length) && 0 <= length)) {
        throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
      }
      let span = -1;
      if (!(length instanceof ExternalLayout)) {
        span = length;
      }
      super(span, property);
      this.length = length;
    }
    getSpan(b2, offset3) {
      let span = this.span;
      if (0 > span) {
        span = this.length.decode(b2, offset3);
      }
      return span;
    }
    decode(b2, offset3) {
      if (void 0 === offset3) {
        offset3 = 0;
      }
      let span = this.span;
      if (0 > span) {
        span = this.length.decode(b2, offset3);
      }
      return b2.slice(offset3, offset3 + span);
    }
    encode(src, b2, offset3) {
      let span = this.length;
      if (this.length instanceof ExternalLayout) {
        span = src.length;
      }
      if (!(Buffer.isBuffer(src) && span === src.length)) {
        throw new TypeError(nameWithProperty("Blob.encode", this) + " requires (length " + span + ") Buffer as src");
      }
      if (offset3 + span > b2.length) {
        throw new RangeError("encoding overruns Buffer");
      }
      b2.write(src.toString("hex"), offset3, span, "hex");
      if (this.length instanceof ExternalLayout) {
        this.length.encode(span, b2, offset3);
      }
      return span;
    }
  };
  var offset2 = (layout, offset3, property) => new OffsetLayout(layout, offset3, property);
  var u83 = (property) => new UInt(1, property);
  var u324 = (property) => new UInt(4, property);
  var nu642 = (property) => new NearUInt64(property);
  var ns642 = (property) => new NearInt64(property);
  var struct3 = (fields, property, decodePrefixes) => new Structure(fields, property, decodePrefixes);
  var union3 = (discr, defaultLayout, property) => new Union(discr, defaultLayout, property);
  var blob3 = (length, property) => new Blob$1(length, property);
  var RustStringLayout = class extends Layout_2 {
    constructor(property) {
      super(-1, property);
      this.property = property;
      this.layout = struct3([
        u324("length"),
        u324("lengthPadding"),
        blob3(offset2(u324(), -8), "chars")
      ], this.property);
    }
    encode(src, b2, offset3 = 0) {
      if (src === null || src === void 0) {
        return this.layout.span;
      }
      const data = {
        chars: Buffer.from(src, "utf8")
      };
      return this.layout.encode(data, b2, offset3);
    }
    decode(b2, offset3 = 0) {
      const data = this.layout.decode(b2, offset3);
      return data["chars"].toString();
    }
    getSpan(b2, offset3 = 0) {
      return u324().span + u324().span + new import_bn2.default(new Uint8Array(b2).slice(offset3, offset3 + 4), 10, "le").toNumber();
    }
  };
  function rustStringLayout(property) {
    return new RustStringLayout(property);
  }
  function publicKey$2(property) {
    return blob3(32, property);
  }
  var LAYOUT = union3(u324("instruction"));
  LAYOUT.addVariant(0, struct3([
    ns642("lamports"),
    ns642("space"),
    publicKey$2("owner")
  ]), "createAccount");
  LAYOUT.addVariant(1, struct3([publicKey$2("owner")]), "assign");
  LAYOUT.addVariant(2, struct3([ns642("lamports")]), "transfer");
  LAYOUT.addVariant(3, struct3([
    publicKey$2("base"),
    rustStringLayout("seed"),
    ns642("lamports"),
    ns642("space"),
    publicKey$2("owner")
  ]), "createAccountWithSeed");
  LAYOUT.addVariant(4, struct3([publicKey$2("authorized")]), "advanceNonceAccount");
  LAYOUT.addVariant(5, struct3([ns642("lamports")]), "withdrawNonceAccount");
  LAYOUT.addVariant(6, struct3([publicKey$2("authorized")]), "initializeNonceAccount");
  LAYOUT.addVariant(7, struct3([publicKey$2("authorized")]), "authorizeNonceAccount");
  LAYOUT.addVariant(8, struct3([ns642("space")]), "allocate");
  LAYOUT.addVariant(9, struct3([
    publicKey$2("base"),
    rustStringLayout("seed"),
    ns642("space"),
    publicKey$2("owner")
  ]), "allocateWithSeed");
  LAYOUT.addVariant(10, struct3([
    publicKey$2("base"),
    rustStringLayout("seed"),
    publicKey$2("owner")
  ]), "assignWithSeed");
  LAYOUT.addVariant(11, struct3([
    ns642("lamports"),
    rustStringLayout("seed"),
    publicKey$2("owner")
  ]), "transferWithSeed");
  var instructionMaxSpan = Math.max(...Object.values(LAYOUT.registry).map((r) => r.span));
  var WrappedLayout$1 = class extends Layout_2 {
    constructor(layout, decoder, encoder, property) {
      super(layout.span, property);
      this.layout = layout;
      this.decoder = decoder;
      this.encoder = encoder;
    }
    decode(b2, offset3) {
      return this.decoder(this.layout.decode(b2, offset3));
    }
    encode(src, b2, offset3) {
      return this.layout.encode(this.encoder(src), b2, offset3);
    }
    getSpan(b2, offset3) {
      return this.layout.getSpan(b2, offset3);
    }
  };
  function publicKey$1(property) {
    return new WrappedLayout$1(blob3(32), (b2) => new PublicKey(b2), (key) => key.toBuffer(), property);
  }
  var NONCE_ACCOUNT_LAYOUT = struct3([
    u324("version"),
    u324("state"),
    publicKey$1("authorizedPubkey"),
    publicKey$1("nonce"),
    struct3([nu642("lamportsPerSignature")], "feeCalculator")
  ]);
  function associated(programId, ...args) {
    let seeds = [import_buffer89.Buffer.from([97, 110, 99, 104, 111, 114])];
    args.forEach((arg) => {
      seeds.push(arg instanceof import_buffer89.Buffer ? arg : translateAddress(arg).toBuffer());
    });
    const [assoc] = PublicKey.findProgramAddressSync(seeds, translateAddress(programId));
    return assoc;
  }
  var TOKEN_PROGRAM_ID = new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
  var ASSOCIATED_PROGRAM_ID = new PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
  var browserPonyfill = { exports: {} };
  (function(module2, exports2) {
    var global2 = typeof self !== "undefined" ? self : commonjsGlobal;
    var __self__ = function() {
      function F2() {
        this.fetch = false;
        this.DOMException = global2.DOMException;
      }
      F2.prototype = global2;
      return new F2();
    }();
    (function(self2) {
      (function(exports3) {
        var support = {
          searchParams: "URLSearchParams" in self2,
          iterable: "Symbol" in self2 && "iterator" in Symbol,
          blob: "FileReader" in self2 && "Blob" in self2 && function() {
            try {
              new Blob();
              return true;
            } catch (e) {
              return false;
            }
          }(),
          formData: "FormData" in self2,
          arrayBuffer: "ArrayBuffer" in self2
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name2) {
          if (typeof name2 !== "string") {
            name2 = String(name2);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name2)) {
            throw new TypeError("Invalid character in header field name");
          }
          return name2.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers(headers) {
          this.map = {};
          if (headers instanceof Headers) {
            headers.forEach(function(value, name2) {
              this.append(name2, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name2) {
              this.append(name2, headers[name2]);
            }, this);
          }
        }
        Headers.prototype.append = function(name2, value) {
          name2 = normalizeName(name2);
          value = normalizeValue(value);
          var oldValue = this.map[name2];
          this.map[name2] = oldValue ? oldValue + ", " + value : value;
        };
        Headers.prototype["delete"] = function(name2) {
          delete this.map[normalizeName(name2)];
        };
        Headers.prototype.get = function(name2) {
          name2 = normalizeName(name2);
          return this.has(name2) ? this.map[name2] : null;
        };
        Headers.prototype.has = function(name2) {
          return this.map.hasOwnProperty(normalizeName(name2));
        };
        Headers.prototype.set = function(name2, value) {
          this.map[normalizeName(name2)] = normalizeValue(value);
        };
        Headers.prototype.forEach = function(callback, thisArg) {
          for (var name2 in this.map) {
            if (this.map.hasOwnProperty(name2)) {
              callback.call(thisArg, this.map[name2], name2, this);
            }
          }
        };
        Headers.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name2) {
            items.push(name2);
          });
          return iteratorFor(items);
        };
        Headers.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name2) {
            items.push([name2, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        }
        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob5) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob5);
          return promise;
        }
        function readBlobAsText(blob5) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsText(blob5);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i = 0; i < view.length; i++) {
            chars[i] = String.fromCharCode(view[i]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this._bodyInit = body;
            if (!body) {
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
              } else {
                return this.blob().then(readBlobAsArrayBuffer);
              }
            };
          }
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode2);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function normalizeMethod(method2) {
          var upcased = method2.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method2;
        }
        function Request(input, options) {
          options = options || {};
          var body = options.body;
          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal;
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
        }
        Request.prototype.clone = function() {
          return new Request(this, { body: this._bodyInit });
        };
        function decode2(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes2) {
            if (bytes2) {
              var split2 = bytes2.split("=");
              var name2 = split2.shift().replace(/\+/g, " ");
              var value = split2.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name2), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              headers.append(key, value);
            }
          });
          return headers;
        }
        Body.call(Request.prototype);
        function Response(bodyInit, options) {
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = "statusText" in options ? options.statusText : "OK";
          this.headers = new Headers(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response.prototype);
        Response.prototype.clone = function() {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          });
        };
        Response.error = function() {
          var response = new Response(null, { status: 0, statusText: "" });
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response.redirect = function(url2, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response(null, { status, headers: { location: url2 } });
        };
        exports3.DOMException = self2.DOMException;
        try {
          new exports3.DOMException();
        } catch (err2) {
          exports3.DOMException = function(message, name2) {
            this.message = message;
            this.name = name2;
            var error2 = Error(message);
            this.stack = error2.stack;
          };
          exports3.DOMException.prototype = Object.create(Error.prototype);
          exports3.DOMException.prototype.constructor = exports3.DOMException;
        }
        function fetch3(input, init2) {
          return new Promise(function(resolve, reject) {
            var request = new Request(input, init2);
            if (request.signal && request.signal.aborted) {
              return reject(new exports3.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              resolve(new Response(body, options));
            };
            xhr.onerror = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.ontimeout = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.onabort = function() {
              reject(new exports3.DOMException("Aborted", "AbortError"));
            };
            xhr.open(request.method, request.url, true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr && support.blob) {
              xhr.responseType = "blob";
            }
            request.headers.forEach(function(value, name2) {
              xhr.setRequestHeader(name2, value);
            });
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch3.polyfill = true;
        if (!self2.fetch) {
          self2.fetch = fetch3;
          self2.Headers = Headers;
          self2.Request = Request;
          self2.Response = Response;
        }
        exports3.Headers = Headers;
        exports3.Request = Request;
        exports3.Response = Response;
        exports3.fetch = fetch3;
        Object.defineProperty(exports3, "__esModule", { value: true });
        return exports3;
      })({});
    })(__self__);
    __self__.fetch.ponyfill = true;
    delete __self__.fetch.polyfill;
    var ctx = __self__;
    exports2 = ctx.fetch;
    exports2.default = ctx.fetch;
    exports2.fetch = ctx.fetch;
    exports2.Headers = ctx.Headers;
    exports2.Request = ctx.Request;
    exports2.Response = ctx.Response;
    module2.exports = exports2;
  })(browserPonyfill, browserPonyfill.exports);
  var fetch2 = /* @__PURE__ */ getDefaultExportFromCjs2(browserPonyfill.exports);
  var UPGRADEABLE_LOADER_STATE_LAYOUT = borsh.rustEnum([
    borsh.struct([], "uninitialized"),
    borsh.struct([borsh.option(borsh.publicKey(), "authorityAddress")], "buffer"),
    borsh.struct([borsh.publicKey("programdataAddress")], "program"),
    borsh.struct([
      borsh.u64("slot"),
      borsh.option(borsh.publicKey(), "upgradeAuthorityAddress")
    ], "programData")
  ], void 0, borsh.u32());
  function isIdlAccounts(accountItem) {
    return "accounts" in accountItem;
  }
  async function idlAddress(programId) {
    const base = (await PublicKey.findProgramAddress([], programId))[0];
    return await PublicKey.createWithSeed(base, seed(), programId);
  }
  function seed() {
    return "anchor:idl";
  }
  var IDL_ACCOUNT_LAYOUT = borsh.struct([
    borsh.publicKey("authority"),
    borsh.vecU8("data")
  ]);
  function decodeIdlAccount(data) {
    return IDL_ACCOUNT_LAYOUT.decode(data);
  }
  function splitArgsAndCtx(idlIx, args) {
    var _a, _b;
    let options = {};
    const inputLen = idlIx.args ? idlIx.args.length : 0;
    if (args.length > inputLen) {
      if (args.length !== inputLen + 1) {
        throw new Error(`provided too many arguments ${args} to instruction ${idlIx === null || idlIx === void 0 ? void 0 : idlIx.name} expecting: ${(_b = (_a = idlIx.args) === null || _a === void 0 ? void 0 : _a.map((a) => a.name)) !== null && _b !== void 0 ? _b : []}`);
      }
      options = args.pop();
    }
    return [args, options];
  }
  var InstructionNamespaceFactory = class {
    static build(idlIx, encodeFn, programId) {
      if (idlIx.name === "_inner") {
        throw new IdlError("the _inner name is reserved");
      }
      const ix = (...args) => {
        const [ixArgs, ctx] = splitArgsAndCtx(idlIx, [...args]);
        validateAccounts(idlIx.accounts, ctx.accounts);
        validateInstruction(idlIx, ...args);
        const keys = ix.accounts(ctx.accounts);
        if (ctx.remainingAccounts !== void 0) {
          keys.push(...ctx.remainingAccounts);
        }
        if (isSet("debug-logs")) {
          console.log("Outgoing account metas:", keys);
        }
        return new TransactionInstruction({
          keys,
          programId,
          data: encodeFn(idlIx.name, toInstruction(idlIx, ...ixArgs))
        });
      };
      ix["accounts"] = (accs) => {
        return InstructionNamespaceFactory.accountsArray(accs, idlIx.accounts, programId, idlIx.name);
      };
      return ix;
    }
    static accountsArray(ctx, accounts, programId, ixName) {
      if (!ctx) {
        return [];
      }
      return accounts.map((acc) => {
        const nestedAccounts = "accounts" in acc ? acc.accounts : void 0;
        if (nestedAccounts !== void 0) {
          const rpcAccs = ctx[acc.name];
          return InstructionNamespaceFactory.accountsArray(rpcAccs, acc.accounts, programId, ixName).flat();
        } else {
          const account = acc;
          let pubkey;
          try {
            pubkey = translateAddress(ctx[acc.name]);
          } catch (err2) {
            throw new Error(`Wrong input type for account "${acc.name}" in the instruction accounts object${ixName !== void 0 ? ' for instruction "' + ixName + '"' : ""}. Expected PublicKey or string.`);
          }
          const optional4 = account.isOptional && pubkey.equals(programId);
          const isWritable = account.isMut && !optional4;
          const isSigner = account.isSigner && !optional4;
          return {
            pubkey,
            isWritable,
            isSigner
          };
        }
      }).flat();
    }
  };
  function validateInstruction(ix, ...args) {
  }
  var TransactionFactory = class {
    static build(idlIx, ixFn) {
      const txFn = (...args) => {
        var _a, _b, _c;
        const [, ctx] = splitArgsAndCtx(idlIx, [...args]);
        const tx = new Transaction();
        if (ctx.preInstructions && ctx.instructions) {
          throw new Error("instructions is deprecated, use preInstructions");
        }
        (_a = ctx.preInstructions) === null || _a === void 0 ? void 0 : _a.forEach((ix) => tx.add(ix));
        (_b = ctx.instructions) === null || _b === void 0 ? void 0 : _b.forEach((ix) => tx.add(ix));
        tx.add(ixFn(...args));
        (_c = ctx.postInstructions) === null || _c === void 0 ? void 0 : _c.forEach((ix) => tx.add(ix));
        return tx;
      };
      return txFn;
    }
  };
  var RpcFactory = class {
    static build(idlIx, txFn, idlErrors, provider) {
      const rpc = async (...args) => {
        var _a;
        const tx = txFn(...args);
        const [, ctx] = splitArgsAndCtx(idlIx, [...args]);
        if (provider.sendAndConfirm === void 0) {
          throw new Error("This function requires 'Provider.sendAndConfirm' to be implemented.");
        }
        try {
          return await provider.sendAndConfirm(tx, (_a = ctx.signers) !== null && _a !== void 0 ? _a : [], ctx.options);
        } catch (err2) {
          throw translateError(err2, idlErrors);
        }
      };
      return rpc;
    }
  };
  var AccountFactory = class {
    static build(idl, coder, programId, provider) {
      var _a;
      const accountFns = {};
      (_a = idl.accounts) === null || _a === void 0 ? void 0 : _a.forEach((idlAccount) => {
        const name2 = (0, import_camelcase.default)(idlAccount.name);
        accountFns[name2] = new AccountClient(idl, idlAccount, programId, provider, coder);
      });
      return accountFns;
    }
  };
  var AccountClient = class {
    get size() {
      return this._size;
    }
    get programId() {
      return this._programId;
    }
    get provider() {
      return this._provider;
    }
    get coder() {
      return this._coder;
    }
    get idlAccount() {
      return this._idlAccount;
    }
    constructor(idl, idlAccount, programId, provider, coder) {
      this._idlAccount = idlAccount;
      this._programId = programId;
      this._provider = provider !== null && provider !== void 0 ? provider : getProvider();
      this._coder = coder !== null && coder !== void 0 ? coder : new BorshCoder(idl);
      this._size = this._coder.accounts.size(idlAccount);
    }
    async fetchNullable(address, commitment) {
      const { data } = await this.fetchNullableAndContext(address, commitment);
      return data;
    }
    async fetchNullableAndContext(address, commitment) {
      const accountInfo = await this.getAccountInfoAndContext(address, commitment);
      const { value, context } = accountInfo;
      return {
        data: value && value.data.length !== 0 ? this._coder.accounts.decode(this._idlAccount.name, value.data) : null,
        context
      };
    }
    async fetch(address, commitment) {
      const { data } = await this.fetchNullableAndContext(address, commitment);
      if (data === null) {
        throw new Error(`Account does not exist or has no data ${address.toString()}`);
      }
      return data;
    }
    async fetchAndContext(address, commitment) {
      const { data, context } = await this.fetchNullableAndContext(address, commitment);
      if (data === null) {
        throw new Error(`Account does not exist ${address.toString()}`);
      }
      return { data, context };
    }
    async fetchMultiple(addresses, commitment) {
      const accounts = await this.fetchMultipleAndContext(addresses, commitment);
      return accounts.map((account) => account ? account.data : null);
    }
    async fetchMultipleAndContext(addresses, commitment) {
      const accounts = await getMultipleAccountsAndContext(this._provider.connection, addresses.map((address) => translateAddress(address)), commitment);
      return accounts.map((result) => {
        if (result == null) {
          return null;
        }
        const { account, context } = result;
        return {
          data: this._coder.accounts.decode(this._idlAccount.name, account.data),
          context
        };
      });
    }
    async all(filters) {
      const filter = this.coder.accounts.memcmp(this._idlAccount.name, filters instanceof Buffer ? filters : void 0);
      const coderFilters = [];
      if ((filter === null || filter === void 0 ? void 0 : filter.offset) != void 0 && (filter === null || filter === void 0 ? void 0 : filter.bytes) != void 0) {
        coderFilters.push({
          memcmp: { offset: filter.offset, bytes: filter.bytes }
        });
      }
      if ((filter === null || filter === void 0 ? void 0 : filter.dataSize) != void 0) {
        coderFilters.push({ dataSize: filter.dataSize });
      }
      let resp = await this._provider.connection.getProgramAccounts(this._programId, {
        commitment: this._provider.connection.commitment,
        filters: [...coderFilters, ...Array.isArray(filters) ? filters : []]
      });
      return resp.map(({ pubkey, account }) => {
        return {
          publicKey: pubkey,
          account: this._coder.accounts.decode(this._idlAccount.name, account.data)
        };
      });
    }
    subscribe(address, commitment) {
      const sub = subscriptions.get(address.toString());
      if (sub) {
        return sub.ee;
      }
      const ee2 = new import_eventemitter32.default();
      address = translateAddress(address);
      const listener = this._provider.connection.onAccountChange(address, (acc) => {
        const account = this._coder.accounts.decode(this._idlAccount.name, acc.data);
        ee2.emit("change", account);
      }, commitment);
      subscriptions.set(address.toString(), {
        ee: ee2,
        listener
      });
      return ee2;
    }
    async unsubscribe(address) {
      let sub = subscriptions.get(address.toString());
      if (!sub) {
        console.warn("Address is not subscribed");
        return;
      }
      if (subscriptions) {
        await this._provider.connection.removeAccountChangeListener(sub.listener).then(() => {
          subscriptions.delete(address.toString());
        }).catch(console.error);
      }
    }
    async createInstruction(signer, sizeOverride) {
      const size = this.size;
      if (this._provider.publicKey === void 0) {
        throw new Error("This function requires the Provider interface implementor to have a 'publicKey' field.");
      }
      return SystemProgram.createAccount({
        fromPubkey: this._provider.publicKey,
        newAccountPubkey: signer.publicKey,
        space: sizeOverride !== null && sizeOverride !== void 0 ? sizeOverride : size,
        lamports: await this._provider.connection.getMinimumBalanceForRentExemption(sizeOverride !== null && sizeOverride !== void 0 ? sizeOverride : size),
        programId: this._programId
      });
    }
    async associated(...args) {
      const addr = await this.associatedAddress(...args);
      return await this.fetch(addr);
    }
    async associatedAddress(...args) {
      return await associated(this._programId, ...args);
    }
    async getAccountInfo(address, commitment) {
      return await this._provider.connection.getAccountInfo(translateAddress(address), commitment);
    }
    async getAccountInfoAndContext(address, commitment) {
      return await this._provider.connection.getAccountInfoAndContext(translateAddress(address), commitment);
    }
  };
  var subscriptions = /* @__PURE__ */ new Map();
  var PROGRAM_LOG = "Program log: ";
  var PROGRAM_DATA = "Program data: ";
  var PROGRAM_LOG_START_INDEX = PROGRAM_LOG.length;
  var PROGRAM_DATA_START_INDEX = PROGRAM_DATA.length;
  var EventManager = class {
    constructor(programId, provider, coder) {
      this._programId = programId;
      this._provider = provider;
      this._eventParser = new EventParser(programId, coder);
      this._eventCallbacks = /* @__PURE__ */ new Map();
      this._eventListeners = /* @__PURE__ */ new Map();
      this._listenerIdCount = 0;
    }
    addEventListener(eventName, callback) {
      var _a;
      let listener = this._listenerIdCount;
      this._listenerIdCount += 1;
      if (!this._eventListeners.has(eventName)) {
        this._eventListeners.set(eventName, []);
      }
      this._eventListeners.set(eventName, ((_a = this._eventListeners.get(eventName)) !== null && _a !== void 0 ? _a : []).concat(listener));
      this._eventCallbacks.set(listener, [eventName, callback]);
      if (this._onLogsSubscriptionId !== void 0) {
        return listener;
      }
      this._onLogsSubscriptionId = this._provider.connection.onLogs(this._programId, (logs, ctx) => {
        if (logs.err) {
          return;
        }
        for (const event of this._eventParser.parseLogs(logs.logs)) {
          const allListeners = this._eventListeners.get(event.name);
          if (allListeners) {
            allListeners.forEach((listener2) => {
              const listenerCb = this._eventCallbacks.get(listener2);
              if (listenerCb) {
                const [, callback2] = listenerCb;
                callback2(event.data, ctx.slot, logs.signature);
              }
            });
          }
        }
      });
      return listener;
    }
    async removeEventListener(listener) {
      const callback = this._eventCallbacks.get(listener);
      if (!callback) {
        throw new Error(`Event listener ${listener} doesn't exist!`);
      }
      const [eventName] = callback;
      let listeners = this._eventListeners.get(eventName);
      if (!listeners) {
        throw new Error(`Event listeners don't exist for ${eventName}!`);
      }
      this._eventCallbacks.delete(listener);
      listeners = listeners.filter((l2) => l2 !== listener);
      this._eventListeners.set(eventName, listeners);
      if (listeners.length === 0) {
        this._eventListeners.delete(eventName);
      }
      if (this._eventCallbacks.size === 0) {
        if (this._eventListeners.size !== 0) {
          throw new Error(`Expected event listeners size to be 0 but got ${this._eventListeners.size}`);
        }
        if (this._onLogsSubscriptionId !== void 0) {
          await this._provider.connection.removeOnLogsListener(this._onLogsSubscriptionId);
          this._onLogsSubscriptionId = void 0;
        }
      }
    }
  };
  var EventParser = class {
    constructor(programId, coder) {
      this.coder = coder;
      this.programId = programId;
    }
    *parseLogs(logs, errorOnDecodeFailure = false) {
      const logScanner = new LogScanner(logs);
      const execution = new ExecutionContext();
      let log2 = logScanner.next();
      while (log2 !== null) {
        let [event, newProgram, didPop] = this.handleLog(execution, log2, errorOnDecodeFailure);
        if (event) {
          yield event;
        }
        if (newProgram) {
          execution.push(newProgram);
        }
        if (didPop) {
          execution.pop();
        }
        log2 = logScanner.next();
      }
    }
    handleLog(execution, log2, errorOnDecodeFailure) {
      if (execution.stack.length > 0 && execution.program() === this.programId.toString()) {
        return this.handleProgramLog(log2, errorOnDecodeFailure);
      } else {
        return [null, ...this.handleSystemLog(log2)];
      }
    }
    handleProgramLog(log2, errorOnDecodeFailure) {
      if (log2.startsWith(PROGRAM_LOG) || log2.startsWith(PROGRAM_DATA)) {
        const logStr = log2.startsWith(PROGRAM_LOG) ? log2.slice(PROGRAM_LOG_START_INDEX) : log2.slice(PROGRAM_DATA_START_INDEX);
        const event = this.coder.events.decode(logStr);
        if (errorOnDecodeFailure && event === null) {
          throw new Error(`Unable to decode event ${logStr}`);
        }
        return [event, null, false];
      } else {
        return [null, ...this.handleSystemLog(log2)];
      }
    }
    handleSystemLog(log2) {
      const logStart = log2.split(":")[0];
      if (logStart.match(/^Program (.*) success/g) !== null) {
        return [null, true];
      } else if (logStart.startsWith(`Program ${this.programId.toString()} invoke`)) {
        return [this.programId.toString(), false];
      } else if (logStart.includes("invoke")) {
        return ["cpi", false];
      } else {
        return [null, false];
      }
    }
  };
  var ExecutionContext = class {
    constructor() {
      this.stack = [];
    }
    program() {
      if (!this.stack.length) {
        throw new Error("Expected the stack to have elements");
      }
      return this.stack[this.stack.length - 1];
    }
    push(newProgram) {
      this.stack.push(newProgram);
    }
    pop() {
      if (!this.stack.length) {
        throw new Error("Expected the stack to have elements");
      }
      this.stack.pop();
    }
  };
  var LogScanner = class {
    constructor(logs) {
      this.logs = logs;
    }
    next() {
      if (this.logs.length === 0) {
        return null;
      }
      let l2 = this.logs[0];
      this.logs = this.logs.slice(1);
      return l2;
    }
  };
  var SimulateFactory = class {
    static build(idlIx, txFn, idlErrors, provider, coder, programId, idl) {
      const simulate = async (...args) => {
        var _a;
        const tx = txFn(...args);
        const [, ctx] = splitArgsAndCtx(idlIx, [...args]);
        let resp = void 0;
        if (provider.simulate === void 0) {
          throw new Error("This function requires 'Provider.simulate' to be implemented.");
        }
        try {
          resp = await provider.simulate(tx, ctx.signers, (_a = ctx.options) === null || _a === void 0 ? void 0 : _a.commitment);
        } catch (err2) {
          throw translateError(err2, idlErrors);
        }
        if (resp === void 0) {
          throw new Error("Unable to simulate transaction");
        }
        const logs = resp.logs;
        if (!logs) {
          throw new Error("Simulated logs not found");
        }
        const events2 = [];
        if (idl.events) {
          let parser = new EventParser(programId, coder);
          for (const event of parser.parseLogs(logs)) {
            events2.push(event);
          }
        }
        return { events: events2, raw: logs };
      };
      return simulate;
    }
  };
  function uint64(property) {
    return new WrappedLayout(blob3(8), (b2) => u644.fromBuffer(b2), (n) => n.toBuffer(), property);
  }
  function publicKey3(property) {
    return new WrappedLayout(blob3(32), (b2) => new PublicKey(b2), (key) => key.toBuffer(), property);
  }
  function coption(layout, property) {
    return new COptionLayout(layout, property);
  }
  var WrappedLayout = class extends Layout_2 {
    constructor(layout, decoder, encoder, property) {
      super(layout.span, property);
      this.layout = layout;
      this.decoder = decoder;
      this.encoder = encoder;
    }
    decode(b2, offset3) {
      return this.decoder(this.layout.decode(b2, offset3));
    }
    encode(src, b2, offset3) {
      return this.layout.encode(this.encoder(src), b2, offset3);
    }
    getSpan(b2, offset3) {
      return this.layout.getSpan(b2, offset3);
    }
  };
  var COptionLayout = class extends Layout_2 {
    constructor(layout, property) {
      super(-1, property);
      this.layout = layout;
      this.discriminator = u324();
    }
    encode(src, b2, offset3 = 0) {
      if (src === null || src === void 0) {
        return this.layout.span + this.discriminator.encode(0, b2, offset3);
      }
      this.discriminator.encode(1, b2, offset3);
      return this.layout.encode(src, b2, offset3 + 4) + 4;
    }
    decode(b2, offset3 = 0) {
      const discriminator = this.discriminator.decode(b2, offset3);
      if (discriminator === 0) {
        return null;
      } else if (discriminator === 1) {
        return this.layout.decode(b2, offset3 + 4);
      }
      throw new Error("Invalid coption " + this.layout.property);
    }
    getSpan(b2, offset3 = 0) {
      return this.layout.getSpan(b2, offset3 + 4) + 4;
    }
  };
  var u644 = class extends import_bn2.default {
    toBuffer() {
      const a = super.toArray().reverse();
      const b2 = Buffer.from(a);
      if (b2.length === 8) {
        return b2;
      }
      if (b2.length >= 8) {
        throw new Error("u64 too large");
      }
      const zeroPad = Buffer.alloc(8);
      b2.copy(zeroPad);
      return zeroPad;
    }
    static fromBuffer(buffer2) {
      if (buffer2.length !== 8) {
        throw new Error(`Invalid buffer length: ${buffer2.length}`);
      }
      return new u644([...buffer2].reverse().map((i) => `00${i.toString(16)}`.slice(-2)).join(""), 16);
    }
  };
  var TOKEN_ACCOUNT_LAYOUT = struct3([
    publicKey3("mint"),
    publicKey3("owner"),
    uint64("amount"),
    coption(publicKey3(), "delegate"),
    ((p2) => {
      const U2 = union3(u83("discriminator"), null, p2);
      U2.addVariant(0, struct3([]), "uninitialized");
      U2.addVariant(1, struct3([]), "initialized");
      U2.addVariant(2, struct3([]), "frozen");
      return U2;
    })("state"),
    coption(uint64(), "isNative"),
    uint64("delegatedAmount"),
    coption(publicKey3(), "closeAuthority")
  ]);
  function decodeTokenAccount(b2) {
    return TOKEN_ACCOUNT_LAYOUT.decode(b2);
  }
  var AccountsResolver = class {
    constructor(_args, _accounts, _provider2, _programId, _idlIx, _accountNamespace, _idlTypes, _customResolver) {
      this._accounts = _accounts;
      this._provider = _provider2;
      this._programId = _programId;
      this._idlIx = _idlIx;
      this._idlTypes = _idlTypes;
      this._customResolver = _customResolver;
      this._args = _args;
      this._accountStore = new AccountStore(_provider2, _accountNamespace, this._programId);
    }
    args(_args) {
      this._args = _args;
    }
    async resolve() {
      await this.resolveConst(this._idlIx.accounts);
      this._resolveEventCpi(this._idlIx.accounts);
      while (await this.resolvePdas(this._idlIx.accounts) + await this.resolveRelations(this._idlIx.accounts) + await this.resolveCustom() > 0) {
      }
    }
    async resolveCustom() {
      if (this._customResolver) {
        const { accounts, resolved } = await this._customResolver({
          args: this._args,
          accounts: this._accounts,
          provider: this._provider,
          programId: this._programId,
          idlIx: this._idlIx
        });
        this._accounts = accounts;
        return resolved;
      }
      return 0;
    }
    resolveOptionalsHelper(partialAccounts, accountItems) {
      const nestedAccountsGeneric = {};
      for (const accountItem of accountItems) {
        const accountName = accountItem.name;
        const partialAccount = partialAccounts[accountName];
        if (partialAccount === void 0)
          continue;
        if (isPartialAccounts(partialAccount)) {
          if (isIdlAccounts(accountItem)) {
            nestedAccountsGeneric[accountName] = this.resolveOptionalsHelper(partialAccount, accountItem["accounts"]);
          } else {
            nestedAccountsGeneric[accountName] = flattenPartialAccounts(partialAccount, true);
          }
        } else {
          if (partialAccount !== null) {
            nestedAccountsGeneric[accountName] = translateAddress(partialAccount);
          } else if (accountItem["isOptional"]) {
            nestedAccountsGeneric[accountName] = this._programId;
          }
        }
      }
      return nestedAccountsGeneric;
    }
    resolveOptionals(accounts) {
      Object.assign(this._accounts, this.resolveOptionalsHelper(accounts, this._idlIx.accounts));
    }
    get(path) {
      const ret = path.reduce((acc, subPath) => acc && acc[subPath], this._accounts);
      if (ret && ret.toBase58) {
        return ret;
      }
    }
    set(path, value) {
      let curr = this._accounts;
      path.forEach((p2, idx) => {
        const isLast = idx == path.length - 1;
        if (isLast) {
          curr[p2] = value;
        }
        curr[p2] = curr[p2] || {};
        curr = curr[p2];
      });
    }
    async resolveConst(accounts, path = []) {
      for (let k2 = 0; k2 < accounts.length; k2 += 1) {
        const accountDescOrAccounts = accounts[k2];
        const subAccounts = accountDescOrAccounts.accounts;
        if (subAccounts) {
          await this.resolveConst(subAccounts, [
            ...path,
            (0, import_camelcase.default)(accountDescOrAccounts.name)
          ]);
        }
        const accountDesc = accountDescOrAccounts;
        const accountDescName = (0, import_camelcase.default)(accountDescOrAccounts.name);
        if (accountDesc.isSigner && !this.get([...path, accountDescName])) {
          if (this._provider.wallet === void 0) {
            throw new Error("This function requires the Provider interface implementor to have a 'wallet' field.");
          }
          this.set([...path, accountDescName], this._provider.wallet.publicKey);
        }
        if (Reflect.has(AccountsResolver.CONST_ACCOUNTS, accountDescName) && !this.get([...path, accountDescName])) {
          this.set([...path, accountDescName], AccountsResolver.CONST_ACCOUNTS[accountDescName]);
        }
      }
    }
    _resolveEventCpi(accounts, path = []) {
      for (const i in accounts) {
        const accountDescOrAccounts = accounts[i];
        const subAccounts = accountDescOrAccounts.accounts;
        if (subAccounts) {
          this._resolveEventCpi(subAccounts, [
            ...path,
            (0, import_camelcase.default)(accountDescOrAccounts.name)
          ]);
        }
        const nextIndex = +i + 1;
        if (nextIndex === accounts.length)
          return;
        const currentName = (0, import_camelcase.default)(accounts[i].name);
        const nextName = (0, import_camelcase.default)(accounts[nextIndex].name);
        if (currentName === "eventAuthority" && nextName === "program") {
          const currentPath = [...path, currentName];
          const nextPath = [...path, nextName];
          if (!this.get(currentPath)) {
            this.set(currentPath, PublicKey.findProgramAddressSync([Buffer.from("__event_authority")], this._programId)[0]);
          }
          if (!this.get(nextPath)) {
            this.set(nextPath, this._programId);
          }
          return;
        }
      }
    }
    async resolvePdas(accounts, path = []) {
      let found = 0;
      for (let k2 = 0; k2 < accounts.length; k2 += 1) {
        const accountDesc = accounts[k2];
        const subAccounts = accountDesc.accounts;
        if (subAccounts) {
          found += await this.resolvePdas(subAccounts, [
            ...path,
            (0, import_camelcase.default)(accountDesc.name)
          ]);
        }
        const accountDescCasted = accountDesc;
        const accountDescName = (0, import_camelcase.default)(accountDesc.name);
        if (accountDescCasted.pda && accountDescCasted.pda.seeds.length > 0 && !this.get([...path, accountDescName])) {
          if (Boolean(await this.autoPopulatePda(accountDescCasted, path))) {
            found += 1;
          }
        }
      }
      return found;
    }
    async resolveRelations(accounts, path = []) {
      let found = 0;
      for (let k2 = 0; k2 < accounts.length; k2 += 1) {
        const accountDesc = accounts[k2];
        const subAccounts = accountDesc.accounts;
        if (subAccounts) {
          found += await this.resolveRelations(subAccounts, [
            ...path,
            (0, import_camelcase.default)(accountDesc.name)
          ]);
        }
        const relations = accountDesc.relations || [];
        const accountDescName = (0, import_camelcase.default)(accountDesc.name);
        const newPath = [...path, accountDescName];
        const accountKey = this.get(newPath);
        if (accountKey) {
          const matching = relations.filter((rel) => !this.get([...path, (0, import_camelcase.default)(rel)]));
          found += matching.length;
          if (matching.length > 0) {
            const account = await this._accountStore.fetchAccount({
              publicKey: accountKey
            });
            await Promise.all(matching.map(async (rel) => {
              const relName = (0, import_camelcase.default)(rel);
              this.set([...path, relName], account[relName]);
              return account[relName];
            }));
          }
        }
      }
      return found;
    }
    async autoPopulatePda(accountDesc, path = []) {
      if (!accountDesc.pda || !accountDesc.pda.seeds)
        throw new Error("Must have seeds");
      const seeds = await Promise.all(accountDesc.pda.seeds.map((seedDesc) => this.toBuffer(seedDesc, path)));
      if (seeds.some((seed2) => typeof seed2 == "undefined")) {
        return;
      }
      const programId = await this.parseProgramId(accountDesc, path);
      if (!programId) {
        return;
      }
      const [pubkey] = await PublicKey.findProgramAddress(seeds, programId);
      this.set([...path, (0, import_camelcase.default)(accountDesc.name)], pubkey);
    }
    async parseProgramId(accountDesc, path = []) {
      var _a;
      if (!((_a = accountDesc.pda) === null || _a === void 0 ? void 0 : _a.programId)) {
        return this._programId;
      }
      switch (accountDesc.pda.programId.kind) {
        case "const":
          return new PublicKey(this.toBufferConst(accountDesc.pda.programId.value));
        case "arg":
          return this.argValue(accountDesc.pda.programId);
        case "account":
          return await this.accountValue(accountDesc.pda.programId, path);
        default:
          throw new Error(`Unexpected program seed kind: ${accountDesc.pda.programId.kind}`);
      }
    }
    async toBuffer(seedDesc, path = []) {
      switch (seedDesc.kind) {
        case "const":
          return this.toBufferConst(seedDesc);
        case "arg":
          return await this.toBufferArg(seedDesc);
        case "account":
          return await this.toBufferAccount(seedDesc, path);
        default:
          throw new Error(`Unexpected seed kind: ${seedDesc.kind}`);
      }
    }
    getType(type5, path = []) {
      if (path.length > 0 && type5.defined) {
        const subType = this._idlTypes.find((t2) => t2.name === type5.defined);
        if (!subType) {
          throw new Error(`Cannot find type ${type5.defined}`);
        }
        const structType = subType.type;
        const field = structType.fields.find((field2) => field2.name === path[0]);
        return this.getType(field.type, path.slice(1));
      }
      return type5;
    }
    toBufferConst(seedDesc) {
      return this.toBufferValue(this.getType(seedDesc.type, (seedDesc.path || "").split(".").slice(1)), seedDesc.value);
    }
    async toBufferArg(seedDesc) {
      const argValue = this.argValue(seedDesc);
      if (typeof argValue === "undefined") {
        return;
      }
      return this.toBufferValue(this.getType(seedDesc.type, (seedDesc.path || "").split(".").slice(1)), argValue);
    }
    argValue(seedDesc) {
      const split2 = seedDesc.path.split(".");
      const seedArgName = (0, import_camelcase.default)(split2[0]);
      const idlArgPosition = this._idlIx.args.findIndex((argDesc) => argDesc.name === seedArgName);
      if (idlArgPosition === -1) {
        throw new Error(`Unable to find argument for seed: ${seedArgName}`);
      }
      return split2.slice(1).reduce((curr, path) => (curr || {})[path], this._args[idlArgPosition]);
    }
    async toBufferAccount(seedDesc, path = []) {
      const accountValue = await this.accountValue(seedDesc, path);
      if (!accountValue) {
        return;
      }
      return this.toBufferValue(seedDesc.type, accountValue);
    }
    async accountValue(seedDesc, path = []) {
      const pathComponents = seedDesc.path.split(".");
      const fieldName = pathComponents[0];
      const fieldPubkey = this.get([...path, (0, import_camelcase.default)(fieldName)]);
      if (fieldPubkey === null) {
        throw new Error(`fieldPubkey is null`);
      }
      if (pathComponents.length === 1) {
        return fieldPubkey;
      }
      const account = await this._accountStore.fetchAccount({
        publicKey: fieldPubkey,
        name: seedDesc.account
      });
      const fieldValue = this.parseAccountValue(account, pathComponents.slice(1));
      return fieldValue;
    }
    parseAccountValue(account, path) {
      let accountField;
      while (path.length > 0) {
        accountField = account[(0, import_camelcase.default)(path[0])];
        path = path.slice(1);
      }
      return accountField;
    }
    toBufferValue(type5, value) {
      switch (type5) {
        case "u8":
          return Buffer.from([value]);
        case "u16":
          let b2 = Buffer.alloc(2);
          b2.writeUInt16LE(value);
          return b2;
        case "u32":
          let buf = Buffer.alloc(4);
          buf.writeUInt32LE(value);
          return buf;
        case "u64":
          let bU64 = Buffer.alloc(8);
          bU64.writeBigUInt64LE(BigInt(value));
          return bU64;
        case "string":
          return Buffer.from(encode$2(value));
        case "publicKey":
          return value.toBuffer();
        default:
          if (type5.array) {
            return Buffer.from(value);
          }
          throw new Error(`Unexpected seed type: ${type5}`);
      }
    }
  };
  AccountsResolver.CONST_ACCOUNTS = {
    associatedTokenProgram: ASSOCIATED_PROGRAM_ID,
    rent: SYSVAR_RENT_PUBKEY,
    systemProgram: SystemProgram.programId,
    tokenProgram: TOKEN_PROGRAM_ID,
    clock: SYSVAR_CLOCK_PUBKEY
  };
  var AccountStore = class {
    constructor(_provider2, _accounts, _programId) {
      this._provider = _provider2;
      this._programId = _programId;
      this._cache = /* @__PURE__ */ new Map();
      this._idls = {};
      this._idls[_programId.toBase58()] = _accounts;
    }
    async ensureIdl(programId) {
      if (!this._idls[programId.toBase58()]) {
        const idl = await Program.fetchIdl(programId, this._provider);
        if (idl) {
          const program = new Program(idl, programId, this._provider);
          this._idls[programId.toBase58()] = program.account;
        }
      }
      return this._idls[programId.toBase58()];
    }
    async fetchAccount({ publicKey: publicKey6, name: name2, programId = this._programId }) {
      const address = publicKey6.toString();
      if (!this._cache.has(address)) {
        if (name2 === "TokenAccount") {
          const accountInfo = await this._provider.connection.getAccountInfo(publicKey6);
          if (accountInfo === null) {
            throw new Error(`invalid account info for ${address}`);
          }
          const data = decodeTokenAccount(accountInfo.data);
          this._cache.set(address, data);
        } else if (name2) {
          const accounts = await this.ensureIdl(programId);
          if (accounts) {
            const accountFetcher = accounts[(0, import_camelcase.default)(name2)];
            if (accountFetcher) {
              const account = await accountFetcher.fetch(publicKey6);
              this._cache.set(address, account);
            }
          }
        } else {
          const account = await this._provider.connection.getAccountInfo(publicKey6);
          if (account === null) {
            throw new Error(`invalid account info for ${address}`);
          }
          const data = account.data;
          const accounts = await this.ensureIdl(account.owner);
          if (accounts) {
            const firstAccountLayout = Object.values(accounts)[0];
            if (!firstAccountLayout) {
              throw new Error("No accounts for this program");
            }
            const result = firstAccountLayout.coder.accounts.decodeAny(data);
            this._cache.set(address, result);
          }
        }
      }
      return this._cache.get(address);
    }
  };
  var MethodsBuilderFactory = class {
    static build(provider, programId, idlIx, ixFn, txFn, rpcFn, simulateFn, viewFn, accountNamespace, idlTypes, customResolver) {
      return (...args) => new MethodsBuilder(args, ixFn, txFn, rpcFn, simulateFn, viewFn, provider, programId, idlIx, accountNamespace, idlTypes, customResolver);
    }
  };
  function isPartialAccounts(partialAccount) {
    return typeof partialAccount === "object" && partialAccount !== null && !("_bn" in partialAccount);
  }
  function flattenPartialAccounts(partialAccounts, throwOnNull) {
    const toReturn = {};
    for (const accountName in partialAccounts) {
      const account = partialAccounts[accountName];
      if (account === null) {
        if (throwOnNull)
          throw new Error("Failed to resolve optionals due to IDL type mismatch with input accounts!");
        continue;
      }
      toReturn[accountName] = isPartialAccounts(account) ? flattenPartialAccounts(account, true) : translateAddress(account);
    }
    return toReturn;
  }
  var MethodsBuilder = class {
    constructor(_args, _ixFn, _txFn, _rpcFn, _simulateFn, _viewFn, _provider2, _programId, _idlIx, _accountNamespace, _idlTypes, _customResolver) {
      this._ixFn = _ixFn;
      this._txFn = _txFn;
      this._rpcFn = _rpcFn;
      this._simulateFn = _simulateFn;
      this._viewFn = _viewFn;
      this._programId = _programId;
      this._accounts = {};
      this._remainingAccounts = [];
      this._signers = [];
      this._preInstructions = [];
      this._postInstructions = [];
      this._autoResolveAccounts = true;
      this._args = _args;
      this._accountsResolver = new AccountsResolver(_args, this._accounts, _provider2, _programId, _idlIx, _accountNamespace, _idlTypes, _customResolver);
    }
    args(_args) {
      this._args = _args;
      this._accountsResolver.args(_args);
    }
    async pubkeys() {
      if (this._autoResolveAccounts) {
        await this._accountsResolver.resolve();
      }
      return this._accounts;
    }
    accounts(accounts) {
      this._autoResolveAccounts = true;
      this._accountsResolver.resolveOptionals(accounts);
      return this;
    }
    accountsStrict(accounts) {
      this._autoResolveAccounts = false;
      this._accountsResolver.resolveOptionals(accounts);
      return this;
    }
    signers(signers) {
      this._signers = this._signers.concat(signers);
      return this;
    }
    remainingAccounts(accounts) {
      this._remainingAccounts = this._remainingAccounts.concat(accounts);
      return this;
    }
    preInstructions(ixs) {
      this._preInstructions = this._preInstructions.concat(ixs);
      return this;
    }
    postInstructions(ixs) {
      this._postInstructions = this._postInstructions.concat(ixs);
      return this;
    }
    async rpc(options) {
      if (this._autoResolveAccounts) {
        await this._accountsResolver.resolve();
      }
      return this._rpcFn(...this._args, {
        accounts: this._accounts,
        signers: this._signers,
        remainingAccounts: this._remainingAccounts,
        preInstructions: this._preInstructions,
        postInstructions: this._postInstructions,
        options
      });
    }
    async rpcAndKeys(options) {
      const pubkeys = await this.pubkeys();
      return {
        pubkeys,
        signature: await this.rpc(options)
      };
    }
    async view(options) {
      if (this._autoResolveAccounts) {
        await this._accountsResolver.resolve();
      }
      if (!this._viewFn) {
        throw new Error("Method does not support views");
      }
      return this._viewFn(...this._args, {
        accounts: this._accounts,
        signers: this._signers,
        remainingAccounts: this._remainingAccounts,
        preInstructions: this._preInstructions,
        postInstructions: this._postInstructions,
        options
      });
    }
    async simulate(options) {
      if (this._autoResolveAccounts) {
        await this._accountsResolver.resolve();
      }
      return this._simulateFn(...this._args, {
        accounts: this._accounts,
        signers: this._signers,
        remainingAccounts: this._remainingAccounts,
        preInstructions: this._preInstructions,
        postInstructions: this._postInstructions,
        options
      });
    }
    async instruction() {
      if (this._autoResolveAccounts) {
        await this._accountsResolver.resolve();
      }
      return this._ixFn(...this._args, {
        accounts: this._accounts,
        signers: this._signers,
        remainingAccounts: this._remainingAccounts,
        preInstructions: this._preInstructions,
        postInstructions: this._postInstructions
      });
    }
    async prepare() {
      return {
        instruction: await this.instruction(),
        pubkeys: await this.pubkeys(),
        signers: await this._signers
      };
    }
    async transaction() {
      if (this._autoResolveAccounts) {
        await this._accountsResolver.resolve();
      }
      return this._txFn(...this._args, {
        accounts: this._accounts,
        signers: this._signers,
        remainingAccounts: this._remainingAccounts,
        preInstructions: this._preInstructions,
        postInstructions: this._postInstructions
      });
    }
  };
  var ViewFactory = class {
    static build(programId, idlIx, simulateFn, idl) {
      const isMut = idlIx.accounts.find((a) => a.isMut);
      const hasReturn = !!idlIx.returns;
      if (isMut || !hasReturn)
        return;
      const view = async (...args) => {
        var _a, _b;
        let simulationResult = await simulateFn(...args);
        const returnPrefix = `Program return: ${programId} `;
        let returnLog = simulationResult.raw.find((l2) => l2.startsWith(returnPrefix));
        if (!returnLog) {
          throw new Error("View expected return log");
        }
        let returnData = decode(returnLog.slice(returnPrefix.length));
        let returnType = idlIx.returns;
        if (!returnType) {
          throw new Error("View expected return type");
        }
        const coder = IdlCoder.fieldLayout({ type: returnType }, Array.from([...(_a = idl.accounts) !== null && _a !== void 0 ? _a : [], ...(_b = idl.types) !== null && _b !== void 0 ? _b : []]));
        return coder.decode(returnData);
      };
      return view;
    }
  };
  var NamespaceFactory = class {
    static build(idl, coder, programId, provider, getCustomResolver) {
      const rpc = {};
      const instruction = {};
      const transaction = {};
      const simulate = {};
      const methods = {};
      const view = {};
      const idlErrors = parseIdlErrors(idl);
      const account = idl.accounts ? AccountFactory.build(idl, coder, programId, provider) : {};
      idl.instructions.forEach((idlIx) => {
        const ixItem = InstructionNamespaceFactory.build(idlIx, (ixName, ix) => coder.instruction.encode(ixName, ix), programId);
        const txItem = TransactionFactory.build(idlIx, ixItem);
        const rpcItem = RpcFactory.build(idlIx, txItem, idlErrors, provider);
        const simulateItem = SimulateFactory.build(idlIx, txItem, idlErrors, provider, coder, programId, idl);
        const viewItem = ViewFactory.build(programId, idlIx, simulateItem, idl);
        const methodItem = MethodsBuilderFactory.build(provider, programId, idlIx, ixItem, txItem, rpcItem, simulateItem, viewItem, account, idl.types || [], getCustomResolver && getCustomResolver(idlIx));
        const name2 = (0, import_camelcase.default)(idlIx.name);
        instruction[name2] = ixItem;
        transaction[name2] = txItem;
        rpc[name2] = rpcItem;
        simulate[name2] = simulateItem;
        methods[name2] = methodItem;
        if (viewItem) {
          view[name2] = viewItem;
        }
      });
      return [
        rpc,
        instruction,
        transaction,
        account,
        simulate,
        methods,
        view
      ];
    }
  };
  var Program = class {
    get programId() {
      return this._programId;
    }
    get idl() {
      return this._idl;
    }
    get coder() {
      return this._coder;
    }
    get provider() {
      return this._provider;
    }
    constructor(idl, programId, provider, coder, getCustomResolver) {
      programId = translateAddress(programId);
      if (!provider) {
        provider = getProvider();
      }
      this._idl = idl;
      this._provider = provider;
      this._programId = programId;
      this._coder = coder !== null && coder !== void 0 ? coder : new BorshCoder(idl);
      this._events = new EventManager(this._programId, provider, this._coder);
      const [rpc, instruction, transaction, account, simulate, methods, views] = NamespaceFactory.build(idl, this._coder, programId, provider, getCustomResolver !== null && getCustomResolver !== void 0 ? getCustomResolver : () => void 0);
      this.rpc = rpc;
      this.instruction = instruction;
      this.transaction = transaction;
      this.account = account;
      this.simulate = simulate;
      this.methods = methods;
      this.views = views;
    }
    static async at(address, provider) {
      const programId = translateAddress(address);
      const idl = await Program.fetchIdl(programId, provider);
      if (!idl) {
        throw new Error(`IDL not found for program: ${address.toString()}`);
      }
      return new Program(idl, programId, provider);
    }
    static async fetchIdl(address, provider) {
      provider = provider !== null && provider !== void 0 ? provider : getProvider();
      const programId = translateAddress(address);
      const idlAddr = await idlAddress(programId);
      const accountInfo = await provider.connection.getAccountInfo(idlAddr);
      if (!accountInfo) {
        return null;
      }
      let idlAccount = decodeIdlAccount(accountInfo.data.slice(8));
      const inflatedIdl = inflate_1(idlAccount.data);
      return JSON.parse(decode$2(inflatedIdl));
    }
    addEventListener(eventName, callback) {
      return this._events.addEventListener(eventName, callback);
    }
    async removeEventListener(listener) {
      return await this._events.removeEventListener(listener);
    }
  };
  var SYSTEM_PROGRAM_ID = new PublicKey("11111111111111111111111111111111");

  // src/App/TokenDetails.tsx
  init_index_browser_esm();
  var import_whirlpools_sdk = __toESM(require_dist3());
  init_index_browser_esm2();
  var import_common_sdk = __toESM(require_dist4());

  // src/App/_helpers/formatPrice.ts
  init_virtual_process_polyfill();
  init_buffer();
  var formatterCompact = Intl.NumberFormat("en", {
    notation: "compact",
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  });
  var formatter = Intl.NumberFormat("en", {
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  });
  function formatPrice(price, compact = false) {
    const priceFloat = price ? price + 0 : 0;
    return compact ? formatterCompact.format(priceFloat) : formatter.format(priceFloat);
  }
  var formatPrice_default = formatPrice;

  // src/App/_helpers/filterChartData.ts
  init_virtual_process_polyfill();
  init_buffer();
  var timeLabel = (time) => {
    const date = new Date(time);
    return `${("0" + date.getHours()).slice(-2)}:${("0" + date.getMinutes()).slice(-2)}`;
  };
  var months = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sept",
    "Oct",
    "Nov",
    "Dec"
  ];
  var dateLabel = (time) => {
    const date = new Date(time);
    return `${months[date.getMonth()]} ${date.getDate()}`;
  };
  var yearLabel = (time) => {
    const date = new Date(time);
    return `${date.getFullYear()}`;
  };
  function filterChartData(chart, data) {
    if (!data) {
      return null;
    }
    switch (chart) {
      case "1H": {
        const time = 1e3 * 60 * 60;
        const points = data.filter(
          (point, i, a) => point[0] >= a[a.length - 1][0] - time
        );
        return {
          points,
          labels: [
            timeLabel(points[0][0]),
            timeLabel(points[Math.floor(points.length / 4)][0]),
            timeLabel(points[Math.floor(points.length * 2 / 4)][0]),
            timeLabel(points[Math.floor(points.length * 3 / 4)][0]),
            timeLabel(points[points.length - 1][0])
          ]
        };
      }
      case "1D": {
        const points = data.filter((_2, i, a) => i % 1 === 0 || i === a.length);
        return {
          points,
          labels: [
            timeLabel(points[0][0]),
            timeLabel(points[Math.floor(points.length * 1 / 4)][0]),
            timeLabel(points[Math.floor(points.length * 2 / 4)][0]),
            timeLabel(points[Math.floor(points.length * 3 / 4)][0]),
            timeLabel(points[points.length - 1][0])
          ]
        };
      }
      case "1W": {
        const time = 1e3 * 60 * 60 * 24 * 7;
        const points = data.filter(
          (point, i, a) => point[0] >= a[a.length - 1][0] - time
        );
        return {
          points,
          labels: [
            dateLabel(points[0][0]),
            dateLabel(points[Math.floor(points.length / 4)][0]),
            dateLabel(points[Math.floor(points.length * 2 / 4)][0]),
            dateLabel(points[Math.floor(points.length * 3 / 4)][0]),
            dateLabel(points[points.length - 1][0])
          ]
        };
      }
      case "1M": {
        const time = 1e3 * 60 * 60 * 24 * 30;
        const points = data.filter(
          (point, i, a) => point[0] >= a[a.length - 1][0] - time
        );
        return {
          points,
          labels: [
            dateLabel(points[0][0]),
            dateLabel(points[Math.floor(points.length / 4)][0]),
            dateLabel(points[Math.floor(points.length * 2 / 4)][0]),
            dateLabel(points[Math.floor(points.length * 3 / 4)][0]),
            dateLabel(points[points.length - 1][0])
          ]
        };
      }
      case "1Y": {
        const time = 1e3 * 60 * 60 * 24 * 365;
        const points = data.filter(
          (point, i, a) => point[0] >= a[a.length - 1][0] - time
        );
        return {
          points,
          labels: [
            dateLabel(points[0][0]),
            dateLabel(points[Math.floor(points.length * 1 / 4)][0]),
            dateLabel(points[Math.floor(points.length * 2 / 4)][0]),
            dateLabel(points[Math.floor(points.length * 3 / 4)][0]),
            dateLabel(points[points.length - 1][0])
          ]
        };
      }
      default: {
        const points = data;
        return {
          points: data,
          labels: [
            yearLabel(points[0][0]),
            yearLabel(points[Math.floor(points.length * 1 / 4)][0]),
            yearLabel(points[Math.floor(points.length * 2 / 4)][0]),
            yearLabel(points[Math.floor(points.length * 3 / 4)][0]),
            yearLabel(points[points.length - 1][0])
          ]
        };
      }
    }
  }
  var filterChartData_default = filterChartData;

  // src/App/StarIcon.tsx
  init_virtual_process_polyfill();
  init_buffer();
  var import_react11 = __toESM(require_react());

  // src/App/Icon.tsx
  init_virtual_process_polyfill();
  init_buffer();
  var import_react10 = __toESM(require_react());
  function Icon({
    path,
    pathHeight,
    pathWidth,
    height,
    width,
    color,
    isFilled = true,
    strokeWidth = 0,
    style = {}
  }) {
    return /* @__PURE__ */ import_react10.default.createElement(
      Svg,
      {
        key: path,
        width,
        height,
        viewBox: `-${strokeWidth} -${strokeWidth} ${pathHeight + strokeWidth * 2} ${pathWidth + strokeWidth * 2}`,
        fill: "none"
      },
      /* @__PURE__ */ import_react10.default.createElement(
        Path,
        {
          d: path,
          fill: isFilled ? color : "none",
          stroke: color,
          style: {
            strokeWidth,
            ...style
          }
        }
      )
    );
  }
  var Icon_default = Icon;

  // src/App/StarIcon.tsx
  function StarIcon({
    size,
    ...props
  }) {
    return /* @__PURE__ */ import_react11.default.createElement(
      Icon_default,
      {
        path: "M9.00001 14.5196L13.15 17.0296C13.91 17.4896 14.84 16.8096 14.64 15.9496L13.54 11.2296L17.21 8.04958C17.88 7.46958 17.52 6.36958 16.64 6.29958L11.81 5.88958L9.92001 1.42958C9.58001 0.619583 8.42001 0.619583 8.08001 1.42958L6.19001 5.87958L1.36001 6.28958C0.480012 6.35958 0.120012 7.45958 0.790012 8.03958L4.46001 11.2196L3.36001 15.9396C3.16001 16.7996 4.09001 17.4796 4.85001 17.0196L9.00001 14.5196Z",
        pathWidth: 18,
        pathHeight: 18,
        height: size,
        width: size,
        ...props
      }
    );
  }
  var StarIcon_default = StarIcon;

  // src/App/_hooks/useRefreshTokenChart.ts
  init_virtual_process_polyfill();
  init_buffer();
  var import_react12 = __toESM(require_react());

  // src/App/_helpers/getChartDataTime.ts
  init_virtual_process_polyfill();
  init_buffer();
  var getChartDataTime = (chart) => ["1H", "1D"].includes(chart) ? "minute" : ["1W", "1M"].includes(chart) ? "hour" : "day";

  // src/App/_types/ChartDataType.ts
  init_virtual_process_polyfill();
  init_buffer();
  var ChartDataType = type({
    prices: array(GraphDataPointType)
  });

  // src/App/_hooks/useRefreshTokenChart.ts
  var refreshtime2 = 1e3 * 60;
  var getUrl = (tokenId, chart) => {
    const days = ["1H", "1D"].includes(chart) ? "1" : ["1W", "1M"].includes(chart) ? "90" : "max";
    return `https://api.coingecko.com/api/v3/coins/${tokenId}/market_chart?vs_currency=usd&days=${days}`;
  };
  function useRefreshTokenChart(tokenId, chart) {
    const dispatch = useDispatch();
    (0, import_react12.useEffect)(() => {
      const fetchTokenChart = () => {
        fetch(getUrl(tokenId, chart)).then((r) => r.json()).then((chartData) => {
          if (ChartDataType.is(chartData)) {
            dispatch(
              SET_TOKEN_CHART({
                tokenId,
                chartData: {
                  [getChartDataTime(chart)]: chartData.prices
                }
              })
            );
          } else {
            throw ChartDataType.validate(chartData)[0];
          }
        }).catch((e) => {
          console.error(e, "refreshing in", refreshtime2);
        });
      };
      fetchTokenChart();
      const refresh = setInterval(fetchTokenChart, refreshtime2);
      return () => {
        clearInterval(refresh);
      };
    }, [tokenId, chart]);
  }
  var useRefreshTokenChart_default = useRefreshTokenChart;

  // src/App/ArrowUpIcon.tsx
  init_virtual_process_polyfill();
  init_buffer();
  var import_react13 = __toESM(require_react());
  function ArrowUpIcon({
    ...props
  }) {
    return /* @__PURE__ */ import_react13.default.createElement(
      Icon_default,
      {
        path: "M5.40879 0.188874C5.36019 0.129815 5.29912 0.0822487 5.22996 0.0495925C5.1608 0.0169363 5.08527 0 5.00879 0C4.93231 0 4.85677 0.0169363 4.78761 0.0495925C4.71845 0.0822487 4.65738 0.129815 4.60879 0.188874L0.108789 6.18887C0.0530757 6.26316 0.0191486 6.35149 0.0108096 6.44397C0.00247066 6.53645 0.0200492 6.62943 0.0615756 6.71248C0.103102 6.79553 0.166936 6.86538 0.245924 6.9142C0.324912 6.96302 0.415933 6.98887 0.508789 6.98887H9.50879C9.60164 6.98887 9.69267 6.96302 9.77165 6.9142C9.85064 6.86538 9.91447 6.79553 9.956 6.71248C9.99753 6.62943 10.0151 6.53645 10.0068 6.44397C9.99843 6.35149 9.9645 6.26316 9.90879 6.18887L5.40879 0.188874Z",
        pathWidth: 10,
        pathHeight: 7,
        ...props
      }
    );
  }
  var ArrowUpIcon_default = ArrowUpIcon;

  // src/App/ArrowDownIcon.tsx
  init_virtual_process_polyfill();
  init_buffer();
  var import_react14 = __toESM(require_react());
  function ArrowDownIcon({
    ...props
  }) {
    return /* @__PURE__ */ import_react14.default.createElement(
      Icon_default,
      {
        path: "M5.4 6.81113C5.3514 6.87019 5.29033 6.91775 5.22117 6.95041C5.15201 6.98306 5.07648 7 5 7C4.92352 7 4.84798 6.98306 4.77882 6.95041C4.70966 6.91775 4.64859 6.87019 4.6 6.81113L0.1 0.811127C0.0442867 0.736842 0.0103596 0.64851 0.00202058 0.556029C-0.0063184 0.463549 0.0112601 0.370572 0.0527866 0.287519C0.094313 0.204466 0.158147 0.134618 0.237135 0.0858011C0.316123 0.036984 0.407144 0.0111265 0.5 0.0111265H9.5C9.59285 0.0111265 9.68388 0.036984 9.76287 0.0858011C9.84185 0.134618 9.90569 0.204466 9.94721 0.287519C9.98874 0.370572 10.0063 0.463549 9.99798 0.556029C9.98964 0.64851 9.95571 0.736842 9.9 0.811127L5.4 6.81113Z",
        pathWidth: 10,
        pathHeight: 7,
        ...props
      }
    );
  }
  var ArrowDownIcon_default = ArrowDownIcon;

  // src/App/TokenDetails.tsx
  var import_token = __toESM(require_token());
  init_index_browser_esm();

  // src/App/thread_program.ts
  init_virtual_process_polyfill();
  init_buffer();
  var IDL = {
    version: "1.3.15",
    name: "thread_program",
    docs: ["Program for creating transaction threads on Solana."],
    instructions: [
      {
        name: "getCrateInfo",
        docs: [
          "Return the crate information via `sol_set_return_data/sol_get_return_data`"
        ],
        accounts: [
          {
            name: "systemProgram",
            isMut: false,
            isSigner: false
          }
        ],
        args: [],
        returns: {
          defined: "CrateInfo"
        }
      },
      {
        name: "threadExec",
        docs: ["Executes the next instruction on thread."],
        accounts: [
          {
            name: "fee",
            isMut: true,
            isSigner: false,
            docs: ["The worker's fee account."]
          },
          {
            name: "penalty",
            isMut: true,
            isSigner: false,
            docs: ["The worker's penalty account."]
          },
          {
            name: "pool",
            isMut: false,
            isSigner: false,
            docs: ["The active worker pool."]
          },
          {
            name: "signatory",
            isMut: true,
            isSigner: true,
            docs: ["The signatory."]
          },
          {
            name: "thread",
            isMut: true,
            isSigner: false,
            docs: ["The thread to execute."]
          },
          {
            name: "worker",
            isMut: false,
            isSigner: false,
            docs: ["The worker."]
          }
        ],
        args: []
      },
      {
        name: "threadCreate",
        docs: ["Creates a new transaction thread."],
        accounts: [
          {
            name: "authority",
            isMut: false,
            isSigner: true,
            docs: ["The authority (owner) of the thread."]
          },
          {
            name: "payer",
            isMut: true,
            isSigner: true,
            docs: ["The payer for account initializations."]
          },
          {
            name: "systemProgram",
            isMut: false,
            isSigner: false,
            docs: ["The Solana system program."]
          },
          {
            name: "thread",
            isMut: true,
            isSigner: false,
            docs: ["The thread to be created."]
          }
        ],
        args: [
          {
            name: "id",
            type: "string"
          },
          {
            name: "kickoffInstruction",
            type: {
              defined: "InstructionData"
            }
          },
          {
            name: "trigger",
            type: {
              defined: "Trigger"
            }
          }
        ]
      },
      {
        name: "threadDelete",
        docs: [
          "Closes an existing thread account and returns the lamports to the owner."
        ],
        accounts: [
          {
            name: "authority",
            isMut: false,
            isSigner: true,
            docs: ["The authority (owner) of the thread."]
          },
          {
            name: "closeTo",
            isMut: true,
            isSigner: false,
            docs: ["The address to return the data rent lamports to."]
          },
          {
            name: "thread",
            isMut: true,
            isSigner: false,
            docs: ["The thread to be delete."]
          }
        ],
        args: []
      },
      {
        name: "threadKickoff",
        docs: ["Kicks off a thread if its trigger condition is active."],
        accounts: [
          {
            name: "signatory",
            isMut: true,
            isSigner: true,
            docs: ["The signatory."]
          },
          {
            name: "thread",
            isMut: true,
            isSigner: false,
            docs: ["The thread to kickoff."]
          },
          {
            name: "worker",
            isMut: false,
            isSigner: false,
            docs: ["The worker."]
          }
        ],
        args: []
      },
      {
        name: "threadPause",
        docs: ["Pauses an active thread."],
        accounts: [
          {
            name: "authority",
            isMut: false,
            isSigner: true,
            docs: ["The authority (owner) of the thread."]
          },
          {
            name: "thread",
            isMut: true,
            isSigner: false,
            docs: ["The thread to be paused."]
          }
        ],
        args: []
      },
      {
        name: "threadResume",
        docs: ["Resumes a paused thread."],
        accounts: [
          {
            name: "authority",
            isMut: false,
            isSigner: true,
            docs: ["The authority (owner) of the thread."]
          },
          {
            name: "thread",
            isMut: true,
            isSigner: false,
            docs: ["The thread to be resumed."]
          }
        ],
        args: []
      },
      {
        name: "threadStop",
        docs: ["Resumes a paused thread."],
        accounts: [
          {
            name: "authority",
            isMut: false,
            isSigner: true,
            docs: ["The authority (owner) of the thread."]
          },
          {
            name: "thread",
            isMut: true,
            isSigner: false,
            docs: ["The thread to be paused."]
          }
        ],
        args: []
      },
      {
        name: "threadUpdate",
        docs: ["Allows an owner to update the mutable properties of a thread."],
        accounts: [
          {
            name: "authority",
            isMut: true,
            isSigner: true,
            docs: ["The authority (owner) of the thread."]
          },
          {
            name: "systemProgram",
            isMut: false,
            isSigner: false,
            docs: ["The Solana system program"]
          },
          {
            name: "thread",
            isMut: true,
            isSigner: false,
            docs: ["The thread to be updated."]
          }
        ],
        args: [
          {
            name: "settings",
            type: {
              defined: "ThreadSettings"
            }
          }
        ]
      },
      {
        name: "threadWithdraw",
        docs: ["Allows an owner to withdraw from a thread's lamport balance."],
        accounts: [
          {
            name: "authority",
            isMut: false,
            isSigner: true,
            docs: ["The authority (owner) of the thread."]
          },
          {
            name: "payTo",
            isMut: true,
            isSigner: false,
            docs: ["The account to withdraw lamports to."]
          },
          {
            name: "thread",
            isMut: true,
            isSigner: false,
            docs: ["The thread to be."]
          }
        ],
        args: [
          {
            name: "amount",
            type: "u64"
          }
        ]
      }
    ],
    accounts: [
      {
        name: "thread",
        docs: ["Tracks the current state of a transaction thread on Solana."],
        type: {
          kind: "struct",
          fields: [
            {
              name: "authority",
              docs: ["The owner of this thread."],
              type: "publicKey"
            },
            {
              name: "createdAt",
              docs: ["The cluster clock at the moment the thread was created."],
              type: {
                defined: "ClockData"
              }
            },
            {
              name: "execContext",
              docs: ["The context of the thread's current execution state."],
              type: {
                option: {
                  defined: "ExecContext"
                }
              }
            },
            {
              name: "fee",
              docs: [
                "The number of lamports to payout to workers per execution."
              ],
              type: "u64"
            },
            {
              name: "id",
              docs: ["The id of the thread, given by the authority."],
              type: "string"
            },
            {
              name: "kickoffInstruction",
              docs: ["The instruction to kick-off the thread."],
              type: {
                defined: "InstructionData"
              }
            },
            {
              name: "nextInstruction",
              docs: ["The next instruction in the thread."],
              type: {
                option: {
                  defined: "InstructionData"
                }
              }
            },
            {
              name: "paused",
              docs: ["Whether or not the thread is currently paused."],
              type: "bool"
            },
            {
              name: "rateLimit",
              docs: ["The maximum number of execs allowed per slot."],
              type: "u64"
            },
            {
              name: "trigger",
              docs: ["The triggering event to kickoff a thread."],
              type: {
                defined: "Trigger"
              }
            }
          ]
        }
      }
    ],
    types: [
      {
        name: "ThreadSettings",
        docs: ["The properties of threads which are updatable."],
        type: {
          kind: "struct",
          fields: [
            {
              name: "fee",
              type: {
                option: "u64"
              }
            },
            {
              name: "kickoffInstruction",
              type: {
                option: {
                  defined: "InstructionData"
                }
              }
            },
            {
              name: "rateLimit",
              type: {
                option: "u64"
              }
            },
            {
              name: "trigger",
              type: {
                option: {
                  defined: "Trigger"
                }
              }
            }
          ]
        }
      },
      {
        name: "ExecContext",
        docs: ["The execution context of a particular transaction thread."],
        type: {
          kind: "struct",
          fields: [
            {
              name: "execsSinceReimbursement",
              docs: ["Number of execs since the last tx reimbursement."],
              type: "u64"
            },
            {
              name: "execsSinceSlot",
              docs: ["Number of execs in this slot."],
              type: "u64"
            },
            {
              name: "lastExecAt",
              docs: ["Slot of the last exec"],
              type: "u64"
            },
            {
              name: "triggerContext",
              docs: ["Context for the triggering condition"],
              type: {
                defined: "TriggerContext"
              }
            }
          ]
        }
      },
      {
        name: "ClockData",
        docs: [
          "The clock object, representing a specific moment in time recorded by a Solana cluster."
        ],
        type: {
          kind: "struct",
          fields: [
            {
              name: "slot",
              docs: ["The current slot."],
              type: "u64"
            },
            {
              name: "epochStartTimestamp",
              docs: ["The timestamp of the first slot in this Solana epoch."],
              type: "i64"
            },
            {
              name: "epoch",
              docs: ["The bank epoch."],
              type: "u64"
            },
            {
              name: "leaderScheduleEpoch",
              docs: [
                "The future epoch for which the leader schedule has most recently been calculated."
              ],
              type: "u64"
            },
            {
              name: "unixTimestamp",
              docs: [
                "Originally computed from genesis creation time and network time",
                "in slots (drifty); corrected using validator timestamp oracle as of",
                "timestamp_correction and timestamp_bounding features."
              ],
              type: "i64"
            }
          ]
        }
      },
      {
        name: "ThreadResponse",
        docs: [
          "A response value target programs can return to update the thread."
        ],
        type: {
          kind: "struct",
          fields: [
            {
              name: "kickoffInstruction",
              docs: [
                "The kickoff instruction to use on the next triggering of the thread.",
                "If none, the kickoff instruction remains unchanged."
              ],
              type: {
                option: {
                  defined: "InstructionData"
                }
              }
            },
            {
              name: "nextInstruction",
              docs: [
                "The next instruction to use on the next execution of the thread."
              ],
              type: {
                option: {
                  defined: "InstructionData"
                }
              }
            }
          ]
        }
      },
      {
        name: "InstructionData",
        docs: ["The data needed execute an instruction on Solana."],
        type: {
          kind: "struct",
          fields: [
            {
              name: "programId",
              docs: [
                "Pubkey of the instruction processor that executes this instruction"
              ],
              type: "publicKey"
            },
            {
              name: "accounts",
              docs: [
                "Metadata for what accounts should be passed to the instruction processor"
              ],
              type: {
                vec: {
                  defined: "AccountMetaData"
                }
              }
            },
            {
              name: "data",
              docs: ["Opaque data passed to the instruction processor"],
              type: "bytes"
            }
          ]
        }
      },
      {
        name: "AccountMetaData",
        docs: ["Account metadata needed to execute an instruction on Solana."],
        type: {
          kind: "struct",
          fields: [
            {
              name: "pubkey",
              docs: ["An account's public key"],
              type: "publicKey"
            },
            {
              name: "isSigner",
              docs: [
                "True if an Instruction requires a Transaction signature matching `pubkey`."
              ],
              type: "bool"
            },
            {
              name: "isWritable",
              docs: [
                "True if the `pubkey` can be loaded as a read-write account."
              ],
              type: "bool"
            }
          ]
        }
      },
      {
        name: "Trigger",
        docs: ["The triggering conditions of a thread."],
        type: {
          kind: "enum",
          variants: [
            {
              name: "Account",
              fields: [
                {
                  name: "address",
                  docs: ["The address of the account to monitor."],
                  type: "publicKey"
                },
                {
                  name: "offset",
                  docs: ["The byte offset of the account data to monitor."],
                  type: "u64"
                },
                {
                  name: "size",
                  docs: [
                    "The size of the byte slice to monitor (must be less than 1kb)"
                  ],
                  type: "u64"
                }
              ]
            },
            {
              name: "Cron",
              fields: [
                {
                  name: "schedule",
                  docs: [
                    "The schedule in cron syntax. Value must be parsable by the `clockwork_cron` package."
                  ],
                  type: "string"
                },
                {
                  name: "skippable",
                  docs: [
                    "Boolean value indicating whether triggering moments may be skipped if they are missed (e.g. due to network downtime).",
                    'If false, any "missed" triggering moments will simply be executed as soon as the network comes back online.'
                  ],
                  type: "bool"
                }
              ]
            },
            {
              name: "Immediate"
            }
          ]
        }
      },
      {
        name: "TriggerContext",
        docs: [
          "The event which allowed a particular transaction thread to be triggered."
        ],
        type: {
          kind: "enum",
          variants: [
            {
              name: "Account",
              fields: [
                {
                  name: "data_hash",
                  docs: ["The account's data hash."],
                  type: "u64"
                }
              ]
            },
            {
              name: "Cron",
              fields: [
                {
                  name: "started_at",
                  docs: ["The threshold moment the schedule was waiting for."],
                  type: "i64"
                }
              ]
            },
            {
              name: "Immediate"
            }
          ]
        }
      }
    ],
    errors: [
      {
        code: 6e3,
        name: "InvalidThreadResponse",
        msg: "The exec response could not be parsed"
      },
      {
        code: 6001,
        name: "InvalidThreadState",
        msg: "The thread is in an invalid state"
      },
      {
        code: 6002,
        name: "TriggerNotActive",
        msg: "The trigger condition has not been activated"
      },
      {
        code: 6003,
        name: "ThreadBusy",
        msg: "This operation cannot be processes because the thread is currently busy"
      },
      {
        code: 6004,
        name: "ThreadPaused",
        msg: "The thread is currently paused"
      },
      {
        code: 6005,
        name: "RateLimitExeceeded",
        msg: "The thread's rate limit has been reached"
      },
      {
        code: 6006,
        name: "MaxRateLimitExceeded",
        msg: "Thread rate limits cannot exceed the maximum allowed value"
      },
      {
        code: 6007,
        name: "UnauthorizedWrite",
        msg: "Inner instruction attempted to write to an unauthorized address"
      },
      {
        code: 6008,
        name: "WithdrawalTooLarge",
        msg: "Withdrawing this amount would leave the thread with less than the minimum required SOL for rent exemption"
      }
    ]
  };

  // src/App/cpi_thready.json
  var cpi_thready_exports = {};
  __export(cpi_thready_exports, {
    default: () => cpi_thready_default,
    instructions: () => instructions,
    name: () => name,
    types: () => types,
    version: () => version3
  });
  var version3 = "0.1.0";
  var name = "cpi_whirlpool_anchor_gen_v0250";
  var instructions = [
    {
      name: "verifyWhirlpoolsConfigAccount",
      accounts: [
        {
          name: "whirlpoolsConfig",
          isMut: false,
          isSigner: false
        }
      ],
      args: []
    },
    {
      name: "verifyFeetierAccount",
      accounts: [
        {
          name: "feetier",
          isMut: false,
          isSigner: false
        }
      ],
      args: []
    },
    {
      name: "verifyWhirlpoolAccount",
      accounts: [
        {
          name: "whirlpool",
          isMut: false,
          isSigner: false
        }
      ],
      args: []
    },
    {
      name: "verifyTickarrayAccount",
      accounts: [
        {
          name: "tickarray",
          isMut: false,
          isSigner: false
        }
      ],
      args: [
        {
          name: "sampling1",
          type: "u32"
        },
        {
          name: "sampling2",
          type: "u32"
        },
        {
          name: "sampling3",
          type: "u32"
        },
        {
          name: "sampling4",
          type: "u32"
        },
        {
          name: "sampling5",
          type: "u32"
        },
        {
          name: "sampling6",
          type: "u32"
        },
        {
          name: "sampling7",
          type: "u32"
        },
        {
          name: "sampling8",
          type: "u32"
        }
      ]
    },
    {
      name: "verifyPositionAccount",
      accounts: [
        {
          name: "position",
          isMut: false,
          isSigner: false
        }
      ],
      args: []
    },
    {
      name: "proxySwap",
      accounts: [
        {
          name: "hydra",
          isMut: false,
          isSigner: true
        },
        {
          name: "whirlpoolProgram",
          isMut: false,
          isSigner: false
        },
        {
          name: "tokenProgram",
          isMut: false,
          isSigner: false
        },
        {
          name: "whirlpool",
          isMut: true,
          isSigner: false
        },
        {
          name: "tokenOwnerAccountA",
          isMut: true,
          isSigner: false
        },
        {
          name: "tokenVaultA",
          isMut: true,
          isSigner: false
        },
        {
          name: "tokenOwnerAccountB",
          isMut: true,
          isSigner: false
        },
        {
          name: "tokenVaultB",
          isMut: true,
          isSigner: false
        },
        {
          name: "tickArray0",
          isMut: true,
          isSigner: false
        },
        {
          name: "tickArray1",
          isMut: true,
          isSigner: false
        },
        {
          name: "tickArray2",
          isMut: true,
          isSigner: false
        },
        {
          name: "oracle",
          isMut: false,
          isSigner: false
        },
        {
          name: "authority",
          isMut: false,
          isSigner: false
        }
      ],
      args: [
        {
          name: "amount",
          type: "u64"
        },
        {
          name: "otherAmountThreshold",
          type: "u64"
        },
        {
          name: "sqrtPriceLimit",
          type: "u128"
        },
        {
          name: "amountSpecifiedIsInput",
          type: "bool"
        },
        {
          name: "aToB",
          type: "bool"
        },
        {
          name: "bump",
          type: "u8"
        }
      ],
      returns: {
        defined: "ThreadResponse"
      }
    },
    {
      name: "proxyOpenPosition",
      accounts: [
        {
          name: "whirlpoolProgram",
          isMut: false,
          isSigner: false
        },
        {
          name: "funder",
          isMut: true,
          isSigner: true
        },
        {
          name: "dev",
          isMut: true,
          isSigner: false
        },
        {
          name: "owner",
          isMut: false,
          isSigner: false
        },
        {
          name: "position",
          isMut: true,
          isSigner: false
        },
        {
          name: "positionMint",
          isMut: true,
          isSigner: true
        },
        {
          name: "positionTokenAccount",
          isMut: true,
          isSigner: false
        },
        {
          name: "whirlpool",
          isMut: false,
          isSigner: false
        },
        {
          name: "tokenProgram",
          isMut: false,
          isSigner: false
        },
        {
          name: "systemProgram",
          isMut: false,
          isSigner: false
        },
        {
          name: "rent",
          isMut: false,
          isSigner: false
        },
        {
          name: "associatedTokenProgram",
          isMut: false,
          isSigner: false
        },
        {
          name: "recentBlockhashes",
          isMut: false,
          isSigner: false
        }
      ],
      args: [
        {
          name: "bumps",
          type: {
            defined: "OpenPositionBumps"
          }
        }
      ]
    },
    {
      name: "proxyIncreaseLiquidity",
      accounts: [
        {
          name: "hydra",
          isMut: false,
          isSigner: true
        },
        {
          name: "whirlpoolProgram",
          isMut: false,
          isSigner: false
        },
        {
          name: "whirlpool",
          isMut: true,
          isSigner: false
        },
        {
          name: "tokenProgram",
          isMut: false,
          isSigner: false
        },
        {
          name: "position",
          isMut: true,
          isSigner: false
        },
        {
          name: "positionTokenAccount",
          isMut: false,
          isSigner: false
        },
        {
          name: "tokenOwnerAccountA",
          isMut: true,
          isSigner: false
        },
        {
          name: "tokenOwnerAccountB",
          isMut: true,
          isSigner: false
        },
        {
          name: "tokenVaultA",
          isMut: true,
          isSigner: false
        },
        {
          name: "tokenVaultB",
          isMut: true,
          isSigner: false
        },
        {
          name: "tickArrayLower",
          isMut: true,
          isSigner: false
        },
        {
          name: "tickArrayUpper",
          isMut: true,
          isSigner: false
        },
        {
          name: "authority",
          isMut: false,
          isSigner: false
        }
      ],
      args: [
        {
          name: "liquidity",
          type: "u128"
        },
        {
          name: "tokenMaxA",
          type: "u64"
        },
        {
          name: "tokenMaxB",
          type: "u64"
        },
        {
          name: "bump",
          type: "u8"
        }
      ],
      returns: {
        defined: "ThreadResponse"
      }
    },
    {
      name: "proxyDecreaseLiquidity",
      accounts: [
        {
          name: "hydra",
          isMut: false,
          isSigner: true
        },
        {
          name: "whirlpoolProgram",
          isMut: false,
          isSigner: false
        },
        {
          name: "whirlpool",
          isMut: true,
          isSigner: false
        },
        {
          name: "tokenProgram",
          isMut: false,
          isSigner: false
        },
        {
          name: "position",
          isMut: true,
          isSigner: false
        },
        {
          name: "positionTokenAccount",
          isMut: false,
          isSigner: false
        },
        {
          name: "tokenOwnerAccountA",
          isMut: true,
          isSigner: false
        },
        {
          name: "tokenOwnerAccountB",
          isMut: true,
          isSigner: false
        },
        {
          name: "tokenVaultA",
          isMut: true,
          isSigner: false
        },
        {
          name: "tokenVaultB",
          isMut: true,
          isSigner: false
        },
        {
          name: "tickArrayLower",
          isMut: true,
          isSigner: false
        },
        {
          name: "tickArrayUpper",
          isMut: true,
          isSigner: false
        },
        {
          name: "authority",
          isMut: false,
          isSigner: false
        }
      ],
      args: [
        {
          name: "bump",
          type: "u8"
        }
      ],
      returns: {
        defined: "ThreadResponse"
      }
    },
    {
      name: "proxyUpdateFeesAndRewards",
      accounts: [
        {
          name: "hydra",
          isMut: false,
          isSigner: true
        },
        {
          name: "whirlpoolProgram",
          isMut: false,
          isSigner: false
        },
        {
          name: "whirlpool",
          isMut: true,
          isSigner: false
        },
        {
          name: "position",
          isMut: true,
          isSigner: false
        },
        {
          name: "tickArrayLower",
          isMut: true,
          isSigner: false
        },
        {
          name: "tickArrayUpper",
          isMut: true,
          isSigner: false
        },
        {
          name: "authority",
          isMut: false,
          isSigner: false
        }
      ],
      args: [
        {
          name: "bump",
          type: "u8"
        }
      ],
      returns: {
        defined: "ThreadResponse"
      }
    },
    {
      name: "proxyCollectFees",
      accounts: [
        {
          name: "hydra",
          isMut: false,
          isSigner: true
        },
        {
          name: "whirlpoolProgram",
          isMut: false,
          isSigner: false
        },
        {
          name: "whirlpool",
          isMut: false,
          isSigner: false
        },
        {
          name: "position",
          isMut: true,
          isSigner: false
        },
        {
          name: "positionTokenAccount",
          isMut: false,
          isSigner: false
        },
        {
          name: "tokenOwnerAccountA",
          isMut: true,
          isSigner: false
        },
        {
          name: "tokenVaultA",
          isMut: true,
          isSigner: false
        },
        {
          name: "tokenOwnerAccountB",
          isMut: true,
          isSigner: false
        },
        {
          name: "tokenVaultB",
          isMut: true,
          isSigner: false
        },
        {
          name: "tokenProgram",
          isMut: false,
          isSigner: false
        },
        {
          name: "authority",
          isMut: false,
          isSigner: false
        }
      ],
      args: [
        {
          name: "bump",
          type: "u8"
        }
      ],
      returns: {
        defined: "ThreadResponse"
      }
    },
    {
      name: "proxyCollectReward",
      accounts: [
        {
          name: "hydra",
          isMut: false,
          isSigner: true
        },
        {
          name: "whirlpoolProgram",
          isMut: false,
          isSigner: false
        },
        {
          name: "whirlpool",
          isMut: false,
          isSigner: false
        },
        {
          name: "position",
          isMut: true,
          isSigner: false
        },
        {
          name: "positionTokenAccount",
          isMut: false,
          isSigner: false
        },
        {
          name: "rewardOwnerAccount",
          isMut: true,
          isSigner: false
        },
        {
          name: "rewardVault",
          isMut: true,
          isSigner: false
        },
        {
          name: "tokenProgram",
          isMut: false,
          isSigner: false
        },
        {
          name: "authority",
          isMut: false,
          isSigner: false
        }
      ],
      args: [
        {
          name: "rewardIndex",
          type: "u8"
        },
        {
          name: "bump",
          type: "u8"
        }
      ],
      returns: {
        defined: "ThreadResponse"
      }
    },
    {
      name: "proxyClosePosition",
      accounts: [
        {
          name: "hydra",
          isMut: false,
          isSigner: true
        },
        {
          name: "whirlpoolProgram",
          isMut: false,
          isSigner: false
        },
        {
          name: "whirlpool",
          isMut: true,
          isSigner: false
        },
        {
          name: "receiver",
          isMut: true,
          isSigner: false
        },
        {
          name: "position",
          isMut: true,
          isSigner: false
        },
        {
          name: "positionMint",
          isMut: true,
          isSigner: false
        },
        {
          name: "positionTokenAccount",
          isMut: true,
          isSigner: false
        },
        {
          name: "tokenProgram",
          isMut: false,
          isSigner: false
        },
        {
          name: "authority",
          isMut: false,
          isSigner: false
        }
      ],
      args: [
        {
          name: "bump",
          type: "u8"
        }
      ],
      returns: {
        defined: "ThreadResponse"
      }
    }
  ];
  var types = [
    {
      name: "OpenPositionBumps",
      type: {
        kind: "struct",
        fields: [
          {
            name: "positionBump",
            type: "u8"
          }
        ]
      }
    }
  ];
  var cpi_thready_default = {
    version: version3,
    name,
    instructions,
    types
  };

  // src/App/TokenDetails.tsx
  var CLOCKWORK_THREAD_PROGRAM_ID = new PublicKey(
    "3XXuUFfweXBwFgFfYaejLvZE4cGZiHgKiGfMtdxNzYmv"
  );
  var SOL = { mint: new PublicKey("So11111111111111111111111111111111111111112"), decimals: 9 };
  var ORCA = { mint: new PublicKey("orcaEKTdK7LKz57vaAYr9QeNsVEPfiu6QeMU1kektZE"), decimals: 6 };
  var BONK = { mint: new PublicKey("DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263"), decimals: 5 };
  var USDC = { mint: new PublicKey("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"), decimals: 6 };
  function TokenDetails(props) {
    const tokenId = props.token.id;
    const { isFavorited, activeChart, chartData } = props;
    console.log(isFavorited);
    const dispatch = useDispatch();
    const provider = new AnchorProvider2(useConnection(), window.xnft.solana, {});
    useRefreshTokenChart_default(tokenId, activeChart);
    const data = filterChartData_default(activeChart, chartData);
    const start = data?.points[0];
    const end = data?.points[data?.points.length - 1];
    const currentPrice = formatPrice_default(props.token.current_price);
    let changeCurrencyNum = props.token.price_change_percentage_24h ?? 0;
    let changePercentNum = props.token.price_change_percentage_24h ?? 0;
    if (start && end) {
      changeCurrencyNum = end[1] - start[1];
      changePercentNum = changeCurrencyNum * 100 / start[1];
    }
    const changeCurrency = formatPrice_default(changeCurrencyNum);
    const changePercent = formatPrice_default(changePercentNum);
    const Arrow = changeCurrencyNum > 0 ? /* @__PURE__ */ import_react15.default.createElement(ArrowUpIcon_default, { isFilled: true, color: green, height: 11, width: 16 }) : /* @__PURE__ */ import_react15.default.createElement(ArrowDownIcon_default, { isFilled: true, color: red, height: 11, width: 16 });
    const color = changeCurrencyNum > 0 ? green : red;
    const colorButton = changeCurrencyNum > 0 ? green : red;
    let connection = useConnection();
    let wallet = usePublicKey();
    async function doathing() {
      let tokens = await connection.getParsedTokenAccountsByOwner(wallet, { programId: import_token.TOKEN_PROGRAM_ID });
      let usdcBal = 0;
      let bonkBal = 0;
      console.log(tokens.value.length);
      for (var t2 of tokens.value) {
        if (t2.account.data.parsed.info.mint == props.token.tokenA) {
          usdcBal = t2.account.data.parsed.info.tokenAmount.uiAmount;
          console.log("usdcBal", usdcBal);
        }
        if (t2.account.data.parsed.info.mint == props.token.tokenB) {
          bonkBal = t2.account.data.parsed.info.tokenAmount.uiAmount;
          console.log("bonkBal", bonkBal);
        }
      }
      const program = new Program(cpi_thready_exports, CLOCKWORK_THREAD_PROGRAM_ID, provider);
      const [authority, bump] = PublicKey.findProgramAddressSync([Buffer.from("authority")], program.programId);
      const SEED_QUEUE = "thread";
      const fetcher = new import_whirlpools_sdk.AccountFetcher(connection);
      const whirlpool_ctx = import_whirlpools_sdk.WhirlpoolContext.from(connection, window.xnft.solana, import_whirlpools_sdk.ORCA_WHIRLPOOL_PROGRAM_ID, fetcher);
      const whirlpool_client = (0, import_whirlpools_sdk.buildWhirlpoolClient)(whirlpool_ctx);
      for (var pool of [props.token]) {
        pool = pool.id;
        let tx = new import_common_sdk.TransactionBuilder(connection, window.xnft.solana);
        const samo_usdc_whirlpool_pubkey = new PublicKey(pool);
        const position_mint_keypair = Keypair.generate();
        const position_mint = position_mint_keypair.publicKey;
        const position_pda = import_whirlpools_sdk.PDAUtil.getPosition(import_whirlpools_sdk.ORCA_WHIRLPOOL_PROGRAM_ID, position_mint);
        const position_ta = await (0, import_common_sdk.deriveATA)(wallet, position_mint);
        const bumps = { positionBump: position_pda.bump };
        const tick_lower_index = import_whirlpools_sdk.PriceMath.priceToInitializableTickIndex(import_common_sdk.DecimalUtil.fromNumber(0.01), BONK.decimals, USDC.decimals, 64);
        const tick_upper_index = import_whirlpools_sdk.PriceMath.priceToInitializableTickIndex(import_common_sdk.DecimalUtil.fromNumber(0.02), BONK.decimals, USDC.decimals, 64);
        var threadName = Math.floor(Math.random() * 99999).toString();
        var [hydra] = PublicKey.findProgramAddressSync(
          [Buffer.from(SEED_QUEUE, "utf-8"), wallet.toBuffer(), Buffer.from(threadName, "utf-8")],
          CLOCKWORK_THREAD_PROGRAM_ID
        );
        console.log(hydra.toBase58());
        tx.addInstruction({ instructions: [SystemProgram.transfer({
          fromPubkey: wallet,
          toPubkey: hydra,
          lamports: 666e-5 * 10 ** 9
        })], signers: [], cleanupInstructions: [] });
        var ix = await program.methods.proxyOpenPosition(
          bumps
        ).accounts({
          hydra,
          whirlpoolProgram: import_whirlpools_sdk.ORCA_WHIRLPOOL_PROGRAM_ID,
          funder: wallet,
          dev: new PublicKey("Gf3sbc5Jb62jH7WcTr3WSNGDQLk1w6wcKMZXKK1SC1E6"),
          owner: wallet,
          position: position_pda.publicKey,
          positionMint: position_mint,
          positionTokenAccount: position_ta,
          whirlpool: samo_usdc_whirlpool_pubkey,
          tokenProgram: import_token.TOKEN_PROGRAM_ID,
          systemProgram: SystemProgram.programId,
          rent: SYSVAR_RENT_PUBKEY,
          associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
          recentBlockhashes: SYSVAR_RECENT_BLOCKHASHES_PUBKEY
        }).instruction();
        const threadProgram = await new Program(
          IDL,
          CLOCKWORK_THREAD_PROGRAM_ID,
          provider
        );
        var magic = await threadProgram.methods.threadCreate(
          threadName,
          {
            accounts: ix.keys,
            programId: new PublicKey(ix.programId),
            data: ix.data
          },
          {
            cron: { schedule: "5 * * * * * *" }
          }
        ).accounts({
          authority: wallet,
          payer: wallet,
          thread: hydra,
          systemProgram: index_browser_esm_exports.SystemProgram.programId
        }).rpc();
        await connection.confirmTransaction(magic);
        const position_data = await fetcher.getPosition(position_pda.publicKey, true);
        const samo_usdc_whirlpool = await whirlpool_client.getPool(samo_usdc_whirlpool_pubkey, true);
        const wagering = bonkBal / 20;
        var quote = (0, import_whirlpools_sdk.increaseLiquidityQuoteByInputToken)(
          BONK.mint,
          import_common_sdk.DecimalUtil.fromNumber(Math.floor(wagering)),
          position_data.tickLowerIndex,
          position_data.tickUpperIndex,
          import_common_sdk.Percentage.fromFraction(0, 1e3),
          samo_usdc_whirlpool
        );
        var threadName = Math.floor(Math.random() * 99999).toString();
        var [hydra] = PublicKey.findProgramAddressSync(
          [Buffer.from(SEED_QUEUE, "utf-8"), wallet.toBuffer(), Buffer.from(threadName, "utf-8")],
          CLOCKWORK_THREAD_PROGRAM_ID
        );
        console.log(hydra.toBase58());
        tx.addInstruction({ instructions: [SystemProgram.transfer({
          fromPubkey: wallet,
          toPubkey: hydra,
          lamports: 666e-5 * 10 ** 9
        })], signers: [], cleanupInstructions: [] });
        var ix = await program.methods.proxyIncreaseLiquidity(
          quote.liquidityAmount,
          quote.tokenMaxA,
          quote.tokenMaxB,
          bump
        ).accounts({
          hydra,
          whirlpoolProgram: import_whirlpools_sdk.ORCA_WHIRLPOOL_PROGRAM_ID,
          whirlpool: samo_usdc_whirlpool_pubkey,
          tokenProgram: import_token.TOKEN_PROGRAM_ID,
          position: position_pda.publicKey,
          positionTokenAccount: await (0, import_common_sdk.deriveATA)(wallet, position_mint),
          tokenOwnerAccountA: await (0, import_common_sdk.deriveATA)(wallet, BONK.mint),
          tokenOwnerAccountB: await (0, import_common_sdk.deriveATA)(wallet, USDC.mint),
          tokenVaultA: samo_usdc_whirlpool.getData().tokenVaultA,
          tokenVaultB: samo_usdc_whirlpool.getData().tokenVaultB,
          tickArrayLower: import_whirlpools_sdk.PDAUtil.getTickArrayFromTickIndex(position_data.tickLowerIndex, 64, samo_usdc_whirlpool_pubkey, import_whirlpools_sdk.ORCA_WHIRLPOOL_PROGRAM_ID).publicKey,
          tickArrayUpper: import_whirlpools_sdk.PDAUtil.getTickArrayFromTickIndex(position_data.tickUpperIndex, 64, samo_usdc_whirlpool_pubkey, import_whirlpools_sdk.ORCA_WHIRLPOOL_PROGRAM_ID).publicKey,
          authority
        }).instruction();
        var magic = await threadProgram.methods.threadCreate(
          threadName,
          {
            accounts: ix.keys,
            programId: new PublicKey(ix.programId),
            data: ix.data
          },
          {
            cron: { schedule: "5 * * * * * *" }
          }
        ).accounts({
          authority: wallet,
          payer: wallet,
          thread: hydra,
          systemProgram: index_browser_esm_exports.SystemProgram.programId
        }).rpc();
        await connection.confirmTransaction(magic);
        const post_position_data = await fetcher.getPosition(position_pda.publicKey, true);
        const delta_liquidity = post_position_data.liquidity.sub(position_data.liquidity);
        const pre_last_updated = (await samo_usdc_whirlpool.refreshData()).rewardLastUpdatedTimestamp;
        var threadName = Math.floor(Math.random() * 99999).toString();
        var [hydra] = PublicKey.findProgramAddressSync(
          [Buffer.from(SEED_QUEUE, "utf-8"), wallet.toBuffer(), Buffer.from(threadName, "utf-8")],
          CLOCKWORK_THREAD_PROGRAM_ID
        );
        console.log(hydra.toBase58());
        tx.addInstruction({ instructions: [SystemProgram.transfer({
          fromPubkey: wallet,
          toPubkey: hydra,
          lamports: 666e-5 * 10 ** 9
        })], signers: [], cleanupInstructions: [] });
        var ix = await program.methods.proxyUpdateFeesAndRewards(bump).accounts({
          hydra,
          whirlpoolProgram: import_whirlpools_sdk.ORCA_WHIRLPOOL_PROGRAM_ID,
          whirlpool: samo_usdc_whirlpool_pubkey,
          position: position_pda.publicKey,
          tickArrayLower: import_whirlpools_sdk.PDAUtil.getTickArrayFromTickIndex(position_data.tickLowerIndex, 64, samo_usdc_whirlpool_pubkey, import_whirlpools_sdk.ORCA_WHIRLPOOL_PROGRAM_ID).publicKey,
          tickArrayUpper: import_whirlpools_sdk.PDAUtil.getTickArrayFromTickIndex(position_data.tickUpperIndex, 64, samo_usdc_whirlpool_pubkey, import_whirlpools_sdk.ORCA_WHIRLPOOL_PROGRAM_ID).publicKey,
          authority
        }).instruction();
        var magic = await threadProgram.methods.threadCreate(
          threadName,
          {
            accounts: ix.keys,
            programId: new PublicKey(ix.programId),
            data: ix.data
          },
          {
            cron: { schedule: "5 * * * * * *" }
          }
        ).accounts({
          authority: wallet,
          payer: wallet,
          thread: hydra,
          systemProgram: index_browser_esm_exports.SystemProgram.programId
        }).rpc();
        await connection.confirmTransaction(magic);
        const post_last_updated = (await samo_usdc_whirlpool.refreshData()).rewardLastUpdatedTimestamp;
        var quote = await (0, import_whirlpools_sdk.decreaseLiquidityQuoteByLiquidity)(
          position_data.liquidity,
          import_common_sdk.Percentage.fromFraction(0, 1e3),
          await whirlpool_client.getPosition(position_pda.publicKey),
          samo_usdc_whirlpool
        );
        var threadName = Math.floor(Math.random() * 99999).toString();
        var [hydra] = PublicKey.findProgramAddressSync(
          [Buffer.from(SEED_QUEUE, "utf-8"), wallet.toBuffer(), Buffer.from(threadName, "utf-8")],
          CLOCKWORK_THREAD_PROGRAM_ID
        );
        console.log(hydra.toBase58());
        tx.addInstruction({ instructions: [SystemProgram.transfer({
          fromPubkey: wallet,
          toPubkey: hydra,
          lamports: 666e-5 * 10 ** 9
        })], signers: [], cleanupInstructions: [] });
        var ix = await program.methods.proxyDecreaseLiquidity(
          bump
        ).accounts({
          hydra,
          whirlpoolProgram: import_whirlpools_sdk.ORCA_WHIRLPOOL_PROGRAM_ID,
          whirlpool: samo_usdc_whirlpool_pubkey,
          tokenProgram: import_token.TOKEN_PROGRAM_ID,
          position: position_pda.publicKey,
          positionTokenAccount: await (0, import_common_sdk.deriveATA)(wallet, position_mint),
          tokenOwnerAccountA: await (0, import_common_sdk.deriveATA)(wallet, BONK.mint),
          tokenOwnerAccountB: await (0, import_common_sdk.deriveATA)(wallet, USDC.mint),
          tokenVaultA: samo_usdc_whirlpool.getData().tokenVaultA,
          tokenVaultB: samo_usdc_whirlpool.getData().tokenVaultB,
          tickArrayLower: import_whirlpools_sdk.PDAUtil.getTickArrayFromTickIndex(position_data.tickLowerIndex, 64, samo_usdc_whirlpool_pubkey, import_whirlpools_sdk.ORCA_WHIRLPOOL_PROGRAM_ID).publicKey,
          tickArrayUpper: import_whirlpools_sdk.PDAUtil.getTickArrayFromTickIndex(position_data.tickUpperIndex, 64, samo_usdc_whirlpool_pubkey, import_whirlpools_sdk.ORCA_WHIRLPOOL_PROGRAM_ID).publicKey,
          authority
        }).instruction();
        var magic = await threadProgram.methods.threadCreate(
          threadName,
          {
            accounts: ix.keys,
            programId: new PublicKey(ix.programId),
            data: ix.data
          },
          {
            cron: { schedule: "5 * * * * * *" }
          }
        ).accounts({
          authority: wallet,
          payer: wallet,
          thread: hydra,
          systemProgram: index_browser_esm_exports.SystemProgram.programId
        }).rpc();
        await connection.confirmTransaction(magic);
        var threadName = Math.floor(Math.random() * 99999).toString();
        var [hydra] = PublicKey.findProgramAddressSync(
          [Buffer.from(SEED_QUEUE, "utf-8"), wallet.toBuffer(), Buffer.from(threadName, "utf-8")],
          CLOCKWORK_THREAD_PROGRAM_ID
        );
        console.log(hydra.toBase58());
        tx.addInstruction({ instructions: [SystemProgram.transfer({
          fromPubkey: wallet,
          toPubkey: hydra,
          lamports: 666e-5 * 10 ** 9
        })], signers: [], cleanupInstructions: [] });
        var ix = await program.methods.proxyCollectFees(bump).accounts({
          hydra,
          whirlpoolProgram: import_whirlpools_sdk.ORCA_WHIRLPOOL_PROGRAM_ID,
          whirlpool: samo_usdc_whirlpool_pubkey,
          position: position_pda.publicKey,
          positionTokenAccount: await (0, import_common_sdk.deriveATA)(wallet, position_mint),
          tokenOwnerAccountA: await (0, import_common_sdk.deriveATA)(wallet, BONK.mint),
          tokenVaultA: samo_usdc_whirlpool.getData().tokenVaultA,
          tokenOwnerAccountB: await (0, import_common_sdk.deriveATA)(wallet, USDC.mint),
          tokenVaultB: samo_usdc_whirlpool.getData().tokenVaultB,
          tokenProgram: import_token.TOKEN_PROGRAM_ID,
          authority
        }).instruction();
        var magic = await threadProgram.methods.threadCreate(
          threadName,
          {
            accounts: ix.keys,
            programId: new PublicKey(ix.programId),
            data: ix.data
          },
          {
            cron: { schedule: "5 * * * * * *" }
          }
        ).accounts({
          authority: wallet,
          payer: wallet,
          thread: hydra,
          systemProgram: index_browser_esm_exports.SystemProgram.programId
        }).rpc();
        await connection.confirmTransaction(magic);
        const samo_usdc_whirlpool_data = samo_usdc_whirlpool.getData();
        for (let reward_index = 0; reward_index < 3; reward_index++) {
          const reward_info = samo_usdc_whirlpool_data.rewardInfos[reward_index];
          if (!import_whirlpools_sdk.PoolUtil.isRewardInitialized(reward_info)) {
            break;
          }
          const rent_ta = async () => {
            return connection.getMinimumBalanceForRentExemption(AccountLayout.span);
          };
          const reward_ta = await (0, import_common_sdk.resolveOrCreateATA)(connection, window.xnft.solana, reward_info.mint, rent_ta);
          var threadName = Math.floor(Math.random() * 99999).toString();
          var [hydra] = PublicKey.findProgramAddressSync(
            [Buffer.from(SEED_QUEUE, "utf-8"), wallet.toBuffer(), Buffer.from(threadName, "utf-8")],
            CLOCKWORK_THREAD_PROGRAM_ID
          );
          console.log(hydra.toBase58());
          tx.addInstruction({ instructions: [SystemProgram.transfer({
            fromPubkey: wallet,
            toPubkey: hydra,
            lamports: 666e-5 * 10 ** 9
          })], signers: [], cleanupInstructions: [] });
          var ix = await program.methods.proxyCollectReward(
            reward_index,
            bump
          ).accounts({
            hydra,
            whirlpoolProgram: import_whirlpools_sdk.ORCA_WHIRLPOOL_PROGRAM_ID,
            whirlpool: samo_usdc_whirlpool_pubkey,
            position: position_pda.publicKey,
            positionTokenAccount: await (0, import_common_sdk.deriveATA)(wallet, position_mint),
            rewardOwnerAccount: reward_ta.address,
            rewardVault: reward_info.vault,
            tokenProgram: import_token.TOKEN_PROGRAM_ID,
            authority
          }).instruction();
          const transaction = new import_common_sdk.TransactionBuilder(connection, window.xnft.solana).addInstruction(reward_ta);
          await transaction.buildAndExecute();
          var magic = await threadProgram.methods.threadCreate(
            threadName,
            {
              accounts: ix.keys,
              programId: new PublicKey(ix.programId),
              data: ix.data
            },
            {
              cron: { schedule: "5 * * * * * *" }
            }
          ).accounts({
            authority: wallet,
            payer: wallet,
            thread: hydra,
            systemProgram: index_browser_esm_exports.SystemProgram.programId
          }).rpc();
          await connection.confirmTransaction(magic);
          const post_position_data2 = await fetcher.getPosition(position_pda.publicKey, true);
        }
        var threadName = Math.floor(Math.random() * 99999).toString();
        var [hydra] = PublicKey.findProgramAddressSync(
          [Buffer.from(SEED_QUEUE, "utf-8"), wallet.toBuffer(), Buffer.from(threadName, "utf-8")],
          CLOCKWORK_THREAD_PROGRAM_ID
        );
        console.log(hydra.toBase58());
        tx.addInstruction({ instructions: [SystemProgram.transfer({
          fromPubkey: wallet,
          toPubkey: hydra,
          lamports: 666e-5 * 10 ** 9
        })], signers: [], cleanupInstructions: [] });
        var ix = await program.methods.proxyClosePosition(bump).accounts({
          hydra,
          whirlpoolProgram: import_whirlpools_sdk.ORCA_WHIRLPOOL_PROGRAM_ID,
          receiver: wallet,
          position: position_pda.publicKey,
          positionMint: position_mint,
          positionTokenAccount: await (0, import_common_sdk.deriveATA)(wallet, position_mint),
          tokenProgram: import_token.TOKEN_PROGRAM_ID,
          authority
        }).instruction();
        var magic = await threadProgram.methods.threadCreate(
          threadName,
          {
            accounts: ix.keys,
            programId: new PublicKey(ix.programId),
            data: ix.data
          },
          {
            cron: { schedule: "5 * * * * * *" }
          }
        ).accounts({
          authority: wallet,
          payer: wallet,
          thread: hydra,
          systemProgram: index_browser_esm_exports.SystemProgram.programId
        }).rpc();
        await connection.confirmTransaction(magic);
        await tx.buildAndExecute();
      }
    }
    return /* @__PURE__ */ import_react15.default.createElement(import_react15.default.Fragment, null, /* @__PURE__ */ import_react15.default.createElement(
      View,
      {
        style: {
          display: "flex",
          padding: "8px 16px"
        }
      },
      /* @__PURE__ */ import_react15.default.createElement(
        View,
        {
          style: {
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            paddingRight: "16px"
          }
        },
        /* @__PURE__ */ import_react15.default.createElement(
          Image,
          {
            style: {
              width: "50px"
            },
            src: props.token.image
          }
        ),
        /* @__PURE__ */ import_react15.default.createElement(
          Image,
          {
            style: {
              width: "50px"
            },
            src: props.token.image2
          }
        )
      ),
      /* @__PURE__ */ import_react15.default.createElement(
        View,
        {
          style: {
            position: "relative",
            display: "flex",
            flexDirection: "column",
            flexGrow: "1"
          }
        },
        /* @__PURE__ */ import_react15.default.createElement(
          Text,
          {
            style: {
              fontFamily: "Inter",
              fontSize: "30px",
              fontWeight: "700",
              lineHeight: "36px"
            }
          },
          `$${currentPrice}`
        ),
        /* @__PURE__ */ import_react15.default.createElement(
          Text,
          {
            style: {
              fontFamily: "Inter",
              fontSize: "16px",
              lineHeight: "24px",
              paddingLeft: "16px",
              color
            }
          },
          `${changePercent}% ($${changeCurrency})`
        ),
        /* @__PURE__ */ import_react15.default.createElement(
          View,
          {
            style: {
              position: "absolute",
              left: "-4px",
              top: "38px"
            }
          },
          Arrow
        )
      ),
      /* @__PURE__ */ import_react15.default.createElement(
        View,
        {
          onClick: () => dispatch(
            FAVORITE({
              assetId: props.token.id,
              isFavorited: !isFavorited
            })
          ),
          style: {
            cursor: "pointer",
            display: "flex",
            alignItems: "center",
            justifyContent: "right",
            paddingRight: "0px"
          }
        },
        /* @__PURE__ */ import_react15.default.createElement(
          StarIcon_default,
          {
            key: colorButton + isFavorited,
            color: colorButton,
            isFilled: isFavorited,
            strokeWidth: 1,
            size: 30
          }
        )
      )
    ), /* @__PURE__ */ import_react15.default.createElement(Button, { onClick: doathing, style: { width: "100%" } }, /* @__PURE__ */ import_react15.default.createElement(Text, null, "Automate")));
  }
  var selector = createSelector(
    (state, props) => state.tokenInfos[props.token.id],
    (state, props) => !!state.favorites[props.token.id],
    (state, props) => {
      const tokenChart = state.tokenCharts[props.token.id] ?? {};
      return tokenChart.activeChart ?? "1D";
    },
    (state, props) => {
      const tokenChart = state.tokenCharts[props.token.id] ?? {};
      const activeChart = tokenChart.activeChart ?? "1D";
      return tokenChart[getChartDataTime(activeChart)];
    },
    (token, isFavorited, activeChart, chartData) => ({
      token,
      isFavorited,
      activeChart,
      chartData
    })
  );
  var TokenDetails_default = connect(selector)(TokenDetails);

  // src/App/TokenList.tsx
  init_virtual_process_polyfill();
  init_buffer();
  var import_react16 = __toESM(require_react());
  function TokenList({ tokenList, tokenInfos, favorites }) {
    const [filter, setFilter] = (0, import_react16.useState)("");
    const nav = useNavigation();
    if (!tokenList) {
      return /* @__PURE__ */ import_react16.default.createElement(CenteredLoader_default, null);
    }
    const favoritesList = tokenList.filter((token) => favorites[token]);
    const nonFavoritesList = tokenList.filter((token) => !favorites[token]);
    nonFavoritesList.length = favoritesList.length > 20 ? 0 : 20 - favoritesList.length;
    let filteredList;
    if (filter !== "") {
      const regex2 = new RegExp(filter, "i");
      filteredList = tokenList.filter(
        (token) => regex2.test(tokenInfos[token]?.name) || regex2.test(tokenInfos[token]?.symbol) || regex2.test(token)
      );
      filteredList.length = 20;
    }
    return /* @__PURE__ */ import_react16.default.createElement(
      View,
      {
        style: {
          display: "flex",
          flexDirection: "column",
          height: "100%",
          padding: "10px 0px",
          cursor: "pointer"
        }
      },
      /* @__PURE__ */ import_react16.default.createElement(
        View,
        {
          style: {
            display: "flex",
            padding: "0px 16px",
            paddingBottom: "10px"
          }
        },
        /* @__PURE__ */ import_react16.default.createElement(
          TextField,
          {
            placeholder: "Search all assets",
            onChange: (e) => {
              setFilter(e.target.value);
            },
            value: filter
          }
        )
      ),
      /* @__PURE__ */ import_react16.default.createElement(
        View,
        {
          style: {
            display: "flex",
            flexGrow: 1,
            position: "relative"
          }
        },
        /* @__PURE__ */ import_react16.default.createElement(ScrollBar, null, filteredList && filteredList.map(
          (token) => renderToken(tokenInfos[token], favorites[token], nav)
        ), !filteredList && favoritesList.map(
          (token) => renderToken(tokenInfos[token], favorites[token], nav)
        ), !filteredList && nonFavoritesList.map(
          (token) => renderToken(tokenInfos[token], favorites[token], nav)
        ))
      )
    );
  }
  function renderToken(token, isFavorited, nav) {
    const changePercent = formatPrice_default(token.price_change_percentage_24h);
    const currentPrice = formatPrice_default(token.current_price);
    const Arrow = (token.price_change_percentage_24h ?? 0) + 0 > 0 ? /* @__PURE__ */ import_react16.default.createElement(ArrowUpIcon_default, { isFilled: true, color: green, height: 10, width: 15 }) : /* @__PURE__ */ import_react16.default.createElement(ArrowDownIcon_default, { isFilled: true, color: red, height: 10, width: 15 });
    const color = (token.price_change_percentage_24h ?? 0) + 0 > 0 ? green : red;
    return /* @__PURE__ */ import_react16.default.createElement(
      View,
      {
        style: {
          padding: "8px 16px",
          display: "flex",
          position: "relative"
        },
        key: token.id,
        onClick: () => nav.push("details", { token })
      },
      /* @__PURE__ */ import_react16.default.createElement(
        View,
        {
          style: {
            display: "flex",
            alignItems: "center",
            paddingRight: "12px",
            justifyContent: "center"
          }
        },
        /* @__PURE__ */ import_react16.default.createElement(
          Image,
          {
            style: {
              width: "34px"
            },
            src: token.image
          }
        ),
        /* @__PURE__ */ import_react16.default.createElement(
          Image,
          {
            style: {
              width: "34px"
            },
            src: token.image2
          }
        )
      ),
      /* @__PURE__ */ import_react16.default.createElement(
        View,
        {
          style: {
            display: "flex",
            flexGrow: 1,
            flexDirection: "column",
            overflow: "hidden"
          }
        },
        /* @__PURE__ */ import_react16.default.createElement(
          Text,
          {
            style: {
              font: "Inter",
              lineHeight: "24px",
              fontSize: "16px",
              overflow: "hidden",
              textOverflow: "ellipsis",
              whiteSpace: "nowrap"
            }
          },
          `${token.name}${isFavorited ? " \u2605" : ""}`
        ),
        /* @__PURE__ */ import_react16.default.createElement(
          Text,
          {
            style: {
              font: "Inter",
              lineHeight: "24px",
              fontSize: "16px",
              color: "#A1A1AA"
            }
          },
          `${token.symbol.toLocaleUpperCase()}`
        )
      ),
      /* @__PURE__ */ import_react16.default.createElement(
        View,
        {
          style: {
            position: "relative",
            minWidth: "71px"
          }
        },
        /* @__PURE__ */ import_react16.default.createElement(
          Text,
          {
            style: {
              font: "Inter",
              fontSize: "16px",
              textAlign: "right",
              fontFeatureSettings: "tnum"
            }
          },
          `${currentPrice}`
        ),
        /* @__PURE__ */ import_react16.default.createElement(
          Text,
          {
            style: {
              font: "Inter",
              fontSize: "16px",
              textAlign: "right",
              paddingRight: "16px",
              fontFeatureSettings: "tnum",
              color
            }
          },
          `${changePercent}%`
        ),
        /* @__PURE__ */ import_react16.default.createElement(
          View,
          {
            style: {
              position: "absolute",
              right: "0px",
              top: "32px"
            }
          },
          Arrow
        )
      )
    );
  }
  var selector2 = createSelector(
    (state) => state.tokenInfos,
    (state) => state.tokenList,
    (state) => state.favorites,
    (tokenInfos, tokenList, favorites) => ({ tokenInfos, tokenList, favorites })
  );
  var TokenList_default = connect(selector2)(TokenList);

  // src/App/Navigation.tsx
  function Navigation() {
    return /* @__PURE__ */ import_react17.default.createElement(
      Stack.Navigator,
      {
        initialRoute: { name: "list" },
        options: ({ route }) => {
          switch (route.name) {
            case "list":
              return {
                title: "Cryptoassets",
                props: {
                  style: {
                    textAlign: "left"
                  }
                }
              };
            case "details": {
              return {
                title: route.props?.token.name
              };
            }
            default:
              throw new Error("unknown route");
          }
        },
        style: {
          font: "Inter",
          fontSize: "20px",
          fontWeight: "700",
          height: "56px"
        }
      },
      /* @__PURE__ */ import_react17.default.createElement(Stack.Screen, { name: "list", component: (props) => /* @__PURE__ */ import_react17.default.createElement(TokenList_default, null) }),
      /* @__PURE__ */ import_react17.default.createElement(
        Stack.Screen,
        {
          name: "details",
          component: (props) => /* @__PURE__ */ import_react17.default.createElement(TokenDetails_default, { ...props })
        }
      )
    );
  }
  var Navigation_default = Navigation;

  // src/App/App.tsx
  esm_default.events.on("connect", () => {
  });
  function _App({ initialized }) {
    useRefreshTokenList_default();
    const dispatch = useDispatch();
    (0, import_react18.useEffect)(() => {
      if (!initialized) {
        const state = window.localStorage.getItem("PricesState");
        if (StateType.is(state)) {
          dispatch(INITIALIZE_STATE({ state }));
        } else {
          console.error(
            "Prices xNFT:",
            "INVALID STATE",
            StateType.validate(state)[0]
          );
          dispatch(INITIALIZE_STATE({ state: null }));
        }
      }
    }, [initialized]);
    if (!initialized) {
      return /* @__PURE__ */ import_react18.default.createElement(CenteredLoader_default, null);
    }
    return /* @__PURE__ */ import_react18.default.createElement(
      View,
      {
        style: {
          position: "relative",
          height: "100%",
          background: "rgb(0,0,0, 0.87)"
        }
      },
      /* @__PURE__ */ import_react18.default.createElement(Navigation_default, null)
    );
  }
  var selector3 = createSelector(
    (state) => state.initialized,
    (initialized) => ({ initialized })
  );
  var ConnectedApp = connect(selector3)(_App);
  function App() {
    return /* @__PURE__ */ import_react18.default.createElement(ReduxProvider, null, /* @__PURE__ */ import_react18.default.createElement(ConnectedApp, null));
  }

  // src/index.tsx
  esm_default.render(
    /* @__PURE__ */ import_react19.default.createElement(AnchorDom, null, /* @__PURE__ */ import_react19.default.createElement(App, null))
  );
})();
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/*!
 *  decimal.js v10.4.3
 *  An arbitrary-precision Decimal type for JavaScript.
 *  https://github.com/MikeMcl/decimal.js
 *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
 *  MIT Licence
 */
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
/*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @license React
 * use-sync-external-store-shim/with-selector.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * Support for translating between Buffer instances and JavaScript
 * native types.
 *
 * {@link module:Layout~Layout|Layout} is the basis of a class
 * hierarchy that associates property names with sequences of encoded
 * bytes.
 *
 * Layouts are supported for these scalar (numeric) types:
 * * {@link module:Layout~UInt|Unsigned integers in little-endian
 *   format} with {@link module:Layout.u8|8-bit}, {@link
 *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},
 *   {@link module:Layout.u32|32-bit}, {@link
 *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}
 *   representation ranges;
 * * {@link module:Layout~UIntBE|Unsigned integers in big-endian
 *   format} with {@link module:Layout.u16be|16-bit}, {@link
 *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},
 *   {@link module:Layout.u40be|40-bit}, and {@link
 *   module:Layout.u48be|48-bit} representation ranges;
 * * {@link module:Layout~Int|Signed integers in little-endian
 *   format} with {@link module:Layout.s8|8-bit}, {@link
 *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},
 *   {@link module:Layout.s32|32-bit}, {@link
 *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}
 *   representation ranges;
 * * {@link module:Layout~IntBE|Signed integers in big-endian format}
 *   with {@link module:Layout.s16be|16-bit}, {@link
 *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},
 *   {@link module:Layout.s40be|40-bit}, and {@link
 *   module:Layout.s48be|48-bit} representation ranges;
 * * 64-bit integral values that decode to an exact (if magnitude is
 *   less than 2^53) or nearby integral Number in {@link
 *   module:Layout.nu64|unsigned little-endian}, {@link
 *   module:Layout.nu64be|unsigned big-endian}, {@link
 *   module:Layout.ns64|signed little-endian}, and {@link
 *   module:Layout.ns64be|unsigned big-endian} encodings;
 * * 32-bit floating point values with {@link
 *   module:Layout.f32|little-endian} and {@link
 *   module:Layout.f32be|big-endian} representations;
 * * 64-bit floating point values with {@link
 *   module:Layout.f64|little-endian} and {@link
 *   module:Layout.f64be|big-endian} representations;
 * * {@link module:Layout.const|Constants} that take no space in the
 *   encoded expression.
 *
 * and for these aggregate types:
 * * {@link module:Layout.seq|Sequence}s of instances of a {@link
 *   module:Layout~Layout|Layout}, with JavaScript representation as
 *   an Array and constant or data-dependent {@link
 *   module:Layout~Sequence#count|length};
 * * {@link module:Layout.struct|Structure}s that aggregate a
 *   heterogeneous sequence of {@link module:Layout~Layout|Layout}
 *   instances, with JavaScript representation as an Object;
 * * {@link module:Layout.union|Union}s that support multiple {@link
 *   module:Layout~VariantLayout|variant layouts} over a fixed
 *   (padded) or variable (not padded) span of bytes, using an
 *   unsigned integer at the start of the data or a separate {@link
 *   module:Layout.unionLayoutDiscriminator|layout element} to
 *   determine which layout to use when interpreting the buffer
 *   contents;
 * * {@link module:Layout.bits|BitStructure}s that contain a sequence
 *   of individual {@link
 *   module:Layout~BitStructure#addField|BitField}s packed into an 8,
 *   16, 24, or 32-bit unsigned integer starting at the least- or
 *   most-significant bit;
 * * {@link module:Layout.cstr|C strings} of varying length;
 * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link
 *   module:Layout~Blob#length|length} raw data.
 *
 * All {@link module:Layout~Layout|Layout} instances are immutable
 * after construction, to prevent internal state from becoming
 * inconsistent.
 *
 * @local Layout
 * @local ExternalLayout
 * @local GreedyCount
 * @local OffsetLayout
 * @local UInt
 * @local UIntBE
 * @local Int
 * @local IntBE
 * @local NearUInt64
 * @local NearUInt64BE
 * @local NearInt64
 * @local NearInt64BE
 * @local Float
 * @local FloatBE
 * @local Double
 * @local DoubleBE
 * @local Sequence
 * @local Structure
 * @local UnionDiscriminator
 * @local UnionLayoutDiscriminator
 * @local Union
 * @local VariantLayout
 * @local BitStructure
 * @local BitField
 * @local Boolean
 * @local Blob
 * @local CString
 * @local Constant
 * @local bindConstructorLayout
 * @module Layout
 * @license MIT
 * @author Peter A. Bigot
 * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}
 */
/**
 * Support for translating between Uint8Array instances and JavaScript
 * native types.
 *
 * {@link module:Layout~Layout|Layout} is the basis of a class
 * hierarchy that associates property names with sequences of encoded
 * bytes.
 *
 * Layouts are supported for these scalar (numeric) types:
 * * {@link module:Layout~UInt|Unsigned integers in little-endian
 *   format} with {@link module:Layout.u8|8-bit}, {@link
 *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},
 *   {@link module:Layout.u32|32-bit}, {@link
 *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}
 *   representation ranges;
 * * {@link module:Layout~UIntBE|Unsigned integers in big-endian
 *   format} with {@link module:Layout.u16be|16-bit}, {@link
 *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},
 *   {@link module:Layout.u40be|40-bit}, and {@link
 *   module:Layout.u48be|48-bit} representation ranges;
 * * {@link module:Layout~Int|Signed integers in little-endian
 *   format} with {@link module:Layout.s8|8-bit}, {@link
 *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},
 *   {@link module:Layout.s32|32-bit}, {@link
 *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}
 *   representation ranges;
 * * {@link module:Layout~IntBE|Signed integers in big-endian format}
 *   with {@link module:Layout.s16be|16-bit}, {@link
 *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},
 *   {@link module:Layout.s40be|40-bit}, and {@link
 *   module:Layout.s48be|48-bit} representation ranges;
 * * 64-bit integral values that decode to an exact (if magnitude is
 *   less than 2^53) or nearby integral Number in {@link
 *   module:Layout.nu64|unsigned little-endian}, {@link
 *   module:Layout.nu64be|unsigned big-endian}, {@link
 *   module:Layout.ns64|signed little-endian}, and {@link
 *   module:Layout.ns64be|unsigned big-endian} encodings;
 * * 32-bit floating point values with {@link
 *   module:Layout.f32|little-endian} and {@link
 *   module:Layout.f32be|big-endian} representations;
 * * 64-bit floating point values with {@link
 *   module:Layout.f64|little-endian} and {@link
 *   module:Layout.f64be|big-endian} representations;
 * * {@link module:Layout.const|Constants} that take no space in the
 *   encoded expression.
 *
 * and for these aggregate types:
 * * {@link module:Layout.seq|Sequence}s of instances of a {@link
 *   module:Layout~Layout|Layout}, with JavaScript representation as
 *   an Array and constant or data-dependent {@link
 *   module:Layout~Sequence#count|length};
 * * {@link module:Layout.struct|Structure}s that aggregate a
 *   heterogeneous sequence of {@link module:Layout~Layout|Layout}
 *   instances, with JavaScript representation as an Object;
 * * {@link module:Layout.union|Union}s that support multiple {@link
 *   module:Layout~VariantLayout|variant layouts} over a fixed
 *   (padded) or variable (not padded) span of bytes, using an
 *   unsigned integer at the start of the data or a separate {@link
 *   module:Layout.unionLayoutDiscriminator|layout element} to
 *   determine which layout to use when interpreting the buffer
 *   contents;
 * * {@link module:Layout.bits|BitStructure}s that contain a sequence
 *   of individual {@link
 *   module:Layout~BitStructure#addField|BitField}s packed into an 8,
 *   16, 24, or 32-bit unsigned integer starting at the least- or
 *   most-significant bit;
 * * {@link module:Layout.cstr|C strings} of varying length;
 * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link
 *   module:Layout~Blob#length|length} raw data.
 *
 * All {@link module:Layout~Layout|Layout} instances are immutable
 * after construction, to prevent internal state from becoming
 * inconsistent.
 *
 * @local Layout
 * @local ExternalLayout
 * @local GreedyCount
 * @local OffsetLayout
 * @local UInt
 * @local UIntBE
 * @local Int
 * @local IntBE
 * @local NearUInt64
 * @local NearUInt64BE
 * @local NearInt64
 * @local NearInt64BE
 * @local Float
 * @local FloatBE
 * @local Double
 * @local DoubleBE
 * @local Sequence
 * @local Structure
 * @local UnionDiscriminator
 * @local UnionLayoutDiscriminator
 * @local Union
 * @local VariantLayout
 * @local BitStructure
 * @local BitField
 * @local Boolean
 * @local Blob
 * @local CString
 * @local Constant
 * @local bindConstructorLayout
 * @module Layout
 * @license MIT
 * @author Peter A. Bigot
 * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}
 */
/**
 * [js-sha256]{@link https://github.com/emn178/js-sha256}
 *
 * @version 0.9.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2017
 * @license MIT
 */
/** @license React v0.20.2
 * scheduler-tracing.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v0.20.2
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v0.26.2
 * react-reconciler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
</script>
    <script src="https://unpkg.com/@coral-xyz/react-xnft-dom-renderer@latest/dist/index.js"></script>
  </body>
</html>

